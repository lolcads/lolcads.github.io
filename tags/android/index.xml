<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Android on lolcads tech blog</title><link>https://lolcads.github.io/tags/android/</link><description>Recent content in Android on lolcads tech blog</description><generator>Hugo</generator><language>en</language><managingEditor>lolcads@posteo.net (lolcads)</managingEditor><webMaster>lolcads@posteo.net (lolcads)</webMaster><copyright>lolcads</copyright><lastBuildDate>Tue, 10 Sep 2024 09:25:28 +0200</lastBuildDate><atom:link href="https://lolcads.github.io/tags/android/index.xml" rel="self" type="application/rss+xml"/><item><title>Bytecode Reuse Attack (Part 4)</title><link>https://lolcads.github.io/posts/2024/09/bytecode_exploitation_3/</link><pubDate>Tue, 10 Sep 2024 09:25:28 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/09/bytecode_exploitation_3/</guid><description>&lt;h1 id="bytecode-reuse-attack-part-4">Bytecode Reuse Attack (Part 4)&lt;/h1>
&lt;p>As last blog post on bytecode - based exploitation on Android, the next step following bytecode injection is discussed, namely: &lt;em>bytecode reuse&lt;/em>.&lt;/p>
&lt;p>To answer the question about &lt;em>why&lt;/em> an attacker needs bytecode reuse, although there already is bytecode injection, remember the &lt;em>arms race&lt;/em> in (binary) exploitation. In a nutshell, a new exploitation technique triggers a reaction in form of at least one security mechanism that (partially) mitigates the new technique. If only bytecode injection was researched, then the best response would be the development of a new security mechanism that prevents &lt;code>nterp&lt;/code> from executing arbitrary data. In other words, &lt;code>nterp&lt;/code> would be restricted to &lt;em>executable code&lt;/em>, i.e. bytecode. To be honest, every developer would respond with such a fix, myself included! However, bytecode injection is not the full potential of bytecode - based exploitation.&lt;/p></description></item><item><title>Bytecode Injection (Part 3)</title><link>https://lolcads.github.io/posts/2024/09/bytecode_exploitation_2/</link><pubDate>Tue, 10 Sep 2024 09:20:53 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/09/bytecode_exploitation_2/</guid><description>&lt;h1 id="bytecode-injection-part-3">Bytecode Injection (Part 3)&lt;/h1>
&lt;p>With all the basics out of the way, this blog post shows the first bytecode - based exploitation technique on Android: &lt;em>bytecode injection&lt;/em>! This opens the door to many interesting exploits, where injected bytecode can function as a one - in - all solution or an intermediate stage.&lt;/p>
&lt;p>In order to fully understand this technique, it is recommended to read the introductory blog posts first! As of writing, there is no public information on this topic except for the Android source code.&lt;/p></description></item><item><title>Fundamentals for Bytecode Exploitation (Part 2)</title><link>https://lolcads.github.io/posts/2024/09/bytecode_exploitation_1/</link><pubDate>Tue, 10 Sep 2024 09:17:43 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/09/bytecode_exploitation_1/</guid><description>&lt;h1 id="fundamentals-for-bytecode-exploitation-part-2">Fundamentals for Bytecode Exploitation (Part 2)&lt;/h1>
&lt;p>Exploiting a vulnerability always requires a certain knowledge about the operating system, including how processes are launched, what libraries are used and how control - flow &amp;ldquo;works&amp;rdquo;. While the latter could be considered coming from the architecture, this is not always the case on Android, because the &lt;em>Android RunTime&lt;/em> (ART) provides ways to call bytecode methods and redirect bytecode control - flow. Hence, ART dictates how bytecode control - flow works, not directly the underlying CPU. Understanding the above mechanisms is the minimal requirement for understanding bytecode - based exploitation. Based on that, more sophisticated analysis techniques can be built specifically for Android bytecode, to make bytecode - based exploitation feasible.&lt;/p></description></item><item><title>Introduction to Android Bytecode Exploitation (Part 1)</title><link>https://lolcads.github.io/posts/2024/09/bytecode_exploitation_0/</link><pubDate>Tue, 10 Sep 2024 09:11:56 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/09/bytecode_exploitation_0/</guid><description>&lt;h1 id="introduction-to-android-bytecode-exploitation-part-1">Introduction to Android Bytecode Exploitation (Part 1)&lt;/h1>
&lt;p>Android resides among the most popular operating systems for mobile devices, which causes Android to also be among the most popular targets for exploitation. While Android is frequently updated to fix the latest CVEs, malicious actors already search for new vulnerabilities, as gaining control over millions of computationally powerful devices is very appealing. The market shares underpin that Android is by far the most lucrative platform for malicious actors targeting mobile platforms.&lt;/p></description></item><item><title>Timing Attack Experiments against Scudo (Part 2)</title><link>https://lolcads.github.io/posts/2024/07/scudo_1/</link><pubDate>Fri, 26 Jul 2024 16:46:21 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/07/scudo_1/</guid><description>&lt;h1 id="attempting-timing-attacks-against-scudo">Attempting Timing Attacks against &lt;em>Scudo&lt;/em>&lt;/h1>
&lt;p>In this second blog post we will take a different approach for attacking &lt;a href="https://cs.android.com/android/platform/superproject/&amp;#43;/android-12.0.0_r31:external/scudo/;bpv=0;bpt=0" target="_blank" rel="noopener">&lt;em>Scudo&lt;/em>&lt;/a>
, i.e. we will try to the measure execution times for calls to &lt;code>malloc&lt;/code> and hope to be able to derive a portion of the internal state of the allocator (i.e. perform side channel attacks). The version of Scudo considered in this blog post is &lt;a href="https://cs.android.com/android/platform/superproject/&amp;#43;/android-12.0.0_r31:external/scudo/METADATA;l=19;drc=45e1036faa0dcfa30a01982880be1137d441333d" target="_blank" rel="noopener">&lt;code>161cca266a9d0b6deb5f1fd2de8ad543649a7fa1&lt;/code>&lt;/a>
.&lt;/p>
&lt;p>There will be almost only negative results (which means I unfortunately could not make it work), except for one. The main conclusion we can draw from this post is that &lt;em>Scudo&lt;/em> is &lt;strong>not&lt;/strong> designed to mitigate timing attacks! This follows from trying to leak a piece of information and then accidentally leaking a different and unclassified piece.&lt;/p></description></item><item><title>Scudo, the Allocator (Part 1)</title><link>https://lolcads.github.io/posts/2024/07/scudo_0/</link><pubDate>Thu, 25 Jul 2024 16:46:21 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/07/scudo_0/</guid><description>&lt;h1 id="binary-exploitation-for-scudo-heap-allocator-on-android">Binary Exploitation for &lt;em>Scudo Heap Allocator&lt;/em> on Android&lt;/h1>
&lt;p>In this series of blog posts, we will investigate how an attacker may leverage the internals of the &lt;a href="https://cs.android.com/android/platform/superproject/&amp;#43;/android-12.0.0_r31:external/scudo/standalone/" target="_blank" rel="noopener">&lt;em>Scudo Allocator&lt;/em>&lt;/a>
 in order to obtain an advantage on an Android OS. To that end, necessary prerequisites will be discussed and analysed for their likelihood. The focus will primarily be on &lt;a href="https://cs.android.com/android/platform/superproject/&amp;#43;/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=57" target="_blank" rel="noopener">&lt;code>malloc&lt;/code>&lt;/a>
 and &lt;a href="https://cs.android.com/android/platform/superproject/&amp;#43;/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=35" target="_blank" rel="noopener">&lt;code>free&lt;/code>&lt;/a>
, although &lt;a href="https://cs.android.com/android/platform/superproject/&amp;#43;/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=122" target="_blank" rel="noopener">&lt;code>realloc&lt;/code>&lt;/a>
 and other functions may also be of interest. According to &lt;a href="https://cs.android.com/android/platform/superproject/&amp;#43;/android-12.0.0_r31:external/scudo/METADATA;l=19;drc=45e1036faa0dcfa30a01982880be1137d441333d" target="_blank" rel="noopener">source code&lt;/a>
, the Scudo version considered in this blog is &lt;code>161cca266a9d0b6deb5f1fd2de8ad543649a7fa1&lt;/code>.&lt;/p></description></item><item><title>E²VA: Use After Free Write/Execute Module (Part 4)</title><link>https://lolcads.github.io/posts/2024/07/eva_3/</link><pubDate>Wed, 24 Jul 2024 16:46:21 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/07/eva_3/</guid><description>&lt;h1 id="exploitation-of-use---after---free-modules">Exploitation of &lt;em>Use - After - Free&lt;/em> Modules&lt;/h1>
&lt;p>In this post we will be discussing how to exploit a &lt;em>Use - After - Free&lt;/em> bug in both &lt;em>UseAfterFreeExecModule&lt;/em> and &lt;em>UseAfterFreeWriteModule&lt;/em>. As the names of the modules suggest, they differ in terms of the impact the bug has. To that end, in &lt;em>UseAfterFreeExecModule&lt;/em> we will be able to control a function pointer, whereas in &lt;em>UseAfterFreeWriteModule&lt;/em> we are given a &lt;em>Write - What - Where&lt;/em> condition.&lt;/p></description></item><item><title>E²VA: Stack Buffer Overflow Module (Part 3)</title><link>https://lolcads.github.io/posts/2024/07/eva_2/</link><pubDate>Tue, 23 Jul 2024 16:46:21 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/07/eva_2/</guid><description>&lt;h1 id="exploitation-of-easystackbufferoverflowmodule">Exploitation of &lt;em>EasyStackBufferOverflowModule&lt;/em>&lt;/h1>
&lt;p>This article describes exploitation of the &lt;em>EasyStackBufferOverflowModule&lt;/em>. During exploitation, various Android - specific caveats are discussed.&lt;/p>
&lt;h2 id="assumptions">Assumptions&lt;/h2>
&lt;p>We will assume that we have successfully grabbed a copy of the &lt;code>.apk&lt;/code> file of &lt;em>damnvulnerableapp&lt;/em>. Also, we will &lt;strong>not&lt;/strong> discuss how to unpack an &lt;code>.apk&lt;/code> file, but rather assume that we have access to &lt;code>libEasyStackBufferOverflowModule.so&lt;/code> and the &lt;code>EasyStackBufferOverflowModule&lt;/code> class. If it is unclear how to get access to these components when only given an &lt;code>.apk&lt;/code> file, read the previous blog posts first!&lt;/p></description></item><item><title>E²VA: Android Basics (Part 2)</title><link>https://lolcads.github.io/posts/2024/07/eva_1/</link><pubDate>Mon, 22 Jul 2024 16:46:21 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/07/eva_1/</guid><description>&lt;h1 id="android-binary-exploitation">Android Binary Exploitation&lt;/h1>
&lt;p>In this post, we will examine security mechanisms that Android 12 employs in order to make binary exploitation a bit harder. Also, we will discuss how to get to certain information like shared - object files that are necessary for successful exploitation. The latter will be generalized to getting limited source code access to an app given a corresponding &lt;code>.apk&lt;/code> file.&lt;/p>
&lt;h2 id="environment">Environment&lt;/h2>
&lt;p>Before diving into details, the technical setup has to be clarified. All of the following observations on security mechanisms were encountered on a x86_64 Pixel 3 emulator running Android 12 (build number is &lt;a href="https://source.android.com/docs/setup/about/build-numbers#build-ids-defined" target="_blank" rel="noopener">&lt;code>SE1A.220203.002.A1&lt;/code>&lt;/a>
). When referencing source code from &lt;em>Android Open Source Project&lt;/em> (AOSP), it will be w.r.t. &lt;a href="https://cs.android.com/android/platform/superproject/&amp;#43;/android-12.0.0_r31:" target="_blank" rel="noopener">Android 12.0.0_r31&lt;/a>
. The build variant for &lt;em>damnvulnerableapp&lt;/em> is currently only &lt;code>debug&lt;/code>. Also there is no GooglePlay enabled as we require root on the device for debugging purposes only.&lt;/p></description></item><item><title>Diving into the art of userspace exploitation under Android - Introducing E²VA (Part 1)</title><link>https://lolcads.github.io/posts/2022/11/diving_into_the_art_of_userspace_exploitation_under_android/</link><pubDate>Mon, 21 Nov 2022 18:54:42 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2022/11/diving_into_the_art_of_userspace_exploitation_under_android/</guid><description>&lt;h1 id="investigating-binary-exploitation-for-jni-on-android">Investigating Binary Exploitation for JNI on Android&lt;/h1>
&lt;p>This post aims to be an introduction into a blog series about binary exploitation on Android. It tries to describe how the environment that runs vulnerable modules is set up and how the &lt;em>damnvulnerableapp&lt;/em> supports the process of binary exploitation on Android.&lt;/p>
&lt;h2 id="warning">Warning&lt;/h2>
&lt;p>The following app is intended to be vulnerable to specific attacks and can result in arbitrary code execution in the context of the app. Therefore, beware of this and do not use this app on a device/emulator that contains personal information whatsoever. Always launch the app in a controlled environment. &lt;strong>No authentication&lt;/strong> is necessary to connect to the app and talk to vulnerable modules. Assuming the app is free of bugs, there is a guarantee that only one client can connect at a time.&lt;/p></description></item></channel></rss>