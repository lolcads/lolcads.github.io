<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on lolcads tech blog</title><link>https://lolcads.github.io/tags/linux/</link><description>Recent content in Linux on lolcads tech blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; lolcads</copyright><lastBuildDate>Thu, 21 Dec 2023 13:47:46 +0100</lastBuildDate><atom:link href="https://lolcads.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>BPF Memory Forensics with Volatility 3</title><link>https://lolcads.github.io/posts/2023/12/bpf_memory_forensics_with_volatility3/</link><pubDate>Thu, 21 Dec 2023 13:47:46 +0100</pubDate><guid>https://lolcads.github.io/posts/2023/12/bpf_memory_forensics_with_volatility3/</guid><description>BPF Memory Forensics with Volatility 3 Introduction and Motivation Have you ever wondered how an eBPF rootkit looks like? Well, here&amp;rsquo;s one, have a good look:
Upon receiving a command and control (C2) request, this specimen can execute arbitrary commands on the infected machine, exfiltrate sensitive files, perform passive and active network discovery scans (like nmap), or provide a privilege escalation backdoor to a local shell. Of course, it&amp;rsquo;s also trying its best to hide itself from system administrators hunting it with different command line tools such as ps, lsof, tcpdump an others or even try tools like rkhunter or chkrootkit.</description><content>&lt;h1 id="bpf-memory-forensics-with-volatility-3">BPF Memory Forensics with Volatility 3&lt;/h1>
&lt;h2 id="introduction-and-motivation">Introduction and Motivation&lt;/h2>
&lt;p>Have you ever wondered how an eBPF rootkit looks like? Well, here&amp;rsquo;s one, have a good look:&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2023/12/ubuntu-20.04-LTS-focal-ebpfkit.png" alt="ubuntu-20.04-LTS-focal-ebpfkit.png">&lt;/p>
&lt;p>Upon receiving a command and control (C2) request, this specimen can execute arbitrary commands on the infected machine, exfiltrate sensitive files, perform passive and active network discovery scans (like &lt;code>nmap&lt;/code>), or provide a privilege escalation backdoor to a local shell. Of course, it&amp;rsquo;s also trying its best to hide itself from system administrators hunting it with different command line tools such as &lt;code>ps&lt;/code>, &lt;code>lsof&lt;/code>, &lt;code>tcpdump&lt;/code> an others or even try tools like &lt;code>rkhunter&lt;/code> or &lt;code>chkrootkit&lt;/code>.&lt;/p>
&lt;p>Well, you say, rootkits have been doing that for more than 20 years now, so what&amp;rsquo;s the news here? The news aren&amp;rsquo;t that much the features, but rather how they are implemented. Everything is realized using a relatively new and rapidly evolving kernel feature: eBPF. Even though it has been in the kernel for almost 10 years now, we&amp;rsquo;re regularly surprised by how many experienced Linux professionals are still unaware of its existence, not even to mention its potential for abuse.&lt;/p>
&lt;p>The above picture was generated from the memory image of a system infected with &lt;a href="https://github.com/Gui774ume/ebpfkit">&lt;code>ebpfkit&lt;/code>&lt;/a>, an open-source PoC rootkit from 2021, using a plugin for the &lt;a href="https://github.com/volatilityfoundation/volatility3">Volatility 3&lt;/a> memory forensics framework. In this blog post, we will present a total of seven plugins that, taken together, facilitate an in depth analysis of the state of the BPF subsystem.&lt;/p>
&lt;p>We structured this post as follows: The next section provides an introduction to the BPF subsystem, while the third section highlights its potential for (ab)use by malware. In section four, we will introduce seven Volatility 3 plugins that facilitate the examination of BPF malware. Section five presents a case study, followed by a section describing our testing and evaluation of the plugins on various Linux distributions.
In the last section, we conclude with a discussion of the steps that are necessary to integrate our work into the upstream Volatility project, other challenges we encountered, and open research questions.&lt;/p>
&lt;p>&lt;em>Note: The words &amp;ldquo;eBPF&amp;rdquo; and &amp;ldquo;BPF&amp;rdquo; will be used interchangeably throughout this post.&lt;/em>&lt;/p>
&lt;h2 id="the-bpf-subsystem">The BPF Subsystem&lt;/h2>
&lt;p>Before delving into the complexities of memory forensics, it is necessary to establish some basics about the BPF subsystem. Readers that are already familiar with the topic can safely skip this section.&lt;/p>
&lt;p>To us, BPF is first of all an &lt;strong>instruction set architecture (ISA)&lt;/strong>. It has ten general purpose registers, which are 64 bit wide, and there are all of the basic operations that you would expect a modern ISA to have. Its creator, Alexei Starovoitov, once described it as a kind of simplified x86-64 and would probably never have imagined that the ISA he cooked up back in 2014 would once enter a standardization process at the IETF. The interested reader can find the current proposed standard &lt;a href="https://datatracker.ietf.org/doc/draft-ietf-bpf-isa/">here&lt;/a>. Of course, there are all the other things that you would expect to come with an ISA, like an ABI that defines the calling convention, and a binary encoding that maps instructions to sequences of four or eight bytes.&lt;/p>
&lt;p>The BPF ISA is used as a compilation target (currently by clang - gcc support is on the way) for programs written in high-level languages (currently C and Rust), however, it is not meant to be implemented in hardware. Therefore, it is conceptually more similar to WebAssembly or Java Bytecode than x86-64 or arm64, i.e., BPF programs are meant to be executed by a &lt;strong>runtime&lt;/strong> that implements the BPF virtual machine (VM). Several BPF runtimes exist, but the &amp;ldquo;reference implementation” is in the Linux kernel.&lt;/p>
&lt;p>Runtimes are, of course, free to choose how they implement the BPF VM. The instruction set was defined in a way that makes it easy to implement a one-to-one just in time (JIT) compiler for many CPU architectures. In fact, in the Linux kernel, even non-mainstream architectures like powerpc, sparc or s390 have BPF JITs. However, the kernel also has an &lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/kernel/bpf/core.c#L1648">interpreter&lt;/a> to run BPF programs on architectures that do not yet support JIT compilation.&lt;/p>
&lt;p>Aside: &lt;em>The BPF platform is what some call a &amp;ldquo;&lt;strong>verified&lt;/strong> target&amp;rdquo;. This means that in order for a program to be valid it has to have some &amp;ldquo;non-local&amp;rdquo; properties. Those include the absence of (unbounded) loops, registers and memory can only be read after they have been written to, the stack depth may not exceed a hard limit, and many more. The interested reader can find a more exhaustive description &lt;a href="https://www.kernel.org/doc/html/latest/bpf/verifier.html">here&lt;/a>. In practice, runtime implementations include an up-front static verification stage and refuse to execute programs that cannot be proven to meet these requirements (some runtime checks may be inserted to account for the known shortcomings of static analysis). This static verification approach is at the hearth of BPF&amp;rsquo;s sandboxing model for untrusted code.&lt;/em>&lt;/p>
&lt;p>Roughly speaking, the BPF subsystem includes, besides the implementation of the BPF VM, a user and kernel space interface for managing the program life cycle as well as infrastructure for transitioning the kernel control flow in and out of programs running inside the VM. Other subsystems can be made &amp;ldquo;programmable&amp;rdquo; by integrating the BPF VM in places where they want to allow the calling of user-defined functions, e.g., for decision making based on their return value. The networking subsystem, for example, supports handing all incoming and outgoing packets on an interface to a BPF program. Those programs can freely rewrite the packet buffer or even decide to drop the packet all together. Another example is the tracing subsystem that supports transitioning control into BPF programs at essentially any instruction via one of the various ways it has to hook into the kernel and user space execution. The final example here is the Linux Security Module (LSM) subsystem that supports calling out to BPF programs at any of its security hooks placed at handpicked choke points in the kernel. There are many more examples of BPF usage in the kernel and even more in &lt;a href="https://dl.acm.org/doi/proceedings/10.1145/3609021">academic research papers&lt;/a> and patches on the mailing list, but we guess we conveyed the general idea.&lt;/p>
&lt;p>BPF programs can interact with the world outside of the VM via so called &lt;strong>helpers&lt;/strong> or &lt;strong>kfuncs&lt;/strong>, i.e., native kernel functions that can be called by BPF programs. Services provided by these functions range from getting a timestamp to sending a signal to the current task or reading arbitrary memory. Which functions a program can call depends on the &lt;em>program type&lt;/em> that was selected when loading it into the VM. When reversing BPF programs, looking for calls to interesting kernel functions is a good point to start.&lt;/p>
&lt;p>The second ingredient you need in order to get any real work done with a BPF program are &lt;strong>maps&lt;/strong>. While programs can store data during their execution using stack memory or by allocating objects on the heap, the only way to persist data across executions of the same program are maps. Maps are mutable persistent key value stores that can be accessed by BPF programs and user space alike, as such they can be used for user-to-BPF, BPF-to-user, or BPF-to-BPF communication, where in the last case the communicating programs may be different or the same program at different times.&lt;/p>
&lt;p>Another relevant aspect of the BPF ecosystem is the promise of &lt;strong>compile once run everywhere (CORE)&lt;/strong>, i.e., a (compiled) BPF program can be run inside of a wide range of Linux kernels that might have different configurations, versions, compilers, and even CPU architectures. This is achieved by having the compiler emit special relocation entries that are processed by a user-space loader prior to loading a program into the kernel&amp;rsquo;s BPF VM. The key ingredient that enables this approach is a self-description of the running kernel in the form of BPF Type Format (BTF) information, which is made available in special files under &lt;code>/sys/kernel/btf/&lt;/code>. For example, BPF source code might do something like &lt;code>current-&amp;gt;comm&lt;/code> to access the name of the process in whose context the program is running. This might generate an assembly instruction that adds the offset of the &lt;code>comm&lt;/code> field to a pointer to the task descriptor that is stored in a register, i.e., &lt;code>ADD R5, IMM&lt;/code>. However, the immediate offset might vary due to kernel version, configuration, structure layout randomization or CPU architecture. Thus, the compiler would emit a relocation entry that tells the user-space loader running on the target system to check the kernel&amp;rsquo;s BTF information in order to overwrite the placeholder with the correct offset. Together with other kinds of relocations, which address things like existence of types and enum variants or their sizes, the loader be used to run the same BPF program on a considerable number of kernels.&lt;/p>
&lt;p>Aside: &lt;em>A problem with the CORE implementation described above is that signatures over BPF programs are meaningless as the program text will be altered by relocations before loading. To allow for a meaningful ahead of time signature there is another approach in which a loader program is generated for the actual program. The loader program is portable without relocations and is signed and loaded together with the un-relocated bytecode of the actual program. Thus, the problem is solved as all text relocations happen in the kernel, i.e., after signatures have been verified.&lt;/em>&lt;/p>
&lt;p>However, there are of course limits to the portability of BPF programs. As we all know, the kernel takes great care to never break user space, within kernel land, on the other hand, there are no stability guarantees at all. BPF programs are not considered to be part of user space and thus there are no forward or backward compatibility guarantees. In practice, that means that APIs exposed to BPF could be removed or changed, attachment points could vanish or change their signature, or programs that are currently accepted by the static verifier could be rejected in the future. Furthermore, changes in kernel configuration could remove structure fields, functions, or kernel APIs that programs rely on. In that sense, BPF programs are in a position similar to out-of-tree kernel modules. That being said, due to CORE, there is no need to have the headers of the target kernel available at compile time and thus a lot less knowledge about the target is needed to be confident that the program will be able to run successfully. Furthermore, in the worst case the program will be rejected by the kernel, but there are no negative implications on system stability by attempting to load it.&lt;/p>
&lt;p>Finally, we should mention that BPF is an entirely privileged interface. There are multiple BPF-related &lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/include/uapi/linux/capability.h#L411">capabilities&lt;/a> that a process can have, which open up various parts of the subsystem. This has not always been the case. A few years ago, unprivileged users were able to load certain types of BPF programs, however, access to the BPF VM comes with two potential security problems. First, the security entirely relies on the correctness of the static verification stage, which is notoriously complex and must keep up with the ever-expanding feature set. It has been demonstrated that errors in the verification process can be exploited for local privilege escalation, e.g., &lt;a href="https://www.zerodayinitiative.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification">CVE-2020-8835&lt;/a> or &lt;a href="https://chompie.rip/Blog+Posts/Kernel+Pwning+with+eBPF+-+a+Love+Story">CVE-2021-3490&lt;/a>. Second, even within the boundaries set by the verifier, the far-reaching control over the CPU instructions that get executed in kernel mode opens up the door for Spectre attacks, c.f., &lt;a href="https://github.com/hamishcoleman/spectre-tests/blob/master/project-zero/writeup_files/WRITEUP#L282">Jann Horn&amp;rsquo;s writeup&lt;/a> or the original &lt;a href="https://spectreattack.com/spectre.pdf">Spectre paper&lt;/a>. For those reasons, the kernel community has decided to remove unprivileged access to BPF &lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/kernel/bpf/Kconfig#L71">by default&lt;/a>.&lt;/p>
&lt;h2 id="bpf-malware">BPF Malware&lt;/h2>
&lt;p>To better understand the implications the addition of the BPF VM has for the Linux malware landscape, we would like to start with a quote from &amp;ldquo;BPF inventor&amp;rdquo; Alexei Starovoitov: &amp;ldquo;If in the past the whole kernel would maybe be [a] hundred of programmers across the world, now a hundred thousand people around the world can program the kernel thanks to BPF.&amp;rdquo;, i.e., BPF significantly lowers the entry barrier to kernel programming and shipping applications that include kernel-level code. While the majority of new kernel programmers are well-intentioned and aim to develop innovative and useful applications, experience has shown that there will be some actors who seek to use new kernel features for malicious purposes.&lt;/p>
&lt;p>From a malware author&amp;rsquo;s perspective, one of the first questions is probably how likely it is that a target system will support the loading of malicious BPF programs. According to our personal experience it is safe to say that most general-purpose desktop and server distributions enable BPF. The feature is also enabled in the &lt;code>android-base.config&lt;/code> as BPF plays a significant role in the Android OS, i.e., essentially every Android device should support BPF - from your fridge to your phone. Concerning the custom kernels used by big tech companies let me quote Brendan Gregg, another early BPF advocate: &amp;ldquo;As companies use more and more eBPF also, it becomes harder for your operating system to not have eBPF because you are no longer eligible to run workloads at Netflix or at Meta or at other companies.&amp;rdquo;. What is more, Google relies on BPF (through &lt;a href="https://github.com/cilium/cilium">&lt;code>cilium&lt;/code>&lt;/a>) in its Kubernetes engine and Facebook uses it for its layer 4 load balancer &lt;a href="https://github.com/facebookincubator/katran">&lt;code>katran&lt;/code>&lt;/a>. For a more comprehensive survey of BPF usage in cloud environments we recommend section 5 of &lt;a href="https://www.usenix.org/conference/usenixsecurity23/presentation/he">&lt;em>Cross Container Attacks: The Bewildered eBPF on Clouds&lt;/em>&lt;/a> by Yi He et al. Thus, most of the machines that constitute &amp;ldquo;the cloud&amp;rdquo; are likely to support BPF. This is particularly interesting as signature verification for BPF programs is still not available, making it the only way to run kernel code on locked-down systems that restrict the use of kernel modules.&lt;/p>
&lt;p>However, enabling the BPF subsystem, i.e., &lt;code>CONFIG_BPF&lt;/code>, is only the beginning of the story. There are many compile-time or run-time configuration choices that affect the capabilities granted to BPF programs, and thus the ways in which they can be used to subvert the security of a system. Giving a full overview of all the available switches and their effect would exceed the scope of this post, however, we will mention some knobs that can be turned to stop the abuses mentioned below.&lt;/p>
&lt;p>If you search for the term “BPF malware” these days, you will find rather sensational articles with titles like &amp;ldquo;eBPF: A new frontier for malware&amp;rdquo;, &amp;ldquo;How BPF-Enabled Malware Works&amp;rdquo;, &amp;ldquo;eBPF Offensive Capabilities – Get Ready for Next-gen Malware&amp;rdquo;, &amp;ldquo;Nothing is Safe Anymore - Beware of the “eBPF Trojan Horse” or &amp;ldquo;HOW DOES EBPF MALWARE PERFORM AGAINST STAR LAB’S KEVLAR EMBEDDED SECURITY?&amp;rdquo;. Needless to say, that they contain hardly any useful information. The truth is that we are not aware of any reports of in-the-wild malware using BPF. Nevertheless, there is no shortage in open source PoC BPF malwares on GitHub. The two biggest ones are probably &lt;a href="https://github.com/Gui774ume/ebpfkit">ebpfkit&lt;/a> and &lt;a href="https://github.com/h3xduck/TripleCross">TripeCross&lt;/a>, however, there are many smaller projects like &lt;a href="https://github.com/eeriedusk/nysm">nysm&lt;/a>, &lt;a href="https://github.com/Esonhugh/sshd_backdoor">sshd_backdoor&lt;/a>, &lt;a href="https://github.com/krisnova/boopkit">boopkit&lt;/a>, &lt;a href="https://github.com/citronneur/pamspy">pamspy&lt;/a>, or &lt;a href="https://github.com/pathtofile/bad-bpf">bad bpf&lt;/a> as well as snippet collections like &lt;a href="https://github.com/nccgroup/ebpf">nccgroup&amp;rsquo;s bpf tools&lt;/a>, &lt;a href="https://github.com/wunderwuzzi23/Offensive-BPF">Offensive-BPF&lt;/a>. Researchers also used malicious BPF programs to &lt;a href="https://www.usenix.org/conference/usenixsecurity23/presentation/he">escape container isolation&lt;/a> in multiple real-world cloud environments.&lt;/p>
&lt;p>There are a couple of core shenanigans that those malwares are constructed around, three of which we will briefly describe here.&lt;/p>
&lt;p>It is possible to transparently (for user space) skip the execution of any system call or to manipulate just the return value after it was executed. This is since BPF can be used for the purpose of &lt;a href="https://lwn.net/Articles/740146/">error injection&lt;/a>. To be precise, any function that is annotated with the &lt;code>ALLOW_ERROR_INJECTION&lt;/code> macro can be manipulated in this way, and every system call is &lt;a href="https://elixir.bootlin.com/linux/v6.1.64/source/arch/x86/include/asm/syscall_wrapper.h#L74">automatically annotated&lt;/a> via the macro that defines it. One would hope that the corresponding configurations &lt;a href="https://elixir.bootlin.com/linux/v6.1.64/source/kernel/trace/Kconfig#L711">&lt;code>BPF_KPROBE_OVERRIDE&lt;/code>&lt;/a> and &lt;a href="https://elixir.bootlin.com/linux/v6.1.67/source/lib/Kconfig.debug#L1880">&lt;code>CONFIG_FUNCTION_ERROR_INJECTION&lt;/code>&lt;/a> would not be enabled in kernels shipped to end users, but they are. There are many things that one can do by lying to user space in this way, one example would be to block the sending of all signals to a specific process, e.g., to protect it from being &lt;a href="https://github.com/Gui774ume/ebpfkit/blob/5727985eab7eca7255ca5cb7c74133c0074e3324/ebpf/ebpfkit/signal.h#L18">killed&lt;/a>. Interestingly, the same helper is also used by BPF-based security solutions like &lt;a href="https://github.com/cilium/tetragon/blob/d8f5d44810ad2079ee408175454aab5c1159f09e/docs/content/en/docs/concepts/tracing-policy/selectors.md?plain=1#L1030">tetragon&lt;/a>, which are deployed in production cloud environments.&lt;/p>
&lt;p>Another common primitive is to write to memory of the current process, which gives attackers the power to perform all sorts of interesting memory corruptions. One of the more original ideas is to &lt;a href="https://github.com/nccgroup/ebpf/tree/master/glibcpwn">inject code&lt;/a> into a process by writing a ROP chain onto its stack. The chain sets up everything to load a shared library and cleanly resumes the process afterwards. More generally, the helper &lt;code>bpf_probe_write_user&lt;/code> is involved in many techniques to hide objects, e.g., sockets or BPF programs, from user space or when manipulating apparent file and directory contents, e.g., &lt;code>/proc&lt;/code>, &lt;code>/etc/sudoers&lt;/code> or &lt;code>~/.ssh/authorized_keys&lt;/code>. In particular, those apparent modifications cannot be caught with file system forensics as they are only happening in the memory of the process that attempts to access the resource, e.g., see &lt;a href="https://github.com/pathtofile/bad-bpf/blob/main/src/textreplace.bpf.c">&lt;code>textreplace&lt;/code>&lt;/a> for an example that allows arbitrary apparent modifications of file contents. While there are in fact a couple of legitimate programs (like the &lt;a href="https://github.com/DataDog/datadog-agent/blob/f425dfa882dd9ca8533172c246ea047be1a40799/pkg/security/ebpf/probes/all.go#L257">Datadog-agent&lt;/a>) using this function, it is probably wise to enable &lt;a href="https://elixir.bootlin.com/linux/v6.1.67/source/security/lockdown/Kconfig#L33">&lt;code>CONFIG_LOCK_DOWN_KERNEL_FORCE_INTEGRITY&lt;/code>&lt;/a> before compilation.&lt;/p>
&lt;p>A rather peculiar aspect of BPF malware is how it communicates over the network. BPF programs are not able to initiate network connections by themselves, but as one of the main applications of BPF is in the networking subsystem, they have far-reaching capabilities when it comes to managing existing traffic. For example, XDP programs get their hands on packets very early in the receive path, long before mechanisms like netfilter, which is much further up the network stack, get a chance to see them. In fact, there are high-end NICs that support &lt;a href="https://www.netronome.com/blog/ever-deeper-bpf-update-hardware-offload-support/">running BPF programs on the device&amp;rsquo;s proces&lt;/a> rather than the host CPU. Furthermore, programs that handle packets can usually modify, reroute, or drop them. In combination, this is often used to receive C2 commands while at the same time hiding the corresponding packets from the rest of the kernel by modifying or dropping them. In addition, BPF&amp;rsquo;s easy programmability makes it simple to implement complex, stateful triggers. To exfiltrate data from the system, the contents, and potentially also the recipient data, of outgoing packets are modified, for example by traffic control (tc) hooks. For unreliable transport protocols higher layers will deal with the induced packet loss, while for TCP the retransmission mechanism ensures that applications will not be impacted. Turn off &lt;a href="https://www.kernelconfig.io/CONFIG_NET_CLS_BPF?q=NET_CLS_BPF&amp;amp;kernelversion=6.6.6&amp;amp;arch=x86">&lt;code>CONFIG_NET_CLS_BPF&lt;/code>&lt;/a> and &lt;a href="https://www.kernelconfig.io/CONFIG_NET_ACT_BPF?q=CONFIG_NET_ACT_BPF&amp;amp;kernelversion=6.6.6&amp;amp;arch=x86">&lt;code>CONFIG_NET_ACT_BPF&lt;/code>&lt;/a> to disable tc BPF programs.&lt;/p>
&lt;p>While the currently charted BPF malware landscape is limited to hobby projects by security researchers and other interested individuals, it would unfortunately not be unheard of that the same projects are eventually discovered during real-world incidents. Advanced Linux malwares, on the other hand, will most likely choose to implement their own BPF programs when they believe that it is beneficial for their cause, for instance to avoid detection by using a mechanism that is not yet well known to the forensic community. Some excerpts from the recent &lt;a href="https://www.youtube.com/watch?v=0BDB53PqcoU">talk by Kris Nova at DevOpsDays Kyiv&lt;/a> give an interesting insight into the concerns that the Ukrainian computer security community had, and still has, regarding the use of BPF in Russian attacks on their systems.&lt;/p>
&lt;p>It would be dishonest to claim that there is a general schema that you can follow while analyzing an incident to discover all malicious BPF programs. As so often, the boundaries between monitoring software, live patches, security solutions and malware are not clearly defined, e.g., in addition to &lt;code>bpf_override_retun&lt;/code> &lt;a href="https://github.com/cilium/tetragon">tetragon&lt;/a> also uses &lt;code>bpf_send_singal&lt;/code>. The first step could be to obtain a baseline of expected BPF-related activity, and carefully analyze any deviations or anomalies. Additionally, a look at the kernel configuration can help to decide which kinds of malicious activity are fundamentally possible. Furthermore, programs that make use of possibly malicious helper functions, like &lt;code>bpf_probe_wite_user&lt;/code>, &lt;code>bpf_send_signal&lt;/code>, &lt;code>bpf_override_return&lt;/code>, or &lt;code>bpf_skb_store_bytes&lt;/code> should be &lt;a href="https://blogs.blackberry.com/en/2021/12/reverse-engineering-ebpfkit-rootkit-with-blackberrys-free-ida-processor-tool">reverse engineered&lt;/a> with particular scrutiny. In addition, there are some clear indicators of malicious activity, like the hiding of programs, which we will discuss in more detail below. Finally, once program signatures are upstreamed, it is highly recommended to enable and enforce them to lock down this attack surface.&lt;/p>
&lt;p>From now on, we will shift gears and focus on the main topic of this post, hunting BPF malware in main memory images.&lt;/p>
&lt;p>&lt;em>Aside: The &lt;a href="https://www.pangulab.cn/en/post/the_bvp47_a_top-tier_backdoor_of_us_nsa_equation_group/">bvp47&lt;/a>, &lt;a href="https://blogs.blackberry.com/en/2022/06/symbiote-a-new-nearly-impossible-to-detect-linux-threat">Symbiote&lt;/a> and &lt;a href="https://sandflysecurity.com/blog/bpfdoor-an-evasive-linux-backdoor-technical-analysis/">BPFdoor&lt;/a> rootkits are often said to be examples of BPF malware. However, they are using only what is now known as classic BPF, i.e., the old-school packet filtering programs used by programs like tcpdump.&lt;/em>&lt;/p>
&lt;h2 id="volatility-plugins">Volatility Plugins&lt;/h2>
&lt;p>Volatility is a &lt;strong>memory forensics framework&lt;/strong> that can be used to analyze physical memory images. It uses information about symbols and types of the operating system that was running on the imaged system to recover high-level information, like the list of running processes or open files, from the raw memory image.&lt;/p>
&lt;p>Individual analyses are implemented as &lt;strong>plugins&lt;/strong> that make use of the framework library as well as other plugins. Some of those plugins are closely modeled after core unix utilities, like the &lt;code>ps&lt;/code> utility for listing processes, the &lt;code>ss&lt;/code> utility for listing network connections or the &lt;code>lsmod&lt;/code> utility for listing kernel modules. Other plugins implement checks that search for common traces of kernel rootkit activity, like the replacement of function pointers or inline hooks.&lt;/p>
&lt;p>There may be multiple ways to obtain the same piece of information, and thus multiple plugins that, on first sight, serve the same purpose. &lt;strong>Inconsistencies&lt;/strong> between the methods, however, could indicate malicious activity that tries to hide its presence or just be artifacts of imperfections in the acquisition process. In any case, inconsistencies are something an investigator should look into.&lt;/p>
&lt;p>In this section we present seven Volatility plugins that we have developed to enable analysis of the BPF subsystem. Three of these are modelled after subcommands of the &lt;a href="https://github.com/libbpf/bpftool">&lt;code>bpftool&lt;/code>&lt;/a> utility and provide basic functionality. We then present three plugins that retrieve similar information from other sources and can thus be used to detect inconsistencies. Finally, we present a plugin that aggregates information from four other plugins to make it easier to interpret.&lt;/p>
&lt;p>_Note: We published the source code for all of our plugins on &lt;a href="https://github.com/vobst/BPFVol3">GitHub&lt;/a>. We would love to see your contributions there! :)&lt;/p>
&lt;h3 id="listing-programs-maps--links">Listing Programs, Maps &amp;amp; Links&lt;/h3>
&lt;p>Arguably the most basic task that you could think of is simply listing the programs that have been loaded into the BPF VM. We will start by doing this on a live system, feel free to follow along in order to discover what your distribution or additional packages that you installed have already loaded.&lt;/p>
&lt;h4 id="live-system">Live System&lt;/h4>
&lt;p>The &lt;code>bpftool&lt;/code> user-space utility allows admins to interact with the BPF subsystem. One of the most basic tasks it supports is the listing of all loaded BPF programs, maps, BTF sections, or links. We are sometimes going to refer to these things collectively as &lt;strong>BPF objects&lt;/strong>. Roughly speaking, links are a mechanism to connect a loaded program to a point where it is being invoked, and BTF is a condensed form of DWARF debug information.&lt;/p>
&lt;p>Lets start with an example to get familiar with the information that is displayed (run &lt;code>btftool&lt;/code> as &lt;code>root&lt;/code>):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-console" data-lang="console"># bpftool prog list
[...]
22: lsm name restrict_filesystems tag 713a545fe0530ce7 gpl
loaded_at 2023-11-26T10:31:42+0100 uid 0
xlated 560B jited 305B memlock 4096B map_ids 13
btf_id 53
[...]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>From left-to-right and top-to-bottom we have: ID used as an identifier for user-space, program type, program name, tag that is a SHA1 hash over the bytecode, license, program load timestamp, uid of process that loaded it, size of the bytecode, size of the jited code, memory blocked by the program, ids of the maps that the program is using, ids to the BTF information for the program.&lt;/p>
&lt;p>We can also inspect the bytecode&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-console" data-lang="console"># bpftool prog dump xlated id &lt;span style="color:#ae81ff">22&lt;/span>
int restrict_filesystems(unsigned long long * ctx):
; int BPF_PROG(restrict_filesystems, struct file *file, int ret)
0: (79) r3 = *(u64 *)(r1 +0)
1: (79) r0 = *(u64 *)(r1 +8)
2: (b7) r1 = 0
[...]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>where each line is the pseudocode of a BPF assembly instruction and we even have line info, which is also stored in the attached BTF information. We can also dump the jited version and confirm that is is essentially a one-to-one translation to x86_64 machine code (depending on the architecture your kernel runs on):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-console" data-lang="console"># bpftool prog dump jited id &lt;span style="color:#ae81ff">22&lt;/span>
int restrict_filesystems(unsigned long long * ctx):
bpf_prog_713a545fe0530ce7_restrict_filesystems:
; int BPF_PROG(restrict_filesystems, struct file *file, int ret)
0: endbr64
4: nopl (%rax,%rax)
9: nop
b: pushq %rbp
c: movq %rsp, %rbp
f: endbr64
13: subq $24, %rsp
1a: pushq %rbx
1b: pushq %r13
1d: movq (%rdi), %rdx
21: movq 8(%rdi), %rax
25: xorl %edi, %edi
[...]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Furthermore, we can display basic information about the maps used by the program&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-console" data-lang="console"># bpftool map list id &lt;span style="color:#ae81ff">13&lt;/span>
13: hash_of_maps name cgroup_hash flags 0x0
key 8B value 4B max_entries 2048 memlock 165920B
&lt;/code>&lt;/pre>&lt;/div>&lt;p>as well as their contents (which are quite boring in this case).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-console" data-lang="console"># bpftool map dump id &lt;span style="color:#ae81ff">13&lt;/span>
Found 0 elements
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can also get information about the variables and types (BTF) defined in the program. This is somewhat comparable to the DWARF debug information that comes with some binaries - just that it is harder to strip since its needed by the BPF VM.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-console" data-lang="console"># bpftool btf dump id &lt;span style="color:#ae81ff">53&lt;/span>
[1] PTR &amp;#39;(anon)&amp;#39; type_id=3
[2] INT &amp;#39;int&amp;#39; size=4 bits_offset=0 nr_bits=32 encoding=SIGNED
[3] ARRAY &amp;#39;(anon)&amp;#39; type_id=2 index_type_id=4 nr_elems=13
[4] INT &amp;#39;__ARRAY_SIZE_TYPE__&amp;#39; size=4 bits_offset=0 nr_bits=32 encoding=(none)
[5] PTR &amp;#39;(anon)&amp;#39; type_id=6
[6] TYPEDEF &amp;#39;uint64_t&amp;#39; type_id=7
[7] TYPEDEF &amp;#39;__uint64_t&amp;#39; type_id=8
[8] INT &amp;#39;unsigned long&amp;#39; size=8 bits_offset=0 nr_bits=64 encoding=(none)
[9] PTR &amp;#39;(anon)&amp;#39; type_id=10
[10] TYPEDEF &amp;#39;uint32_t&amp;#39; type_id=11
[11] TYPEDEF &amp;#39;__uint32_t&amp;#39; type_id=12
[12] INT &amp;#39;unsigned int&amp;#39; size=4 bits_offset=0 nr_bits=32 encoding=(none)
[13] STRUCT &amp;#39;(anon)&amp;#39; size=24 vlen=3
&amp;#39;type&amp;#39; type_id=1 bits_offset=0
&amp;#39;key&amp;#39; type_id=5 bits_offset=64
&amp;#39;value&amp;#39; type_id=9 bits_offset=128
[...]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As we said earlier, links are what connects a loaded program to a point that invokes it.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-console" data-lang="console"># bpftool link list
[...]
3: tracing prog 22
prog_type lsm attach_type lsm_mac
target_obj_id 1 target_btf_id 82856
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Again, from left-to-right and top-to-bottom we have: ID, type, attached program&amp;rsquo;s ID, program&amp;rsquo;s load type, type that program was attached with, ID of the BTF object that the following field refers to, ID of the type that the program is attached to (functions can also have BTF entries). Note that everything but the first line depends on the type of link that is examined. To find the point where the program is called by the kernel we can inspect the relevant BTF object (the kernel&amp;rsquo;s in this case).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-console" data-lang="console"># bpftool btf dump id &lt;span style="color:#ae81ff">1&lt;/span> | rg &lt;span style="color:#ae81ff">82856&lt;/span>
[82856] FUNC &amp;#39;bpf_lsm_file_open&amp;#39; type_id=16712 linkage=static
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Thus we can conclude that the program is invoked early in the &lt;code>do_dentry_open&lt;/code> function via the &lt;code>security_file_open&lt;/code> LSM hook and that its return value decides whether the process will be allowed to open the file (we&amp;rsquo;re skipping some steps here, see our &lt;a href="https://blog.eb9f.de/2023/04/24/lsm2bpf.html">earlier article&lt;/a> for the full story).&lt;/p>
&lt;p>We performed this little &amp;ldquo;live investigation&amp;rdquo; on a laptop running Arch Linux with kernel 6.6.2-arch1-1 and the program wasn&amp;rsquo;t malware but rather loaded by systemd on boot. You can find the commit that introduced the feature &lt;a href="https://github.com/systemd/systemd/commit/021d1e96123289182565f0b3ce5a705b0e84fe48">here&lt;/a>. Again, you can see that in the future there will be more legitimate BPF programs running on your systems (servers, desktops and mobiles) than you might think!&lt;/p>
&lt;h4 id="memory-image">Memory Image&lt;/h4>
&lt;p>As a first step towards BPF memory forensics it would be nice to be able to perform the above investigation on a memory image. We will now introduce three plugins that aim to make this possible.&lt;/p>
&lt;p>We already saw that all sorts of BPF objects are identified by an ID. Internally, these IDs are allocated using the &lt;a href="https://www.kernel.org/doc/html/latest/core-api/idr.html?highlight=idr">IDR mechanism&lt;/a>, a core kernel API. For that purpose, three variables are defined at the top of &lt;code>/kernel/bpf/syscall.c&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">[...]
&lt;span style="color:#66d9ef">static&lt;/span> DEFINE_IDR(prog_idr);
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">DEFINE_SPINLOCK&lt;/span>(prog_idr_lock);
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">DEFINE_IDR&lt;/span>(map_idr);
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">DEFINE_SPINLOCK&lt;/span>(map_idr_lock);
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">DEFINE_IDR&lt;/span>(link_idr);
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">DEFINE_SPINLOCK&lt;/span>(link_idr_lock);
[...]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Under the hood, the ID allocation mechanism uses an &lt;a href="https://www.kernel.org/doc/html/latest/core-api/xarray.html?highlight=xarray">extensible array (xarray)&lt;/a>, a tree-like data structure that is rooted in the &lt;code>idr_rt&lt;/code> member of the structure that is defined by the macro. The ID of a new object is simply an unused index into the array, and the value stored at this index is a pointer to a structure that describes it. Thus, we can re-create the listing capabilities of &lt;code>bpftool&lt;/code> by simply iterating the array. You can find the code that does so in the &lt;a href="https://github.com/vobst/BPFVol3/blob/main/src/utility/datastructures.py#L17">XArray&lt;/a> class.&lt;/p>
&lt;p>Dereferencing the array entries leads us to structures that hold most of the information displayed by &lt;code>bpftool&lt;/code> earlier.&lt;/p>
&lt;p>Entries of the &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/kernel/bpf/syscall.c#L50">&lt;code>prog_idr&lt;/code>&lt;/a> point to objects of type &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/include/linux/bpf.h#L1217">&lt;code>bpf_prog&lt;/code>&lt;/a>, the &lt;code>aux&lt;/code> member of this type points to a &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/include/linux/bpf.h#L1129">structure&lt;/a> that hols additional information about the program. We can see how the information &lt;code>bpftool&lt;/code> displays is generated from these structures in the &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/kernel/bpf/syscall.c#L3896">&lt;code>bpf_prog_get_info_by_fd&lt;/code>&lt;/a> function by filling a &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/include/uapi/linux/bpf.h#L6172">&lt;code>bpf_prog_info&lt;/code>&lt;/a> struct. The plugin &lt;a href="https://github.com/vobst/BPFVol3/blob/main/src/plugins/bpf_listprogs.py">&lt;code>bpf_listprogs&lt;/code>&lt;/a> re-implements some of the logic of this functions and displays the following pieces of information.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">columns: list[tuple[str, type]] &lt;span style="color:#f92672">=&lt;/span> [
(&lt;span style="color:#e6db74">&amp;#34;OFFSET (V)&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;ID&amp;#34;&lt;/span>, int),
(&lt;span style="color:#e6db74">&amp;#34;TYPE&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;NAME&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;TAG&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;LOADED AT&amp;#34;&lt;/span>, int),
(&lt;span style="color:#e6db74">&amp;#34;MAP IDs&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;BTF ID&amp;#34;&lt;/span>, int),
(&lt;span style="color:#e6db74">&amp;#34;HELPERS&amp;#34;&lt;/span>, str),
]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Some comments are in order:&lt;/p>
&lt;ul>
&lt;li>&lt;code>OFFSET (V)&lt;/code> are the low 6 bytes of the &lt;code>bpf_prog&lt;/code> structure&amp;rsquo;s virtual address. This is useful as a unique identifier of the structure.&lt;/li>
&lt;li>&lt;code>LOADED AT&lt;/code> is the number of nanoseconds since boot when the program was loaded. Converting it to an absolute timestamp requires parsing additional kernel time-keeping structures and is not in scope for this plugin. There exist Volatility patches that add this functionality but they are not upstream yet. Once they are, it should be trivial to convert this field to match the &lt;code>bpftool&lt;/code> output.&lt;/li>
&lt;li>&lt;code>HELPERS&lt;/code> is a field that is not reported by &lt;code>bpftool&lt;/code>. It displays a list of all the kernel functions that are called by the BPF program, i.e., BPF helpers and kfuncs, and is helpful to quickly identify programs that use possibly malicious or non-standard helpers.&lt;/li>
&lt;li>The reporting of memory utilization is omitted as we consider it to be less important for forensic investigations, however, it would be easy to add.&lt;/li>
&lt;/ul>
&lt;p>The second &lt;code>bpftool&lt;/code> functionality the plugin supports is the dumping of programs in bytecode and jited forms. To dump the machine code of the program, we follow the &lt;code>bpf_func&lt;/code> pointer in the &lt;code>bpf_prog&lt;/code> structure, which points to the entrypoint of the jited BPF program. The length of the machine code is stored in the &lt;code>jited_len&lt;/code> field of the same structure. While we support dumping the raw bytes to a file, their analysis is tedious due to missing symbol information. Thus, we also support disassembling the program and annotating all occurring addresses with the corresponding symbol, which makes the programs much easier to analyze.&lt;/p>
&lt;p>Dumping the BPF bytecode is straightforward as well. The flexible &lt;code>insni&lt;/code> array member of the &lt;code>bpf_prog&lt;/code> structure holds the bytecode instructions and the &lt;code>len&lt;/code> field holds their number. Here, we also support dumping the raw and disassembled bytecode. However, the additional symbol annotations are not implemented. As the bytecode is not &amp;ldquo;what actually runs&amp;rdquo;, we consider this information more susceptible to anti-forensic tampering and thus focused on the machine code, which is what is executed when invoking the program.&lt;/p>
&lt;p>&lt;em>Note: We use &lt;a href="https://github.com/capstone-engine/capstone">Capstone&lt;/a> for disassembling the BPF bytecode. Unfortunately, Capstone&amp;rsquo;s BPF architecture is outdated and thus bytecode is sometimes not disassembled entirely. As a workaround, you can dump the raw bytes and use another tool to disassemble them.&lt;/em>&lt;/p>
&lt;p>Entries of the &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/kernel/bpf/syscall.c#L52">&lt;code>map_idr&lt;/code>&lt;/a> point to &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/include/linux/bpf.h#L202">&lt;code>bpf_map&lt;/code>&lt;/a> objects. The &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/include/uapi/linux/bpf.h#L6214">&lt;code>bpf_map_info&lt;/code>&lt;/a> structure parsed by &lt;code>bpftool&lt;/code> is filled in &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/kernel/bpf/syscall.c#L4185">&lt;code>bpf_map_get_info_by_fd&lt;/code>&lt;/a> and the plugin &lt;a href="https://github.com/vobst/BPFVol3/blob/main/src/plugins/bpf_listmaps.py">&lt;code>bpf_listmaps&lt;/code>&lt;/a> is simply copying the logic to display the following pieces of information.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">columns: list[tuple[str, Any]] &lt;span style="color:#f92672">=&lt;/span> [
(&lt;span style="color:#e6db74">&amp;#34;OFFSET (V)&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;ID&amp;#34;&lt;/span>, int),
(&lt;span style="color:#e6db74">&amp;#34;TYPE&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;NAME&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;KEY SIZE&amp;#34;&lt;/span>, int),
(&lt;span style="color:#e6db74">&amp;#34;VALUE SIZE&amp;#34;&lt;/span>, int),
(&lt;span style="color:#e6db74">&amp;#34;MAX ENTRIES&amp;#34;&lt;/span>, int),
]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Dumping the contents of maps is hard due to the diversity in map types. Each map type requires its own handling, beginning with manually downcasting the &lt;code>bpf_map&lt;/code> object to the correct container type. One approach to avoid implementing each lookup mechanism separately, would be through emulation of the &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/include/linux/bpf.h#L78">&lt;code>map_get_next_key&lt;/code>&lt;/a> and &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/kernel/bpf/syscall.c#L235">&lt;code>bpf_map_copy_value&lt;/code>&lt;/a> kernel functions, where the former is a function pointer found in the map&amp;rsquo;s operations structure. However, this is not in scope for the current plugin.&lt;/p>
&lt;p>Furthermore, the dumping could be enhanced by utilizing the BTF information that is optionally attached to the map to properly display keys and values, similar to the &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/kernel/trace/bpf_trace.c#L1015">&lt;code>bpf_snprintf_btf&lt;/code>&lt;/a> helper that can be used to pretty-print objects using their BTF information.&lt;/p>
&lt;p>We implemented the dumping for the most straightforward map type - arrays - but the plugin does not support dumping other types of maps.&lt;/p>
&lt;p>Entries of the &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/kernel/bpf/syscall.c#L54">&lt;code>link_idr&lt;/code>&lt;/a> point to objects of type &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/include/linux/bpf.h#L1259">&lt;code>bpf_link&lt;/code>&lt;/a>. Again, there is an informational structure, &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/include/uapi/linux/bpf.h#L6242">&lt;code>bpf_link_info&lt;/code>&lt;/a>, which is this time filled in the &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/kernel/bpf/syscall.c#L4246">&lt;code>bpf_link_get_info_by_fd&lt;/code>&lt;/a> function. By analyzing this function, we wrote the &lt;a href="https://github.com/vobst/BPFVol3/blob/main/src/plugins/bpf_listlinks.py">&lt;code>bpf_listlinks&lt;/code>&lt;/a> plugin that retrieves the following pieces of information.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">columns: list[tuple[str, Any]] &lt;span style="color:#f92672">=&lt;/span> [
(&lt;span style="color:#e6db74">&amp;#34;OFFSET (V)&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;ID&amp;#34;&lt;/span>, int),
(&lt;span style="color:#e6db74">&amp;#34;TYPE&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;PROG&amp;#34;&lt;/span>, int),
(&lt;span style="color:#e6db74">&amp;#34;ATTACH&amp;#34;&lt;/span>, str),
]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here, the last column is obtained by mimicking the virtual call to &lt;code>link-&amp;gt;ops-&amp;gt;fill_link_info&lt;/code> that adds link-type specific information about the associated attachment point, e.g., for tracing links it adds the BTF object and type IDs we saw earlier.&lt;/p>
&lt;h3 id="lsm-hooks">LSM Hooks&lt;/h3>
&lt;p>Our three listing plugins have one conceptual weakness in common: they rely entirely on information obtained by parsing the &lt;code>(prog|map|link)_idr&lt;/code>s. However, the entire ID mechanism is in the user-facing part of the BPF subsystem, its simply a means for user space to refer to BPF objects in syscalls. Thus, our plugins are susceptible to trivial anti-forensic tampering.&lt;/p>
&lt;p>In our research, we prototyped two anti-forensic methods that remove BPF objects from these structures while still keeping the corresponding program active in the kernel. First, the more straightforward way is to simply write a kernel module that uses standard APIs to remove IDs from the IDRs. The second one is based on the observation that the lifecycle of BPF objects is managed via reference counts. Thus, if we artificially increment the reference count of an object that (indirectly) holds references to all other objects that are required to operate a BPF program, e.g., a link, we can prevent the program&amp;rsquo;s destruction when all &amp;ldquo;regular&amp;rdquo; references are dropped.&lt;/p>
&lt;p>One approach to counter these anti-forensic measures is to &amp;ldquo;approach from the other side&amp;rdquo;. Instead of relying on information from sources that are far detached from the actual program execution, we go to the very places and mechanisms that invoke the program. The downside is obviously that this low-level code is much more program-type and architecture specific, the results, on the other hand, are more robust.&lt;/p>
&lt;p>In a &lt;a href="https://blog.eb9f.de/2023/04/24/lsm2bpf.html">previous blog post&lt;/a> we described the low-level details that lead up to the execution of BPF LSM programs in great detail. Based on this knowledge, we developed the &lt;a href="https://github.com/vobst/BPFVol3/blob/main/src/plugins/bpf_lsm.py">&lt;code>bpf_lsm&lt;/code>&lt;/a> plugin that can discover hidden BPF programs attached to security hooks. In short, the plugin checks the places where the kernel control flow may be diverted into the BPF VM for the presence of inline hooks. If they are found, it cross checks with the links IDR to see if there is a corresponding link, the absence of which is a strong indication of tampering. Additionally, the plugin is also valuable in the absence of tampering, as it shows you the exact program attachment point without the need to manually resolve BTF IDs. In particular, the plugin displays the number of attached programs and their IDs along with the name of the LSM hook where they are attached.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">columns: list[tuple[str, type]] &lt;span style="color:#f92672">=&lt;/span> [
(&lt;span style="color:#e6db74">&amp;#34;LSM HOOK&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;Nr. PROGS&amp;#34;&lt;/span>, int),
(&lt;span style="color:#e6db74">&amp;#34;IDs&amp;#34;&lt;/span>, str),
]
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="networking-hooks">Networking Hooks&lt;/h3>
&lt;p>As we described above, traffic control (tc) programs are especially useful for exfiltrating information from infected machines, e.g., by hijacking existing TCP connections. Thus, the second plugin that obtains its information from more tamper resistant sources targets tc BPF programs. It only relies on the &lt;a href="https://elixir.bootlin.com/linux/v6.1.65/source/include/net/sch_generic.h#L1265">&lt;code>mini_Qdisc&lt;/code>&lt;/a> structure that is used on the transmission and receive fast paths to look up queuing disciplines (qdisc) attached to a network device.&lt;/p>
&lt;p>We use the &lt;a href="https://github.com/volatilityfoundation/community3/blob/master/Sheffer_Shaked_Docker/plugins/ifconfig.py">&lt;code>ifconfig plugin&lt;/code>&lt;/a> by Ofek Shaked and Amir Sheffer to obtain a list of all network devices. Then, we find the above-mentioned structure and use it to collect all BPF programs that are involved into qdiscs on this device. With kernel 6.3 the process of locating the &lt;code>mini_Qdisc&lt;/code> from the network interface changed slightly due to the introduction of link-based attachment of tc programs, however, the plugin recognizes and handles both cases. Finally, the &lt;a href="https://github.com/vobst/BPFVol3/blob/main/src/plugins/bpf_netdev.py">&lt;code>bpf_netdev&lt;/code>&lt;/a> plugin displays the following information about each interface where at least one BPF program was found,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">columns: list[tuple[str, type]] &lt;span style="color:#f92672">=&lt;/span> [
(&lt;span style="color:#e6db74">&amp;#34;NAME&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;MAC ADDR&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;EGRESS&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;INGRESS&amp;#34;&lt;/span>, str),
]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>where the &lt;code>EGRESS&lt;/code> and &lt;code>INGRESS&lt;/code> hold the IDs of the programs that process packets flowing into the respective direction.&lt;/p>
&lt;h3 id="finding-processes">Finding Processes&lt;/h3>
&lt;p>Yet another way to discover BPF objects is through the processes that hold on to them. As with many other resources, programs, links, maps, and btf are represented to processes as file descriptors. They can be used to act on the object, retrieve information about it, and serve as a mechanism to clean up after processes that did not exit gracefully. Furthermore, an investigator might want to find out which process holds on to a specific BPF object in order to investigate this process further.&lt;/p>
&lt;p>Thus, the &lt;a href="https://github.com/vobst/BPFVol3/blob/main/src/plugins/bpf_listprocs.py">&lt;code>bpf_listprocs&lt;/code>&lt;/a> plugin displays the following pieces of information for every process that holds on to at least one BPF object via a file descriptor.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">columns: list[tuple[str, type]] &lt;span style="color:#f92672">=&lt;/span> [
(&lt;span style="color:#e6db74">&amp;#34;PID&amp;#34;&lt;/span>, int),
(&lt;span style="color:#e6db74">&amp;#34;COMM&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;PROGS&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;MAPS&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;LINKS&amp;#34;&lt;/span>, str),
]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here, the &lt;code>PROGS&lt;/code>. &lt;code>MAPS&lt;/code>, and &lt;code>LINKS&lt;/code> columns display the IDs of the respective objects. This list is generated by iterating over all file descriptors and the associated &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/include/linux/fs.h#L940">&lt;code>file&lt;/code>&lt;/a> structures. BPF objects are identified by checking the file operations &lt;code>f_op&lt;/code> pointer, and the corresponding &lt;code>bpf_(prog|map|link)&lt;/code> structures are found by following the pointer stored in the &lt;code>private&lt;/code> member.&lt;/p>
&lt;p>Not every BPF object must be reachable from the process list, however. They can, for example, also be represented as files under the special &lt;code>bpf&lt;/code> filesystem, which is usually mounted at &lt;code>/sys/fs/bpf&lt;/code>, or processes can close file descriptors and the object will remain alive as long as there are other references to it.&lt;/p>
&lt;h3 id="connecting-the-dots">Connecting the Dots&lt;/h3>
&lt;p>Finally, we would like to present the &lt;a href="https://github.com/vobst/BPFVol3/blob/main/src/plugins/bpf_graph.py">&lt;code>bpf_graph&lt;/code>&lt;/a> plugin, a meta analysis that we have build on top of the four listing plugins. As its name suggest, its goal is to visualize the state of the BPF subsystem as a graph.&lt;/p>
&lt;p>There are four types of nodes in this graph: programs, maps, links and processes. Different node types are distinguished by shape. Within a node type, the different program/map/link types are distinguished by color and process nodes are colored based on their process ID (PID). Furthermore, map and program nodes are labeled with the ID and name of the object, link nodes are labeled with the ID and attachment information of the link, and process nodes receive the PID and comm (name of the user-space program binary) of their process as labels.&lt;/p>
&lt;p>There are three types of edges to establish relationships between nodes: file descriptor, link, and map. File descriptor edges are dotted and connect processes to BPF objects that they have an open fd for. Link edges are dashed and connect BPF links to the program they reference. Finally, map edges are drawn solid and connect maps to all of the programs that use them.&lt;/p>
&lt;p>Especially for large applications with hundreds or even thousands of objects, it is essential to be able to filter the graph to make it useful. We have therefore implemented two additional options that can be passed to the plugin. First, you can pass a list of node types to include in the output. Second, you can pass a list of nodes, and only the connected components that contain at least one of those nodes will be drawn.&lt;/p>
&lt;p>The idea of this plugin is to make the information of the four listing plugins more accessible to investigators by combining it into a single picture. This is especially useful for complex applications with possibly hundreds of programs and maps, or on busy systems where many different processes have loaded BPF programs.&lt;/p>
&lt;p>Plugin output comes in two forms, a dot-format encoding of the graph, where each BPF object node has metadata containing all of the plugin columns, and as a picture of the graph, drawn with a default layout algorithm. The latter should suffice for most users, but the former allows advanced use-cases to do further processing.&lt;/p>
&lt;p>&lt;em>Note: We provide &lt;a href="https://github.com/vobst/BPFVol3/tree/main/docs">standalone documentation&lt;/a> for all plugins in our project on GitHub.&lt;/em>&lt;/p>
&lt;h2 id="case-study">Case Study&lt;/h2>
&lt;p>In this section we will use the plugins to examine the memory image of a system with a high level of BPF activity. To get a diverse set of small BPF applications we launched the example programs that come with &lt;a href="https://github.com/libbpf/libbpf-bootstrap">libbpf-bootstrap&lt;/a> and some of the kernel self-tests. You can download the &lt;a href="https://drive.proton.me/urls/DBWB4GFRK8#7IbjrGRg6o5z">memory image&lt;/a> and &lt;a href="https://drive.proton.me/urls/BCKSBBZ6Z4#ZeZcrnYlF7tZ">symbols&lt;/a> to follow along. If you prefer to analyze a single, large application have a look at the &lt;code>krie&lt;/code> example &lt;a href="https://github.com/vobst/BPFVol3/blob/main/docs/examples/krie/krie.md">in our plugin documentation&lt;/a>.&lt;/p>
&lt;p>A good first step is to use the graph plugin to get an overview of the subsystem (&lt;code># vol -f /io/dumps/debian-bookworm-6.1.0-13-amd64_all.raw linux.bpf_graph&lt;/code>).&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2023/12/debian-bookworm-6.1.0-13-amd64_all.png" alt="debian-bookworm-6.1.0-13-amd64_all.png">&lt;/p>
&lt;p>As we can see, there are several components corresponding to different processes, each of which holds a number of BPF resources. Let us begin by examining the &amp;ldquo;Hello, World&amp;rdquo; example of BPF, the &lt;a href="https://github.com/libbpf/libbpf-bootstrap/blob/master/examples/c/minimal.bpf.c">&lt;code>minimal&lt;/code>&lt;/a> program:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">/* Copyright (c) 2020 Facebook */&lt;/span>
&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;linux/bpf.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;bpf/bpf_helpers.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">char&lt;/span> LICENSE[] SEC(&lt;span style="color:#e6db74">&amp;#34;license&amp;#34;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Dual BSD/GPL&amp;#34;&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> my_pid &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
SEC(&lt;span style="color:#e6db74">&amp;#34;tp/syscalls/sys_enter_write&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">int&lt;/span> handle_tp(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ctx)
{
&lt;span style="color:#66d9ef">int&lt;/span> pid &lt;span style="color:#f92672">=&lt;/span> bpf_get_current_pid_tgid() &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (pid &lt;span style="color:#f92672">!=&lt;/span> my_pid)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
bpf_printk(&lt;span style="color:#e6db74">&amp;#34;BPF triggered from PID %d.&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, pid);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The above source code is compiled with clang to produce an ELF relocatable object file. It contains the BPF bytecode along with additional information, like BTF sections, CORE relocations, programs as well as their attachment mechanisms and points, maps that are used and so on. This ELF is then embedded into a user space program that statically links against libbpf. At runtime, it passed the ELF to libbpf, which takes care of all the relocations and kernel interactions required to wire up the program to the BPF VM.&lt;/p>
&lt;p>With the above C code in the back of our heads, we can now have a look at the relevant component of live system’s BPF object graph. To limit the output of the plugin to the connected components that contain certain nodes, we can add the &lt;code>--components&lt;/code> flag to the invocation and give it a list of nodes (the format is &lt;code>&amp;lt;node_type&amp;gt;-&amp;lt;id&amp;gt;&lt;/code> where &lt;code>node_type&lt;/code> is in &lt;code>{map,link,prog,proc}&lt;/code> and &lt;code>id&lt;/code> is the BPF object ID or PID).&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2023/12/debian-bookworm-6.1.0-13-amd64_all_components_proc-695.png" alt="debian-bookworm-6.1.0-13-amd64_all_components_proc-695.png">&lt;/p>
&lt;p>As we can see, the ELF has caused libbpf to create a program, two maps and a link while loading. We can now use our plugins to gather more information about each object. Let&amp;rsquo;s start with the program itself.&lt;/p>
&lt;pre tabindex="0">&lt;code># vol -f /io/dumps/debian-bookworm-6.1.0-13-amd64_all.raw linux.bpf_listprogs --id 98 --dump-jited --dump-xlated
Volatility 3 Framework 2.5.0
Progress: 100.00 Stacking attempts finished
OFFSET (V) ID TYPE NAME TAG LOADED AT MAP IDs BTF ID HELPERS
0xbce500673000 98 TRACEPOINT handle_tp 6a5dcef153b1001e 1417821088492 40,45 196 bpf_get_current_pid_tgid,bpf_trace_printk
&lt;/code>&lt;/pre>&lt;p>By looking at the last column we can see that it is indeed using two kernel helper functions, where the apparent call to &lt;code>bpf_printk&lt;/code> turns out to be a macro that expands to &lt;code>bpf_trace_printk&lt;/code>. If we look at the program byte and the machine code side by side, we can discover a few things.&lt;/p>
&lt;pre tabindex="0">&lt;code># cat .prog_0xbce500673000_98_bdisasm
0x0: 85 00 00 00 10 b2 02 00 call 0x2b210
0x8: 77 00 00 00 20 00 00 00 rsh64 r0, 0x20
0x10: 18 01 00 00 00 a0 49 00 00 00 00 00 e5 bc ff ff lddw r1, 0xffffbce50049a000
0x20: 61 11 00 00 00 00 00 00 ldxw r1, [r1]
0x28: 5d 01 05 00 00 00 00 00 jne r1, r0, +0x5
0x30: 18 01 00 00 10 83 83 f5 00 00 00 00 7b 9b ff ff lddw r1, 0xffff9b7bf5838310
0x40: b7 02 00 00 1c 00 00 00 mov64 r2, 0x1c
0x48: bf 03 00 00 00 00 00 00 mov64 r3, r0
0x50: 85 00 00 00 80 0c ff ff call 0xffff0c80
0x58: b7 00 00 00 00 00 00 00 mov64 r0, 0x0
0x60: 95 00 00 00 00 00 00 00 exit
# cat .prog_0xbce500673000_98_mdisasm
handle_tp:
0xffffc03772a0: 0f 1f 44 00 00 nop dword ptr [rax + rax]
0xffffc03772a5: 66 90 nop
0xffffc03772a7: 55 push rbp
0xffffc03772a8: 48 89 e5 mov rbp, rsp
0xffffc03772ab: e8 d0 fc aa f1 call 0xffffb1e26f80 # bpf_get_current_pid_tgid
0xffffc03772b0: 48 c1 e8 20 shr rax, 0x20
0xffffc03772b4: 48 bf 00 a0 49 00 e5 bc ff ff movabs rdi, 0xffffbce50049a000 # minimal_.bss + 0x110
0xffffc03772be: 8b 7f 00 mov edi, dword ptr [rdi]
0xffffc03772c1: 48 39 c7 cmp rdi, rax
0xffffc03772c4: 75 17 jne 0xffffc03772dd # handle_tp + 0x3d
0xffffc03772c6: 48 bf 10 83 83 f5 7b 9b ff ff movabs rdi, 0xffff9b7bf5838310 # minimal_.rodata + 0x110
0xffffc03772d0: be 1c 00 00 00 mov esi, 0x1c
0xffffc03772d5: 48 89 c2 mov rdx, rax
0xffffc03772d8: e8 13 57 a7 f1 call 0xffffb1dec9f0 # bpf_trace_printk
0xffffc03772dd: 31 c0 xor eax, eax
0xffffc03772df: c9 leave
0xffffc03772e0: c3 ret
0xffffc03772e1: cc int3
&lt;/code>&lt;/pre>&lt;p>The first lesson here is probably that symbol annotations are useful :). As expected, when ignoring the prologue and epilogue inserted by the JIT-compiler, the translation between BPF and x86_64 is essentially one-to-one. Furthermore, uses of global C variables like &lt;code>my_pid&lt;/code> or the format string result in direct references to kernel memory, where the closest preceding symbols are the &lt;code>minimal_.bss&lt;/code>&amp;rsquo;s and &lt;code>minimal_.rodata&lt;/code>&amp;rsquo;s &lt;code>bpf_map&lt;/code> structures, respectively. For simple array maps, the &lt;code>bpf_map&lt;/code> structure resides at the beginning of a buffer that also holds the array data, &lt;code>0x110&lt;/code> is simply the offset at which the map&amp;rsquo;s payload data starts. More generally, libbpf will automatically create maps to hold the variables living in the &lt;code>.data&lt;/code>, &lt;code>.rodata&lt;/code>, and &lt;code>.bss&lt;/code> sections.&lt;/p>
&lt;p>Dumping the map contents confirms that the &lt;code>.bss&lt;/code> map holds the &lt;code>minimal&lt;/code> process&amp;rsquo;s PID while the &lt;code>.rodata&lt;/code> map contains the format string.&lt;/p>
&lt;pre tabindex="0">&lt;code># vol -f /io/dumps/debian-bookworm-6.1.0-13-amd64_all.raw linux.bpf_listmaps --id 45 40 --dump
Volatility 3 Framework 2.5.0
Progress: 100.00 Stacking attempts finished
OFFSET (V) ID TYPE NAME KEY SIZE VALUE SIZE MAX ENTRIES
0xbce500499ef0 40 ARRAY minimal_.bss 4 4 1
0x9b7bf5838200 45 ARRAY minimal_.rodata 4 28 1
# cat .map_0xbce500499ef0_40
{&amp;quot;0&amp;quot;: &amp;quot;section (.bss) = {\n (my_pid) (int) b'\\xb7\\x02\\x00\\x00'\n&amp;quot;}
# cat .map_0x9b7bf5838200_45
{&amp;quot;0&amp;quot;: &amp;quot;section (.rodata) = {\n (handle_tp.____fmt) b'BPF triggered from PID %d.\\n\\x00'\n&amp;quot;}
&lt;/code>&lt;/pre>&lt;p>In the source code we saw the directive &lt;code>SEC(&amp;quot;tp/syscalls/sys_enter_write&amp;quot;)&lt;/code>, which instructs the compiler to place the &lt;code>handle_tp&lt;/code> function&amp;rsquo;s BPF bytecode in an ELF section called &lt;code>&amp;quot;tp/syscalls/sys_enter_write&amp;quot;&lt;/code>. While loading, libbpf picks this up and creates a link that attaches the program to a perf event that is activated by the &lt;code>sys_enter_write&lt;/code> tracepoint. We can inspect the link, but getting more information about the corresponding trace point is not yet implemented. Contributions are always highly welcome :)&lt;/p>
&lt;pre tabindex="0">&lt;code># vol -f /io/dumps/debian-bookworm-6.1.0-13-amd64_all.raw linux.bpf_listlinks --id 11
Volatility 3 Framework 2.5.0
Progress: 100.00 Stacking attempts finished
OFFSET (V) ID TYPE PROG ATTACH
0x9b7bc2c09ae0 11 PERF_EVENT 98
&lt;/code>&lt;/pre>&lt;p>Dissecting the &amp;ldquo;Hello, World&amp;rdquo; programm was useful to get an impression of what a BPF application looks like at runtime. Before concluding this section, we will have a look at a less minimalist example, the process with PID 687.&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2023/12/debian-bookworm-6.1.0-13-amd64_all_components_proc-687.png" alt="debian-bookworm-6.1.0-13-amd64_all_components_proc-687.png">&lt;/p>
&lt;p>This process is one of the kernel self-tests. It tests a BPF feature that allows to load new function pointer tables used for dynamic dispatch (so called structure operations), where the individual operations are implemented as BPF programs, at runtime. The programs that implement the new operations can be recognized by their type &lt;code>STRUCT_OPS&lt;/code>.&lt;/p>
&lt;pre tabindex="0">&lt;code># vol -f /io/dumps/debian-bookworm-6.1.0-13-amd64_all.raw linux.bpf_listprogs --id 37 39 40 42 43 44 45
Volatility 3 Framework 2.5.0
Progress: 100.00 Stacking attempts finished
OFFSET (V) ID TYPE NAME TAG LOADED AT MAP IDs BTF ID HELPERS
0xbce5003b7000 37 STRUCT_OPS dctcp_init 562160e42a59841c 1417427431243 9,10,7 124 bpf_sk_storage_get,bpf_sk_storage_delete
0xbce50046b000 39 STRUCT_OPS dctcp_ssthresh cddbf7f9cf9b52d7 1417427590219 9 124
0xbce500473000 40 STRUCT_OPS dctcp_update_alpha 6e84698df8007e42 1417427647277 9 124
0xbce500487000 42 STRUCT_OPS dctcp_state dc878de7981c438b 1417427777414 9 124
0xbce500493000 43 STRUCT_OPS dctcp_cwnd_event 70cbe888b7ece66f 1417427888091 9 124 bpf_tcp_send_ack
0xbce5004e5000 44 STRUCT_OPS dctcp_cwnd_undo 78b977678332d89f 1417428066805 9 124
0xbce5004eb000 45 STRUCT_OPS dctcp_cong_avoid 20ff0d9ab24c8843 1417428109672 9 124 tcp_reno_cong_avoid
&lt;/code>&lt;/pre>&lt;p>The mapping between the programs and the function pointer table they implement is realized through a special map of type &lt;code>STRUCT_OPS&lt;/code> created by the process.&lt;/p>
&lt;pre tabindex="0">&lt;code># vol -f /io/dumps/debian-bookworm-6.1.0-13-amd64_all.raw linux.bpf_listmaps --id 11 12
Volatility 3 Framework 2.5.0
Progress: 100.00 Stacking attempts finished
OFFSET (V) ID TYPE NAME KEY SIZE VALUE SIZE MAX ENTRIES
0x9b7bc3c41000 11 STRUCT_OPS dctcp_nouse 4 256 1
0x9b7bc3c43400 12 STRUCT_OPS dctcp 4 256 1
&lt;/code>&lt;/pre>&lt;p>Unfortunately, the current implementation does not parse the contents of the map, so it cannot determine the name of the kernel structure being implemented and the mapping between its member functions and the BPF programs. As always, contributions are highly welcome :). In this case, we would find out that it implements &lt;a href="https://elixir.bootlin.com/linux/v6.1.65/source/include/net/tcp.h#L1071">&lt;code>tcp_congestion_ops&lt;/code>&lt;/a> to load a new TCP congestion control algorithm on the fly.&lt;/p>
&lt;p>There is a lot more to explore in this memory image, so feel free to have a closer look at the other processes. You might also want to check out the &lt;code>krie&lt;/code> example in &lt;a href="https://github.com/vobst/BPFVol3/blob/main/docs/examples/krie/krie.md">&lt;code>our documentation&lt;/code>&lt;/a> to get an impression of a larger BPF application.&lt;/p>
&lt;h2 id="testing">Testing&lt;/h2>
&lt;p>We tested the plugins on memory images acquired from virtual machines running on QEMU/KVM that were suspended for the duration of the acquisition process. To ensure the correctness of all plugin results, we have cross-checked them by debugging the guest kernel as well as comparing them with &lt;code>bpftool&lt;/code> running on the guest.&lt;/p>
&lt;p>Below is a list of the distributions and releases that we used for manual testing&lt;/p>
&lt;p>&lt;strong>Debian&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>12.2.0-14, Linux 6.1.0-13&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Ubuntu&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>22.04.2, Linux 5.15.0-89-generic&lt;/li>
&lt;li>20.04, Linux 5.4.0-26-generic&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Custom&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Linux 6.0.12, various configurations&lt;/li>
&lt;li>Linux 6.2.12, various configurations&lt;/li>
&lt;/ul>
&lt;p>For each of these kernels, we tested at least all the plugins on an image taken during the execution of the libbpf-bootstrap example programs.&lt;/p>
&lt;p>Additionally, to the above mentioned kernels we also developed an evaluation framework (the code is not public). The framework is based on &lt;a href="https://www.vagrantup.com/">Vagrant&lt;/a> and &lt;a href="https://libvirt.org/">libvirt&lt;/a>/&lt;a href="https://linux-kvm.org/page/Main_Page">KVM&lt;/a>. First we create and update all VMs. After that we run programs from &lt;code>libbpf-bootstrap&lt;/code> with &lt;code>nohup&lt;/code> so that we can leave the VM and dump the memory from outside. To dump the memory we use &lt;code>virsh&lt;/code> with &lt;code>virsh dump &amp;lt;name of VM&amp;gt; --memory-only&lt;/code>. &lt;code>virsh dump&lt;/code> pauses the VM for a clean acquisition of the main memory. We also install debug symbols for all the Linux distributions under investigation so that we can gather the debug kernels (&lt;code>vmlinux&lt;/code> with DWARF debugging information) and the &lt;code>System.map&lt;/code> file. We then use both files with &lt;a href="https://github.com/volatilityfoundation/dwarf2json">&lt;code>dwarf2json&lt;/code>&lt;/a> to generate the ISF information that Volatility 3 needs. Currently, we tested the following Linux distributions with their respective kernels:&lt;/p>
&lt;ul>
&lt;li>Alma Linux 9 - Linux kernel 5.14.0-362.8.1.el9_3.x86_64 ✅&lt;/li>
&lt;li>Fedora 38 - Linux kernel 6.6.6-100.fc38.x86_64 ✅&lt;/li>
&lt;li>Fedora 39 - Linux kernel 6.6.6-200.fc39.x86_64 ✅&lt;/li>
&lt;li>CentOS Stream 9 - Linux kernel 5.14.0-391.el9.x86_64 ✅&lt;/li>
&lt;li>Rocky Linux 8 - Linux kernel 4.18.0-513.9.1.el8_9.x86_64 ✅&lt;/li>
&lt;li>Rocky Linux 9 - 🪲 &lt;code>kernel-debuginfo-common&lt;/code> package is missing so the kernel debugging symbols cannot be installed (&lt;a href="https://download.rockylinux.org/pub/rocky/9/BaseOS/x86_64/debug/tree/Packages/k/">list of packages&lt;/a>)&lt;/li>
&lt;li>Debian 11 - Linux kernel 5.10.0-26-amd64 ✅&lt;/li>
&lt;li>Debian 12 - Linux kernel 6.1.0-13-amd64 ✅&lt;/li>
&lt;li>Ubuntu 22.04 - Linux kernel 5.15.0-88-generic ✅&lt;/li>
&lt;li>Ubuntu 23.10 - Linux kernel 6.5.0-10-generic ✅ (works partially, but process listing is broken due to this &lt;a href="https://github.com/volatilityfoundation/dwarf2json/issues/57">dwarf2json GitHub Issue&lt;/a>)&lt;/li>
&lt;li>ArchLinux - Linux kernel 6.6.7-arch1-1 ✅ (works partially, but breaks probably due to the same issue as &lt;a href="https://github.com/volatilityfoundation/volatility3/issues/1065">volatility3/dwarf2json GitHub Issue&lt;/a>)&lt;/li>
&lt;li>openSUSE Tumbleweed - 🪲 we currently did not find the debugging symbols in the debugging kernel (&lt;a href="https://bugzilla.opensuse.org/show_bug.cgi?id=1218163">openSUSE Bugzilla&lt;/a>)&lt;/li>
&lt;/ul>
&lt;p>We will check if the problems get resolved and re-evaluate our plugin. Generally, our framework is designed to support more distributions as well and we will try to evaluate the plugin on a wider variety of them.&lt;/p>
&lt;p>During our automated analysis we encountered an interesting problem. To collect the kernels with debugging symbols from the VMs we need to copy them to the host. When copying the kernel executable file it will be read into main memory by the kernel&amp;rsquo;s page-cache mechanism. This implies that parts of the kernel file (vmlinux) and the kernel itself (the running kernel not the file) may be present in the dump. This can lead to the problem of the Volatility 3 function &lt;code>find_aslr&lt;/code> (&lt;a href="https://github.com/volatilityfoundation/volatility3/blob/fdf93f502fa8d0edc2b60764463aee3c455aeb03/volatility3/framework/automagic/linux.py#L121">source code&lt;/a>) first finding matches in the page-cached kernel file (vmlinux) and not in the running kernel. An issue has been opened &lt;a href="https://github.com/volatilityfoundation/volatility3/pull/1070">here&lt;/a>.&lt;/p>
&lt;h2 id="related-work">Related Work&lt;/h2>
&lt;p>There are several articles on BPF that cover different security-related aspects of the subsystem. In this section, we will briefly discuss the ones that are most relevant to the presented work.&lt;/p>
&lt;p>&lt;strong>Memory Forensics&lt;/strong>: The &lt;a href="https://github.com/crash-utility/crash/tree/master">&lt;code>crash&lt;/code>&lt;/a> utility, which is used to analyze live systems or kernel core dumps, has a &lt;a href="https://github.com/crash-utility/crash/blob/master/bpf.c">&lt;code>bpf&lt;/code> subcommand&lt;/a> that can be used to display information about BPF maps and programs. However, as it is not a forensics tool it relies solely on the information obtained via the &lt;code>prog_idr&lt;/code> and &lt;code>map_ird&lt;/code>. Similarly, the &lt;a href="https://github.com/osandov/drgn">&lt;code>drgn&lt;/code>&lt;/a> programmable debugger comes with a &lt;a href="https://github.com/osandov/drgn/blob/main/tools/bpf_inspect.py">script&lt;/a> to list BPF programs and maps but suffers from the same problems when it comes to anti-forensic techniques. Furthermore, &lt;code>drgn&lt;/code> and &lt;code>crash&lt;/code> are primarily known as debugging tools for systems developers and as such not necessarily well-established in the digital forensics and incidence response (DFIR) community. In contrast, we implemented our analyses as plugins for the popular Volatility framework well-known in the DFIR community. Finally, A. Case and G. Richard presented Volatility plugins for investigating the Linux tracing infrastructure in their &lt;a href="https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Fixing-A-Memory-Forensics-Blind-Spot-Linux-Kernel-Tracing-wp.pdf">BlackHat US 2021 paper&lt;/a>. Apart from a plugin that lists programs by parsing the &lt;code>prog_idr&lt;/code>, they have also implemented several plugins that can find BPF programs by analyzing the data structures of the attachment mechanisms they use, such as kprobes, tracepoints or perf events. Thus, their plugins are also able to discover inconsistencies that could reveal anti-forensic tampering. However, they have never publicly released their plugins and despite several attempts we have been unable to contact the authors to obtain a copy of the source code. Volatility already supports detecting BPF programs attached to sockets in its &lt;a href="https://github.com/volatilityfoundation/volatility3/blame/develop/volatility3/framework/plugins/linux/sockstat.py#L163">&lt;code>sockstat&lt;/code>&lt;/a> plugin. The displayed information is limited to names and IDs.&lt;/p>
&lt;p>&lt;strong>Reverse Engineering&lt;/strong>: Reverse engineering BPF programs is a key step while triaging the findings of our plugins. Recently, the &lt;a href="https://github.com/NationalSecurityAgency/ghidra">Ghidra&lt;/a> software reverse engineering (SRE) suite gained &lt;a href="https://github.com/NationalSecurityAgency/ghidra/pull/4258">support for the BPF architecture&lt;/a>, which means that its powerful decompiler can be used to analyze BPF bytecode extracted from kernel memory or user-space programs. Furthermore, BPF bytecode is oftentimes embedded into user-space programs that use framework libraries to load it into the kernel at runtime. For programs written in the Go programming language, &lt;a href="https://github.com/Gui774ume/ebpfkit-monitor">ebpfkit-monitor&lt;/a> can parse the binary format of these embedded files to list the defined programs and maps as well as their interactions. It uses this information to generate graphs that are similar to those of our &lt;code>bpf_graph&lt;/code> plugin. Although the utility of these graphs has inspired our plugin, it is fundamentally different in that it displays information about the state of the kernel&amp;rsquo;s BPF subsystem extracted from a memory image. Consequently, it is inherently agnostic to the user-space framework that was used for compiling and loading the programs. Additionally, it displays the actual state of the BPF subsystem instead of the BPF objects that might be created by an executable at runtime.&lt;/p>
&lt;p>&lt;strong>Runtime Protection and Monitoring&lt;/strong>: Important aspects of countering BPF malware are preventing attackers from loading malicious BPF programs and logging suspicious events for later review. &lt;a href="https://github.com/Gui774ume/krie">krie&lt;/a> and &lt;a href="https://github.com/Gui774ume/ebpfkit-monitor">ebpfkit-monitor&lt;/a> are tools that can be used to log BPF-related events as well as to deny processes access to the BPF system call.&lt;/p>
&lt;p>Simply blocking access on a per-process basis is too course-grained for many applications and thus &lt;a href="https://medium.com/@yunwei356/the-secure-path-forward-for-ebpf-runtime-challenges-and-innovations-968f9d71fc16">multiple approaches were proposed&lt;/a> to implement a more fine-grained access control model for the BPF subsystem to facilitate the realization of least privilege policies. Among those, one can further distinguish between proposals that implement access control in user space, kernel space, or a hypervisor.&lt;/p>
&lt;p>&lt;a href="https://bpfman.io/main/">&lt;code>bpfman&lt;/code>&lt;/a> (formerly known as bpfd) is a privileged user space daemon that acts as proxy for loading BPF programs and can be used to implement different access control policies. A combination of a privileged user-space daemon and kernel changes is used in the proposed &lt;a href="https://lwn.net/Articles/947173/">BPF token approach&lt;/a> that allows delegation of access to specific parts of the BPF subsystem to container processes by a privileged daemon.&lt;/p>
&lt;p>A fine-grained in-kernel access control is offered by the &lt;a href="https://dl.acm.org/doi/abs/10.5555/3620237.3620571">CapBits&lt;/a> proposed by Yi He et al. Here, two bitfields are added to the &lt;code>task_struct&lt;/code>, where one defines the access that a process has to the BPF subsystem, e.g., allowed program types and helpers, and the other restricts the access that BPF programs can have on the process, e.g., to prevent it from being traced by kprobe programs. Namespaces are already used in many areas of the Linux kernel to virtualize global resources like PIDs or network devices. Thus, Y. &lt;a href="https://lwn.net/Articles/927354/">Shao proposed introducing BPF namespaces&lt;/a> to limit the scope of loaded programs to processes inside of the namespace. Finally, &lt;a href="https://www.youtube.com/watch?v=9p4qviq60z8">signatures over programs&lt;/a> are a mechanism that allows the kernel to verify their provenance, which can be used analogous to module signatures that prevent attackers from loading malicious kernel modules.&lt;/p>
&lt;p>Lastly, Y. Wang et al. &lt;a href="https://dl.acm.org/doi/10.1145/3609021.3609305">proposed&lt;/a> moving large parts of the BPF VM from the kernel into a hypervisor, where they implement a multi-step verification process that includes enforcing a security policy, checking signatures, and scanning for known malicious programs. In the security policy, allowed programs can be specified as a set of deterministic finite automata, which allows for accepting dynamically generated programs without allowing for arbitrary code to be loaded.&lt;/p>
&lt;p>All these approaches are complementary to our plugins as they focus on reducing the chance that an attacker can successfully load a malicious program, while we assume that this step has already happened and aim to detect their presence.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>In this post, we gave an introduction to the Linux BPF subsystem and discussed its potential for abuse. We then presented seven Volatility plugins that allow investigators to detect BPF malware in memory images and evaluated them on multiple versions of popular Linux distributions. To conclude the post, we will briefly discuss related projects we are working on and plans for future work.&lt;/p>
&lt;p>This project grew out of the preparation of a &lt;a href="https://web.archive.org/web/20230323233100/https://dfrws.org/forensic-analysis-of-ebpf-based-linux-rootkits/">workshop&lt;/a> on BPF rootkits at the DFRWS EU 2023 annual conference (&lt;a href="https://github.com/vobst/bpf-rootkit-workshop">materials&lt;/a>). We began working on this topic because we believe that the forensic community needs to expand its toolbox in response to the rise of BPF in the Linux world to fill blind spots in existing analysis methods. Additionally, investigators who may encounter BPF in their work should be made aware of the potential relevance of the subsystem to their investigation.&lt;/p>
&lt;p>While the workshop, our plugins, and this post are an important step towards this goal, much work remains to be done. First, in order for the present work to be useful in the real world our next goal must be to upstream most of it into the Volatility 3 project. Only this will ensure that investigators all around the world will be able to easily find and use it. This will require:&lt;/p>
&lt;ul>
&lt;li>Refactoring of our utility code to use Volatility 3&amp;rsquo;s extension class mechanism&lt;/li>
&lt;li>The &lt;code>bpf_graph&lt;/code> plugin relies on &lt;a href="https://networkx.org/documentation/stable/reference/algorithms/index.html">networkx&lt;/a>, which is not yet a dependency of Volatility 3. If the introduction of a new dependency into the upstream project is not feasible, one could make it optional by checking for the presence of the package within the plugin.&lt;/li>
&lt;li>Additional testing on older kernel versions and kernels with diverse configurations to meet Volatility&amp;rsquo;s high standards regarding compatibility&lt;/li>
&lt;/ul>
&lt;p>We will be happy to work with upstream developers to make the integration happen.&lt;/p>
&lt;p>Furthermore, there remains the problem of dealing with the wide variety of map types when extracting their contents, as well as the related problem of pretty-printing them using BTF information. Here, we consider a manual implementation approach to be impractical and would explore the possibility of using emulation of the relevant functions.&lt;/p>
&lt;p>Regarding the advanced analysis aimed at countering anti-forensics, we have also implemented consistency checks against the lists of kprobes and tracepoints, but these require further work to be ready for publication. We also described additional analyses in our workshop that still need to be implemented.&lt;/p>
&lt;p>Finally, an interesting side effect of the introduction of BPF into the Linux kernel is that most of the functionality requires BTF information for the kernel and modules to be available. This provides an easy solution to the problem of obtaining type information from a raw memory image, a step that is central to automatic profile generation. We have already shown that it is possible to reliably extract BTF sections from memory images by implementing a &lt;a href="https://github.com/vobst/BPFVol3/blob/extractbtf/src/plugins/btf_extract.py">plugin&lt;/a> for that. We have also explored the possibility of combining this with existing approaches for extracting symbol information in order to obtain working profiles from a dump. While the results are promising, further work is needed to have a usable solution.&lt;/p>
&lt;h2 id="appendix">Appendix&lt;/h2>
&lt;h3 id="a-kernel-configuration">A: Kernel Configuration&lt;/h3>
&lt;p>This section provides a list of compile-time kernel configuration options that can be adjusted to restrict the capabilities of BPF programs. In general, it is recommended to disable unused features in order to reduce the attack surface of a system.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/kernel/bpf/Kconfig#L26">&lt;code>BPF_SYSCALL=n&lt;/code>&lt;/a>: Disables the BPF system call. Probably breaks most systemd-based systems.&lt;/li>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/lib/Kconfig.debug#L345">&lt;code>DEBUG_INFO_BTF=n&lt;/code>&lt;/a>: Disables generation of BTF debug information, i.e., CORE no longer works on this system. Forces attackers to compile on/for the system they want to compromise.&lt;/li>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/kernel/bpf/Kconfig#L90">&lt;code>BPF_LSM=n&lt;/code>&lt;/a>: BPF programs cannot be attached to LSM hooks.&lt;/li>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v6.1.67/source/security/lockdown/Kconfig#L33">&lt;code>LOCK_DOWN_KERNEL_FORCE_INTEGRITY=y&lt;/code>&lt;/a>: Prohibits the use of &lt;code>bpf_probe_write_user&lt;/code>.&lt;/li>
&lt;li>&lt;a href="https://www.kernelconfig.io/CONFIG_NET_CLS_BPF?q=NET_CLS_BPF&amp;amp;kernelversion=6.6.6&amp;amp;arch=x86">&lt;code>NET_CLS_BPF=n&lt;/code>&lt;/a> and &lt;a href="https://www.kernelconfig.io/CONFIG_NET_ACT_BPF?q=CONFIG_NET_ACT_BPF&amp;amp;kernelversion=6.6.6&amp;amp;arch=x86">&lt;code>NET_ACT_BPF=n&lt;/code>&lt;/a>: BPF programs cannot be used in TC classifier actions. Stops some data exfiltration techniques.&lt;/li>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v6.1.67/source/lib/Kconfig.debug#L1880">&lt;code>FUNCTION_ERROR_INJECTION=n&lt;/code>&lt;/a>: Disables the function error injection framework, i.e., BPF programs can no longer use &lt;code>bpf_override_return&lt;/code>.&lt;/li>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/net/netfilter/Kconfig#L1168">&lt;code>NETFILTER_XT_MATCH_BPF=n&lt;/code>&lt;/a>: Disables option to use &lt;a href="https://blog.cloudflare.com/programmable-packet-filtering-with-magic-firewall/">BPF programs in nftables rules&lt;/a>. Could be used to implement malicious firewall rules.&lt;/li>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/kernel/trace/Kconfig#L696">&lt;code>BPF_EVENTS=n&lt;/code>&lt;/a>: Removes the option to attach BPF programs to kprobes, uprobes, and tracepoints.&lt;/li>
&lt;/ul>
&lt;p>Below are options that limit features that we consider less likely to be used by malware.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/net/bpfilter/Kconfig#L2">&lt;code>BPFILTER=n&lt;/code>&lt;/a>: This is an unfinished BPF-based replacement of iptables/nftables (currently not functional).&lt;/li>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/net/Kconfig#L397">&lt;code>LWTUNNEL_BPF=n&lt;/code>&lt;/a>: Disables the use of BPF programs for routing decisions in light weight tunnels.&lt;/li>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/init/Kconfig#L1157">&lt;code>CGROUP_BPF=n&lt;/code>&lt;/a>: Disables the option to attach BPF programs to cgoups. Cgroup programs can monitor various networking-related events of processes in the group. Probably breaks most systemd-based systems.&lt;/li>
&lt;/ul></content></item><item><title>Exploration of the Dirty Pipe Vulnerability (CVE-2022-0847)</title><link>https://lolcads.github.io/posts/2022/06/dirty_pipe_cve_2022_0847/</link><pubDate>Mon, 06 Jun 2022 19:57:03 +0200</pubDate><guid>https://lolcads.github.io/posts/2022/06/dirty_pipe_cve_2022_0847/</guid><description>Intro This blog post reflects our exploration of the Dirty Pipe Vulnerability in the Linux kernel. The bug was discovered by Max Kellermann and described here. If you haven&amp;rsquo;t read the original publication yet, we&amp;rsquo;d suggest that you read it first (maybe also twice ;)). While Kellermann&amp;rsquo;s post is a great resource that contains all the relevant information to understand the bug, it assumes some familiarity with the Linux kernel. To fully understand what&amp;rsquo;s going on we&amp;rsquo;d like to shed some light on specific kernel internals.</description><content>&lt;h2 id="intro">Intro&lt;/h2>
&lt;p>This blog post reflects our exploration of the Dirty Pipe Vulnerability in the Linux kernel. The bug was discovered by Max Kellermann and described &lt;a href="https://dirtypipe.cm4all.com/">here&lt;/a>. If you haven&amp;rsquo;t read the original publication yet, we&amp;rsquo;d suggest that you read it first (maybe also twice ;)). While Kellermann&amp;rsquo;s post is a great resource that contains all the relevant information to understand the bug, it assumes some familiarity with the Linux kernel. To fully understand what&amp;rsquo;s going on we&amp;rsquo;d like to shed some light on specific kernel internals. The aim of this post is to share our knowledge and to provide a resource for other interested individuals. The idea of this post is as follows: We take a small proof-of-concept (PoC) program and divide it into several stages. Each stage issues a system call (or syscall for short), and we will look inside the kernel to understand which actions and state changes occur in response to those calls. For this we use both, the kernel source code (&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source">elixir.bootlin.com&lt;/a>, version 5.17.9) and a kernel debugging setup (derived from &lt;a href="https://github.com/martinclauss/linux-kernel-debugging">linux-kernel-debugging&lt;/a>). The Dirty Pipe-specific debugging setup and the PoC code is provided in a &lt;a href="https://github.com/vobst/lkd-cve">GitHub&lt;/a> repository.&lt;/p>
&lt;h2 id="our-goal--disclaimer">Our Goal / Disclaimer&lt;/h2>
&lt;p>It&amp;rsquo;s important to talk about the goal of our investigation first:&lt;/p>
&lt;ul>
&lt;li>Do we want to understand how the Linux kernel works in general? Maybe not right now&amp;hellip;&lt;/li>
&lt;li>Do we want to know what the vulnerability is? Why it occurs? How it can be exploited? Yes!&lt;/li>
&lt;/ul>
&lt;p>It is important to keep in mind, what we want to achieve. The Linux kernel is a &lt;strong>very&lt;/strong> complex piece of software. We have to leave some blind spots, but that&amp;rsquo;s &lt;strong>absolutely okay&lt;/strong> :)&lt;/p>
&lt;p>Thus, when we show kernel source code we will often hide parts that are not directly relevant for our discussion to improve readability. In general, those parts may very well be security-relevant and we encourage you to follow the links to review the original code. In particular, if you want to find your own vulnerabilities or become a kernel hacker you should spend more time to understand (all) the mechanisms and details! ;)&lt;/p>
&lt;h2 id="page-cache">Page Cache&lt;/h2>
&lt;p>The page cache plays an important role in the Dirty Pipe vulnerability so let&amp;rsquo;s see what it is and how it works first.&lt;/p>
&lt;blockquote>
&lt;p>The physical memory is volatile and the common case for getting data into the memory is to read it from files. Whenever a file is read, the data is put into the page cache to avoid expensive disk access on the subsequent reads. Similarly, when one writes to a file, the data is placed in the page cache and eventually gets into the backing storage device. The written pages are marked as dirty and when Linux decides to reuse them for other purposes, it makes sure to synchronize the file contents on the device with the updated data. &lt;a href="https://www.kernel.org/doc/html/latest/admin-guide/mm/concepts.html#page-cache">source&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>In particular, the above means that if any process on the system (or the kernel itself) requests data from a file that is already cached, the cached data is used instead of accessing the disk. Of course there are ways to influence this behavior by using flags (&lt;code>O_DIRECT | O_SYNC&lt;/code>) when opening a file, or by explicitly instructing the kernel to &lt;code>sync&lt;/code>hronize dirty pages. You could also discard the cached pages using the &lt;code>sysfs&lt;/code> pseudo file system: &lt;code># echo 1 &amp;gt; /proc/sys/vm/drop_caches&lt;/code>. However, in most situations the cached data is what is ultimately used by the kernel (and thus also the user processes).&lt;/p>
&lt;p>At this point we can already tease what the Dirty Pipe vulnerability is all about: It will allow us to overwrite the cached data of any file that we are allowed to &lt;strong>open&lt;/strong> (read-only access is sufficient), without the page cache actually marking the overwritten page as &amp;lsquo;dirty&amp;rsquo;. Thus, we can trick the system into thinking that the file contents changed (at least for a while) without leaving traces on disk.&lt;/p>
&lt;p>But let&amp;rsquo;s not get ahead of ourselves, the goal is after all to understand &lt;em>why&lt;/em> this happens. As we can see, the first thing our PoC does, is opening a file for reading, without any additional flags.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> tfd;
...
pause_for_inspection(&lt;span style="color:#e6db74">&amp;#34;About to open() file&amp;#34;&lt;/span>);
tfd &lt;span style="color:#f92672">=&lt;/span> open(&lt;span style="color:#e6db74">&amp;#34;./target_file&amp;#34;&lt;/span>, O_RDONLY);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L61">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>The kernel function handling our &lt;code>open&lt;/code> user space call is &lt;code>do_sys_openat2()&lt;/code>. It attempts to get the file in the desired mode, and if everything succeeds it installs a new file descriptor that is backed by the file and returns it (the file descriptor is just an &lt;code>int&lt;/code>eger).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>
&lt;span style="color:#a6e22e">do_sys_openat2&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> dfd, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> __user &lt;span style="color:#f92672">*&lt;/span>filename, &lt;span style="color:#66d9ef">struct&lt;/span> open_how &lt;span style="color:#f92672">*&lt;/span>how)
{
&lt;span style="color:#66d9ef">struct&lt;/span> open_flags op;
&lt;span style="color:#66d9ef">int&lt;/span> fd &lt;span style="color:#f92672">=&lt;/span> build_open_flags(how, &lt;span style="color:#f92672">&amp;amp;&lt;/span>op);
&lt;span style="color:#66d9ef">struct&lt;/span> filename &lt;span style="color:#f92672">*&lt;/span>tmp;
...
tmp &lt;span style="color:#f92672">=&lt;/span> getname(filename);
...
fd &lt;span style="color:#f92672">=&lt;/span> get_unused_fd_flags(how&lt;span style="color:#f92672">-&amp;gt;&lt;/span>flags);
...
&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>f &lt;span style="color:#f92672">=&lt;/span> do_filp_open(dfd, tmp, &lt;span style="color:#f92672">&amp;amp;&lt;/span>op); &lt;span style="color:#75715e">// lolcads: maybe follow ...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// but don&amp;#39;t get lost ;)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>...
&lt;span style="color:#66d9ef">if&lt;/span> (IS_ERR(f)) { &lt;span style="color:#75715e">// lolcads: e.g. permission checks failed, doesn&amp;#39;t exist...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> put_unused_fd(fd);
fd &lt;span style="color:#f92672">=&lt;/span> PTR_ERR(f);
} &lt;span style="color:#66d9ef">else&lt;/span> {
fsnotify_open(f);
fd_install(fd, f);
}
putname(tmp);
&lt;span style="color:#66d9ef">return&lt;/span> fd; &lt;span style="color:#75715e">// lolcads: breakpoint 1
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/open.c#L1198">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Following the call to &lt;code>do_filp_open()&lt;/code> bears the danger of getting lost in the jungle of the (virtual) file system. To avoid going down that rabbit hole we place our first breakpoint on the &lt;code>return&lt;/code> statement. This gives us the opportunity to find the &lt;code>struct file&lt;/code> that is backing the file descriptor our PoC process receives.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">struct&lt;/span> file {
...
&lt;span style="color:#66d9ef">struct&lt;/span> path f_path;
&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>f_inode;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> file_operations &lt;span style="color:#f92672">*&lt;/span>f_op;
...
&lt;span style="color:#66d9ef">struct&lt;/span> address_space &lt;span style="color:#f92672">*&lt;/span>f_mapping;
...
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/fs.h#L956">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Importantly, the &lt;code>f_mapping&lt;/code> field leads us to the &lt;code>struct address_space&lt;/code> that represents the page cache object associated to the file. The &lt;code>a_ops&lt;/code> field points to implementations of typical operations one might want to perform on a page cache object e.g., reading ahead, marking pages as dirty or writing back dirty pages, and so on.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">struct&lt;/span> address_space {
&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>host;
&lt;span style="color:#66d9ef">struct&lt;/span> xarray i_pages;
...
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> nrpages;
pgoff_t writeback_index;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> address_space_operations &lt;span style="color:#f92672">*&lt;/span>a_ops;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> flags;
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/fs.h#L450">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>The actual cached data lies on one or more pages somewhere in physical memory. Each and every page of physical memory is described by a &lt;code>struct page&lt;/code>. An &lt;a href="https://lwn.net/Articles/745073/">extendable array&lt;/a> (&lt;code>struct xarray&lt;/code>) containing pointers to those page structs can be found in the &lt;code>i_pages&lt;/code> field of the &lt;code>struct address_space&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">struct&lt;/span> page {
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> flags;
...
&lt;span style="color:#75715e">/* Page cache and anonymous pages */&lt;/span>
&lt;span style="color:#66d9ef">struct&lt;/span> address_space &lt;span style="color:#f92672">*&lt;/span>mapping;
pgoff_t index; &lt;span style="color:#75715e">/* Our offset within mapping. */&lt;/span>
...
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * If the page can be mapped to userspace, encodes the number
&lt;/span>&lt;span style="color:#75715e"> * of times this page is referenced by a page table.
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
atomic_t _mapcount;
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * If the page is neither PageSlab nor mappable to userspace,
&lt;/span>&lt;span style="color:#75715e"> * the value stored here may help determine what this page
&lt;/span>&lt;span style="color:#75715e"> * is used for. See page-flags.h for a list of page types
&lt;/span>&lt;span style="color:#75715e"> * which are currently stored here.
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> page_type;
...
&lt;span style="color:#75715e">/* Usage count. *DO NOT USE DIRECTLY*. See page_ref.h */&lt;/span>
atomic_t _refcount;
...
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * On machines where all RAM is mapped into kernel address space,
&lt;/span>&lt;span style="color:#75715e"> * we can simply calculate the virtual address. On machines with
&lt;/span>&lt;span style="color:#75715e"> * highmem some memory is mapped into kernel virtual memory
&lt;/span>&lt;span style="color:#75715e"> * dynamically, so we need a place to store that address.
&lt;/span>&lt;span style="color:#75715e"> * Note that this field could be 16 bits on x86 ... ;)
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * Architectures with slow multiplication can define
&lt;/span>&lt;span style="color:#75715e"> * WANT_PAGE_VIRTUAL in asm/page.h
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>virtual; &lt;span style="color:#75715e">/* Kernel virtual address (NULL if
&lt;/span>&lt;span style="color:#75715e"> not kmapped, ie. highmem) */&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/mm_types.h#L72">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>The last comment gives a hint at how to find the actual page of physical memory described by this struct within the kernel&amp;rsquo;s virtual address space. (The kernel maps all of physical memory into its virtual address space so we know its &lt;em>somewhere&lt;/em>. Refer to the &lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/Documentation/x86/x86_64/mm.rst">documentation&lt;/a> for more details.)&lt;/p>
&lt;pre tabindex="0">&lt;code>========================================================================================================================
Start addr | Offset | End addr | Size | VM area description
========================================================================================================================
...
ffff888000000000 | -119.5 TB | ffffc87fffffffff | 64 TB | direct mapping of all physical memory (page_offset_base)
...
&lt;/code>&lt;/pre>&lt;p>The key to finding the &amp;lsquo;needle in the haystack&amp;rsquo; is another region of the kernel&amp;rsquo;s virtual address space.&lt;/p>
&lt;blockquote>
&lt;p>The sparse vmemmap uses a virtually mapped memory map to optimize pfn_to_page and page_to_pfn operations. There is a global struct page *vmemmap pointer that points to a virtually contiguous array of struct page objects. A PFN is an index to that array and the offset of the struct page from vmemmap is the PFN of that page. &lt;a href="https://www.kernel.org/doc/html/latest/vm/memory-model.html">source&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>========================================================================================================================
Start addr | Offset | End addr | Size | VM area description
========================================================================================================================
...
ffffe90000000000 | -23 TB | ffffe9ffffffffff | 1 TB | ... unused hole
ffffea0000000000 | -22 TB | ffffeaffffffffff | 1 TB | virtual memory map (vmemmap_base)
ffffeb0000000000 | -21 TB | ffffebffffffffff | 1 TB | ... unused hole
...
&lt;/code>&lt;/pre>&lt;p>In the debugger we can confirm that the address of the &lt;code>struct page&lt;/code> associated to the &lt;code>struct address_space&lt;/code> of the &lt;code>target_file&lt;/code> our &lt;code>poc&lt;/code> process opened indeed lies within this range.&lt;/p>
&lt;pre tabindex="0">&lt;code>struct task_struct at 0xffff888103a71c80
&amp;gt; 'pid': 231
&amp;gt; 'comm': &amp;quot;poc&amp;quot;, '\000' &amp;lt;repeats 12 times&amp;gt;
struct file at 0xffff8881045b0800
&amp;gt; 'f_mapping': 0xffff8881017d9460
&amp;gt; filename: target_file
struct address_space at 0xffff8881017d9460
&amp;gt; 'a_ops': 0xffffffff82226ce0 &amp;lt;ext4_aops&amp;gt;
&amp;gt; 'i_pages.xa_head' : 0xffffea0004156880 &amp;lt;- here!
&lt;/code>&lt;/pre>&lt;p>The kernel implements the translation of this address into a position in the contiguous mapping of all physical memory using a series of macros that hide behind a call to &lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/mm.h#L1712">&lt;code>lowmem_page_address / page_to_virt&lt;/code>&lt;/a>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">#define page_to_virt(x) __va(PFN_PHYS(page_to_pfn(x)))
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define page_to_pfn __page_to_pfn
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define __page_to_pfn(page) (unsigned long)((page) - vmemmap) &lt;/span>&lt;span style="color:#75715e">// (see .config: CONFIG_SPARSEMEM_VMEMMAP=y)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define vmemmap ((struct page *)VMEMMAP_START)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e"># define VMEMMAP_START vmemmap_base &lt;/span>&lt;span style="color:#75715e">// (see .config: CONFIG_DYNAMIC_MEMORY_LAYOUT=y)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define PFN_PHYS(x) ((phys_addr_t)(x) &amp;lt;&amp;lt; PAGE_SHIFT)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define PAGE_SHIFT 12
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define __va(x) ((void *)((unsigned long)(x)+PAGE_OFFSET))
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define PAGE_OFFSET ((unsigned long)__PAGE_OFFSET)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define __PAGE_OFFSET page_offset_base &lt;/span>&lt;span style="color:#75715e">// (see .config: CONFIG_DYNAMIC_MEMORY_LAYOUT=y)
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>When following the macros, make sure to consider your architecture (e.g., x86) and check for compile time definitions in the &lt;code>.config&lt;/code> file of your build (e.g., &lt;code>CONFIG_DYNAMIC_MEMORY_LAYOUT=y&lt;/code>). The values of &lt;code>vmemmap_base&lt;/code> and &lt;code>page_offset_base&lt;/code> are in general effected by &lt;a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization#Kernel_address_space_layout_randomization">KASLR&lt;/a> but can be determined at runtime e.g., by using the debugger.&lt;/p>
&lt;p>Equipped with this knowledge, we can &lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_scripts_gdb/lkd/structs.py#L158">script the debugger&lt;/a> to do this calculation for us and print the cached data of the file we opened.&lt;/p>
&lt;pre tabindex="0">&lt;code>struct page at 0xffffea0004156880
&amp;gt; virtual: 0xffff8881055a2000
&amp;gt; data: b'File owned by root!\n'[...]b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
&lt;/code>&lt;/pre>&lt;p>Inspecting the file permissions confirms that we are indeed not allowed to write to it.&lt;/p>
&lt;p>&lt;code>-rw-r--r-- 1 root root 20 May 19 20:15 target_file&lt;/code>&lt;/p>
&lt;p>Next, we are going to explore the second kernel subsystem involved in the Dirty Pipe vulnerability.&lt;/p>
&lt;h2 id="pipes-general">Pipes (general)&lt;/h2>
&lt;p>Pipes are a unidirectional inter-process communication (IPC) mechanism found in UNIX-like operating systems. In essence, a pipe is a buffer in kernel space that is accessed by processes through file descriptors. Unidirectionality means that there are two types of file descriptors, &lt;em>read&lt;/em> and &lt;em>write&lt;/em> ones:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> pipefds[&lt;span style="color:#ae81ff">2&lt;/span>];
pipe(pipefds);
&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code> ┌───────────────────┐
write() ---&amp;gt; pipefds[1] │&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;│ pipefds[0] ---&amp;gt; read()
└───────────────────┘
&lt;/code>&lt;/pre>&lt;p>Upon creating a pipe the calling process receives both file descriptors, but usually it proceeds by distributing one or both of the file descriptors to other processes (e.g., by &lt;code>fork/clone&lt;/code>ing or through UNIX domain &lt;code>socket&lt;/code>s) to facilitate IPC. They are, for example, used by shells to connect stdout and stdin of the launched sub-processes.&lt;/p>
&lt;pre tabindex="0">&lt;code>$ strace -f sh -c 'echo &amp;quot;Hello world&amp;quot; | wc' 2&amp;gt;&amp;amp;1 | grep -E &amp;quot;(pipe|dup2|close|clone|execve|write|read)&amp;quot;
...
sh: pipe([3, 4]) = 0 // parent shell creates pipe
sh: clone(...) // spawn child shell that will do echo (build-in command)
sh: close(4) = 0 // parent shell does not need writing end anymore
echo sh: close(3) // close reading end
echo sh: dup2(4, 1) = 0 // set stdout equal to writing end
echo sh: close(4) // close duplicate writing end
echo sh: write(1, &amp;quot;Hello world\n&amp;quot;, 12) = 12 // child shell performs write to pipe
...
sh: clone(...) // spawn child shell that will later execve wc
sh: close(3) = 0 // parent shell does not need reading end anymore
...
wc sh: dup2(3, 0) = 0 // set stdin equal to reading end
wc sh: close(3) = 0 // close duplicate reading end
wc sh: execve(&amp;quot;/usr/bin/wc&amp;quot;, [&amp;quot;wc&amp;quot;],...) // exec wc
wc: read(0, &amp;quot;Hello world\n&amp;quot;, 16384) = 12 // wc reads from pipe
...
&lt;/code>&lt;/pre>&lt;p>We mostly care about anonymous pipes as seen in the example above but there are also named pipes (see, e.g., &lt;a href="https://www.linuxjournal.com/article/2156">here&lt;/a>)&lt;/p>
&lt;p>Check out the excellent book &lt;em>The Linux Programming Interface&lt;/em> by Michael Kerrisk, Chapter 44 &amp;ldquo;Pipes and FIFOs&amp;rdquo; for more information and examples.&lt;/p>
&lt;h2 id="pipes-initialization">Pipes (initialization)&lt;/h2>
&lt;p>After opening the target file, our PoC process proceeds by creating a pipe:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> pipefds[&lt;span style="color:#ae81ff">2&lt;/span>];
...
pause_for_inspection(&lt;span style="color:#e6db74">&amp;#34;About to create pipe()&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> (pipe(pipefds)) {
exit(&lt;span style="color:#ae81ff">1&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L70">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Let&amp;rsquo;s investigate what the kernel does to provide the pipe functionality.&lt;/p>
&lt;h3 id="overview">Overview&lt;/h3>
&lt;p>Our system call is handled by the kernel function &lt;code>do_pipe2&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">SYSCALL_DEFINE1(pipe, &lt;span style="color:#66d9ef">int&lt;/span> __user &lt;span style="color:#f92672">*&lt;/span>, fildes)
{
&lt;span style="color:#66d9ef">return&lt;/span> do_pipe2(fildes, &lt;span style="color:#ae81ff">0&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L1026">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">do_pipe2&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> __user &lt;span style="color:#f92672">*&lt;/span>fildes, &lt;span style="color:#66d9ef">int&lt;/span> flags)
{
&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>files[&lt;span style="color:#ae81ff">2&lt;/span>];
&lt;span style="color:#66d9ef">int&lt;/span> fd[&lt;span style="color:#ae81ff">2&lt;/span>];
&lt;span style="color:#66d9ef">int&lt;/span> error;
error &lt;span style="color:#f92672">=&lt;/span> __do_pipe_flags(fd, files, flags);
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>error) {
&lt;span style="color:#66d9ef">if&lt;/span> (unlikely(copy_to_user(fildes, fd, &lt;span style="color:#66d9ef">sizeof&lt;/span>(fd)))) {
fput(files[&lt;span style="color:#ae81ff">0&lt;/span>]);
fput(files[&lt;span style="color:#ae81ff">1&lt;/span>]);
put_unused_fd(fd[&lt;span style="color:#ae81ff">0&lt;/span>]);
put_unused_fd(fd[&lt;span style="color:#ae81ff">1&lt;/span>]);
error &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>EFAULT;
} &lt;span style="color:#66d9ef">else&lt;/span> {
fd_install(fd[&lt;span style="color:#ae81ff">0&lt;/span>], files[&lt;span style="color:#ae81ff">0&lt;/span>]);
fd_install(fd[&lt;span style="color:#ae81ff">1&lt;/span>], files[&lt;span style="color:#ae81ff">1&lt;/span>]);
}
}
&lt;span style="color:#66d9ef">return&lt;/span> error;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L1004">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Here we can see that two integer file descriptors, backed by two distinct files, are created. One for the reading &lt;code>fd[0]&lt;/code>, and one for the writing &lt;code>fd[1]&lt;/code> end of the pipe. The descriptors are also copied from the kernel to user space &lt;code>copy_to_user(fildes, fd, sizeof(fd))&lt;/code>, where &lt;code>fildes&lt;/code> is the user space pointer we specified with the call to &lt;code>pipe(pipefds)&lt;/code> in our PoC.&lt;/p>
&lt;p>Following the call to &lt;code>__do_pipe_flags()&lt;/code> reveals which data structures the kernel uses to implement our pipe. We summarized the relevant structures and their relationships in the following figure:&lt;/p>
&lt;pre tabindex="0">&lt;code> ┌──────────────────┐
┌──────────────────────┐ ┌►│struct pipe_buffer│
┌────────────────────────┐ ┌──►│struct pipe_inode_info│ │ │... │
┌───► │struct file │ │ │ │ │ │page = Null │
│ │ │ │ │... │ │ │... │
File desciptor table │ │... │ │ │ │ │ ├──────────────────┤
│ │ │ │ │head = 0 │ │ │struct pipe_buffer│
int fd │ struct file *f │ │f_inode ───────────────┼──┐ │ │ │ │ │... │
──────────┼───────────────── │ │ │ │ │ │tail = 0 │ │ │page = Null │
... │ ... │ │fmode = O_RDONLY | ... │ │ ┌─────────────┐ │ │ │ │ │... │
│ │ │ │ ├─►│struct inode │ │ │ring_size = 16 │ │ ├──────────────────┤
pipefd_r │ f_read ──────┘ │... │ │ │ │ │ │ │ │ │ ... │
│ └────────────────────────┘ │ │... │ │ │... │ │ ├──────────────────┤
pipefd_w │ f_write ──────┐ │ │ │ │ │ │ │ │struct pipe_buffer│
│ │ ┌────────────────────────┐ │ │i_pipe ─────┼─┘ │bufs ─────────────────┼──┘ │... │
... │ ... └───► │struct file │ │ │ │ │ │ │page = Null │
│ │ │ │ │... │ │... │ │... │
│ │... │ │ │ │ └──────────────────────┘ └──────────────────┘
│ │ │ │i_fop ──────┼─┐
│f_inode ───────────────┼──┘ │ │ │ ┌─────────────────────────────────────┐
│ │ │... │ └──►│struct file_operations │
│fmode = O_WRONLY | ... │ └─────────────┘ │ │
│ │ │... │
│... │ │ │
└────────────────────────┘ │read_iter = pipe_read │
│ │
│write_iter = pipe_write │
│ │
│... │
│ │
│splice_write = iter_file_splice_write│
│ │
│... │
└─────────────────────────────────────┘
&lt;/code>&lt;/pre>&lt;p>The two integer file descriptors, representing the pipe in user space, are backed by two &lt;code>struct file&lt;/code>s that only differ in their permission bits. In particular, they both refer to the same &lt;code>struct inode&lt;/code>.&lt;/p>
&lt;blockquote>
&lt;p>The inode (index node) is a data structure in a Unix-style file system that describes a file-system object such as a file or a directory. Each inode stores the attributes and disk block locations of the object&amp;rsquo;s data. File-system object attributes may include metadata (times of last change, access, modification), as well as owner and permission data.
[&amp;hellip;]
A directory is a list of inodes with their assigned names. The list includes an entry for itself, its parent, and each of its children. &lt;a href="https://en.wikipedia.org/wiki/Inode">source&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>The &lt;code>i_fop&lt;/code> field of the inode contains a pointer to a &lt;code>struct file_operations&lt;/code>. This structure holds function pointers to the implementations of the various operations that can be performed on the pipe. Importantly, those include the functions the kernel will use to handle a process' request to &lt;code>read()&lt;/code> or &lt;code>write()&lt;/code> the pipe.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> file_operations pipefifo_fops &lt;span style="color:#f92672">=&lt;/span> {
.open &lt;span style="color:#f92672">=&lt;/span> fifo_open,
.llseek &lt;span style="color:#f92672">=&lt;/span> no_llseek,
.read_iter &lt;span style="color:#f92672">=&lt;/span> pipe_read,
.write_iter &lt;span style="color:#f92672">=&lt;/span> pipe_write,
.poll &lt;span style="color:#f92672">=&lt;/span> pipe_poll,
.unlocked_ioctl &lt;span style="color:#f92672">=&lt;/span> pipe_ioctl,
.release &lt;span style="color:#f92672">=&lt;/span> pipe_release,
.fasync &lt;span style="color:#f92672">=&lt;/span> pipe_fasync,
.splice_write &lt;span style="color:#f92672">=&lt;/span> iter_file_splice_write,
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L1218">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>As stated above, an inode is not limited to describing pipes, and for other file types this field would point to another set of function pointers / implementations.&lt;/p>
&lt;p>The pipe-specific part of the inode is mostly contained in the &lt;code>struct pipe_inode_info&lt;/code> pointed to by the &lt;code>i_pipe&lt;/code> field.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * struct pipe_inode_info - a linux kernel pipe
&lt;/span>&lt;span style="color:#75715e"> * @mutex: mutex protecting the whole thing
&lt;/span>&lt;span style="color:#75715e"> * @rd_wait: reader wait point in case of empty pipe
&lt;/span>&lt;span style="color:#75715e"> * @wr_wait: writer wait point in case of full pipe
&lt;/span>&lt;span style="color:#75715e"> * @head: The point of buffer production
&lt;/span>&lt;span style="color:#75715e"> * @tail: The point of buffer consumption
&lt;/span>&lt;span style="color:#75715e"> * @note_loss: The next read() should insert a data-lost message
&lt;/span>&lt;span style="color:#75715e"> * @max_usage: The maximum number of slots that may be used in the ring
&lt;/span>&lt;span style="color:#75715e"> * @ring_size: total number of buffers (should be a power of 2)
&lt;/span>&lt;span style="color:#75715e"> * @nr_accounted: The amount this pipe accounts for in user-&amp;gt;pipe_bufs
&lt;/span>&lt;span style="color:#75715e"> * @tmp_page: cached released page
&lt;/span>&lt;span style="color:#75715e"> * @readers: number of current readers of this pipe
&lt;/span>&lt;span style="color:#75715e"> * @writers: number of current writers of this pipe
&lt;/span>&lt;span style="color:#75715e"> * @files: number of struct file referring this pipe (protected by -&amp;gt;i_lock)
&lt;/span>&lt;span style="color:#75715e"> * @r_counter: reader counter
&lt;/span>&lt;span style="color:#75715e"> * @w_counter: writer counter
&lt;/span>&lt;span style="color:#75715e"> * @poll_usage: is this pipe used for epoll, which has crazy wakeups?
&lt;/span>&lt;span style="color:#75715e"> * @fasync_readers: reader side fasync
&lt;/span>&lt;span style="color:#75715e"> * @fasync_writers: writer side fasync
&lt;/span>&lt;span style="color:#75715e"> * @bufs: the circular array of pipe buffers
&lt;/span>&lt;span style="color:#75715e"> * @user: the user who created this pipe
&lt;/span>&lt;span style="color:#75715e"> * @watch_queue: If this pipe is a watch_queue, this is the stuff for that
&lt;/span>&lt;span style="color:#75715e"> **/&lt;/span>
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info {
&lt;span style="color:#66d9ef">struct&lt;/span> mutex mutex;
wait_queue_head_t rd_wait, wr_wait;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> head;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> tail;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> max_usage;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> ring_size;
&lt;span style="color:#75715e">#ifdef CONFIG_WATCH_QUEUE
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> note_loss;
&lt;span style="color:#75715e">#endif
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> nr_accounted;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> readers;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> writers;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> files;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> r_counter;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> w_counter;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> poll_usage;
&lt;span style="color:#66d9ef">struct&lt;/span> page &lt;span style="color:#f92672">*&lt;/span>tmp_page;
&lt;span style="color:#66d9ef">struct&lt;/span> fasync_struct &lt;span style="color:#f92672">*&lt;/span>fasync_readers;
&lt;span style="color:#66d9ef">struct&lt;/span> fasync_struct &lt;span style="color:#f92672">*&lt;/span>fasync_writers;
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_buffer &lt;span style="color:#f92672">*&lt;/span>bufs;
&lt;span style="color:#66d9ef">struct&lt;/span> user_struct &lt;span style="color:#f92672">*&lt;/span>user;
&lt;span style="color:#75715e">#ifdef CONFIG_WATCH_QUEUE
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> watch_queue &lt;span style="color:#f92672">*&lt;/span>watch_queue;
&lt;span style="color:#75715e">#endif
&lt;/span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/pipe_fs_i.h#L58">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>At this point we can get a first idea of how pipes are implemented. On a high level, the kernel thinks of a pipe as a circular array of &lt;code>pipe_buffer&lt;/code> structures (sometimes also called a ring). The &lt;code>bufs&lt;/code> field is a pointer to the start of this array.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * struct pipe_buffer - a linux kernel pipe buffer
&lt;/span>&lt;span style="color:#75715e"> * @page: the page containing the data for the pipe buffer
&lt;/span>&lt;span style="color:#75715e"> * @offset: offset of data inside the @page
&lt;/span>&lt;span style="color:#75715e"> * @len: length of data inside the @page
&lt;/span>&lt;span style="color:#75715e"> * @ops: operations associated with this buffer. See @pipe_buf_operations.
&lt;/span>&lt;span style="color:#75715e"> * @flags: pipe buffer flags. See above.
&lt;/span>&lt;span style="color:#75715e"> * @private: private data owned by the ops.
&lt;/span>&lt;span style="color:#75715e"> **/&lt;/span>
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_buffer {
&lt;span style="color:#66d9ef">struct&lt;/span> page &lt;span style="color:#f92672">*&lt;/span>page;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> offset, len;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> pipe_buf_operations &lt;span style="color:#f92672">*&lt;/span>ops;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> flags;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> private;
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/pipe_fs_i.h#L26">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>There are two positions in this array: one for writing to (the &lt;code>head&lt;/code>) - and one for reading from (the &lt;code>tail&lt;/code>) the pipe. The &lt;code>ring_size&lt;/code> defaults to &lt;code>16&lt;/code> and will always be a power of 2, which is why circularity is implemented by masking index accesses with &lt;code>ring_size - 1&lt;/code> (e.g., &lt;code>bufs[head &amp;amp; (ring_size - 1)]&lt;/code>). The &lt;code>page&lt;/code> field is a pointer to a &lt;code>struct page&lt;/code> describing where the actual data held by the &lt;code>pipe_buffer&lt;/code> is stored. We will elaborate more on the process of adding and consuming data below. Note that each &lt;code>pipe_buffer&lt;/code> has one page associated which means that the total capacity of the pipe is &lt;code>ring_size * 4096 bytes (4KB)&lt;/code>.&lt;/p>
&lt;p>A process can get and set the size of this ring using the &lt;code>fcntl()&lt;/code> system call with the &lt;code>F_GETPIPE_SZ&lt;/code> and &lt;code>F_SETPIPE_SZ&lt;/code> flags, respectively. Our PoC sets the size of its pipe to a single buffer (4KB / one page) for simplicity.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span>
&lt;span style="color:#a6e22e">setup_pipe&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> pipefd_r, &lt;span style="color:#66d9ef">int&lt;/span> pipefd_w) {
&lt;span style="color:#66d9ef">if&lt;/span> (fcntl(pipefd_w, F_SETPIPE_SZ, PAGESIZE) &lt;span style="color:#f92672">!=&lt;/span> PAGESIZE) {
exit(&lt;span style="color:#ae81ff">1&lt;/span>);
}
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L48">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;h3 id="code">Code&lt;/h3>
&lt;p>We can also follow the setup of the pipe in the kernel source code. The initialization of the integer file descriptors happens in &lt;code>__do_pipe_flags()&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">__do_pipe_flags&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>fd, &lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">**&lt;/span>files, &lt;span style="color:#66d9ef">int&lt;/span> flags)
{
&lt;span style="color:#66d9ef">int&lt;/span> error;
&lt;span style="color:#66d9ef">int&lt;/span> fdw, fdr;
...
error &lt;span style="color:#f92672">=&lt;/span> create_pipe_files(files, flags);
...
fdr &lt;span style="color:#f92672">=&lt;/span> get_unused_fd_flags(flags);
...
fdw &lt;span style="color:#f92672">=&lt;/span> get_unused_fd_flags(flags);
...
audit_fd_pair(fdr, fdw);
fd[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> fdr;
fd[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> fdw;
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L954">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>The backing files are initialized in &lt;code>create_pipe_files()&lt;/code>. We can see that both files are identical up to permissions, contain a reference to the pipe in their private data, and are opened as &lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/open.c#L1423">streams&lt;/a>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">create_pipe_files&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">**&lt;/span>res, &lt;span style="color:#66d9ef">int&lt;/span> flags)
{
&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>inode &lt;span style="color:#f92672">=&lt;/span> get_pipe_inode();
&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>f;
&lt;span style="color:#66d9ef">int&lt;/span> error;
...
f &lt;span style="color:#f92672">=&lt;/span> alloc_file_pseudo(inode, pipe_mnt, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
O_WRONLY &lt;span style="color:#f92672">|&lt;/span> (flags &lt;span style="color:#f92672">&amp;amp;&lt;/span> (O_NONBLOCK &lt;span style="color:#f92672">|&lt;/span> O_DIRECT)),
&lt;span style="color:#f92672">&amp;amp;&lt;/span>pipefifo_fops);
...
f&lt;span style="color:#f92672">-&amp;gt;&lt;/span>private_data &lt;span style="color:#f92672">=&lt;/span> inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_pipe;
res[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> alloc_file_clone(f, O_RDONLY &lt;span style="color:#f92672">|&lt;/span> (flags &lt;span style="color:#f92672">&amp;amp;&lt;/span> O_NONBLOCK),
&lt;span style="color:#f92672">&amp;amp;&lt;/span>pipefifo_fops);
...
res[&lt;span style="color:#ae81ff">0&lt;/span>]&lt;span style="color:#f92672">-&amp;gt;&lt;/span>private_data &lt;span style="color:#f92672">=&lt;/span> inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_pipe;
res[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> f;
stream_open(inode, res[&lt;span style="color:#ae81ff">0&lt;/span>]);
stream_open(inode, res[&lt;span style="color:#ae81ff">1&lt;/span>]);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L911">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>The initialization of the common inode structure happens in &lt;code>get_pipe_inode()&lt;/code>. We can see that an inode is created and also information for the pipe is allocated and stored such that &lt;code>inode-&amp;gt;i_pipe&lt;/code> can later be used to access the pipe from a given inode. Furthermore, &lt;code>inode-&amp;gt;i_fops&lt;/code> specifies the implementations used for file operations on a pipe.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">get_pipe_inode&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>inode &lt;span style="color:#f92672">=&lt;/span> new_inode_pseudo(pipe_mnt&lt;span style="color:#f92672">-&amp;gt;&lt;/span>mnt_sb);
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>pipe;
...
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_ino &lt;span style="color:#f92672">=&lt;/span> get_next_ino();
pipe &lt;span style="color:#f92672">=&lt;/span> alloc_pipe_info();
...
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_pipe &lt;span style="color:#f92672">=&lt;/span> pipe;
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>files &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>readers &lt;span style="color:#f92672">=&lt;/span> pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>writers &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_fop &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>pipefifo_fops; &lt;span style="color:#75715e">// lolcads: see description below
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * Mark the inode dirty from the very beginning,
&lt;/span>&lt;span style="color:#75715e"> * that way it will never be moved to the dirty
&lt;/span>&lt;span style="color:#75715e"> * list because &amp;#34;mark_inode_dirty()&amp;#34; will think
&lt;/span>&lt;span style="color:#75715e"> * that it already _is_ on the dirty list.
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_state &lt;span style="color:#f92672">=&lt;/span> I_DIRTY;
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_mode &lt;span style="color:#f92672">=&lt;/span> S_IFIFO &lt;span style="color:#f92672">|&lt;/span> S_IRUSR &lt;span style="color:#f92672">|&lt;/span> S_IWUSR;
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_uid &lt;span style="color:#f92672">=&lt;/span> current_fsuid();
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_gid &lt;span style="color:#f92672">=&lt;/span> current_fsgid();
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_atime &lt;span style="color:#f92672">=&lt;/span> inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_mtime &lt;span style="color:#f92672">=&lt;/span> inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_ctime &lt;span style="color:#f92672">=&lt;/span> current_time(inode);
&lt;span style="color:#66d9ef">return&lt;/span> inode;
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L871">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Most of the pipe-specific setup happens is &lt;code>alloc_pipe_info()&lt;/code>. Here you can see the actual creation of the pipe, not just the inode, but the &lt;code>pipe_buffer&lt;/code>s / &lt;code>pipe_inode_info-&amp;gt;bufs&lt;/code> that hold the content / data of the pipe.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">alloc_pipe_info&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>pipe;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> pipe_bufs &lt;span style="color:#f92672">=&lt;/span> PIPE_DEF_BUFFERS; &lt;span style="color:#75715e">// lolcads: defaults to 16
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> user_struct &lt;span style="color:#f92672">*&lt;/span>user &lt;span style="color:#f92672">=&lt;/span> get_current_user();
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> user_bufs;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> max_size &lt;span style="color:#f92672">=&lt;/span> READ_ONCE(pipe_max_size);
&lt;span style="color:#75715e">// lolcads: allocate the inode info
&lt;/span>&lt;span style="color:#75715e">&lt;/span> pipe &lt;span style="color:#f92672">=&lt;/span> kzalloc(&lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info), GFP_KERNEL_ACCOUNT);
...
&lt;span style="color:#75715e">// lolcads: allocate the buffers with the page references
&lt;/span>&lt;span style="color:#75715e">&lt;/span> pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>bufs &lt;span style="color:#f92672">=&lt;/span> kcalloc(pipe_bufs, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> pipe_buffer),
GFP_KERNEL_ACCOUNT);
&lt;span style="color:#66d9ef">if&lt;/span> (pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>bufs) { &lt;span style="color:#75715e">// lolcads: set up the rest of the relevant fields
&lt;/span>&lt;span style="color:#75715e">&lt;/span> init_waitqueue_head(&lt;span style="color:#f92672">&amp;amp;&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>rd_wait);
init_waitqueue_head(&lt;span style="color:#f92672">&amp;amp;&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>wr_wait);
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>r_counter &lt;span style="color:#f92672">=&lt;/span> pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>w_counter &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>max_usage &lt;span style="color:#f92672">=&lt;/span> pipe_bufs;
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ring_size &lt;span style="color:#f92672">=&lt;/span> pipe_bufs;
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>nr_accounted &lt;span style="color:#f92672">=&lt;/span> pipe_bufs;
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>user &lt;span style="color:#f92672">=&lt;/span> user;
mutex_init(&lt;span style="color:#f92672">&amp;amp;&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>mutex);
&lt;span style="color:#66d9ef">return&lt;/span> pipe;
}
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L782">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;h3 id="debugger">Debugger&lt;/h3>
&lt;p>We can print a summary of the freshly initialized pipe (after resizing it) by breaking at the end of &lt;code>pipe_fcntl()&lt;/code>, which is the handler invoked in the &lt;code>case F_SETPIPE_SZ:&lt;/code> of the switch statement inside &lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L1392">&lt;code>do_fcntl()&lt;/code>&lt;/a>.&lt;/p>
&lt;pre tabindex="0">&lt;code>struct pipe_inode_info at 0xffff8881044aec00
&amp;gt; 'head': 0
&amp;gt; 'tail': 0
&amp;gt; 'ring_size': 1
&amp;gt; 'bufs': 0xffff888101f8a180
struct pipe_buffer at 0xffff888101f8a180
&amp;gt; 'page': NULL
&amp;gt; 'offset': 0
&amp;gt; 'len': 0
&amp;gt; 'ops': NULL
&amp;gt; 'flags':
&lt;/code>&lt;/pre>&lt;p>There&amp;rsquo;s not much to see yet, but we keep this as a reference to see how things evolve over time.&lt;/p>
&lt;h2 id="pipes-readingwriting">Pipes (reading/writing)&lt;/h2>
&lt;h3 id="writing">Writing&lt;/h3>
&lt;p>After allocating the pipe, the PoC proceeds by writing to it.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span>
&lt;span style="color:#a6e22e">fill_pipe&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> pipefd_w) {
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> PAGESIZE &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
pause_for_inspection(&lt;span style="color:#e6db74">&amp;#34;About to perform first write() to pipe&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">==&lt;/span> PAGESIZE &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>) {
pause_for_inspection(&lt;span style="color:#e6db74">&amp;#34;About to perform last write() to pipe&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">if&lt;/span> (write(pipefd_w, &lt;span style="color:#e6db74">&amp;#34;AAAAAAAA&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>) {
exit(&lt;span style="color:#ae81ff">1&lt;/span>);
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L18">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>By looking at the file operations of a pipe inode we can see that &lt;code>write&lt;/code>s to a pipe are handled by &lt;code>pipe_write()&lt;/code>. When data is moved across the kernel-user-space boundary (or within the kernel) one frequently encounters vectorized I/O using &lt;a href="https://lwn.net/Articles/625077/">&lt;code>iov_iter&lt;/code>&lt;/a> objects. For our purposes we can think of them as buffers but feel free to follow the links to learn more (also &lt;a href="https://en.wikipedia.org/wiki/Vectored_I/O">this&lt;/a>).&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-c=" data-lang="c=">static ssize_t
pipe_write(struct kiocb *iocb, struct iov_iter *from)
{
struct file *filp = iocb-&amp;gt;ki_filp;
struct pipe_inode_info *pipe = filp-&amp;gt;private_data;
unsigned int head;
ssize_t ret = 0;
size_t total_len = iov_iter_count(from);
ssize_t chars;
bool was_empty = false;
...
/*
* If it wasn't empty we try to merge new data into
* the last buffer.
*
* That naturally merges small writes, but it also
* page-aligns the rest of the writes for large writes
* spanning multiple pages.
*/
head = pipe-&amp;gt;head;
was_empty = pipe_empty(head, pipe-&amp;gt;tail);
chars = total_len &amp;amp; (PAGE_SIZE-1);
if (chars &amp;amp;&amp;amp; !was_empty) {
unsigned int mask = pipe-&amp;gt;ring_size - 1;
struct pipe_buffer *buf = &amp;amp;pipe-&amp;gt;bufs[(head - 1) &amp;amp; mask];
int offset = buf-&amp;gt;offset + buf-&amp;gt;len;
if ((buf-&amp;gt;flags &amp;amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;amp;&amp;amp;
offset + chars &amp;lt;= PAGE_SIZE) {
...
ret = copy_page_from_iter(buf-&amp;gt;page, offset, chars, from);
...
buf-&amp;gt;len += ret;
if (!iov_iter_count(from))
goto out;
}
}
for (;;) {
...
head = pipe-&amp;gt;head;
if (!pipe_full(head, pipe-&amp;gt;tail, pipe-&amp;gt;max_usage)) {
unsigned int mask = pipe-&amp;gt;ring_size - 1;
struct pipe_buffer *buf = &amp;amp;pipe-&amp;gt;bufs[head &amp;amp; mask];
struct page *page = pipe-&amp;gt;tmp_page;
int copied;
if (!page) {
page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);
...
pipe-&amp;gt;tmp_page = page;
}
/* Allocate a slot in the ring in advance and attach an
* empty buffer. If we fault or otherwise fail to use
* it, either the reader will consume it or it'll still
* be there for the next write.
*/
spin_lock_irq(&amp;amp;pipe-&amp;gt;rd_wait.lock);
head = pipe-&amp;gt;head;
if (pipe_full(head, pipe-&amp;gt;tail, pipe-&amp;gt;max_usage)) {
spin_unlock_irq(&amp;amp;pipe-&amp;gt;rd_wait.lock);
continue;
}
pipe-&amp;gt;head = head + 1;
spin_unlock_irq(&amp;amp;pipe-&amp;gt;rd_wait.lock);
/* Insert it into the buffer array */
buf = &amp;amp;pipe-&amp;gt;bufs[head &amp;amp; mask];
buf-&amp;gt;page = page;
buf-&amp;gt;ops = &amp;amp;anon_pipe_buf_ops;
buf-&amp;gt;offset = 0;
buf-&amp;gt;len = 0;
if (is_packetized(filp))
buf-&amp;gt;flags = PIPE_BUF_FLAG_PACKET;
else
buf-&amp;gt;flags = PIPE_BUF_FLAG_CAN_MERGE;
pipe-&amp;gt;tmp_page = NULL;
copied = copy_page_from_iter(page, 0, PAGE_SIZE, from);
...
ret += copied;
buf-&amp;gt;offset = 0;
buf-&amp;gt;len = copied;
if (!iov_iter_count(from))
break;
}
if (!pipe_full(head, pipe-&amp;gt;tail, pipe-&amp;gt;max_usage))
continue;
...
}
out:
...
return ret;
}
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L416">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>When handling a &lt;code>write()&lt;/code> to a pipe, the kernel differentiates between two cases. First it checks if it can append (at least a part of) the data to &lt;code>page&lt;/code> of the &lt;code>pipe_buffer&lt;/code> that is currently the &lt;code>head&lt;/code> of the ring. Whether or not this is possible is decided by three things:&lt;/p>
&lt;ul>
&lt;li>is the pipe non-empty when we start writing? (implies that there are initialized buffers available)
&lt;code>!was_empty&lt;/code>&lt;/li>
&lt;li>is the &lt;code>PIPE_BUF_FLAG_CAN_MERGE&lt;/code> flag set?
&lt;code>buf-&amp;gt;flags &amp;amp; PIPE_BUF_FLAG_CAN_MERGE&lt;/code>&lt;/li>
&lt;li>is there is enough space left on the page?
&lt;code>offset + chars &amp;lt;= PAGE_SIZE&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>If the answer to all of those questions is &lt;em>yes&lt;/em> the kernel starts the write by appending to the existing page.&lt;/p>
&lt;p>To complete the rest of the write the kernel advances the &lt;code>head&lt;/code> to the next &lt;code>pipe_buffer&lt;/code>, allocates a fresh &lt;code>page&lt;/code> for it, initializes the flags (the&lt;code>PIPE_BUF_FLAG_CAN_MERGE&lt;/code> flag will be set, unless the user explicitly asked for the pipe to be in &lt;code>O_DIRECT&lt;/code> mode), and writes the data to the beginning of the new page. This continues until there is no data left to write (or the pipe is full). Regarding the &lt;code>O_DIRECT&lt;/code> mode of &lt;code>pipe()&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>[...]
O_DIRECT (since Linux 3.4)
Create a pipe that performs I/O in &amp;quot;packet&amp;quot; mode. Each
write(2) to the pipe is dealt with as a separate packet,
and read(2)s from the pipe will read one packet at a time.
[...]
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://www.man7.org/linux/man-pages/man2/pipe.2.html">source&lt;/a>&lt;/p>
&lt;p>This is handled in the &lt;code>if&lt;/code>-condition &lt;code>is_packetized(filp)&lt;/code> in &lt;code>pipe_write()&lt;/code> (see above).&lt;/p>
&lt;p>We can also see these two types of writes in the debugger. The first write is into an empty pipe and thus initializes our previously zero-filled pipe buffer.&lt;/p>
&lt;pre tabindex="0">&lt;code>struct pipe_buffer at 0xffff888101f8a180
&amp;gt; 'page': 0xffffea00040e3bc0
&amp;gt; 'offset': 0
&amp;gt; 'len': 8
&amp;gt; 'ops': 0xffffffff8221bb00 &amp;lt;anon_pipe_buf_ops&amp;gt;
&amp;gt; 'flags': PIPE_BUF_FLAG_CAN_MERGE
struct page at 0xffffea00040e3bc0
&amp;gt; virtual: 0xffff8881038ef000
&amp;gt; data: b'AAAAAAAA\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'[...]b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
&lt;/code>&lt;/pre>&lt;p>All subsequent writes go down the &amp;ldquo;append path&amp;rdquo; and fill the existing page.&lt;/p>
&lt;pre tabindex="0">&lt;code>struct pipe_buffer at 0xffff888101f8a180
&amp;gt; 'page': 0xffffea00040e3bc0
&amp;gt; 'offset': 0
&amp;gt; 'len': 4096
&amp;gt; 'ops': 0xffffffff8221bb00 &amp;lt;anon_pipe_buf_ops&amp;gt;
&amp;gt; 'flags': PIPE_BUF_FLAG_CAN_MERGE
struct page at 0xffffea00040e3bc0
&amp;gt; virtual: 0xffff8881038ef000
&amp;gt; data: b'AAAAAAAAAAAAAAAAAAAA'[...]b'AAAAAAAAAAAAAAAAAAAA'
&lt;/code>&lt;/pre>&lt;h3 id="reading">Reading&lt;/h3>
&lt;p>Next, the POC drains the pipe by consuming / &lt;code>read&lt;/code>ing all the &lt;code>A&lt;/code>s from the reading end.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span>
&lt;span style="color:#a6e22e">drain_pipe&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> pipefd_r) {
&lt;span style="color:#66d9ef">char&lt;/span> buf[&lt;span style="color:#ae81ff">8&lt;/span>];
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> PAGESIZE &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">==&lt;/span> PAGESIZE &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>) {
pause_for_inspection(&lt;span style="color:#e6db74">&amp;#34;About to perform last read() from pipe&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">if&lt;/span> (read(pipefd_r, buf, &lt;span style="color:#ae81ff">8&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>) {
exit(&lt;span style="color:#ae81ff">1&lt;/span>);
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L34">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>The case where a process asks the kernel to &lt;code>read()&lt;/code> from a pipe is handled by the function &lt;code>pipe_read()&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> ssize_t
&lt;span style="color:#a6e22e">pipe_read&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> kiocb &lt;span style="color:#f92672">*&lt;/span>iocb, &lt;span style="color:#66d9ef">struct&lt;/span> iov_iter &lt;span style="color:#f92672">*&lt;/span>to)
{
size_t total_len &lt;span style="color:#f92672">=&lt;/span> iov_iter_count(to);
&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>filp &lt;span style="color:#f92672">=&lt;/span> iocb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ki_filp;
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>pipe &lt;span style="color:#f92672">=&lt;/span> filp&lt;span style="color:#f92672">-&amp;gt;&lt;/span>private_data;
&lt;span style="color:#66d9ef">bool&lt;/span> was_full, wake_next_reader &lt;span style="color:#f92672">=&lt;/span> false;
ssize_t ret;
...
ret &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
__pipe_lock(pipe);
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * We only wake up writers if the pipe was full when we started
&lt;/span>&lt;span style="color:#75715e"> * reading in order to avoid unnecessary wakeups.
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * But when we do wake up writers, we do so using a sync wakeup
&lt;/span>&lt;span style="color:#75715e"> * (WF_SYNC), because we want them to get going and generate more
&lt;/span>&lt;span style="color:#75715e"> * data for us.
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
was_full &lt;span style="color:#f92672">=&lt;/span> pipe_full(pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>head, pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>tail, pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>max_usage);
&lt;span style="color:#66d9ef">for&lt;/span> (;;) {
&lt;span style="color:#75715e">/* Read -&amp;gt;head with a barrier vs post_one_notification() */&lt;/span>
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> head &lt;span style="color:#f92672">=&lt;/span> smp_load_acquire(&lt;span style="color:#f92672">&amp;amp;&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>head);
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> tail &lt;span style="color:#f92672">=&lt;/span> pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>tail;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> mask &lt;span style="color:#f92672">=&lt;/span> pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ring_size &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
...
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>pipe_empty(head, tail)) {
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_buffer &lt;span style="color:#f92672">*&lt;/span>buf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>bufs[tail &lt;span style="color:#f92672">&amp;amp;&lt;/span> mask];
size_t chars &lt;span style="color:#f92672">=&lt;/span> buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>len;
size_t written;
&lt;span style="color:#66d9ef">int&lt;/span> error;
&lt;span style="color:#66d9ef">if&lt;/span> (chars &lt;span style="color:#f92672">&amp;gt;&lt;/span> total_len) {
...
chars &lt;span style="color:#f92672">=&lt;/span> total_len;
}
...
written &lt;span style="color:#f92672">=&lt;/span> copy_page_to_iter(buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>page, buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>offset, chars, to);
...
ret &lt;span style="color:#f92672">+=&lt;/span> chars;
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>offset &lt;span style="color:#f92672">+=&lt;/span> chars;
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>len &lt;span style="color:#f92672">-=&lt;/span> chars;
...
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>len) {
pipe_buf_release(pipe, buf);
...
tail&lt;span style="color:#f92672">++&lt;/span>;
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>tail &lt;span style="color:#f92672">=&lt;/span> tail;
...
}
total_len &lt;span style="color:#f92672">-=&lt;/span> chars;
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>total_len)
&lt;span style="color:#66d9ef">break&lt;/span>; &lt;span style="color:#75715e">/* common path: read succeeded */&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>pipe_empty(head, tail)) &lt;span style="color:#75715e">/* More to do? */&lt;/span>
&lt;span style="color:#66d9ef">continue&lt;/span>;
}
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>writers)
&lt;span style="color:#66d9ef">break&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (ret)
&lt;span style="color:#66d9ef">break&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (filp&lt;span style="color:#f92672">-&amp;gt;&lt;/span>f_flags &lt;span style="color:#f92672">&amp;amp;&lt;/span> O_NONBLOCK) {
ret &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>EAGAIN;
&lt;span style="color:#66d9ef">break&lt;/span>;
}
...
}
...
&lt;span style="color:#66d9ef">if&lt;/span> (ret &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
file_accessed(filp);
&lt;span style="color:#66d9ef">return&lt;/span> ret;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L231">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>If the pipe is non-empty, the data is taken from the &lt;code>tail&lt;/code>-indexed &lt;code>pipe_buffer&lt;/code> (in &lt;code>bufs&lt;/code>). In case, a buffer is emptied during a read, the &lt;code>release&lt;/code> function pointer of the &lt;code>ops&lt;/code> field of the &lt;code>pipe_buffer&lt;/code> is executed. For a &lt;code>pipe_buffer&lt;/code> that was initialized by an earlier &lt;code>write()&lt;/code>, the &lt;code>ops&lt;/code> field is a pointer to the &lt;code>struct pipe_buf_operations anon_pipe_buf_ops&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> pipe_buf_operations anon_pipe_buf_ops &lt;span style="color:#f92672">=&lt;/span> {
.release &lt;span style="color:#f92672">=&lt;/span> anon_pipe_buf_release,
.try_steal &lt;span style="color:#f92672">=&lt;/span> anon_pipe_buf_try_steal,
.get &lt;span style="color:#f92672">=&lt;/span> generic_pipe_buf_get,
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L214">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * pipe_buf_release - put a reference to a pipe_buffer
&lt;/span>&lt;span style="color:#75715e"> * @pipe: the pipe that the buffer belongs to
&lt;/span>&lt;span style="color:#75715e"> * @buf: the buffer to put a reference to
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">pipe_buf_release&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>pipe,
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_buffer &lt;span style="color:#f92672">*&lt;/span>buf)
{
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> pipe_buf_operations &lt;span style="color:#f92672">*&lt;/span>ops &lt;span style="color:#f92672">=&lt;/span> buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ops;
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ops &lt;span style="color:#f92672">=&lt;/span> NULL;
ops&lt;span style="color:#f92672">-&amp;gt;&lt;/span>release(pipe, buf);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/pipe_fs_i.h#L197">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">anon_pipe_buf_release&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>pipe,
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_buffer &lt;span style="color:#f92672">*&lt;/span>buf)
{
&lt;span style="color:#66d9ef">struct&lt;/span> page &lt;span style="color:#f92672">*&lt;/span>page &lt;span style="color:#f92672">=&lt;/span> buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>page;
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * If nobody else uses this page, and we don&amp;#39;t already have a
&lt;/span>&lt;span style="color:#75715e"> * temporary page, let&amp;#39;s keep track of it as a one-deep
&lt;/span>&lt;span style="color:#75715e"> * allocation cache. (Otherwise just release our reference to it)
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> (page_count(page) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>tmp_page)
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>tmp_page &lt;span style="color:#f92672">=&lt;/span> page;
&lt;span style="color:#66d9ef">else&lt;/span>
put_page(page);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L125">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Thus, &lt;code>anon_pipe_buf_release()&lt;/code> is executed, which calls &lt;code>put_page()&lt;/code> to release our reference to the page. Note that while the &lt;code>ops&lt;/code> pointer is set to NULL to signal that be buffer has been released, the &lt;code>page&lt;/code> and &lt;code>flags&lt;/code> fields of the &lt;code>pipe_buffer&lt;/code> are left unmodified. It is thus the responsibility of code that might reuse a pipe buffer to initialize all its fields, otherwise the values are &amp;ldquo;uninitialized&amp;rdquo;. We can confirm this by printing the pipe structures after the last read.&lt;/p>
&lt;pre tabindex="0">&lt;code>struct pipe_inode_info at 0xffff8881044aec00
&amp;gt; 'head': 1
&amp;gt; 'tail': 1
&amp;gt; 'ring_size': 1
&amp;gt; 'bufs': 0xffff888101f8a180
struct pipe_buffer at 0xffff888101f8a180
&amp;gt; 'page': 0xffffea00040e3bc0
&amp;gt; 'offset': 4096
&amp;gt; 'len': 0
&amp;gt; 'ops': NULL
&amp;gt; 'flags': PIPE_BUF_FLAG_CAN_MERGE
&lt;/code>&lt;/pre>&lt;h3 id="summary">Summary&lt;/h3>
&lt;p>For us, the key takeaways are:&lt;/p>
&lt;ol>
&lt;li>Writes to a pipe can append to the &lt;code>page&lt;/code> of a &lt;code>pipe_buffer&lt;/code> if its &lt;code>PIPE_BUF_FLAG_CAN_MERGE&lt;/code> flag is set.&lt;/li>
&lt;li>This flag is set by default for buffers that are initialized by writes.&lt;/li>
&lt;li>Emptying a pipe with a &lt;code>read()&lt;/code> leaves the &lt;code>pipe_buffer&lt;/code>s' flags unmodified.&lt;/li>
&lt;/ol>
&lt;p>However, &lt;code>write&lt;/code>s to a pipe are not the only way fill it!&lt;/p>
&lt;h2 id="pipes-splicing">Pipes (splicing)&lt;/h2>
&lt;p>Besides reading and writing, the Linux programming interface also offers the &lt;code>splice&lt;/code> syscall for moving data from or to a pipe. This is what our PoC does next.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c"> pause_for_inspection(&lt;span style="color:#e6db74">&amp;#34;About to splice() file to pipe&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> (splice(tfd, &lt;span style="color:#ae81ff">0&lt;/span>, pipefds[&lt;span style="color:#ae81ff">1&lt;/span>], &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
exit(&lt;span style="color:#ae81ff">1&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L76">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Since this syscall may not be as well-known as the others, let&amp;rsquo;s briefly discuss it from a user&amp;rsquo;s perspective.&lt;/p>
&lt;h3 id="the-splice-system-call-user-land">The &lt;code>splice&lt;/code> System Call (user land)&lt;/h3>
&lt;pre tabindex="0">&lt;code>SPLICE(2) Linux Programmer's Manual SPLICE(2)
NAME
splice - splice data to/from a pipe
SYNOPSIS
#define _GNU_SOURCE /* See feature_test_macros(7) */
#include &amp;lt;fcntl.h&amp;gt;
ssize_t splice(int fd_in, off64_t *off_in, int fd_out,
off64_t *off_out, size_t len, unsigned int flags);
DESCRIPTION
splice() moves data between two file descriptors without copying between kernel
address space and user address space. It transfers up to len bytes of data from
the file descriptor fd_in to the file descriptor fd_out, where one of the file
descriptors must refer to a pipe.
The following semantics apply for fd_in and off_in:
* If fd_in refers to a pipe, then off_in must be NULL.
* If fd_in does not refer to a pipe and off_in is NULL, then bytes are read from
fd_in starting from the file offset, and the file offset is adjusted appropri‐
ately.
* If fd_in does not refer to a pipe and off_in is not NULL, then off_in must
point to a buffer which specifies the starting offset from which bytes will be
read from fd_in; in this case, the file offset of fd_in is not changed.
Analogous statements apply for fd_out and off_out.
&lt;/code>&lt;/pre>&lt;p>As mentioned above, a process can obtain a file descriptor using the &lt;code>sys_open&lt;/code> system call. If the process wishes to write the file content (or a part of it) into a pipe it has different options. It could &lt;code>read()&lt;/code> the data from the file into a buffer in its memory (or &lt;code>mmap()&lt;/code> the file) and then &lt;code>write()&lt;/code> it to the pipe. However, this involves a total of three context switches (kernel-user-space boundary). To make this whole operation more efficient the Linux kernel implements the &lt;code>sys_splice&lt;/code> system call. It essentially does the copying (not really a copy, see below) directly from one file descriptor to another one within the kernel space. As we will see, this makes a lot of sense because the content of a file or a pipe is already present in the kernel memory as a buffer or page or another structure.
One of &lt;code>fd_in&lt;/code> or &lt;code>fd_out&lt;/code> must be a pipe. The other &lt;code>fd_xxx&lt;/code> can be another pipe, a file, a socket, a block device, a character device. See Max Kellermann&amp;rsquo;s original blog post for an example how splicing is used to optimize real-world software (and how this application lead him to finding this bug :) Check out &lt;a href="https://web.archive.org/web/20130521163124/http://kerneltrap.org/node/6505">this&lt;/a> to read how Linus Torvalds himself explains the &lt;code>splice&lt;/code> system call 8-)&lt;/p>
&lt;h3 id="the-splice-system-call-implementation">The &lt;code>splice&lt;/code> System Call (Implementation)&lt;/h3>
&lt;p>The &lt;em>very&lt;/em> high level idea of the &lt;code>splice&lt;/code> implementation is illustrated in the following figure. After splicing, both, the pipe and the page cache, have different views of the same underlying data in memory. &lt;em>You might want to open this SVG image in a new tab and zoom in a bit.&lt;/em>
&lt;img src="https://lolcads.github.io/2022/06/pipe_and_page_cache.svg" alt="Pipe and Page Cache Overview">&lt;/p>
&lt;p>To see that this figure is correct, we start from the system call&amp;rsquo;s entry point &lt;code>SYSCALL_DEFINE6(splice,...)&lt;/code>, and first arrive at the function &lt;code>__do_splice()&lt;/code> that is responsible for copying the offset values from and to user space. The called function &lt;code>do_splice()&lt;/code> determines if we want to splice to, from or between pipes. In the first case the function&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">do_splice_to&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>in, loff_t &lt;span style="color:#f92672">*&lt;/span>ppos,
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>pipe, size_t len,
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> flags);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>is called, which executes&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">in&lt;span style="color:#f92672">-&amp;gt;&lt;/span>f_op&lt;span style="color:#f92672">-&amp;gt;&lt;/span>splice_read(in, ppos, pipe, len, flags);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/splice.c#L773">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>From here on, the execution path depends on the type of file we want to splice to the pipe. Since our target is a regular file and our VM uses the &lt;code>ext2&lt;/code> file system, the correct implementation is found in &lt;code>ext2_file_operations&lt;/code>. Note: If you debug the exploit on another machine with e.g. ext4 file system, feel free to follow this path&amp;hellip; we&amp;rsquo;ll meet again later ;) If you interested in this nice abstraction check out the &lt;a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html">Linux Virtual File System&lt;/a> documentation.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> file_operations ext2_file_operations &lt;span style="color:#f92672">=&lt;/span> {
...
.read_iter &lt;span style="color:#f92672">=&lt;/span> ext2_file_read_iter,
...
.splice_read &lt;span style="color:#f92672">=&lt;/span> generic_file_splice_read,
...
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/ext2/file.c#L182">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Calling &lt;code>generic_file_splice_read()&lt;/code> (eventually&amp;hellip;) leads us to &lt;code>filemap_read()&lt;/code>. Notice that at this point we switch from the file system &lt;code>fs/&lt;/code> into the &lt;a href="https://www.kernel.org/doc/html/latest/core-api/mm-api.html">memory management&lt;/a> &lt;code>mm/&lt;/code> subsystem of the kernel.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * filemap_read - Read data from the page cache.
&lt;/span>&lt;span style="color:#75715e"> * @iocb: The iocb to read.
&lt;/span>&lt;span style="color:#75715e"> * @iter: Destination for the data.
&lt;/span>&lt;span style="color:#75715e"> * @already_read: Number of bytes already read by the caller.
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * Copies data from the page cache. If the data is not currently present,
&lt;/span>&lt;span style="color:#75715e"> * uses the readahead and readpage address_space operations to fetch it.
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * Return: Total number of bytes copied, including those already read by
&lt;/span>&lt;span style="color:#75715e"> * the caller. If an error happens before any bytes are copied, returns
&lt;/span>&lt;span style="color:#75715e"> * a negative error number.
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
ssize_t &lt;span style="color:#a6e22e">filemap_read&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> kiocb &lt;span style="color:#f92672">*&lt;/span>iocb, &lt;span style="color:#66d9ef">struct&lt;/span> iov_iter &lt;span style="color:#f92672">*&lt;/span>iter,
ssize_t already_read)
{
&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>filp &lt;span style="color:#f92672">=&lt;/span> iocb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ki_filp;
&lt;span style="color:#66d9ef">struct&lt;/span> file_ra_state &lt;span style="color:#f92672">*&lt;/span>ra &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>filp&lt;span style="color:#f92672">-&amp;gt;&lt;/span>f_ra;
&lt;span style="color:#66d9ef">struct&lt;/span> address_space &lt;span style="color:#f92672">*&lt;/span>mapping &lt;span style="color:#f92672">=&lt;/span> filp&lt;span style="color:#f92672">-&amp;gt;&lt;/span>f_mapping;
&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>inode &lt;span style="color:#f92672">=&lt;/span> mapping&lt;span style="color:#f92672">-&amp;gt;&lt;/span>host;
&lt;span style="color:#66d9ef">struct&lt;/span> folio_batch fbatch;
...
folio_batch_init(&lt;span style="color:#f92672">&amp;amp;&lt;/span>fbatch);
...
&lt;span style="color:#66d9ef">do&lt;/span> {
...
error &lt;span style="color:#f92672">=&lt;/span> filemap_get_pages(iocb, iter, &lt;span style="color:#f92672">&amp;amp;&lt;/span>fbatch);
...
&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> folio_batch_count(&lt;span style="color:#f92672">&amp;amp;&lt;/span>fbatch); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">struct&lt;/span> folio &lt;span style="color:#f92672">*&lt;/span>folio &lt;span style="color:#f92672">=&lt;/span> fbatch.folios[i];
size_t fsize &lt;span style="color:#f92672">=&lt;/span> folio_size(folio);
size_t offset &lt;span style="color:#f92672">=&lt;/span> iocb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ki_pos &lt;span style="color:#f92672">&amp;amp;&lt;/span> (fsize &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
size_t bytes &lt;span style="color:#f92672">=&lt;/span> min_t(loff_t, end_offset &lt;span style="color:#f92672">-&lt;/span> iocb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ki_pos,
fsize &lt;span style="color:#f92672">-&lt;/span> offset);
size_t copied;
...
copied &lt;span style="color:#f92672">=&lt;/span> copy_folio_to_iter(folio, offset, bytes, iter);
already_read &lt;span style="color:#f92672">+=&lt;/span> copied;
iocb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ki_pos &lt;span style="color:#f92672">+=&lt;/span> copied;
ra&lt;span style="color:#f92672">-&amp;gt;&lt;/span>prev_pos &lt;span style="color:#f92672">=&lt;/span> iocb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ki_pos;
...
}
...
folio_batch_init(&lt;span style="color:#f92672">&amp;amp;&lt;/span>fbatch);
} &lt;span style="color:#66d9ef">while&lt;/span> (iov_iter_count(iter) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> iocb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ki_pos &lt;span style="color:#f92672">&amp;lt;&lt;/span> isize &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>error);
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/mm/filemap.c#L2645">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>In this function the actual copying (again no real byte-for-byte copy&amp;hellip; see below) of data from the page cache to the pipe takes place. In a loop, the data is copied in chunks by the call to &lt;code>copy_folio_to_iter()&lt;/code>. Note that a &lt;a href="https://lwn.net/Articles/849538/">folio&lt;/a> is not quite the same as a page, but for our purposes this doesn&amp;rsquo;t matter.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">copied &lt;span style="color:#f92672">=&lt;/span> copy_folio_to_iter(folio, offset, bytes, iter);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Besides, however, that if we look closer at the implementation of this operation in &lt;code>copy_page_to_iter_pipe()&lt;/code>, we notice that the data is not actually copied at all!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> size_t &lt;span style="color:#a6e22e">copy_page_to_iter_pipe&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> page &lt;span style="color:#f92672">*&lt;/span>page, size_t offset, size_t bytes,
&lt;span style="color:#66d9ef">struct&lt;/span> iov_iter &lt;span style="color:#f92672">*&lt;/span>i)
{
...
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>pipe &lt;span style="color:#f92672">=&lt;/span> i&lt;span style="color:#f92672">-&amp;gt;&lt;/span>pipe;
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_buffer &lt;span style="color:#f92672">*&lt;/span>buf;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> p_mask &lt;span style="color:#f92672">=&lt;/span> pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ring_size &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i_head &lt;span style="color:#f92672">=&lt;/span> i&lt;span style="color:#f92672">-&amp;gt;&lt;/span>head;
size_t off;
...
off &lt;span style="color:#f92672">=&lt;/span> i&lt;span style="color:#f92672">-&amp;gt;&lt;/span>iov_offset;
buf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>bufs[i_head &lt;span style="color:#f92672">&amp;amp;&lt;/span> p_mask];
&lt;span style="color:#66d9ef">if&lt;/span> (off) {
&lt;span style="color:#66d9ef">if&lt;/span> (offset &lt;span style="color:#f92672">==&lt;/span> off &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>page &lt;span style="color:#f92672">==&lt;/span> page) {
&lt;span style="color:#75715e">/* merge with the last one */&lt;/span>
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>len &lt;span style="color:#f92672">+=&lt;/span> bytes;
i&lt;span style="color:#f92672">-&amp;gt;&lt;/span>iov_offset &lt;span style="color:#f92672">+=&lt;/span> bytes;
&lt;span style="color:#66d9ef">goto&lt;/span> out;
}
i_head&lt;span style="color:#f92672">++&lt;/span>;
buf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>bufs[i_head &lt;span style="color:#f92672">&amp;amp;&lt;/span> p_mask];
}
...
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ops &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>page_cache_pipe_buf_ops;
get_page(page);
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>page &lt;span style="color:#f92672">=&lt;/span> page;
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>offset &lt;span style="color:#f92672">=&lt;/span> offset;
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>len &lt;span style="color:#f92672">=&lt;/span> bytes;
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/lib/iov_iter.c#L382">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>We first try to &amp;lsquo;append&amp;rsquo; the current copy operation to an earlier one by increasing the &lt;code>length&lt;/code> of the &lt;code>pipe_buffer&lt;/code> at &lt;code>head&lt;/code>. In case this is not possible, we simply advance the &lt;code>head&lt;/code> and put a &lt;em>reference to&lt;/em> the page we copy into its &lt;code>page&lt;/code> field while making sure that &lt;code>offset&lt;/code> and &lt;code>length&lt;/code> are set correctly. Indeed, the idea behind the efficiency of &lt;code>sys_splice&lt;/code> is to implement it as a &lt;em>zero-copy&lt;/em> operation, where pointers and reference counts are used instead of actually duplicating the data.&lt;/p>
&lt;p>Clearly this code potentially reuses the &lt;code>pipe_buffer&lt;/code>s (&lt;code>buf = &amp;amp;pipe-&amp;gt;bufs[i_head &amp;amp; p_mask]&lt;/code>), and thus all fields &lt;em>must&lt;/em> be checked and maybe re-initialized (there exist some old values, that might not be correct anymore). In particular, the initialization of the &lt;code>flags&lt;/code> is missing. As pointed out by Max Kellermann, it was missing since the &lt;a href="https://github.com/torvalds/linux/commit/241699cd72a8489c9446ae3910ddd243e9b9061b">commit&lt;/a> that introduced this function.&lt;/p>
&lt;h3 id="debugger-1">Debugger&lt;/h3>
&lt;p>We can also observe the effect of the zero-copy operation and missing initialization in the debugger. This is the output from earlier,&lt;/p>
&lt;pre tabindex="0">&lt;code>struct file at 0xffff8881045b0800
&amp;gt; 'f_mapping': 0xffff8881017d9460
&amp;gt; filename: target_file
struct address_space at 0xffff8881017d9460
&amp;gt; 'a_ops': 0xffffffff82226ce0 &amp;lt;ext4_aops&amp;gt;
&amp;gt; 'i_pages.xa_head' : 0xffffea0004156880
struct page at 0xffffea0004156880
&amp;gt; virtual: 0xffff8881055a2000
&amp;gt; data: b'File owned by root!\n'[...]b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
&lt;/code>&lt;/pre>&lt;p>and this is the state of the pipe after splicing&lt;/p>
&lt;pre tabindex="0">&lt;code>struct pipe_inode_info at 0xffff8881044aec00
&amp;gt; 'head': 2
&amp;gt; 'tail': 1
&amp;gt; 'ring_size': 1
&amp;gt; 'bufs': 0xffff888101f8a180
struct pipe_buffer at 0xffff888101f8a180
&amp;gt; 'page': 0xffffea0004156880 &amp;lt;- same page as before
&amp;gt; 'offset': 0
&amp;gt; 'len': 5
&amp;gt; 'ops': 0xffffffff8221cee0 &amp;lt;page_cache_pipe_buf_ops&amp;gt;
&amp;gt; 'flags': PIPE_BUF_FLAG_CAN_MERGE &amp;lt;- flag still set... oopsie :)
&lt;/code>&lt;/pre>&lt;p>The data pointer in the &lt;code>struct address_space&lt;/code> (which represents the page cache&amp;rsquo;s view on the &lt;code>target_file&lt;/code>) and the &lt;code>pipe_buffer&lt;/code> at &lt;code>head&lt;/code> are equal, while the offset and length reflect what our PoC specified in its call to &lt;code>splice&lt;/code>. Note that we are reusing the buffer we emptied earlier, re-initializing all fields &lt;em>but&lt;/em> the flags.&lt;/p>
&lt;h2 id="whats-the-actual-problem">What&amp;rsquo;s the Actual Problem?&lt;/h2>
&lt;p>At this point the problem becomes evident. With &lt;strong>anonymous&lt;/strong> pipe buffers it is allowed to continue the writing where the previous write stopped, which is indicated by the &lt;code>PIPE_BUF_FLAG_CAN_MERGE&lt;/code> flag. With the &lt;strong>file-backed buffers&lt;/strong>, created by splicing, this should not be allowed by the kernel since those pages are &amp;ldquo;owned&amp;rdquo; by the page cache and not by the pipe.&lt;/p>
&lt;p>Thus, when we &lt;code>splice()&lt;/code> the data from a file into a pipe we would have to set &lt;code>buf-&amp;gt;flags = 0&lt;/code> to indicate that it is not okay to append data to an already existing - not fully written - page (&lt;code>buf-&amp;gt;page&lt;/code>) since this page belongs to the page cache (the file). When we &lt;code>pipe_write()&lt;/code> (or in our program just &lt;code>write()&lt;/code>) again we write into the page cache&amp;rsquo;s page because the check &lt;code>buf-&amp;gt;flags &amp;amp; PIPE_BUF_FLAG_CAN_MERGE&lt;/code> is &lt;code>true&lt;/code> (see &lt;code>pipe_write&lt;/code> above if you forgot about that part).&lt;/p>
&lt;p>So the main problem is that we start with an anonymous pipe that will then be &amp;ldquo;turned into&amp;rdquo; a file-backed pipe (not the whole pipe but some buffers) by the &lt;code>splice()&lt;/code> but the pipe does not get this information since &lt;code>buf-&amp;gt;flags&lt;/code> is not set to &lt;code>0&lt;/code> and thus the merging is still allowed.&lt;/p>
&lt;p>The &lt;a href="https://github.com/torvalds/linux/commit/9d2231c5d74e13b2a0546fee6737ee4446017903">patch&lt;/a> is simply adding the missing initialization.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">diff --git a/lib/iov_iter.c b/lib/iov_iter.c
index b0e0acdf96c15e..6dd5330f7a9957 100644
&lt;span style="color:#f92672">--- a/lib/iov_iter.c
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+++ b/lib/iov_iter.c
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span>&lt;span style="color:#75715e">@@ -414,6 +414,7 @@ static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t by
&lt;/span>&lt;span style="color:#75715e">&lt;/span>return 0;
buf-&amp;gt;ops = &amp;amp;page_cache_pipe_buf_ops;
&lt;span style="color:#a6e22e">+ buf-&amp;gt;flags = 0;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> get_page(page);
buf-&amp;gt;page = page;
buf-&amp;gt;offset = offset;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As we can see above, our PoC arranged for the &lt;code>PIPE_BUF_FLAG_CAN_MERGE&lt;/code> flag to be set on the pipe buffer re-used for the splice. Thus, the last write will trigger the bug.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">pause_for_inspection(&lt;span style="color:#e6db74">&amp;#34;About to write() into page cache&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> (write(pipefds[&lt;span style="color:#ae81ff">1&lt;/span>], &lt;span style="color:#e6db74">&amp;#34;pwned by user&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">13&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span>) {
exit(&lt;span style="color:#ae81ff">1&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L81">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Back in the debugger, we can see that the final invocation of &lt;code>pipe_write()&lt;/code> appends to the partially filled &lt;code>pipe_buffer&lt;/code> that is backed by the page cache.&lt;/p>
&lt;pre tabindex="0">&lt;code>struct address_space at 0xffff8881017d9460
&amp;gt; 'a_ops': 0xffffffff82226ce0 &amp;lt;ext4_aops&amp;gt;
&amp;gt; 'i_pages.xa_head' : 0xffffea0004156880
struct pipe_inode_info at 0xffff8881044aec00
&amp;gt; 'head': 2
&amp;gt; 'tail': 1
&amp;gt; 'ring_size': 1
&amp;gt; 'bufs': 0xffff888101f8a180
struct pipe_buffer at 0xffff888101f8a180
&amp;gt; 'page': 0xffffea0004156880
&amp;gt; 'offset': 0
&amp;gt; 'len': 18
&amp;gt; 'ops': 0xffffffff8221cee0 &amp;lt;page_cache_pipe_buf_ops&amp;gt;
&amp;gt; 'flags': PIPE_BUF_FLAG_CAN_MERGE
struct page at 0xffffea0004156880
&amp;gt; virtual: 0xffff8881055a2000
&amp;gt; data: b'File pwned by user!\n'[...]b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
&lt;/code>&lt;/pre>&lt;p>Here we can see that &lt;code>owned by root&lt;/code> (starting at index 5 of &amp;ldquo;File owned by root!&amp;quot;) has been overwritten with &lt;code>pwned by user&lt;/code> in the page cache.&lt;/p>
&lt;p>In the shell we can confirm that the file contents changed for all processes on the system&lt;/p>
&lt;pre tabindex="0">&lt;code>user@lkd-debian-qemu:~$ ./poc
user@lkd-debian-qemu:~$ cat target_file
File pwned by user!
user@lkd-debian-qemu:~$ exit
root@lkd-debian-qemu:~# echo 1 &amp;gt; /proc/sys/vm/drop_caches
[ 232.397273] bash (203): drop_caches: 1
root@lkd-debian-qemu:~# su user
user@lkd-debian-qemu:~$ cat target_file
File owned by root
&lt;/code>&lt;/pre>&lt;p>You can also see that the changes to the file&amp;rsquo;s page cache data are not written back to disk. After clearing the page cache, the old content appears again. But, all other programs would use the modified version from the page cache since the kernel transparently offers you the cached version of the file data (that&amp;rsquo;s the purpose of the page cache).&lt;/p>
&lt;h3 id="limitations">Limitations&lt;/h3>
&lt;p>There are some inherent limitations to the writes that we can perform using this technique that are due to implementation of the pipe and page cache that Max Kellermann mentions:&lt;/p>
&lt;blockquote>
&lt;p>the attacker must have read permissions (because it needs to splice() a page into a pipe)&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>the offset must not be on a page boundary (because at least one byte of that page must have been spliced into the pipe)&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>the write cannot cross a page boundary (because a new anonymous buffer would be created for the rest)&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>the file cannot be resized (because the pipe has its own page fill management and does not tell the page cache how much data has been appended)&lt;/p>
&lt;/blockquote>
&lt;h2 id="approaches-to-understand-the-bug">Approaches to Understand the Bug&lt;/h2>
&lt;h3 id="top-down-vs-bottom-up-vs-hybrid">Top Down vs. Bottom Up vs. Hybrid&lt;/h3>
&lt;p>Given a PoC and a patch there are different approaches to investigate the vulnerability.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Top Down&lt;/strong>: find the &lt;code>splice()&lt;/code>, &lt;code>write()&lt;/code>, &lt;code>read()&lt;/code> system call implementation and go deeper.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Bottom Up&lt;/strong>: have a look at the fix: &lt;a href="https://github.com/torvalds/linux/commit/9d2231c5d74e13b2a0546fee6737ee4446017903">https://github.com/torvalds/linux/commit/9d2231c5d74e13b2a0546fee6737ee4446017903&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">diff --git a/lib/iov_iter.c b/lib/iov_iter.c
index b0e0acdf96c15e..6dd5330f7a9957 100644
&lt;span style="color:#f92672">--- a/lib/iov_iter.c
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+++ b/lib/iov_iter.c
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span>&lt;span style="color:#75715e">@@ -414,6 +414,7 @@ static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t by
&lt;/span>&lt;span style="color:#75715e">&lt;/span> return 0;
buf-&amp;gt;ops = &amp;amp;page_cache_pipe_buf_ops;
&lt;span style="color:#a6e22e">+ buf-&amp;gt;flags = 0;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> get_page(page);
buf-&amp;gt;page = page;
buf-&amp;gt;offset = offset;
&lt;span style="color:#75715e">@@ -577,6 +578,7 @@ static size_t push_pipe(struct iov_iter *i, size_t size,
&lt;/span>&lt;span style="color:#75715e">&lt;/span> break;
buf-&amp;gt;ops = &amp;amp;default_pipe_buf_ops;
&lt;span style="color:#a6e22e">+ buf-&amp;gt;flags = 0;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> buf-&amp;gt;page = page;
buf-&amp;gt;offset = 0;
buf-&amp;gt;len = min_t(ssize_t, left, PAGE_SIZE);
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>find &lt;code>lib/iov_iter.c&lt;/code> (more concrete the functions &lt;code>copy_page_to_iter_pipe()&lt;/code> and &lt;code>push_pipe()&lt;/code>) and your way back to the system calls.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Hybrid&lt;/strong>: start from &lt;code>splice()&lt;/code> system call but know where we will end (either of the patched functions from above)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="linux-kernel-source">Linux Kernel Source&lt;/h3>
&lt;p>Access to the source code:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/torvalds/linux">https://github.com/torvalds/linux&lt;/a> + ctags + cscope (&lt;code>make cscope tags&lt;/code>) or an IDE that is capable of creating cross references (might be very resource hungry because of the kernel&amp;rsquo;s size!)&lt;/li>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source">https://elixir.bootlin.com/linux/v5.17.9/source&lt;/a> (cross references already created + no need for extra tools)&lt;/li>
&lt;/ul>
&lt;p>When reading kernel source code for the first time, you might encounter some obstacles. In general it is easy to get lost and thus you should always keep in mind what it is that you are interested in finding / understanding. We must also understand that it is &lt;em>impossible&lt;/em> to understand every line of the code that we look at. Use a best-effort approach to understand the things that get you closer to you goal). You will encounter:&lt;/p>
&lt;ul>
&lt;li>lots of error checking: in general &lt;em>very&lt;/em> interesting, however, here we ignore it (i.e. &lt;code>return -EXYZ&lt;/code> code paths)&lt;/li>
&lt;li>many layers of macros, (inlined) function calls and definitions: collect everything and simplify it. Note: you cannot set breakpoints on macros, which might be a problem as well.&lt;/li>
&lt;li>structures full of function pointers:
&lt;ul>
&lt;li>for example, look under &amp;ldquo;Referenced in [&amp;hellip;] files&amp;rdquo; on &lt;a href="https://elixir.bootlin.com">https://elixir.bootlin.com&lt;/a>&lt;/li>
&lt;li>&amp;ldquo;decide&amp;rdquo; for some implementation (in our case ext2 file system)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>conditional compilation depending on:
&lt;ul>
&lt;li>compile time options: check the config files you used for your build &lt;code>.config&lt;/code>&lt;/li>
&lt;li>processor architecture: go for &lt;code>x86-64&lt;/code> if present, else take the generic version&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>A detailed and streamlined analysis of any bug makes it seem shallow, however, don&amp;rsquo;t get fooled by that impression. Making sense of the bug requires a conceptual understanding of multiple interacting subsystems of the Linux kernel. A root cause analysis without a PoC, blog post, or patch at hand would be a tricky task. In general, the nature of this bug makes it a great opportunity to learn about the Linux kernel. A missing initialization is a welcome diversion from the ubiquitous memory corruption issues (that a lot of exploit developers love ;)). Furthermore, in contrast to those kind of vulnerabilities, the exploitation of this one is almost trivial, stable, and it works across a huge range of Linux distributions. Maybe you got motivated to check out some more complex vulnerabilities / exploits or the Linux kernel yourself :).&lt;/p></content></item></channel></rss>