<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kernel on lolcads tech blog</title><link>https://lolcads.github.io/tags/kernel/</link><description>Recent content in Kernel on lolcads tech blog</description><generator>Hugo</generator><language>en</language><managingEditor>lolcads@posteo.net (lolcads)</managingEditor><webMaster>lolcads@posteo.net (lolcads)</webMaster><copyright>lolcads</copyright><lastBuildDate>Thu, 29 Jan 2026 10:00:00 +0200</lastBuildDate><atom:link href="https://lolcads.github.io/tags/kernel/index.xml" rel="self" type="application/rss+xml"/><item><title>Improving Linux Heap Exploit Reliability with FreshSlices and CPU-Bullying</title><link>https://lolcads.github.io/posts/2026/01/freshslices_and_cpubullies/</link><pubDate>Thu, 29 Jan 2026 10:00:00 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2026/01/freshslices_and_cpubullies/</guid><description>&lt;p&gt;Exploits built around heap-based memory corruptions will never be perfectly reliable. There are multiple factors contributing to this, one being that the heap is shared among all tasks (user processes and kernel threads) running on a machine. Thus, the task running the exploit cannot exercise perfect control over it.&lt;/p&gt;
&lt;p&gt;Much has already been written about the art of shaping the kernel heap and creating desired layouts reliably. This post assumes a reader who is somewhat familiar with the subject, i.e., I will not recount any basics here. Instead, I will focus on two generic techniques for improving an exploit process&amp;rsquo; control over the kernel heap.&lt;/p&gt;</description></item><item><title>Towards utilizing BTF Information in Linux Memory Forensics</title><link>https://lolcads.github.io/posts/2024/11/btf2json/</link><pubDate>Wed, 13 Nov 2024 12:38:49 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/11/btf2json/</guid><description>&lt;p&gt;This post is about some work that I did on automatic profile generation for memory forensics of Linux systems. To be upfront about it: This work is somewhat half-finished &amp;ndash; it already does something quite useful, but it could do a lot more, and it has not been evaluated thoroughly enough to be considered &amp;ldquo;production ready&amp;rdquo;. The reason I decided to publish it anyway is that I believe that there is an interesting opportunity to change the way in which we generate profiles for the analysis of Linux memory images &lt;em&gt;in practice&lt;/em&gt;. However, in order for it to become a production tool, at least one outstanding problem has to be addressed (I have some ideas on that one) and lots of coding work needs to be done &amp;ndash; and I simply do not have the resources to work on that right now.&lt;/p&gt;</description></item><item><title>BPF Memory Forensics with Volatility 3</title><link>https://lolcads.github.io/posts/2023/12/bpf_memory_forensics_with_volatility3/</link><pubDate>Thu, 21 Dec 2023 13:47:46 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2023/12/bpf_memory_forensics_with_volatility3/</guid><description>&lt;h1 id="bpf-memory-forensics-with-volatility-3"&gt;BPF Memory Forensics with Volatility 3&lt;/h1&gt;
&lt;h2 id="introduction-and-motivation"&gt;Introduction and Motivation&lt;/h2&gt;
&lt;p&gt;Have you ever wondered how an eBPF rootkit looks like? Well, here&amp;rsquo;s one, have a good look:&lt;/p&gt;
&lt;p&gt;&lt;div class="not-prose"&gt;
&lt;figure&gt;
 &lt;img src="https://lolcads.github.io/2023/12/ubuntu-20.04-LTS-focal-ebpfkit.png"
 alt="ubuntu-20.04-LTS-focal-ebpfkit.png" 
 loading="lazy"
 &gt;
 &lt;/figure&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Upon receiving a command and control (C2) request, this specimen can execute arbitrary commands on the infected machine, exfiltrate sensitive files, perform passive and active network discovery scans (like &lt;code&gt;nmap&lt;/code&gt;), or provide a privilege escalation backdoor to a local shell. Of course, it&amp;rsquo;s also trying its best to hide itself from system administrators hunting it with different command line tools such as &lt;code&gt;ps&lt;/code&gt;, &lt;code&gt;lsof&lt;/code&gt;, &lt;code&gt;tcpdump&lt;/code&gt; an others or even try tools like &lt;code&gt;rkhunter&lt;/code&gt; or &lt;code&gt;chkrootkit&lt;/code&gt;.&lt;/p&gt;</description></item><item><title>Exploration of the Dirty Pipe Vulnerability (CVE-2022-0847)</title><link>https://lolcads.github.io/posts/2022/06/dirty_pipe_cve_2022_0847/</link><pubDate>Mon, 06 Jun 2022 19:57:03 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2022/06/dirty_pipe_cve_2022_0847/</guid><description>&lt;h2 id="intro"&gt;Intro&lt;/h2&gt;
&lt;p&gt;This blog post reflects our exploration of the Dirty Pipe Vulnerability in the Linux kernel. The bug was discovered by Max Kellermann and described &lt;a href="https://dirtypipe.cm4all.com/" target="_blank" rel="noopener"&gt;here&lt;/a&gt;
. If you haven&amp;rsquo;t read the original publication yet, we&amp;rsquo;d suggest that you read it first (maybe also twice ;)). While Kellermann&amp;rsquo;s post is a great resource that contains all the relevant information to understand the bug, it assumes some familiarity with the Linux kernel. To fully understand what&amp;rsquo;s going on we&amp;rsquo;d like to shed some light on specific kernel internals. The aim of this post is to share our knowledge and to provide a resource for other interested individuals. The idea of this post is as follows: We take a small proof-of-concept (PoC) program and divide it into several stages. Each stage issues a system call (or syscall for short), and we will look inside the kernel to understand which actions and state changes occur in response to those calls. For this we use both, the kernel source code (&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source" target="_blank" rel="noopener"&gt;elixir.bootlin.com&lt;/a&gt;
, version 5.17.9) and a kernel debugging setup (derived from &lt;a href="https://github.com/martinclauss/linux-kernel-debugging" target="_blank" rel="noopener"&gt;linux-kernel-debugging&lt;/a&gt;
). The Dirty Pipe-specific debugging setup and the PoC code is provided in a &lt;a href="https://github.com/vobst/lkd-cve" target="_blank" rel="noopener"&gt;GitHub&lt;/a&gt;
 repository.&lt;/p&gt;</description></item><item><title>Exploiting CVE-2021-43247</title><link>https://lolcads.github.io/posts/2022/06/exploiting_cve_2021_43247/</link><pubDate>Thu, 02 Jun 2022 10:59:55 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2022/06/exploiting_cve_2021_43247/</guid><description>&lt;p&gt;In this blog post I will go in depth into the inner workings of &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2021-43247" target="_blank" rel="noopener"&gt;CVE-2021-43247&lt;/a&gt;
, which was fixed on the 14th of December 2021.
This bug was classified as &amp;ldquo;Windows TCP/IP Driver Elevation of Privilege Vulnerability&amp;rdquo;.
The vulnerability itself was probably dormant for a long time, but became exploitable when the &lt;code&gt;AF_UNIX&lt;/code&gt; address family
was first introduced in 2019.&lt;/p&gt;
&lt;p&gt;I will also take this as an excuse to explain in detail, what drivers are, how user space communicates with drivers,
what a Local Privilege Escalation (LPE) is and what how we can achieve it in this case.&lt;/p&gt;</description></item></channel></rss>