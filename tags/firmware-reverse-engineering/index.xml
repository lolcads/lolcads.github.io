<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Firmware Reverse Engineering on lolcads tech blog</title><link>https://lolcads.github.io/tags/firmware-reverse-engineering/</link><description>Recent content in Firmware Reverse Engineering on lolcads tech blog</description><generator>Hugo</generator><language>en</language><managingEditor>lolcads@posteo.net (lolcads)</managingEditor><webMaster>lolcads@posteo.net (lolcads)</webMaster><copyright>lolcads</copyright><lastBuildDate>Mon, 25 Nov 2024 10:37:07 +0100</lastBuildDate><atom:link href="https://lolcads.github.io/tags/firmware-reverse-engineering/index.xml" rel="self" type="application/rss+xml"/><item><title>coderec: Detecting Machine Code in Binary Files</title><link>https://lolcads.github.io/posts/2024/11/coderec/</link><pubDate>Mon, 25 Nov 2024 10:37:07 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/11/coderec/</guid><description>&lt;p&gt;Firmware reverse engineering comes with some unique challenges compared to the
reversing of programs that run in the user space of some mainstream operating
system. You will encounter one of them before Ghidra&amp;rsquo;s Code Browser even opens.
Let&amp;rsquo;s illustrate it at a concrete example: I recently got myself some old Cisco
devices off eBay as I was curious to have a look at their proprietary IOS
operating system. However, when loading the IOS image into Ghidra&lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt; you are
greeted with the following screen:&lt;/p&gt;</description></item></channel></rss>