<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Forensics on lolcads tech blog</title><link>https://lolcads.github.io/tags/forensics/</link><description>Recent content in Forensics on lolcads tech blog</description><generator>Hugo</generator><language>en</language><managingEditor>lolcads@posteo.net (lolcads)</managingEditor><webMaster>lolcads@posteo.net (lolcads)</webMaster><copyright>lolcads</copyright><lastBuildDate>Wed, 13 Nov 2024 12:38:49 +0100</lastBuildDate><atom:link href="https://lolcads.github.io/tags/forensics/index.xml" rel="self" type="application/rss+xml"/><item><title>Towards utilizing BTF Information in Linux Memory Forensics</title><link>https://lolcads.github.io/posts/2024/11/btf2json/</link><pubDate>Wed, 13 Nov 2024 12:38:49 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/11/btf2json/</guid><description>&lt;p>This post is about some work that I did on automatic profile generation for memory forensics of Linux systems. To be upfront about it: This work is somewhat half-finished &amp;ndash; it already does something quite useful, but it could do a lot more, and it has not been evaluated thoroughly enough to be considered &amp;ldquo;production ready&amp;rdquo;. The reason I decided to publish it anyway is that I believe that there is an interesting opportunity to change the way in which we generate profiles for the analysis of Linux memory images &lt;em>in practice&lt;/em>. However, in order for it to become a production tool, at least one outstanding problem has to be addressed (I have some ideas on that one) and lots of coding work needs to be done &amp;ndash; and I simply do not have the resources to work on that right now.&lt;/p></description></item><item><title>*PowerView* is evil, but *PowerVi* and *ew* are legit, right? - Missing signature-based detections due to PowerShell Script Block Logging Fragmentation</title><link>https://lolcads.github.io/posts/2024/04/psscriptblockfragmentation/</link><pubDate>Mon, 15 Apr 2024 11:01:40 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/04/psscriptblockfragmentation/</guid><description>&lt;h1 id="powerview-is-evil-but-powervi-and-ew-are-legit-right---missing-signature-based-detections-due-to-powershell-script-block-logging-fragmentation">&lt;em>PowerView&lt;/em> is evil, but &lt;em>PowerVi&lt;/em> and &lt;em>ew&lt;/em> are legit, right? - Missing signature-based detections due to PowerShell Script Block Logging Fragmentation&lt;/h1>
&lt;h2 id="update-15082024">Update [15/08/2024]:&lt;/h2>
&lt;p>In a &lt;a href="https://x.com/nas_bench/status/1806253324456403316" target="_blank" rel="noopener">short discussion on X&lt;/a>
 the source code of the PowerShell Script Block Fragmentation was &lt;a href="https://github.com/PowerShell/PowerShell/blob/7ec8e4ed8f47e81e70de5353500f8a01d5fe396c/src/System.Management.Automation/engine/runtime/CompiledScriptBlock.cs#L1451-L1454" target="_blank" rel="noopener">linked&lt;/a>
.
Looking at the comment in the code, it becomes clear that the size of a script block fragment is intentionally set to a random value in order to deny attackers the easy possibility to split their scripts as they wish.
If a script block is larger than 20000 (Unicode) characters, it is split into fragments with sizes 10000 plus a random value between 0 and 10000 - resulting in script block sizes from 10000 to 20000 characters.
Further research is needed to answer the question if and how the fragmentation of PowerShell script blocks can still be exploited.&lt;/p></description></item><item><title>BPF Memory Forensics with Volatility 3</title><link>https://lolcads.github.io/posts/2023/12/bpf_memory_forensics_with_volatility3/</link><pubDate>Thu, 21 Dec 2023 13:47:46 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2023/12/bpf_memory_forensics_with_volatility3/</guid><description>&lt;h1 id="bpf-memory-forensics-with-volatility-3">BPF Memory Forensics with Volatility 3&lt;/h1>
&lt;h2 id="introduction-and-motivation">Introduction and Motivation&lt;/h2>
&lt;p>Have you ever wondered how an eBPF rootkit looks like? Well, here&amp;rsquo;s one, have a good look:&lt;/p>
&lt;p>&lt;div class="not-prose">
&lt;figure>
 &lt;img src="https://lolcads.github.io/2023/12/ubuntu-20.04-LTS-focal-ebpfkit.png"
 alt="ubuntu-20.04-LTS-focal-ebpfkit.png" 
 loading="lazy"
 >
 &lt;/figure>&lt;/div>
&lt;/p>
&lt;p>Upon receiving a command and control (C2) request, this specimen can execute arbitrary commands on the infected machine, exfiltrate sensitive files, perform passive and active network discovery scans (like &lt;code>nmap&lt;/code>), or provide a privilege escalation backdoor to a local shell. Of course, it&amp;rsquo;s also trying its best to hide itself from system administrators hunting it with different command line tools such as &lt;code>ps&lt;/code>, &lt;code>lsof&lt;/code>, &lt;code>tcpdump&lt;/code> an others or even try tools like &lt;code>rkhunter&lt;/code> or &lt;code>chkrootkit&lt;/code>.&lt;/p></description></item></channel></rss>