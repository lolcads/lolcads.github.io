<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>sockets on lolcads tech blog</title><link>https://lolcads.github.io/tags/sockets/</link><description>Recent content in sockets on lolcads tech blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; lolcads</copyright><lastBuildDate>Tue, 22 Feb 2022 14:24:40 +0100</lastBuildDate><atom:link href="https://lolcads.github.io/tags/sockets/index.xml" rel="self" type="application/rss+xml"/><item><title>libdesock</title><link>https://lolcads.github.io/posts/2022/02/libdesock/</link><pubDate>Tue, 22 Feb 2022 14:24:40 +0100</pubDate><guid>https://lolcads.github.io/posts/2022/02/libdesock/</guid><description>Fuzzing Network Applications with AFL and libdesock Fuzzing network servers with AFL is challenging since AFL provides its input via stdin or command line arguments while servers get their input over network connections. As the popularity of AFL grew, many attempts have been made of fuzzing popular servers like apache and nginx using different techniques and hacky workarounds. However an off-the-shelf network fuzzing solution for AFL didn&amp;rsquo;t exist for a long time until so-called &amp;ldquo;desocketing&amp;rdquo; tools emerged.</description><content>&lt;h1 id="fuzzing-network-applications-with-afl-and-libdesock">Fuzzing Network Applications with AFL and libdesock&lt;/h1>
&lt;p>Fuzzing network servers with AFL is challenging since AFL provides its
input via stdin or command line arguments while servers get their input
over network connections.
As the popularity of AFL grew, many attempts have been made of fuzzing
popular servers like apache and nginx using different
techniques and hacky workarounds. However an off-the-shelf network fuzzing
solution for AFL didn&amp;rsquo;t exist for a long time until so-called &amp;ldquo;desocketing&amp;rdquo;
tools emerged.
These desocketing tools enabled network fuzzing without
making a lot of additional modifications to the program under test
and quickly became widely used in combination with AFL.&lt;/p>
&lt;h2 id="what-is-desocketing">What is &amp;ldquo;desocketing&amp;rdquo;?&lt;/h2>
&lt;p>Before desocketing tools were published two common techniques for
network fuzzing were&lt;/p>
&lt;ol>
&lt;li>Sending fuzz input over real network connections&lt;/li>
&lt;li>Modifying the target source to use stdin instead of sockets&lt;/li>
&lt;/ol>
&lt;p>The first approach is the most prevalent used by popular fuzzers
like &lt;a href="https://github.com/jtpereyda/boofuzz">boofuzz&lt;/a> or in academia by &lt;a href="https://github.com/aflnet/aflnet">AFLnet&lt;/a> or &lt;a href="https://github.com/stateafl/stateafl">StateAFL&lt;/a>.
This however suffers performance- and stability-drawbacks.
Stability is affected because the servers run with all threads and child processes
enabled. Background threads can be scheduled independently from the input being sent
resulting in invalid coverage information.
Performance is affected because of the amount of kernel activity and network overhead involved.&lt;/p>
&lt;p>The second approach solves the network overhead problem but does not reduce the
kernel activity. It also takes a considerable amount of effort that may lead
to changing &lt;a href="https://securitylab.github.com/research/fuzzing-sockets-FTP/">thousands of lines of code&lt;/a>.&lt;/p>
&lt;p>Desocketing aims to reduce kernel activity and the amount of modifications necessary to a program.
It works by building a shared library that implements functions
like &lt;code>socket()&lt;/code> and &lt;code>accept()&lt;/code> and preloading it via &lt;code>LD_PRELOAD&lt;/code>
into the address space of a network application where it replaces
the network stack of the libc.
The desocketing library simulates incoming connections to the server
but every read on a socket is replaced by a read on stdin
and every write on a socket is redirected to stdout.
Strictly speaking the latter isn&amp;rsquo;t necessary for fuzzing but it&amp;rsquo;s useful
for debugging.&lt;/p>
&lt;p>The following figure demonstrates how to desock nginx such that the network
traffic becomes visible on a terminal.&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/02/demo.svg" alt="">&lt;/p>
&lt;h2 id="how-desocketing-works">How desocketing works&lt;/h2>
&lt;p>Making desocketing libraries has its complexities.
AFLplusplus' &lt;a href="https://github.com/AFLplusplus/AFLplusplus/tree/stable/utils/socket_fuzzing">socketfuzz&lt;/a>
ships a desocketing library that just returns &lt;code>0&lt;/code> (stdin) in &lt;code>accept()&lt;/code>.
Unfortunately this doesn&amp;rsquo;t quite work because &lt;code>send()&lt;/code> and &lt;code>recv()&lt;/code> need an
fd that actually refers to a network connection. If you pass them an fd that
refers to a file the kernel will complain.
Thus we need more complicated methods.&lt;/p>
&lt;p>At the time of writing this, there exists only one popular desocketing solution: &lt;a href="https://github.com/zardus/preeny">preeny&lt;/a>.
preeny creates a socketpair &lt;code>(a,b)&lt;/code> and spawns two threads &lt;code>t1&lt;/code> and
&lt;code>t2&lt;/code> in every call to &lt;code>socket()&lt;/code>.&lt;/p>
&lt;ul>
&lt;li>Thread &lt;code>t1&lt;/code> forwards all data from stdin to &lt;code>a&lt;/code>&lt;/li>
&lt;li>Thread &lt;code>t2&lt;/code> forwards all data from &lt;code>a&lt;/code> to stdout&lt;/li>
&lt;li>In &lt;code>socket()&lt;/code> preeny returns &lt;code>b&lt;/code>&lt;/li>
&lt;li>When AFL writes input to stdin, thread &lt;code>t1&lt;/code> forwards that data to &lt;code>a&lt;/code>&lt;/li>
&lt;li>Writing to &lt;code>a&lt;/code> means that the data will become available in &lt;code>b&lt;/code> and the
application can read the request from &lt;code>b&lt;/code>&lt;/li>
&lt;li>The application writes a response back to &lt;code>b&lt;/code>, making the data available
in socket &lt;code>a&lt;/code> where &lt;code>t2&lt;/code> forwards it to stdout.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://lolcads.github.io/2022/02/preeny.png" alt="">&lt;/p>
&lt;p>Unfortunately this design makes preeny unsuitable for fuzzing:&lt;/p>
&lt;ol>
&lt;li>Spawning threads and joining them introduces additional overhead.&lt;/li>
&lt;li>Each thread realizes busy waiting by calling &lt;code>poll()&lt;/code> every 15ms&lt;/li>
&lt;li>Preeny still relies on a lot of kernel interaction. I/O multiplexing (select, poll, epoll)
is left completely to the kernel.&lt;/li>
&lt;li>The threads may introduce additional instability.&lt;br>
Normally you want to disable threads when fuzzing with AFL.&lt;/li>
&lt;li>It can handle only single-threaded applications but most of the servers
are multi-threaded&lt;/li>
&lt;/ol>
&lt;p>A better desocketing library is needed that is more resource-efficient and handles the complexities of
modern network applications correctly.
So we created a new desocketing library: &amp;ldquo;libdesock&amp;rdquo;.&lt;/p>
&lt;h2 id="using-libdesock">Using libdesock&lt;/h2>
&lt;p>libdesock fully emulates the network stack of the kernel. The kernel is only queried to obtain file
descriptors and to do I/O on stdin and stdout.
Everything else - handling of connections, I/O multiplexing (select, poll, epoll), handling socket metadata (getsockname, getpeername) - entierly happens in userland.&lt;br>
In contrast to preeny, libdesock supports multi-threaded applications and its overall design
makes it more resource efficient and 5x faster than preeny.
This has no effect on AFL&amp;rsquo;s exec/s though, since that primarily depends on the program
and the input.&lt;/p>
&lt;p>We have tested libdesock on common network daemons like&lt;/p>
&lt;ul>
&lt;li>nginx&lt;/li>
&lt;li>Apache httpd&lt;/li>
&lt;li>OpenSSH&lt;/li>
&lt;li>Exim&lt;/li>
&lt;li>bind9&lt;/li>
&lt;li>OpenVPN&lt;/li>
&lt;li>Redis&lt;/li>
&lt;li>dnsmasq&lt;/li>
&lt;li>cupsd&lt;/li>
&lt;li>curl (clients are supported too)&lt;/li>
&lt;/ul>
&lt;p>and several smaller applications.&lt;br>
libdesock also supports event libraries like&lt;/p>
&lt;ul>
&lt;li>libevent&lt;/li>
&lt;li>libuv&lt;/li>
&lt;li>libapr-2&lt;/li>
&lt;/ul>
&lt;p>Network applications generally are very complex and require modifications to be fuzzable with AFL.&lt;br>
They use multiple processes and threads, encryption, compression, checksums, hashes
and sometimes custom allocators that don&amp;rsquo;t work with ASAN.
They also run in an endless loop and have a lot of disk I/O (pidfiles, logfiles, temporary files).
Setting these targets up for fuzzing means to reduce the complexity of the applications.
The following example demonstrates the modifications necessary to fuzz &lt;a href="https://security.appspot.com/vsftpd.html">vsftpd&lt;/a>, a popular FTP server on Linux.&lt;/p>
&lt;h2 id="fuzzing-vsftpd">Fuzzing vsftpd&lt;/h2>
&lt;h3 id="getting-the-source">Getting the source&lt;/h3>
&lt;p>Download version 3.0.5 of vsftpd:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">wget https://security.appspot.com/downloads/vsftpd-3.0.5.tar.gz
tar -xf vsftpd-3.0.5.tar.gz
cd vsftpd-3.0.5
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="patching-the-source">Patching the source&lt;/h3>
&lt;p>vsftpd creates a new child process for each connection. We prohibit that
by commenting out the code that does the fork in &lt;code>standalone.c&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -153,6 +153,7 @@ vsf_standalone_main(void)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> child_info.num_this_ip = 0;
p_raw_addr = vsf_sysutil_sockaddr_get_raw_addr(p_accept_addr);
child_info.num_this_ip = handle_ip_count(p_raw_addr);
&lt;span style="color:#a6e22e">+ /*
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> if (tunable_isolate)
{
if (tunable_http_enable &amp;amp;&amp;amp; tunable_isolate_network)
&lt;span style="color:#75715e">@@ -168,6 +169,8 @@ vsf_standalone_main(void)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
new_child = vsf_sysutil_fork_failok();
}
&lt;span style="color:#a6e22e">+ */
&lt;/span>&lt;span style="color:#a6e22e">+ new_child = 0;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> if (new_child != 0)
{
/* Parent context */
&lt;/code>&lt;/pre>&lt;/div>&lt;p>vsftpd duplicates the FTP command socket to stdin, stdout and stderr.
This obviously interfers with AFL so we disable that in &lt;code>defs.h&lt;/code> &amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -3,7 +3,7 @@
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
#define VSFTP_DEFAULT_CONFIG &amp;#34;/etc/vsftpd.conf&amp;#34;
&lt;span style="color:#f92672">-#define VSFTP_COMMAND_FD 0
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+#define VSFTP_COMMAND_FD 29
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span>
#define VSFTP_PASSWORD_MAX 128
#define VSFTP_USERNAME_MAX 128
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip; and in &lt;code>standalone.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -205,9 +205,7 @@ static void
&lt;/span>&lt;span style="color:#75715e">&lt;/span> prepare_child(int new_client_sock)
{
/* We must satisfy the contract: command socket on fd 0, 1, 2 */
&lt;span style="color:#f92672">- vsf_sysutil_dupfd2(new_client_sock, 0);
&lt;/span>&lt;span style="color:#f92672">- vsf_sysutil_dupfd2(new_client_sock, 1);
&lt;/span>&lt;span style="color:#f92672">- vsf_sysutil_dupfd2(new_client_sock, 2);
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+ vsf_sysutil_dupfd2(new_client_sock, VSFTP_COMMAND_FD);
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> if (new_client_sock &amp;gt; 2)
{
vsf_sysutil_close(new_client_sock);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Next, vsftpd enforces a custom memory limit that interfers with ASAN.
We disable the memory limit in &lt;code>sysutil.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -2793,6 +2793,7 @@ void
&lt;/span>&lt;span style="color:#75715e">&lt;/span> vsf_sysutil_set_address_space_limit(unsigned long bytes)
{
/* Unfortunately, OpenBSD is missing RLIMIT_AS. */
&lt;span style="color:#a6e22e">+ return;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> #ifdef RLIMIT_AS
int ret;
struct rlimit rlim;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then we add a forkserver to vsftpd in &lt;code>prelogin.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -59,6 +59,7 @@ init_connection(struct vsf_session* p_sess)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
emit_greeting(p_sess);
}
&lt;span style="color:#a6e22e">+ __AFL_INIT();
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> parse_username_password(p_sess);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>vsftpd registers a &lt;code>SIGCHLD&lt;/code> handler that interfers with the forkserver
so we have to disable that too in &lt;code>standalone.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -74,7 +74,7 @@ vsf_standalone_main(void)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
vsf_sysutil_setproctitle(&amp;#34;LISTENER&amp;#34;);
}
&lt;span style="color:#f92672">- vsf_sysutil_install_sighandler(kVSFSysUtilSigCHLD, handle_sigchld, 0, 1);
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+ //vsf_sysutil_install_sighandler(kVSFSysUtilSigCHLD, handle_sigchld, 0, 1);
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> vsf_sysutil_install_sighandler(kVSFSysUtilSigHUP, handle_sighup, 0, 1);
if (tunable_listen)
{
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Last but not least we disable the &lt;code>bug()&lt;/code> function in &lt;code>utility.c&lt;/code>. This function does a failing &lt;code>fcntl()&lt;/code>
on an fd returned by the desocketing library since the fd is not a real socket. vsftpd handles the &lt;code>fcntl()&lt;/code> failure by calling &lt;code>bug()&lt;/code> again
leading to an infinite loop.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -40,6 +40,7 @@ die2(const char* p_text1, const char* p_text2)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> void
bug(const char* p_text)
{
&lt;span style="color:#a6e22e">+ return;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> /* Rats. Try and write the reason to the network for diagnostics */
vsf_sysutil_activate_noblock(VSFTP_COMMAND_FD);
(void) vsf_sysutil_write_loop(VSFTP_COMMAND_FD, &amp;#34;500 OOPS: &amp;#34;, 10);
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="build-configuration">Build configuration&lt;/h3>
&lt;p>In the &lt;code>Makefile&lt;/code> replace:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -1,16 +1,16 @@
&lt;/span>&lt;span style="color:#75715e">&lt;/span> # Makefile for systems with GNU tools
&lt;span style="color:#f92672">-CC = gcc
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+CC = afl-clang-fast
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> INSTALL = install
IFLAGS = -idirafter dummyinc
#CFLAGS = -g
&lt;span style="color:#f92672">-CFLAGS = -O2 -fPIE -fstack-protector --param=ssp-buffer-size=4 \
&lt;/span>&lt;span style="color:#f92672">- -Wall -W -Wshadow -Werror -Wformat-security \
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+CFLAGS = -fsanitize=address -g -Og -fPIE -fstack-protector \
&lt;/span>&lt;span style="color:#a6e22e">+ -Wall -W -Wshadow -Wformat-security \
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> -D_FORTIFY_SOURCE=2 \
#-pedantic -Wconversion
LIBS = `./vsf_findlibs.sh`
&lt;span style="color:#f92672">-LINK = -Wl,-s
&lt;/span>&lt;span style="color:#f92672">-LDFLAGS = -fPIE -pie -Wl,-z,relro -Wl,-z,now
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+LINK =
&lt;/span>&lt;span style="color:#a6e22e">+LDFLAGS = -fPIE -pie -Wl,-z,relro -Wl,-z,now -fsanitize=address
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span>
OBJS = main.o utility.o prelogin.o ftpcmdio.o postlogin.o privsock.o \
tunables.o ftpdataio.o secbuf.o ls.o \
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="runtime-configuration">Runtime configuration&lt;/h3>
&lt;p>Like most other servers, vsftpd needs a config file. Create
&lt;code>fuzz.conf&lt;/code> with the following contents:&lt;/p>
&lt;pre tabindex="0">&lt;code>listen=YES
seccomp_sandbox=NO
one_process_model=YES
# User management
anonymous_enable=YES
no_anon_password=YES
nopriv_user=nobody
# Permissions
connect_from_port_20=NO
run_as_launching_user=YES
listen_port=2121
listen_address=127.0.0.1
pasv_address=127.0.0.1
# Filesystem interactions
write_enable=NO
download_enable=NO
&lt;/code>&lt;/pre>&lt;h3 id="start-fuzzing">Start fuzzing&lt;/h3>
&lt;p>To use the desocketing library with AFL we need to set the &lt;code>AFL_PRELOAD&lt;/code>
variable.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">export AFL_PRELOAD&lt;span style="color:#f92672">=&lt;/span>libdesock.so
afl-fuzz -i corpus -o findings -m none -- ./vsftpd fuzz.conf
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://lolcads.github.io/2022/02/afl.svg" alt="">&lt;/p>
&lt;p>Now it&amp;rsquo;s only a matter of high-quality custom mutators and time to find some bugs.&lt;/p>
&lt;p>libdesock can be downloaded here: &lt;a href="https://github.com/fkie-cad/libdesock">https://github.com/fkie-cad/libdesock&lt;/a>&lt;/p></content></item></channel></rss>