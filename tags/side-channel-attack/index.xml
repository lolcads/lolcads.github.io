<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Side Channel Attack on lolcads tech blog</title><link>https://lolcads.github.io/tags/side-channel-attack/</link><description>Recent content in Side Channel Attack on lolcads tech blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; lolcads</copyright><lastBuildDate>Fri, 26 Jul 2024 16:46:21 +0100</lastBuildDate><atom:link href="https://lolcads.github.io/tags/side-channel-attack/index.xml" rel="self" type="application/rss+xml"/><item><title>Timing Attack Experiments against Scudo (Part 2)</title><link>https://lolcads.github.io/posts/2024/07/scudo_1/</link><pubDate>Fri, 26 Jul 2024 16:46:21 +0100</pubDate><guid>https://lolcads.github.io/posts/2024/07/scudo_1/</guid><description>Attempting Timing Attacks against Scudo In this second blog post we will take a different approach for attacking Scudo, i.e. we will try to the measure execution times for calls to malloc and hope to be able to derive a portion of the internal state of the allocator (i.e. perform side channel attacks). The version of Scudo considered in this blog post is 161cca266a9d0b6deb5f1fd2de8ad543649a7fa1.
There will be almost only negative results (which means I unfortunately could not make it work), except for one.</description><content>&lt;h1 id="attempting-timing-attacks-against-scudo">Attempting Timing Attacks against &lt;em>Scudo&lt;/em>&lt;/h1>
&lt;p>In this second blog post we will take a different approach for attacking &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/;bpv=0;bpt=0">&lt;em>Scudo&lt;/em>&lt;/a>, i.e. we will try to the measure execution times for calls to &lt;code>malloc&lt;/code> and hope to be able to derive a portion of the internal state of the allocator (i.e. perform side channel attacks). The version of Scudo considered in this blog post is &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/METADATA;l=19;drc=45e1036faa0dcfa30a01982880be1137d441333d">&lt;code>161cca266a9d0b6deb5f1fd2de8ad543649a7fa1&lt;/code>&lt;/a>.&lt;/p>
&lt;p>There will be almost only negative results (which means I unfortunately could not make it work), except for one. The main conclusion we can draw from this post is that &lt;em>Scudo&lt;/em> is &lt;strong>not&lt;/strong> designed to mitigate timing attacks! This follows from trying to leak a piece of information and then accidentally leaking a different and unclassified piece.&lt;/p>
&lt;p>&lt;strong>Disclaimer&lt;/strong>: The following analyses can be incomplete and/or incorrect. Also the experiments conducted are on a &lt;strong>very&lt;/strong> basic level compared to the complex field of &lt;em>Data Science&lt;/em>. The style of this post is informal and chosen based on the idea of practical attacks on Android.&lt;/p>
&lt;h2 id="experimental-setup">Experimental Setup&lt;/h2>
&lt;p>As usual, there is a module for the &lt;em>damnvulnerableapp&lt;/em> of the form:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">JNIEXPORT jbyteArray JNICALL
&lt;span style="color:#a6e22e">Java_com_damnvulnerableapp_vulnerable_modules_HeapSCAModule_handleMessage&lt;/span>(JNIEnv &lt;span style="color:#f92672">*&lt;/span>env,
jclass class,
jbyteArray message) {
&lt;span style="color:#66d9ef">uint32_t&lt;/span> length &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength(env, message);
&lt;span style="color:#66d9ef">if&lt;/span> (length &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> NULL;
jbyte &lt;span style="color:#f92672">*&lt;/span>raw &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements(env, message, NULL);
&lt;span style="color:#66d9ef">if&lt;/span> (raw) {
jbyteArray result &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray(env, &lt;span style="color:#ae81ff">8&lt;/span>);
&lt;span style="color:#66d9ef">switch&lt;/span> (raw[&lt;span style="color:#ae81ff">0&lt;/span>]) {
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;span style="color:#75715e">// Malloc
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>((&lt;span style="color:#66d9ef">uint64_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>raw[&lt;span style="color:#ae81ff">1&lt;/span>]);
&lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ptr;
ptr &lt;span style="color:#f92672">=&lt;/span> malloc(size);
(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion(env, result, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, (jbyte&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>ptr);
&lt;span style="color:#66d9ef">break&lt;/span>;
}
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;span style="color:#75715e">// Free
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ptr &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">uint64_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>raw[&lt;span style="color:#ae81ff">1&lt;/span>]);
free(ptr);
(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion(env, result, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, (jbyte&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>ptr);
&lt;span style="color:#66d9ef">break&lt;/span>;
}
}
&lt;span style="color:#66d9ef">return&lt;/span> result;
}
&lt;span style="color:#66d9ef">return&lt;/span> NULL;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This module lets the user directly control whether and how to call &lt;code>malloc&lt;/code> and &lt;code>free&lt;/code>, or, to be more precise, &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=292;bpv=0;bpt=0">&lt;code>Allocator::allocate&lt;/code>&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=507;bpv=0;bpt=0">&lt;code>Allocator::deallocate&lt;/code>&lt;/a>. The input is composed like this: &lt;code>&amp;lt;func id&amp;gt;&amp;lt;size | ptr&amp;gt;&lt;/code> (9 bytes).&lt;/p>
&lt;p>&lt;em>damnvulnerableapp&lt;/em> is run in an &lt;em>x86-64&lt;/em> emulator (Pixel 3) running Android 12 and forwards &lt;em>remote&lt;/em> user requests to the above module. It is already expected to see a lot of timing noise based on this setup.&lt;/p>
&lt;p>Notice that measuring execution time of a remote call to e.g. &lt;code>malloc(0x10)&lt;/code> (primary allocation) will actually measure execution time of a call to &lt;code>Java_com_damnvulnerableapp_vulnerable_modules_HeapSCAModule_handleMessage&lt;/code>, which is called from Java.&lt;/p>
&lt;p>As regards the client used to communicate with the app, it is written in &lt;em>C&lt;/em>, thus it is expected to run faster than the former &lt;em>Python&lt;/em> client. Because &lt;em>damnvulnerableapp&lt;/em> uses a request - response model, i.e. a client has to request e.g. &lt;code>malloc(0x10)&lt;/code>, gets a response that the request &amp;ldquo;worked&amp;rdquo; and then has to fetch the result with a second request, the time measurements are conducted as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">struct&lt;/span> timespec before;
&lt;span style="color:#66d9ef">struct&lt;/span> timespec after;
...
&lt;span style="color:#75715e">// Request malloc(0x10)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>app_forward(fd, (&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)message, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer, &lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer_length, &lt;span style="color:#f92672">&amp;amp;&lt;/span>before);
&lt;span style="color:#75715e">// Free response buffer
&lt;/span>&lt;span style="color:#75715e">&lt;/span>free(buffer);
&lt;span style="color:#75715e">// Request result of malloc(0x10)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>app_fetch(fd, &lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer, &lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer_length, &lt;span style="color:#f92672">&amp;amp;&lt;/span>after);
&lt;span style="color:#75715e">// Extract result from response
&lt;/span>&lt;span style="color:#75715e">&lt;/span>pointer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">uint64_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)get_content(buffer, buffer_length);
&lt;span style="color:#75715e">// Free response buffer
&lt;/span>&lt;span style="color:#75715e">&lt;/span>free(buffer);
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>app_fetch&lt;/code> and &lt;code>app_forward&lt;/code> (internally call &lt;code>app_send_formatted&lt;/code>) are the core of this client:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">enum&lt;/span> error_code &lt;span style="color:#a6e22e">app_fetch&lt;/span>(...)
{
...
result &lt;span style="color:#f92672">=&lt;/span> app_send_formatted(fd, &lt;span style="color:#e6db74">&amp;#34;CONTENT&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;FETCH&amp;#34;&lt;/span>, (&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, NULL);
&lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">!=&lt;/span> error_success) {
log_error(&lt;span style="color:#e6db74">&amp;#34;Failed to forward buffer&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> result;
}
result &lt;span style="color:#f92672">=&lt;/span> app_full_read(fd, buffer, buffer_size);
&lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">!=&lt;/span> error_success) {
log_error(&lt;span style="color:#e6db74">&amp;#34;Failed to read response to forward&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> result;
}
&lt;span style="color:#75715e">// Measure time after fetching result
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (after_receive &lt;span style="color:#f92672">!=&lt;/span> NULL)
clock_gettime(CLOCK_THREAD_CPUTIME_ID, after_receive);
...
}
&lt;span style="color:#66d9ef">enum&lt;/span> error_code &lt;span style="color:#a6e22e">app_send_formatted&lt;/span>(...)
{
...
&lt;span style="color:#75715e">// Measure time before forwarding message
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (before_send &lt;span style="color:#f92672">!=&lt;/span> NULL)
clock_gettime(CLOCK_THREAD_CPUTIME_ID, before_send);
result &lt;span style="color:#f92672">=&lt;/span> app_full_write(fd, buffer, buffer_size &lt;span style="color:#f92672">+&lt;/span> content_length);
free(buffer);
&lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">!=&lt;/span> error_success) {
log_error(&lt;span style="color:#e6db74">&amp;#34;Failed to send request&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> result;
}
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Because of the request - response model, there is additional noise introduced by being forced to make two remote requests for one e.g. &lt;code>malloc(0x10)&lt;/code>!&lt;/p>
&lt;p>Lets again summarize expected sources of noise introduced by the experimental setup:&lt;/p>
&lt;ol>
&lt;li>Android OS is emulated and therefore does not behave like an Android OS running on a &amp;ldquo;real&amp;rdquo; device (e.g. in terms of CPU power and scheduling)&lt;/li>
&lt;li>Remote access to &lt;em>damnvulnerableapp&lt;/em>. Although the emulator that runs the app is launched within the same device we will perform the measurements with, this is an additional layer of indirection.&lt;/li>
&lt;li>Call to e.g. &lt;code>malloc&lt;/code> is actually a call to &lt;code>handleMessage&lt;/code>, which has to be invoked from Java. The call stack is pretty deep&amp;hellip;&lt;/li>
&lt;li>Two requests per operation&lt;/li>
&lt;/ol>
&lt;h2 id="timing-attacks">Timing Attacks&lt;/h2>
&lt;p>In this section, timing attacks on different targets within &lt;em>Scudo&lt;/em> will be discussed.&lt;/p>
&lt;h3 id="attacking-chunks-array">Attacking Chunks Array&lt;/h3>
&lt;p>The core idea is to abuse a timing side channel on &lt;code>Allocator::allocate&lt;/code>, i.e. calling &lt;code>malloc&lt;/code> in &lt;em>damnvulnerableapp&lt;/em>. &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=69;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>C-&amp;gt;Count&lt;/code>&lt;/a> will be the target of the attack, i.e. based on the measured execution times, we try to estimate the value of &lt;code>C-&amp;gt;Count&lt;/code>.&lt;/p>
&lt;p>One may ask, why &lt;code>C-&amp;gt;Count&lt;/code> is interesting. There are two reasons:&lt;/p>
&lt;ol>
&lt;li>The chunk arrays are shuffled to, among other things, prevent an attacker from predicting where the next allocated chunk will be located. E.g. this can prevent heap overflows. Knowing &lt;code>C-&amp;gt;Count&lt;/code> looks like the first natural step to predicting how the array looks like in terms of address ordering.&lt;/li>
&lt;li>&lt;code>SizeClassAllocatorLocalCache::allocate&lt;/code> contains a classical pattern for a timing side channel:
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">allocate&lt;/span>(uptr ClassId) {
...
PerClass &lt;span style="color:#f92672">*&lt;/span>C &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>PerClassArray[ClassId];
&lt;span style="color:#66d9ef">if&lt;/span> (C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) { &lt;span style="color:#75715e">// If C-&amp;gt;Count = 0, then execution time is longer than &amp;#34;usual&amp;#34;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> ...
refill(C, ClassId);
...
}
&lt;span style="color:#75715e">// The rest is very fast
&lt;/span>&lt;span style="color:#75715e">&lt;/span> ...
CompactPtrT CompactP &lt;span style="color:#f92672">=&lt;/span> C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Chunks[&lt;span style="color:#f92672">--&lt;/span>C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count];
...
&lt;span style="color:#66d9ef">return&lt;/span> Allocator&lt;span style="color:#f92672">-&amp;gt;&lt;/span>decompactPtr(ClassId, CompactP);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>When allocating memory from the primary allocator via e.g. &lt;code>malloc(0x10)&lt;/code>, then there is a number of allocations that will result in triggering &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=69;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>C-&amp;gt;Count == 0&lt;/code>&lt;/a>, which again triggers execution of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=169;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>refill&lt;/code>&lt;/a>. Afterwards, assuming that batches are only pushed back through &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=182;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>drain&lt;/code>&lt;/a> or are newly allocated via &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=361;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>map&lt;/code>&lt;/a>, we can distinguish the following cases for &lt;code>C-&amp;gt;Count&lt;/code>:&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=183;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>C-&amp;gt;Count = C-&amp;gt;MaxCount / 2&lt;/code>&lt;/a>. This stems from the fact that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=84;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>deallocate&lt;/code>&lt;/a> can create batches if the corresponding &lt;code>Chunks&lt;/code> array is full. To be precise, this will trigger the execution of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=182;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>drain&lt;/code>&lt;/a>, where &lt;code>C-&amp;gt;Count = C-&amp;gt;MaxCount&lt;/code>. Therefore the minimum &lt;code>Count = Min(C-&amp;gt;MaxCount / 2, C-&amp;gt;Count)&lt;/code> in &lt;code>drain&lt;/code> will evaluate to &lt;code>0 &amp;lt; C-&amp;gt;MaxCount / 2 &amp;lt; C-&amp;gt;MaxCount&lt;/code>. Finally, &lt;code>C-&amp;gt;Count -= Count &amp;lt;=&amp;gt; C-&amp;gt;Count = C-&amp;gt;MaxCount - C-&amp;gt;MaxCount / 2 = C-&amp;gt;MaxCount / 2&lt;/code>. Notice that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=153;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">&lt;code>C-&amp;gt;MaxCount = 2 * TransferBatch::getMaxCached(Size)&lt;/code>&lt;/a>. As can be seen in the next step, for &lt;code>malloc(0x10)&lt;/code>, this will result in &lt;code>C-&amp;gt;MaxCount = 2 * 13 = 26 =&amp;gt; C-&amp;gt;Count = 26 / 2 = 13&lt;/code>.&lt;/li>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=396;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>C-&amp;gt;Count = MaxCount&lt;/code>&lt;/a>, i.e.:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count &lt;span style="color:#f92672">=&lt;/span> MaxCount
&lt;span style="color:#f92672">=&lt;/span> TransferBatch&lt;span style="color:#f92672">::&lt;/span>getMaxCached(Size)
&lt;span style="color:#f92672">=&lt;/span> Min(MaxNumCached, SizeClassMap&lt;span style="color:#f92672">::&lt;/span>getMaxCachedHint(Size))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(Config&lt;span style="color:#f92672">::&lt;/span>MaxNumCachedHint, N)))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, (&lt;span style="color:#ae81ff">1U&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> Config&lt;span style="color:#f92672">::&lt;/span>MaxBytesCachedLog) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>u32&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Size))))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, (&lt;span style="color:#ae81ff">1U&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> Classes[ClassId &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>])))
&lt;/code>&lt;/pre>&lt;/div>&lt;p>where &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/size_class_map.h;l=269;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Classes&lt;/code>&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">constexpr&lt;/span> u32 Classes[] &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#ae81ff">0x00020&lt;/span>, &lt;span style="color:#ae81ff">0x00030&lt;/span>, &lt;span style="color:#ae81ff">0x00040&lt;/span>, &lt;span style="color:#ae81ff">0x00050&lt;/span>, &lt;span style="color:#ae81ff">0x00060&lt;/span>, &lt;span style="color:#ae81ff">0x00070&lt;/span>, &lt;span style="color:#ae81ff">0x00080&lt;/span>, &lt;span style="color:#ae81ff">0x00090&lt;/span>,
&lt;span style="color:#ae81ff">0x000a0&lt;/span>, &lt;span style="color:#ae81ff">0x000b0&lt;/span>, &lt;span style="color:#ae81ff">0x000c0&lt;/span>, &lt;span style="color:#ae81ff">0x000e0&lt;/span>, &lt;span style="color:#ae81ff">0x000f0&lt;/span>, &lt;span style="color:#ae81ff">0x00110&lt;/span>, &lt;span style="color:#ae81ff">0x00120&lt;/span>, &lt;span style="color:#ae81ff">0x00130&lt;/span>,
&lt;span style="color:#ae81ff">0x00150&lt;/span>, &lt;span style="color:#ae81ff">0x00160&lt;/span>, &lt;span style="color:#ae81ff">0x00170&lt;/span>, &lt;span style="color:#ae81ff">0x00190&lt;/span>, &lt;span style="color:#ae81ff">0x001d0&lt;/span>, &lt;span style="color:#ae81ff">0x00210&lt;/span>, &lt;span style="color:#ae81ff">0x00240&lt;/span>, &lt;span style="color:#ae81ff">0x002a0&lt;/span>,
&lt;span style="color:#ae81ff">0x00330&lt;/span>, &lt;span style="color:#ae81ff">0x00370&lt;/span>, &lt;span style="color:#ae81ff">0x003a0&lt;/span>, &lt;span style="color:#ae81ff">0x00400&lt;/span>, &lt;span style="color:#ae81ff">0x00430&lt;/span>, &lt;span style="color:#ae81ff">0x004a0&lt;/span>, &lt;span style="color:#ae81ff">0x00530&lt;/span>, &lt;span style="color:#ae81ff">0x00610&lt;/span>,
&lt;span style="color:#ae81ff">0x00730&lt;/span>, &lt;span style="color:#ae81ff">0x00840&lt;/span>, &lt;span style="color:#ae81ff">0x00910&lt;/span>, &lt;span style="color:#ae81ff">0x009c0&lt;/span>, &lt;span style="color:#ae81ff">0x00a60&lt;/span>, &lt;span style="color:#ae81ff">0x00b10&lt;/span>, &lt;span style="color:#ae81ff">0x00ca0&lt;/span>, &lt;span style="color:#ae81ff">0x00e00&lt;/span>,
&lt;span style="color:#ae81ff">0x00fb0&lt;/span>, &lt;span style="color:#ae81ff">0x01030&lt;/span>, &lt;span style="color:#ae81ff">0x01130&lt;/span>, &lt;span style="color:#ae81ff">0x011f0&lt;/span>, &lt;span style="color:#ae81ff">0x01490&lt;/span>, &lt;span style="color:#ae81ff">0x01650&lt;/span>, &lt;span style="color:#ae81ff">0x01930&lt;/span>, &lt;span style="color:#ae81ff">0x02010&lt;/span>,
&lt;span style="color:#ae81ff">0x02190&lt;/span>, &lt;span style="color:#ae81ff">0x02490&lt;/span>, &lt;span style="color:#ae81ff">0x02850&lt;/span>, &lt;span style="color:#ae81ff">0x02d50&lt;/span>, &lt;span style="color:#ae81ff">0x03010&lt;/span>, &lt;span style="color:#ae81ff">0x03210&lt;/span>, &lt;span style="color:#ae81ff">0x03c90&lt;/span>, &lt;span style="color:#ae81ff">0x04090&lt;/span>,
&lt;span style="color:#ae81ff">0x04510&lt;/span>, &lt;span style="color:#ae81ff">0x04810&lt;/span>, &lt;span style="color:#ae81ff">0x05c10&lt;/span>, &lt;span style="color:#ae81ff">0x06f10&lt;/span>, &lt;span style="color:#ae81ff">0x07310&lt;/span>, &lt;span style="color:#ae81ff">0x08010&lt;/span>, &lt;span style="color:#ae81ff">0x0c010&lt;/span>, &lt;span style="color:#ae81ff">0x10010&lt;/span>,
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So for a small allocation, i.e. for &lt;code>ClassId = 1&lt;/code>, we get:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count &lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, &lt;span style="color:#ae81ff">0x2000&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>)))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, &lt;span style="color:#ae81ff">256&lt;/span>)))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, &lt;span style="color:#ae81ff">13&lt;/span>))
&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Notice that &lt;code>C-&amp;gt;Count = MaxCount&lt;/code> is true for all batches added to &lt;code>FreeList&lt;/code> except for the last one, because &lt;code>N&lt;/code> depends on a minimum:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">for&lt;/span> (u32 I &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; I &lt;span style="color:#f92672">&amp;lt;&lt;/span> NumberOfBlocks;) {
TransferBatch &lt;span style="color:#f92672">*&lt;/span>B &lt;span style="color:#f92672">=&lt;/span>
C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>createBatch(ClassId, &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&amp;gt;&lt;/span>(decompactPtrInternal(
CompactPtrBase, ShuffleArray[I])));
&lt;span style="color:#66d9ef">if&lt;/span> (UNLIKELY(&lt;span style="color:#f92672">!&lt;/span>B))
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;span style="color:#66d9ef">const&lt;/span> u32 N &lt;span style="color:#f92672">=&lt;/span> Min(MaxCount, NumberOfBlocks &lt;span style="color:#f92672">-&lt;/span> I); &lt;span style="color:#75715e">// If (NumberOfBlocks - I &amp;lt; MaxCount) =&amp;gt; last iteration
&lt;/span>&lt;span style="color:#75715e">&lt;/span> B&lt;span style="color:#f92672">-&amp;gt;&lt;/span>setFromArray(&lt;span style="color:#f92672">&amp;amp;&lt;/span>ShuffleArray[I], N);
Region&lt;span style="color:#f92672">-&amp;gt;&lt;/span>FreeList.push_back(B);
I &lt;span style="color:#f92672">+=&lt;/span> N;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="single---threaded-timing---based-side-channel-attack-on-primary">Single - Threaded Timing - Based Side Channel Attack on Primary&lt;/h4>
&lt;p>Assuming that the only thread that accesses the &lt;em>Scudo&lt;/em> primary for allocations of the form &lt;code>malloc(0x10)&lt;/code> can be convinced to run this allocation with a constant, computable overhead. Then, the following attack might enable the prediction of &lt;code>C-&amp;gt;Count&lt;/code> based on measures of elapsed time:&lt;/p>
&lt;ol>
&lt;li>In iteration &lt;code>j&lt;/code> perform 13 allocations (assuming classid 1 allocations, i.e. &lt;code>malloc(0x10)&lt;/code>). For each allocation let &lt;code>x_{i,j}&lt;/code> be the measured execution time (so &lt;code>0 &amp;lt;= i &amp;lt;= 12&lt;/code>).&lt;/li>
&lt;li>Add &lt;code>x_{i,j}&lt;/code> to the list &lt;code>X_i&lt;/code>.&lt;/li>
&lt;li>After &lt;code>0 &amp;lt;= j &amp;lt; num_iterations&lt;/code> 13 - chunk allocations, compute the average over each list. Let &lt;code>x_i'&lt;/code> be the average of &lt;code>X_i&lt;/code>&lt;/li>
&lt;li>Let &lt;code>k := argmax_{0&amp;lt;=i&amp;lt;=12} x_i'&lt;/code>&lt;/li>
&lt;li>Return &lt;code>k&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>Consider the following visualization:
&lt;img src="https://lolcads.github.io/2024/07/scudo_1_single_threaded_expectation_attack.png" alt="Single Threaded Expectation Attack">&lt;/p>
&lt;p>From the diagram we can see that &lt;code>C-&amp;gt;Count = 4&lt;/code>. Now, if we start measuring the execution times, i.e. we get &lt;code>x_{0,0}&lt;/code> for &lt;code>C-&amp;gt;Count = 4&lt;/code>, &lt;code>x_{1,0}&lt;/code> for &lt;code>C-&amp;gt;Count = 3&lt;/code> etc. we can see that for &lt;code>C-&amp;gt;Count = 0&lt;/code> &lt;code>x_{4,0}&lt;/code> is the biggest value. Therefore, right after &lt;code>allocate&lt;/code> returns, the result &lt;code>k = 4&lt;/code> of the above attack corresponds to the index of the biggest value &lt;code>x_{4,0}&lt;/code>. Note that the second index is used to perform the 13 allocations multiple times in order to cancel out noise using the mean. Also, assuming that each call to &lt;code>malloc&lt;/code> via &lt;a href="#experimental-setup">&lt;code>handleMessage&lt;/code>&lt;/a> is only triggering this very &lt;code>malloc&lt;/code>, i.e. there is no other call to &lt;code>malloc&lt;/code> that influences &lt;code>C-&amp;gt;Count&lt;/code>, after the attack &lt;code>C-&amp;gt;Count&lt;/code> takes the same value it had before performing the attack (because &lt;code>C-&amp;gt;Count&lt;/code> is in mod 13 and we run &lt;code>13 * num_iterations&lt;/code> allocations, which is divisible by 13).&lt;/p>
&lt;p>Before the above attack, it may be beneficial to run a few allocations to ensure that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=333;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">&lt;code>populateFreeList&lt;/code>&lt;/a> is called. This will result in &lt;a href="#attacking-chunks-array">&lt;code>13&lt;/code>&lt;/a> chunks being available in &lt;code>C-&amp;gt;Chunks&lt;/code> and thus &lt;code>C-&amp;gt;Count = 13&lt;/code> right after &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=74;bpv=0;bpt=1">&lt;code>refill&lt;/code>&lt;/a> and &lt;code>C-&amp;gt;Count = 12&lt;/code> right after &lt;code>allocate&lt;/code> returns.&lt;/p>
&lt;p>The main problem is that the assumptions are too strong for this attack to work on a real - world app. I.e. there are multiple threads that run &lt;code>malloc(0x10)&lt;/code>. Therefore, the timings measured from the perspective of a single thread may be influenced by the following:&lt;/p>
&lt;ol>
&lt;li>Thread synchronization in &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=356;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Allocator::allocate&lt;/code>&lt;/a>. I.e. if there is another thread currently allocating memory via the primary, then our thread is forced to wait until the critical section is unlocked.&lt;/li>
&lt;li>Between two calls to &lt;code>malloc(0x10)&lt;/code>, there may be an arbitrary amount of threads that run &lt;code>malloc(0x10)&lt;/code> due to scheduling. Therefore, the above attack, which assumes to be able to run 13 consecutive allocations in a row, is unlikely to work. This basically poisons the averages, which makes all of them look almost the same!&lt;/li>
&lt;li>Remote call to &lt;code>malloc&lt;/code> can trigger multiple allocations! Therefore, one measurement might decrease &lt;code>C-&amp;gt;Count&lt;/code> by two or more instead of one.&lt;/li>
&lt;/ol>
&lt;h4 id="multithreaded-timing---based-side-channel-attacks-on-primary">Multithreaded Timing - Based Side Channel Attacks on Primary&lt;/h4>
&lt;p>This section describes different approaches that aim to predict &lt;code>C-&amp;gt;Count&lt;/code> based on measured timings in a multithreaded environment.&lt;/p>
&lt;h5 id="learn-distribution-from-leaked-counts">Learn Distribution from Leaked Counts&lt;/h5>
&lt;p>Let &lt;code>c_i&lt;/code> for &lt;code>0 &amp;lt;= i &amp;lt; n&lt;/code> be the leaked values for &lt;code>C-&amp;gt;Count&lt;/code> from one thread (with fixed TSD) right before each &lt;code>malloc(0x10)&lt;/code>. Notice that due to multithreading, this leaked value might differ from the value that is used in the following &lt;code>malloc&lt;/code> call. We assume that the probability for this is negligible though.&lt;/p>
&lt;p>Then compute for &lt;code>0 &amp;lt;= i &amp;lt; n-1&lt;/code> the difference of the &lt;code>C-&amp;gt;Count&lt;/code> values, i.e. &lt;code>d_i = -(c_{i+1} - c_{i}) mod 13&lt;/code>. With high probability, the &lt;code>d_i&lt;/code> represent the amount of &lt;code>malloc(0x10)&lt;/code> calls performed by other threads between each pair of &lt;code>malloc(0x10)&lt;/code> calls performed by our thread. Remember that the &lt;code>c_i&lt;/code> are leaked from our main thread.&lt;/p>
&lt;p>Construct the probability distribution according to the frequencies of the &lt;code>d_i&lt;/code> values. It is expected to be binomially distributed. Then, apply those probabilities to the timings. I.e. between each consecutive pair of time measurements &lt;code>x_i&lt;/code> and &lt;code>x_{i+1}&lt;/code> there is a random variable &lt;code>D_i&lt;/code> distributed according to the above distribution.&lt;/p>
&lt;p>Assuming we have a sequence of values for &lt;code>C-&amp;gt;Count&lt;/code> that is unknown, then every element in this unknown sequence can be represented as a random variable. To be precise, letting &lt;code>C_i&lt;/code> be the random variables representing the &lt;code>C-&amp;gt;Count&lt;/code> before the i-th &lt;code>malloc(0x10)&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>C_{i+1} = C_i + D_i = C_i + D // for all i: D_i are iid., so D~freq{d_i} is enough
&lt;/code>&lt;/pre>&lt;p>Assuming that there is an anchor point, i.e. there exists a constant value &lt;code>0 &amp;lt;= C_0 &amp;lt; 13&lt;/code> that is the first value for &lt;code>C-&amp;gt;Count&lt;/code>, then&lt;/p>
&lt;pre tabindex="0">&lt;code>C_{i+1} = C_i + D = (((C_0 + D) + D) + ... ) + D = C_0 + (i + 1) * D
=&amp;gt; E[C_{i+1}] = C_0 + (i+1) * E[D] = C_0 + (i+1) * (1/(n-1) * sum(d_i))
&lt;/code>&lt;/pre>&lt;p>Given a sequence of timings &lt;code>x_i&lt;/code> for &lt;code>0 &amp;lt;= i &amp;lt; m&lt;/code> measured by calling &lt;code>malloc(0x10)&lt;/code>, we could try to identify an anchor point, i.e. a point where &lt;code>refill&lt;/code> was triggered by e.g. taking &lt;code>max(x_i)&lt;/code>. If we get &lt;code>x_k = max(x_i)&lt;/code>, then we performed &lt;code>k + 1&lt;/code> allocations in order to get to this maximum value. Therefore, we could try to compute &lt;code>E[C_k]&lt;/code> to get the expected value for &lt;code>C-&amp;gt;Count&lt;/code>, which is based on the above formula.&lt;/p>
&lt;p>Unfortunately, there are some problems with this approach:&lt;/p>
&lt;ol>
&lt;li>Does not take into account that other threads still run &lt;code>malloc(0x10)&lt;/code> in the background. Although this approach &lt;em>might&lt;/em> work for computing the most probable value for &lt;code>C-&amp;gt;Count&lt;/code>, it would be invalidated the moment another thread called &lt;code>malloc(0x10)&lt;/code>.&lt;/li>
&lt;li>Probabilistic approach&amp;hellip;in practice, this will most likely not be that much better than just guessing the value, because there are only so few possible values &lt;code>C-&amp;gt;Count&lt;/code> can take.&lt;/li>
&lt;/ol>
&lt;h5 id="learn-thresholds">Learn Thresholds&lt;/h5>
&lt;p>Another approach is to learn thresholds that distinguish a &amp;ldquo;refill - timing&amp;rdquo; from any other timing. Thus we will try to &amp;ldquo;learn&amp;rdquo; a threshold that allows for separating timings into either &amp;ldquo;refill&amp;rdquo; or &amp;ldquo;non - refill&amp;rdquo;. Although this approach might be too &amp;ldquo;simple&amp;rdquo;, because the problem can also be interpreted as distinguishing at least two guassian distributions, we can give it a try.&lt;/p>
&lt;p>Initially, every thread is assigned to a &lt;code>TSD&lt;/code> (linked to a cache, i.e. the &lt;code>Chunks&lt;/code> array used in e.g. &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=0;l=66">&lt;code>allocate&lt;/code>&lt;/a>, which is based on the primary) in a &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/tsd_shared.h;l=157;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">round - robin fashion&lt;/a>. As experience showed that the app often has at least 20 threads, and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/tsd_shared.h;l=33;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>NumberOfTSDs&lt;/code>&lt;/a> is either &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/allocator_config.h;l=109">&lt;code>DefaultTSDCount = 2&lt;/code>&lt;/a> or &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/linux.cpp;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=137">&lt;code>getNumberOfCPUs&lt;/code>&lt;/a>, which on the test system can at most be &lt;code>8&lt;/code>, we can conclude that there are multiple threads referencing the same TSD. This is still better than having &lt;strong>all&lt;/strong> threads sharing a single TSD!&lt;/p>
&lt;p>As the UAF module (see previous posts on &lt;em>Use - After - Free&lt;/em>) suggests that the current &lt;code>TSD&lt;/code> of the JNI thread &amp;ldquo;rarely&amp;rdquo; changes (due to exploitation of the UAF module working almost always), in the following we will assume that we use the same TSD. We will also assume that there either is no other thread that references the current &lt;code>TSD&lt;/code> or is at least one such thread, but this thread does not allocate often from the primary with classid 1.&lt;/p>
&lt;p>Performing only primary allocations of size &lt;code>0x10&lt;/code>, i.e. repeatedly calling a JNI function that calls &lt;code>malloc(0x10)&lt;/code>, results in the following plot:
&lt;img src="https://lolcads.github.io/2024/07/scudo_1_primary_alloc_only_4000_1.png" alt="Primary Allocations(only) in form of malloc(0x10)">&lt;/p>
&lt;p>Further analysis of this plot reveals the following issues:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>There might exist 3 distinct distributions. I.e. it is possible to almost reliably (i.e. with high probability (whp)) differentiate between three different kinds of timings. This suggests that the types of timings are:&lt;/p>
&lt;ol>
&lt;li>&lt;code>refill&lt;/code> is called. Expected to be linked to the distribution with the highest mean.
&lt;ol>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=102;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>popBatch&lt;/code>&lt;/a> has a batch in the free list&lt;/li>
&lt;li>&lt;code>popBatch&lt;/code> has to call &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=333">&lt;code>populateFreeList&lt;/code>&lt;/a> &amp;ndash;&amp;gt; expected to take &lt;strong>a lot of time&lt;/strong>.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;code>getTSDAndLock&lt;/code> takes longer, i.e. synchronization blocks execution.&lt;/li>
&lt;li>&lt;code>allocate&lt;/code> instantly returns a chunk.&lt;/li>
&lt;/ol>
&lt;p>Notice that currently, there is &lt;strong>NO CERTAIN MAPPING&lt;/strong> between the first two types of timings and the two distributions with the highest means. However, whp. the distribution with the lowest mean is linked to the event that &lt;code>allocate&lt;/code> instantly returns a chunk.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Assuming the distribution with the smallest mean is linked to the event that &lt;code>allocate&lt;/code> instantly returns a chunk and that at least one distribution is caused by multithreading, then with probability at least &lt;code>min(1394 / 4000, 1787 / 4000) = min(0.3485, 0.44675)&lt;/code> the TSD is shared with another thread.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Another &amp;ldquo;distortion&amp;rdquo; that could appear, but is very improbable, is that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=505;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>crc32&lt;/code>&lt;/a> calculation takes &lt;strong>very&lt;/strong> long for specific values. As this has been empirically tested, this can be ruled out for now (I searched for values, which cause long execution times in the &lt;code>crc32&lt;/code> instruction&amp;hellip; without success).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Calling JNI functions can non - deterministically cause longer execution times e.g. by calling &lt;code>malloc&lt;/code> internally.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>If the amount of points in the two distributions with the highest means are proportional to the total amount of points, then this rules out the possibility that the free list is filled with a lot of batches initially, because there can only be a constant amount of batches initially stored in the free list. Therefore, increasing the amount of allocations will reveal whether the amount of points in both distributions grows with the amount of allocations.&lt;/p>
&lt;p>Also, notice that our thread will permanently allocate memory via &lt;code>malloc(0x10)&lt;/code>. If there was another thread that freed memory using &lt;code>free&lt;/code> on previously allocated classid - 1 chunks (assuming no memory leaks), then this cannot create a new batch, i.e. result in &lt;code>drain&lt;/code> and therefore &lt;code>pushBatch&lt;/code> being called, because our thread will not call &lt;code>free&lt;/code> at all (of course there might be implicit calls to &lt;code>free&lt;/code>, but they would not be part of &lt;em>Scudo&lt;/em>). In addition to that, as Java threads have a 1 - 1 mapping with user - level threads (&lt;code>pthread_create&lt;/code>), there cannot be multiple threads running &lt;code>handleMessage&lt;/code>.&lt;/p>
&lt;p>Interestingly, it turns out that one call to the JNI function may cause multiple internal &lt;code>malloc&lt;/code> calls from the same or a TSD - sharing thread. E.g., if each remote &lt;code>malloc&lt;/code> resulted in two malloc calls, i.e. one internal call and the call we requested, then, assuming &lt;code>C-&amp;gt;Count &amp;lt; 13&lt;/code>, there will be six fast calls and one slow call. The timings used for analysis so far may contain multiple &lt;code>malloc&lt;/code> calls, which explains the existence of three distributions. Two of those three distributions are actually the same only with shifted means, one contains the timings with only one &lt;code>malloc&lt;/code>, the other one with two calls to &lt;code>malloc&lt;/code>. This is due to the fact that &lt;code>handleMessage&lt;/code> seems to call &lt;code>malloc&lt;/code> at most twice, but at least once. Therefore, the distributions with the smallest and biggest means seem to represent one &lt;code>malloc&lt;/code> and two mallocs without refill respectively, whereas the &amp;ldquo;middle&amp;rdquo; distribution seems to represent a single allocation with refill&amp;hellip;although this does not really make sense, because there would have to be a lot of refills&amp;hellip;&lt;/p>
&lt;p>In order to prove that synchronization is an issue and that one call to &lt;code>handleMessage&lt;/code> can cause two &lt;code>malloc&lt;/code> calls, consider the following analysis (performed via gdb):&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;Index of handleMessage call&amp;gt;(length = &amp;lt;amount cache allocations per handleMessage&amp;gt;):
&amp;lt;Thread ID&amp;gt;: count=&amp;lt;C-&amp;gt;Count value&amp;gt;, id=&amp;lt;Class ID&amp;gt;
0(length = 0):
1(length = 1):
20: count=0xb, id=0x00000020
2(length = 2):
20: count=0xa, id=0x00000020
20: count=0x9, id=0x00000020
3(length = 1):
20: count=0x8, id=0x00000020
4(length = 2):
20: count=0x7, id=0x00000020
20: count=0x6, id=0x00000020
5(length = 0):
6(length = 0):
7(length = 2):
20: count=0x5, id=0x00000020
20: count=0x4, id=0x00000020
8(length = 2):
20: count=0x3, id=0x00000020
20: count=0x2, id=0x00000020
9(length = 1):
20: count=0x1, id=0x00000020
10(length = 1):
20: count=0x0, id=0x00000020
11(length = 1):
20: count=0xc, id=0x00000020
12(length = 1):
20: count=0xb, id=0x00000020
13(length = 0):
14(length = 2):
20: count=0xa, id=0x00000020
20: count=0x9, id=0x00000020
15(length = 0):
16(length = 0):
17(length = 1):
20: count=0x8, id=0x00000020
18(length = 1):
20: count=0x7, id=0x00000020
19(length = 0):
20(length = 2):
20: count=0x6, id=0x00000020
20: count=0x5, id=0x00000020
21(length = 1):
20: count=0x4, id=0x00000020
22(length = 1):
20: count=0x3, id=0x00000020
23(length = 0):
24(length = 1):
20: count=0x2, id=0x00000020
25(length = 1):
20: count=0x1, id=0x00000020
26(length = 0):
27(length = 2):
20: count=0x0, id=0x00000020
20: count=0xc, id=0x00000020
28(length = 1):
20: count=0xb, id=0x00000020
29(length = 1):
20: count=0xa, id=0x00000020
30(length = 0):
31(length = 0):
32(length = 2):
20: count=0x9, id=0x00000020
20: count=0x8, id=0x00000020
33(length = 1):
20: count=0x7, id=0x00000020
34(length = 1):
20: count=0x6, id=0x00000020
35(length = 3):
20: count=0x5, id=0x00000020
5: count=0x5, id=0x00000020
20: count=0x4, id=0x00000020
36(length = 2):
20: count=0x3, id=0x00000020
20: count=0x2, id=0x00000020
37(length = 2):
20: count=0x1, id=0x00000020
20: count=0x0, id=0x00000020
38(length = 2):
20: count=0xc, id=0x00000020
20: count=0xb, id=0x00000020
39(length = 2):
20: count=0xa, id=0x00000020
20: count=0x9, id=0x00000020
40(length = 0):
41(length = 0):
42(length = 1):
20: count=0x8, id=0x00000020
43(length = 1):
20: count=0x7, id=0x00000020
44(length = 2):
20: count=0x6, id=0x00000020
20: count=0x5, id=0x00000020
45(length = 0):
46(length = 0):
47(length = 1):
20: count=0x4, id=0x00000020
48(length = 0):
49(length = 1):
20: count=0x3, id=0x00000020
50(length = 1):
20: count=0x2, id=0x00000020
51(length = 1):
20: count=0x1, id=0x00000020
52(length = 2):
20: count=0x0, id=0x00000020
20: count=0xc, id=0x00000020
53(length = 0):
54(length = 0):
55(length = 0):
56(length = 1):
20: count=0xb, id=0x00000020
57(length = 1):
20: count=0xa, id=0x00000020
58(length = 1):
20: count=0x9, id=0x00000020
59(length = 2):
20: count=0x8, id=0x00000020
20: count=0x7, id=0x00000020
60(length = 0):
61(length = 2):
20: count=0x6, id=0x00000020
20: count=0x5, id=0x00000020
62(length = 0):
63(length = 0):
64(length = 0):
65(length = 0):
66(length = 1):
20: count=0x4, id=0x00000020
67(length = 1):
20: count=0x3, id=0x00000020
68(length = 1):
20: count=0x2, id=0x00000020
69(length = 0):
70(length = 1):
20: count=0x1, id=0x00000020
71(length = 0):
72(length = 1):
20: count=0x0, id=0x00000020
73(length = 1):
20: count=0xc, id=0x00000020
74(length = 1):
20: count=0xb, id=0x00000020
75(length = 1):
20: count=0xa, id=0x00000020
76(length = 2):
20: count=0x9, id=0x00000020
20: count=0x8, id=0x00000020
77(length = 2):
20: count=0x7, id=0x00000020
20: count=0x6, id=0x00000020
78(length = 8):
5: count=0x5, id=0x00000020
5: count=0x4, id=0x00000020
5: count=0x3, id=0x00000020
5: count=0x2, id=0x00000020
5: count=0x2, id=0x00000020
5: count=0x2, id=0x00000020
5: count=0x2, id=0x00000020
20: count=0x4, id=0x00000020
79(length = 3):
5: count=0x4, id=0x00000020
20: count=0x4, id=0x00000020
20: count=0x3, id=0x00000020
80(length = 1):
20: count=0x2, id=0x00000020
81(length = 2):
20: count=0x1, id=0x00000020
20: count=0x0, id=0x00000020
82(length = 1):
20: count=0xc, id=0x00000020
83(length = 2):
20: count=0xb, id=0x00000020
20: count=0xa, id=0x00000020
84(length = 2):
20: count=0x9, id=0x00000020
20: count=0x8, id=0x00000020
85(length = 0):
86(length = 2):
20: count=0x7, id=0x00000020
20: count=0x6, id=0x00000020
87(length = 1):
20: count=0x5, id=0x00000020
88(length = 1):
20: count=0x4, id=0x00000020
89(length = 1):
20: count=0x3, id=0x00000020
90(length = 1):
20: count=0x2, id=0x00000020
91(length = 0):
92(length = 0):
93(length = 1):
20: count=0x1, id=0x00000020
94(length = 2):
20: count=0x0, id=0x00000020
20: count=0xc, id=0x00000020
95(length = 2):
20: count=0xb, id=0x00000020
20: count=0xa, id=0x00000020
96(length = 0):
97(length = 1):
20: count=0x9, id=0x00000020
&lt;/code>&lt;/pre>&lt;p>Thread 20 is the main thread calling &lt;code>handleMessage&lt;/code>. Its allocations are interleaved with allocations from thread 5. Notice that there are &lt;strong>no&lt;/strong> inconsistencies in the above measurement, although it seems impossible for count to stay the same. This is due to thread 5 calling &lt;code>free&lt;/code> in between calls to &lt;code>malloc&lt;/code>.&lt;/p>
&lt;p>Therefore, there is at least one other thread sharing the same TSD as our thread. As execution in &lt;code>gdb&lt;/code> is &amp;ldquo;weird&amp;rdquo; sometimes, it can be assumed that multi - threading is even worse if no debugger is present. Overall, with at least one other thread interleaving and with uncertainty whether one call to &lt;code>handleMessage&lt;/code> results in one or two calls to &lt;code>malloc&lt;/code>, there seems to be no clear path to derive the actual value for &lt;code>C-&amp;gt;Count&lt;/code>.&lt;/p>
&lt;h5 id="analysing-accurate-measurements">Analysing Accurate Measurements&lt;/h5>
&lt;p>Performing timing analysis on the actual device, i.e. in the form of&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">clock_gettime(CLOCK_THREAD_CPUTIME_ID, &lt;span style="color:#f92672">&amp;amp;&lt;/span>before);
ptr &lt;span style="color:#f92672">=&lt;/span> malloc(size);
clock_gettime(CLOCK_THREAD_CPUTIME_ID, &lt;span style="color:#f92672">&amp;amp;&lt;/span>after);
elapsed &lt;span style="color:#f92672">=&lt;/span> (after.tv_sec &lt;span style="color:#f92672">*&lt;/span> NS_PER_SECOND &lt;span style="color:#f92672">+&lt;/span> after.tv_nsec) &lt;span style="color:#f92672">-&lt;/span> (before.tv_sec &lt;span style="color:#f92672">*&lt;/span> NS_PER_SECOND &lt;span style="color:#f92672">+&lt;/span> before.tv_nsec);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>reveals an interesting and quite natural result:
&lt;img src="https://lolcads.github.io/2024/07/scudo_1_primary_alloc_local_3316.png" alt="Time Measurements performed locally on the emulator">&lt;/p>
&lt;p>Mapping three distributions to the same set of measurements yields:
&lt;img src="https://lolcads.github.io/2024/07/scudo_1_primary_alloc_local_3316_3_dist.png" alt="Time Measurements performed locally on the emulator (3 distributions)">.&lt;/p>
&lt;p>Notice that these measurements are stripped off multiple layers of noise:&lt;/p>
&lt;ol>
&lt;li>Noise introduced by remote communication&lt;/li>
&lt;li>Noise introduced by an arbitrary amount of function calls required for e.g. setting up a JNI call.&lt;/li>
&lt;li>Some synchronization of threads. Notice that measuring the elapsed time for &lt;code>malloc(0x10)&lt;/code> directly requires no further data fetching and therefore less threads are involved&amp;hellip;&lt;/li>
&lt;/ol>
&lt;h3 id="attacking-secondary-cache">Attacking Secondary Cache&lt;/h3>
&lt;p>Naturally, we could also try to attack &lt;strong>the&lt;/strong> secondary cache via a timing attack. As with classical cache - based side channel attacks, we would expect:&lt;/p>
&lt;ol>
&lt;li>fast execution time, if entry is in cache, i.e. &lt;em>cache hit&lt;/em>&lt;/li>
&lt;li>slow execution time, if entry is &lt;strong>not&lt;/strong> in cache, i.e. &lt;em>cache miss&lt;/em>&lt;/li>
&lt;/ol>
&lt;p>Unfortunately, my experiments have been shut down by the fact that &lt;strong>there is only one secondary for all threads&lt;/strong>. From experience, &lt;em>damnvulnerableapp:VulnerableActivity&lt;/em> uses at least 20 threads. The experiment consisted of two events, i.e. &lt;em>cache hit&lt;/em> and &lt;em>cache miss&lt;/em>:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;em>cache hit&lt;/em>:&lt;/p>
&lt;p>For the experiment, we repeat n times:&lt;/p>
&lt;ol>
&lt;li>Allocate chunk via secondary&lt;/li>
&lt;li>Free chunk&lt;/li>
&lt;li>Measure time required in 1.&lt;/li>
&lt;/ol>
&lt;p>From the second iteration onwards, assuming no other threads steals the freed chunk from the cache, allocations are assumed to be fast. Statistics are taken over 400 measurements (repeated three times):&lt;/p>
&lt;ol>
&lt;li>avg = 351142.4975, var = 6215682405.529994, standard dev = 78839.59922228166; Without first: avg = 350635.6090225564, var = 6128486185.496259, standard dev = 78284.64846632614`&lt;/li>
&lt;li>avg = 293603.4925, var = 9048178621.879944, standard dev = 95121.91451963078; Without first entry: 292885.1203007519, 8864432314.622118, 94151.11425056061&lt;/li>
&lt;li>avg = 343784.9075, var = 8457856232.698944, standard dev = 91966.60389890966; Without first entry: 343308.24812030076, 8388172201.665255, 91586.96523886603&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>&lt;em>cache miss&lt;/em>:&lt;/p>
&lt;p>For the experiment, we repeat n times:&lt;/p>
&lt;ol>
&lt;li>Allocate chunk via secondary&lt;/li>
&lt;li>Measure time required in 1.&lt;/li>
&lt;/ol>
&lt;p>In the worst case, the first 32 allocations are covered by cache entries. Assuming that no other thread frees a lot of memory that results in chunks, which cover our requests, we end up with the following results (over 400 measurements, repeated twice):&lt;/p>
&lt;ol>
&lt;li>avg = 353609.1975, var = 7648425849.838493, standard dev = 87455.27914219069; Without first 32 entries: 354754.0652173913, 7595866298.691399, 87154.26724315567&lt;/li>
&lt;li>avg = 320303.5725, var = 7655033941.299744, standard dev = 87493.05081719201; Without first 32 entries: 320182.16576086957, 7793835282.176328, 88282.70092252687&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>As can be seen from the repeated experiments, there seems to be no clear way for distinguishing secondary cache hits and misses. This might be due to the fact that there are roughly 20 threads sharing the same 32 cache entries! If we knew the distribution behind some random variable &lt;code>X&lt;/code> that represents the amount of secondary &lt;code>allocate&lt;/code> calls done in between two allocations performed by our thread, then we might be able to derive a probability distribution on the measured timings and maybe derive the most probable outcome, i.e. either cache hit or miss. But this seems like a rabbit hole, i.e. it does not seem to help in exploiting &lt;em>Scudo&lt;/em>.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>So, what is the result of the above &amp;ldquo;attacks&amp;rdquo; that do not really achieve anything&amp;hellip; Well, I argue that we actually achieved something without knowing that we achieved it, i.e. we can identify whether there are sometimes one and sometimes two calls to &lt;code>malloc&lt;/code> when running &lt;code>handleMessage&lt;/code>.&lt;/p>
&lt;p>Recall the visualization of the measurements:
&lt;img src="https://lolcads.github.io/2024/07/scudo_1_primary_alloc_only_4000_1.png" alt="Primary Allocations(only) in form of malloc(0x10)">&lt;/p>
&lt;p>Of course, the above diagram is composed of measuring only 4000 execution times. Still, we can tell whether a new time measurement belongs to either the red or the blue distribution with high probability, if the assumption is correct that the red and blue distributions represent one and two calls to &lt;code>malloc&lt;/code>, respectively! Adding to the pile, being able to distinguish time measurements like shown in the diagram suggests that there is some underlying information to be extracted. Notice that the distributions shown in the diagram come from time measurements taken over a JNI call and not a &lt;code>malloc&lt;/code> call directly!&lt;/p>
&lt;p>As can be seen from the measurements taken &lt;a href="#analysing-accurate-measurements">locally&lt;/a>, &lt;em>Scudo&lt;/em> leaks information through execution times and thus is not designed to mitigate timing attacks. Further analyses are required to apply and evaluate the whole potential of side channel attacks on &lt;em>Scudo&lt;/em>.&lt;/p>
&lt;p>Unfortunately, I am neither a data scientist nor an expert in statistics or side channel attacks. Hence, the analyses conducted in this blog post are very basic and, again, might be incorrect and/or incomplete.&lt;/p>
&lt;p>Therefore, attacking &lt;em>Scudo&lt;/em> in terms of timing attacks has to be postponed until a corresponding expert joins the game.&lt;/p></content></item></channel></rss>