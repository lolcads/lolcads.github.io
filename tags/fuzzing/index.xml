<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Fuzzing on lolcads tech blog</title><link>https://lolcads.github.io/tags/fuzzing/</link><description>Recent content in Fuzzing on lolcads tech blog</description><generator>Hugo</generator><language>en</language><managingEditor>lolcads@posteo.net (lolcads)</managingEditor><webMaster>lolcads@posteo.net (lolcads)</webMaster><copyright>lolcads</copyright><lastBuildDate>Wed, 21 May 2025 18:32:12 +0200</lastBuildDate><atom:link href="https://lolcads.github.io/tags/fuzzing/index.xml" rel="self" type="application/rss+xml"/><item><title>How to build a high-performance network fuzzer with LibAFL and libdesock</title><link>https://lolcads.github.io/posts/2025/05/high_performance_network_fuzzing/</link><pubDate>Wed, 21 May 2025 18:32:12 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2025/05/high_performance_network_fuzzing/</guid><description>&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Existing network fuzzing solutions struggle on all fronts.
Speed is a big problem because they use either real network connections or
emulation/virtualization for snapshot-based fuzzing, both of which have a
huge overhead.
And, they struggle with deeply exploring the target since most of
the tools out there are built on top of AFL.&lt;br&gt;
For our vulnerability research, we built a high-performance network fuzzer
that tackles these problems and would like to present its setup in this post.&lt;br&gt;
The first issue we addressed was the problem of input generation. We developed
our own input representation and mutators that work with text-based protocols.
For that we used &lt;a href="https://github.com/AFLplusplus/LibAFL" target="_blank" rel="noopener"&gt;LibAFL&lt;/a&gt;
, a library for building custom fuzzers, which made
this very easy.&lt;br&gt;
The second problem we approached was how to feed inputs to network applications.
For this, we chose to &amp;ldquo;desocket&amp;rdquo; the applications with &lt;a href="https://github.com/fkie-cad/libdesock" target="_blank" rel="noopener"&gt;libdesock&lt;/a&gt;
 and serve
the individual packets over a shared memory channel.&lt;br&gt;
We compared our tool to &lt;a href="https://github.com/aflnet/aflnet" target="_blank" rel="noopener"&gt;AFLNet&lt;/a&gt;
, arguably the most popular network fuzzer at
the time of writing this, and found that our setup gave us a 42x performance boost,
orders of magnitude more coverage and new vulnerabilities in already heavily
fuzzed software.&lt;/p&gt;</description></item><item><title>libdesock</title><link>https://lolcads.github.io/posts/2022/02/libdesock/</link><pubDate>Tue, 22 Feb 2022 14:24:40 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2022/02/libdesock/</guid><description>&lt;h1 id="fuzzing-network-applications-with-afl-and-libdesock"&gt;Fuzzing Network Applications with AFL and libdesock&lt;/h1&gt;
&lt;p&gt;Fuzzing network servers with AFL is challenging since AFL provides its
input via stdin or command line arguments while servers get their input
over network connections.
As the popularity of AFL grew, many attempts have been made of fuzzing
popular servers like apache and nginx using different
techniques and hacky workarounds. However an off-the-shelf network fuzzing
solution for AFL didn&amp;rsquo;t exist for a long time until so-called &amp;ldquo;desocketing&amp;rdquo;
tools emerged.
These desocketing tools enabled network fuzzing without
making a lot of additional modifications to the program under test
and quickly became widely used in combination with AFL.&lt;/p&gt;</description></item></channel></rss>