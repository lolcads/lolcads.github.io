<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Reliability on lolcads tech blog</title><link>https://lolcads.github.io/tags/reliability/</link><description>Recent content in Reliability on lolcads tech blog</description><generator>Hugo</generator><language>en</language><managingEditor>lolcads@posteo.net (lolcads)</managingEditor><webMaster>lolcads@posteo.net (lolcads)</webMaster><copyright>lolcads</copyright><lastBuildDate>Thu, 29 Jan 2026 10:00:00 +0200</lastBuildDate><atom:link href="https://lolcads.github.io/tags/reliability/index.xml" rel="self" type="application/rss+xml"/><item><title>Improving Linux Heap Exploit Reliability with FreshSlices and CPU-Bullying</title><link>https://lolcads.github.io/posts/2026/01/freshslices_and_cpubullies/</link><pubDate>Thu, 29 Jan 2026 10:00:00 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2026/01/freshslices_and_cpubullies/</guid><description>&lt;p&gt;Exploits built around heap-based memory corruptions will never be perfectly reliable. There are multiple factors contributing to this, one being that the heap is shared among all tasks (user processes and kernel threads) running on a machine. Thus, the task running the exploit cannot exercise perfect control over it.&lt;/p&gt;
&lt;p&gt;Much has already been written about the art of shaping the kernel heap and creating desired layouts reliably. This post assumes a reader who is somewhat familiar with the subject, i.e., I will not recount any basics here. Instead, I will focus on two generic techniques for improving an exploit process&amp;rsquo; control over the kernel heap.&lt;/p&gt;</description></item></channel></rss>