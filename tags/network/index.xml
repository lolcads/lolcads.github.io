<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Network on lolcads tech blog</title><link>https://lolcads.github.io/tags/network/</link><description>Recent content in Network on lolcads tech blog</description><generator>Hugo</generator><language>en</language><managingEditor>lolcads@posteo.net (lolcads)</managingEditor><webMaster>lolcads@posteo.net (lolcads)</webMaster><copyright>lolcads</copyright><lastBuildDate>Wed, 21 May 2025 18:32:12 +0200</lastBuildDate><atom:link href="https://lolcads.github.io/tags/network/index.xml" rel="self" type="application/rss+xml"/><item><title>How to build a high-performance network fuzzer with LibAFL and libdesock</title><link>https://lolcads.github.io/posts/2025/05/high_performance_network_fuzzing/</link><pubDate>Wed, 21 May 2025 18:32:12 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2025/05/high_performance_network_fuzzing/</guid><description>&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Existing network fuzzing solutions struggle on all fronts.
Speed is a big problem because they use either real network connections or
emulation/virtualization for snapshot-based fuzzing, both of which have a
huge overhead.
And, they struggle with deeply exploring the target since most of
the tools out there are built on top of AFL.&lt;br&gt;
For our vulnerability research, we built a high-performance network fuzzer
that tackles these problems and would like to present its setup in this post.&lt;br&gt;
The first issue we addressed was the problem of input generation. We developed
our own input representation and mutators that work with text-based protocols.
For that we used &lt;a href="https://github.com/AFLplusplus/LibAFL" target="_blank" rel="noopener"&gt;LibAFL&lt;/a&gt;
, a library for building custom fuzzers, which made
this very easy.&lt;br&gt;
The second problem we approached was how to feed inputs to network applications.
For this, we chose to &amp;ldquo;desocket&amp;rdquo; the applications with &lt;a href="https://github.com/fkie-cad/libdesock" target="_blank" rel="noopener"&gt;libdesock&lt;/a&gt;
 and serve
the individual packets over a shared memory channel.&lt;br&gt;
We compared our tool to &lt;a href="https://github.com/aflnet/aflnet" target="_blank" rel="noopener"&gt;AFLNet&lt;/a&gt;
, arguably the most popular network fuzzer at
the time of writing this, and found that our setup gave us a 42x performance boost,
orders of magnitude more coverage and new vulnerabilities in already heavily
fuzzed software.&lt;/p&gt;</description></item><item><title>friTap - Decrypting TLS on the fly</title><link>https://lolcads.github.io/posts/2022/08/fritap/</link><pubDate>Fri, 12 Aug 2022 13:09:24 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2022/08/fritap/</guid><description>&lt;h2 id="encryption---a-curse-and-a-blessing-at-the-same-time"&gt;Encryption - a curse and a blessing at the same time&lt;/h2&gt;
&lt;p&gt;Digital communication in today&amp;rsquo;s world has a particularly high status in our society. Financial transactions are conducted via online banking, private communication is increasingly limited to digital messenger services, and even health data is experiencing a shift to digital form. Due to the growth of such sensitive digital data, the need for secure transmission of such data has become increasingly important over the past decades. With the introduction of high-performance and digitally secure cryptographic methods, such as SSL/TLS, today&amp;rsquo;s digital communications are predominantly encrypted. Whereas back then, for example, an attacker could hang himself between the client and the server and read the data traffic without encryption, today all he sees is a jumble of letters.
Encryption is truly a boon for protecting sensitive personal data, but it also has its drawbacks, as with almost everything. Encrypted communications negate the ability to analyze communications, which is very relevant when reverse engineering malware or researching vulnerabilities.&lt;/p&gt;</description></item><item><title>libdesock</title><link>https://lolcads.github.io/posts/2022/02/libdesock/</link><pubDate>Tue, 22 Feb 2022 14:24:40 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2022/02/libdesock/</guid><description>&lt;h1 id="fuzzing-network-applications-with-afl-and-libdesock"&gt;Fuzzing Network Applications with AFL and libdesock&lt;/h1&gt;
&lt;p&gt;Fuzzing network servers with AFL is challenging since AFL provides its
input via stdin or command line arguments while servers get their input
over network connections.
As the popularity of AFL grew, many attempts have been made of fuzzing
popular servers like apache and nginx using different
techniques and hacky workarounds. However an off-the-shelf network fuzzing
solution for AFL didn&amp;rsquo;t exist for a long time until so-called &amp;ldquo;desocketing&amp;rdquo;
tools emerged.
These desocketing tools enabled network fuzzing without
making a lot of additional modifications to the program under test
and quickly became widely used in combination with AFL.&lt;/p&gt;</description></item></channel></rss>