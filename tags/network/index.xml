<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>network on lolcads tech blog</title><link>https://lolcads.github.io/tags/network/</link><description>Recent content in network on lolcads tech blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; lolcads</copyright><lastBuildDate>Fri, 12 Aug 2022 13:09:24 +0200</lastBuildDate><atom:link href="https://lolcads.github.io/tags/network/index.xml" rel="self" type="application/rss+xml"/><item><title>friTap - Decrypting TLS on the fly</title><link>https://lolcads.github.io/posts/2022/08/fritap/</link><pubDate>Fri, 12 Aug 2022 13:09:24 +0200</pubDate><guid>https://lolcads.github.io/posts/2022/08/fritap/</guid><description>Encryption - a curse and a blessing at the same time Digital communication in today&amp;rsquo;s world has a particularly high status in our society. Financial transactions are conducted via online banking, private communication is increasingly limited to digital messenger services, and even health data is experiencing a shift to digital form. Due to the growth of such sensitive digital data, the need for secure transmission of such data has become increasingly important over the past decades.</description><content>&lt;h2 id="encryption---a-curse-and-a-blessing-at-the-same-time">Encryption - a curse and a blessing at the same time&lt;/h2>
&lt;p>Digital communication in today&amp;rsquo;s world has a particularly high status in our society. Financial transactions are conducted via online banking, private communication is increasingly limited to digital messenger services, and even health data is experiencing a shift to digital form. Due to the growth of such sensitive digital data, the need for secure transmission of such data has become increasingly important over the past decades. With the introduction of high-performance and digitally secure cryptographic methods, such as SSL/TLS, today&amp;rsquo;s digital communications are predominantly encrypted. Whereas back then, for example, an attacker could hang himself between the client and the server and read the data traffic without encryption, today all he sees is a jumble of letters.
Encryption is truly a boon for protecting sensitive personal data, but it also has its drawbacks, as with almost everything. Encrypted communications negate the ability to analyze communications, which is very relevant when reverse engineering malware or researching vulnerabilities.&lt;/p>
&lt;h2 id="man-in-the-middle-proxy-as-a-solution">Man-in-the-middle proxy as a solution&lt;/h2>
&lt;p>One of the best known solutions to intercept and decrypt encrypted communications is the so-called &amp;ldquo;man-in-the-middle&amp;rdquo; attack. In this case, the attacker or analyst pretends to be a trustworthy communication partner to the client. However, since the client often does not know how the client&amp;rsquo;s communication partner, referred to hereafter as the server, communicates or behaves, the attacker (or analyst) forwards the communication to the server and pretends to be the client.
To establish encrypted communication via TLS, for example, a certificate is required, which the server sends to the client when the connection is established. So a connection is established between the MitM proxy and the client using a MitM certificate (fake certificate) and a connection is established between the MitM proxy and the server using a server certificate.
&lt;img src="https://lolcads.github.io/2022/08/mitm_proxy_without_cert_pinning.svg" alt="MitM">&lt;/p>
&lt;p>Due to this setup, the communication between client and server is routed through the MitM proxy and can be processed on it without encryption.&lt;/p>
&lt;p>There are some preventive measures that can prevent such an attack, especially on mobile devices. One of the best known measures is the so-called &amp;ldquo;certificate pinning&amp;rdquo;. This involves storing the expected server certificate or a hash of the certificate in the binary of the client itself. If the client subsequently receives a certificate from the alleged server, this is compared with the embedded certificate or verified by means of a hash value. If this verification is not successful, then the connection is aborted.&lt;/p>
&lt;p>A possible solution to this problem would be to modify the pinning code itself:&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/08/certpinning_hooking.svg" alt="Pinning">&lt;/p>
&lt;p>This approach is possible, but in many cases it is very time-consuming, since the implementations of the pinning can differ greatly depending on the version and the analysis of the code must be performed again for each new version if the pinning is not used from a well known library. In addition, there are, especially with malware, several different implementations of pinning, which is why a general approach often does not lead to the goal.&lt;/p>
&lt;h2 id="our-approach">Our approach:&lt;/h2>
&lt;p>One thing is certain: in order to get the unencrypted communication, the client application must be &amp;ldquo;attacked&amp;rdquo;. This led us to ask why we don&amp;rsquo;t directly extract the decrypted SSL/TLS stream or the key material from the target appliaction.&lt;/p>
&lt;h3 id="abstraction-of-using-a-library">Abstraction of using a library&lt;/h3>
&lt;p>Most applications that perform encrypted communication use a widely available library to do so, such as OpenSSL and NSS. These libraries try to keep the encryption of the data as abstract as possible, so that the use of the library is very convenient. Among other things, they encapsulate the TLS handshake and the sending and receiving of encrypted data.&lt;/p>
&lt;p>A common program flow utilizing a TLS library looks like this:&lt;/p>
&lt;p>The application wants to establish a secure TLS connection to a server. It uses the TLS library for this purpose, which performs the handshake as shown below:&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/08/connection.gif" alt="GIF here">&lt;/p>
&lt;p>After establishing the TLS connection, data can now be sent and received using the read and write functions of the TLS library as shown in the figure below.&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/08/fritap_approach.svg" alt="TLS hooking">&lt;/p>
&lt;p>Exactly these TLS-read and TLS-write functions are used by the target application to read and write the plaintext from TLS stream, respectively.
Hence our tool, &lt;a href="https://github.com/fkie-cad/friTap">friTap&lt;/a>, is hooking them in order to receive the plaintext of the encrypted packets. Beside this friTap is also able to extract the used TLS keys.&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/08/hooking_Fritap.svg" alt="friTap">&lt;/p>
&lt;h3 id="fritap-usage">friTap usage&lt;/h3>
&lt;p>&lt;a href="https://github.com/fkie-cad/friTap">friTap&lt;/a> comes with two operation modes. One is to get the plaintext from the TLS payload as PCAP and the other is to get the used TLS keys.
In order to get the decrypted TLS payload we need the &lt;code>-p&lt;/code> parameter:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ./friTap.py –m –p decryptedTLS.pcap &amp;lt;target_app&amp;gt;
…
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> BoringSSL.so found &amp;amp; will be hooked on Android!
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Android dynamic loader hooked.
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Logging pcap to decryptedTLS.pcap
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>-m&lt;/code> paramter indicates that we are analysing a mobile application in the above example. For extracting the TLS keys from a target application we need the &lt;code>-k&lt;/code> parameter:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ./friTap.py –m –k TLS_keys.log &amp;lt;target_app&amp;gt;
…
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> BoringSSL.so found &amp;amp; will be hooked on Android!
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Android dynamic loader hooked.
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Logging keylog file to TLS_keys.log
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As a result friTap writes all TLS keys to the &lt;code>TLS_keys.log&lt;/code> file using the &lt;a href="https://firefox-source-docs.mozilla.org/security/nss/legacy/key_log_format/index.html">NSS Key Log Format&lt;/a>.&lt;/p>
&lt;h2 id="fritap-internals">friTap internals&lt;/h2>
&lt;p>After understanding the overall approach lets dive into the internals of &lt;a href="https://github.com/fkie-cad/friTap">friTap&lt;/a>.&lt;/p>
&lt;h3 id="frida">FRIDA&lt;/h3>
&lt;p>&lt;a href="https://github.com/fkie-cad/friTap">friTap&lt;/a> is built on the dynamic instrumentation toolkit &lt;a href="https://frida.re/">FRIDA&lt;/a>, which allows developers, reverse engineers and security researchers to dynamically analyze and instrument programs. FRIDA allows you to execute Javascript code within the target program, which gives you the ability to hook functions, read and write program memory, execute custom code, and more. A Python API is provided for using FRIDA, which makes it very user-friendly.&lt;/p>
&lt;p>To accomplish this, FRIDA injects the &lt;a href="https://bellard.org/quickjs/">QuickJS Javascript engine&lt;/a> (can also be changed to the &lt;a href="https://v8.dev/">V8 runtime&lt;/a>) into the target process and an agent that acts as communication interfaces between the instrumentarized process and its own tool later on.
After injection of the engine and the agent, the user is able to execute own Javascript code inside the target process and receive data from it. More on the inner workings of FRIDA can be found &lt;a href="https://frida.re/docs/presentations/">here&lt;/a>.&lt;/p>
&lt;h3 id="program-flow">Program flow&lt;/h3>
&lt;p>A rough overview of the flow of friTap can be seen in the following diagrams, which are explained in more detail in the sections that follow.
The first step after loading the friTap JS script into the target process is to identify the operating system (os) of the target process:&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/08/fritap_choose_os_agent_final.svg" alt="">&lt;/p>
&lt;p>Then an os specific agent will be loaded. This agent enumerates all loaded libraries/modules from the target process. FRIDA provides a function for this purpose that returns for each loaded module its name, base address, size and path in the file system. Based on the name of the modules friTap can identify a SSL/TLS library. Depending on the version and operating system, the name of the loaded module can vary greatly. friTap tries to cover all potential module names of supported libraries as best as possible using expressive regex. The operating system-specific agent determines which libraries are supported and how its hooking is implemented:&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/08/fritap_hook.svg" alt="">&lt;/p>
&lt;p>When a supported library is detected, friTap tries to hook the &lt;code>SSL-read()&lt;/code>, &lt;code>SSL-write()&lt;/code> and &lt;code>SSL-keyexport()&lt;/code> functions of the respective library and all other functions required for this. Sometimes the target library doesn&amp;rsquo;t provide a key export function, in those cases friTap have to parse the heap in order to find the keys in the memory of the target process.&lt;/p>
&lt;p>Next we want to dive into the implementation details of the mentioned parts of friTap. As mentioned above friTap checks at first on which plattform our target process is running and invoke than its respective os specific agent:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">load_os_specific_agent&lt;/span>() {
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">isWindows&lt;/span>()){
&lt;span style="color:#a6e22e">load_windows_hooking_agent&lt;/span>()
}&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">isAndroid&lt;/span>()){
&lt;span style="color:#a6e22e">load_android_hooking_agent&lt;/span>()
}&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">isLinux&lt;/span>()){
&lt;span style="color:#a6e22e">load_linux_hooking_agent&lt;/span>()
}&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">isiOS&lt;/span>()){
&lt;span style="color:#a6e22e">load_ios_hooking_agent&lt;/span>()
}&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">isMacOS&lt;/span>()){
&lt;span style="color:#a6e22e">load_macos_hooking_agent&lt;/span>()
}&lt;span style="color:#66d9ef">else&lt;/span>{
&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Error: not supported plattform!\nIf you want to have support for this plattform please make an issue at our github page.&amp;#34;&lt;/span>)
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This agent installs the hooks for the detected libraries. First the enumerations of the supported SSL/TLS libaries are safed (&lt;code>module_library_mapping&lt;/code>) and provided for the different hooks. In the following we see how this is done for Android:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">load_android_hooking_agent&lt;/span>() {
&lt;span style="color:#a6e22e">module_library_mapping&lt;/span>[&lt;span style="color:#a6e22e">plattform_name&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> [[&lt;span style="color:#e6db74">/.*libssl_sb.so/&lt;/span>, &lt;span style="color:#a6e22e">boring_execute&lt;/span>],[&lt;span style="color:#e6db74">/.*libssl\.so/&lt;/span>, &lt;span style="color:#a6e22e">boring_execute&lt;/span>],[&lt;span style="color:#e6db74">/.*libgnutls\.so/&lt;/span>, &lt;span style="color:#a6e22e">gnutls_execute&lt;/span>],[&lt;span style="color:#e6db74">/.*libwolfssl\.so/&lt;/span>, &lt;span style="color:#a6e22e">wolfssl_execute&lt;/span>],[&lt;span style="color:#e6db74">/.*libnspr[0-9]?\.so/&lt;/span>,&lt;span style="color:#a6e22e">nss_execute&lt;/span>], [&lt;span style="color:#e6db74">/libmbedtls\.so.*/&lt;/span>, &lt;span style="color:#a6e22e">mbedTLS_execute&lt;/span>]];
&lt;span style="color:#a6e22e">install_java_hooks&lt;/span>();
&lt;span style="color:#a6e22e">hook_native_Android_SSL_Libs&lt;/span>(&lt;span style="color:#a6e22e">module_library_mapping&lt;/span>);
&lt;span style="color:#a6e22e">hook_Android_Dynamic_Loader&lt;/span>(&lt;span style="color:#a6e22e">module_library_mapping&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>If supported, friTap installs java based hooks. Right now these java hooks only installed for Android applications. Next the plattform (operating system) specific hooks are installed. After a supported SSL/TLS library has been found, the search for the corresponding functions (read, write, key export) inside the module is started. This is done using the mapped functions from &lt;code>module_library_mapping&lt;/code>. When we have a closer look into the enumerations we can see that for each detected library an appropriate so called &lt;code>&amp;lt;libname&amp;gt;-execute&lt;/code> function is mapped. This mapped function contains the implementation details of the &lt;code>SSL-read()&lt;/code>, &lt;code>SSL-write()&lt;/code> and &lt;code>SSL-keyexport()&lt;/code> hooks. Strictly speaking, for each identified library, its platform-specific hook (read, write, export) is installed for the corresponding library. Fortunately, the majority of hooking implementations are platform independent, with only a few platforms having differences. This means that the overall hooking implementation for a specific library is provided by an os independent super class. In the following we see the Android OpenSSL hooking implementation with the implementations inherited from its superclass:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">/* from openssl_boringssl_android.ts */&lt;/span>
&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">OpenSSL_BoringSSL_Android&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">OpenSSL_BoringSSL&lt;/span> {
&lt;span style="color:#a6e22e">constructor&lt;/span>(&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">moduleName&lt;/span>&lt;span style="color:#f92672">:&lt;/span>String, &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">socket_library&lt;/span>&lt;span style="color:#f92672">:&lt;/span>String){
&lt;span style="color:#66d9ef">super&lt;/span>(&lt;span style="color:#a6e22e">moduleName&lt;/span>,&lt;span style="color:#a6e22e">socket_library&lt;/span>);
}
&lt;span style="color:#a6e22e">execute_hooks&lt;/span>(){
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">install_plaintext_read_hook&lt;/span>();
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">install_plaintext_write_hook&lt;/span>();
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">install_tls_keys_callback_hook&lt;/span>();
}
}
&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">boring_execute&lt;/span>(&lt;span style="color:#a6e22e">moduleName&lt;/span>&lt;span style="color:#f92672">:&lt;/span>String){
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">boring_ssl&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">OpenSSL_BoringSSL_Android&lt;/span>(&lt;span style="color:#a6e22e">moduleName&lt;/span>,&lt;span style="color:#a6e22e">socket_library&lt;/span>);
&lt;span style="color:#a6e22e">boring_ssl&lt;/span>.&lt;span style="color:#a6e22e">execute_hooks&lt;/span>();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The specific functions of the library are only then hooked in the superclass. This is done by library&amp;rsquo;s specific function names (SSL_read, SSL_write&amp;hellip;) which are passed to our &lt;code>readAddresses()&lt;/code> function in order to obtain the addresses for hooking.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">/* super class openssl_boringssl.ts */&lt;/span>
&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">OpenSSL_BoringSSL&lt;/span> {
&lt;span style="color:#75715e">// global variables
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">library_method_mapping&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> Array&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> } &lt;span style="color:#f92672">=&lt;/span> {};
&lt;span style="color:#a6e22e">addresses&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">NativePointer&lt;/span> };
...
&lt;span style="color:#a6e22e">constructor&lt;/span>(&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">moduleName&lt;/span>&lt;span style="color:#f92672">:&lt;/span>String, &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">socket_library&lt;/span>&lt;span style="color:#f92672">:&lt;/span>String,&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">passed_library_method_mapping&lt;/span>&lt;span style="color:#f92672">?:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> Array&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> }){
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">passed_library_method_mapping&lt;/span> &lt;span style="color:#f92672">!==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;undefined&amp;#39;&lt;/span>){
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">library_method_mapping&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">passed_library_method_mapping&lt;/span>;
}&lt;span style="color:#66d9ef">else&lt;/span>{
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">library_method_mapping&lt;/span>[&lt;span style="color:#e6db74">`*&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">moduleName&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">*`&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#e6db74">&amp;#34;SSL_read&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SSL_write&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SSL_get_fd&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SSL_get_session&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SSL_SESSION_get_id&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SSL_new&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SSL_CTX_set_keylog_callback&amp;#34;&lt;/span>]
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">library_method_mapping&lt;/span>[&lt;span style="color:#e6db74">`*&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">socket_library&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">*`&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#e6db74">&amp;#34;getpeername&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;getsockname&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;ntohs&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;ntohl&amp;#34;&lt;/span>]
}
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addresses&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">readAddresses&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">library_method_mapping&lt;/span>);
...
}
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>FRIDA provides with the &lt;a href="https://frida.re/docs/javascript-api/#apiresolver">ApiResolver&lt;/a> a function &lt;code>enumerateMatches(&amp;quot;exports:&amp;quot; + library_name + &amp;quot;!&amp;quot; + method)&lt;/code>:
This is passed the name of the function, the name of the module and the type (export, import) in a single string. If a match is found, information about this function is returned, of which friTap only needs and stores the address. Below is the whole listing of friTap&amp;rsquo;s &lt;code>readAddresses()&lt;/code> function:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">//File: agent/shared/shared_functions.ts
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e">* Read the addresses for the given methods from the given modules
&lt;/span>&lt;span style="color:#75715e">* @param {{[key: string]: Array&amp;lt;String&amp;gt; }} library_method_mapping A string indexed list of arrays, mapping modules to methods
&lt;/span>&lt;span style="color:#75715e">* @return {{[key: string]: NativePointer }} A string indexed list of NativePointers, which point to the respective methods
&lt;/span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">readAddresses&lt;/span>(&lt;span style="color:#a6e22e">library_method_mapping&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> Array&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> })&lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">NativePointer&lt;/span> } {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">resolver&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">ApiResolver&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;module&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">addresses&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">NativePointer&lt;/span> } &lt;span style="color:#f92672">=&lt;/span> {}
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">library_name&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#a6e22e">library_method_mapping&lt;/span>) {
&lt;span style="color:#a6e22e">library_method_mapping&lt;/span>[&lt;span style="color:#a6e22e">library_name&lt;/span>].&lt;span style="color:#a6e22e">forEach&lt;/span>(&lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">method&lt;/span>) {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">matches&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">resolver&lt;/span>.&lt;span style="color:#a6e22e">enumerateMatches&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;exports:&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">library_name&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;!&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">method&lt;/span>)
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">match_number&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">method_name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">method&lt;/span>.&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">method_name&lt;/span>.&lt;span style="color:#a6e22e">endsWith&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;*&amp;#34;&lt;/span>)){
&lt;span style="color:#a6e22e">method_name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">method_name&lt;/span>.&lt;span style="color:#a6e22e">substring&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#a6e22e">method_name&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
}
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">matches&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Could not find &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">library_name&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;!&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">method&lt;/span>
}
&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">matches&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>){
&lt;span style="color:#a6e22e">devlog&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Found &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">method&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">matches&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>].&lt;span style="color:#a6e22e">address&lt;/span>)
}&lt;span style="color:#66d9ef">else&lt;/span>{
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">matches&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>; &lt;span style="color:#a6e22e">k&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">matches&lt;/span>[&lt;span style="color:#a6e22e">k&lt;/span>].&lt;span style="color:#a6e22e">name&lt;/span>.&lt;span style="color:#a6e22e">endsWith&lt;/span>(&lt;span style="color:#a6e22e">method_name&lt;/span>)){
&lt;span style="color:#a6e22e">match_number&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span>;
&lt;span style="color:#a6e22e">devlog&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Found &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">method&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">matches&lt;/span>[&lt;span style="color:#a6e22e">match_number&lt;/span>].&lt;span style="color:#a6e22e">address&lt;/span>)
&lt;span style="color:#66d9ef">break&lt;/span>;
}
}
}
&lt;span style="color:#a6e22e">addresses&lt;/span>[&lt;span style="color:#a6e22e">method_name&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">matches&lt;/span>[&lt;span style="color:#a6e22e">match_number&lt;/span>].&lt;span style="color:#a6e22e">address&lt;/span>;
})
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">addresses&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After all relevant function addresses are available, friTap finally installs the hooks when entering or leaving the respective functions. More on this later.&lt;/p>
&lt;p>It is possible that a program to be analyzed does not load an SSL/TLS library at program start or loads an SSL/TLS library again at another time. For this case friTap hooks a function in the respective standard library of the operating system. The following is the implementation for Android:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">/* File agent/android/android_agent.ts */&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">hook_Android_Dynamic_Loader&lt;/span>(&lt;span style="color:#a6e22e">module_library_mapping&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> Array&lt;span style="color:#f92672">&amp;lt;&lt;/span>[&lt;span style="color:#a6e22e">any&lt;/span>, (&lt;span style="color:#a6e22e">moduleName&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>)=&amp;gt;&lt;span style="color:#66d9ef">void&lt;/span>]&lt;span style="color:#f92672">&amp;gt;&lt;/span> })&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>{
...
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">regex_libdl&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">/.*libdl.*\.so/&lt;/span>
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">libdl&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">moduleNames&lt;/span>.&lt;span style="color:#a6e22e">find&lt;/span>(&lt;span style="color:#a6e22e">element&lt;/span> =&amp;gt; &lt;span style="color:#a6e22e">element&lt;/span>.&lt;span style="color:#a6e22e">match&lt;/span>(&lt;span style="color:#a6e22e">regex_libdl&lt;/span>))
...
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">dl_exports&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Process&lt;/span>.&lt;span style="color:#a6e22e">getModuleByName&lt;/span>(&lt;span style="color:#a6e22e">libdl&lt;/span>).&lt;span style="color:#a6e22e">enumerateExports&lt;/span>()
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">dlopen&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;dlopen&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">ex&lt;/span> &lt;span style="color:#66d9ef">of&lt;/span> &lt;span style="color:#a6e22e">dl_exports&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">ex&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#34;android_dlopen_ext&amp;#34;&lt;/span>) {
&lt;span style="color:#a6e22e">dlopen&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;android_dlopen_ext&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">break&lt;/span>
}
}
&lt;span style="color:#a6e22e">Interceptor&lt;/span>.&lt;span style="color:#a6e22e">attach&lt;/span>(&lt;span style="color:#a6e22e">Module&lt;/span>.&lt;span style="color:#a6e22e">getExportByName&lt;/span>(&lt;span style="color:#a6e22e">libdl&lt;/span>, &lt;span style="color:#a6e22e">dlopen&lt;/span>), {
&lt;span style="color:#a6e22e">onEnter&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">args&lt;/span>) {
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">moduleName&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>].&lt;span style="color:#a6e22e">readCString&lt;/span>()
},
&lt;span style="color:#a6e22e">onLeave&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">retval&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">moduleName&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>) {
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">map&lt;/span> &lt;span style="color:#66d9ef">of&lt;/span> &lt;span style="color:#a6e22e">module_library_mapping&lt;/span>[&lt;span style="color:#a6e22e">plattform_name&lt;/span>]){
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">regex&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">map&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>]
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">func&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">map&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">regex&lt;/span>.&lt;span style="color:#a6e22e">test&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">moduleName&lt;/span>)){
&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">moduleName&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> was loaded &amp;amp; will be hooked on Android!`&lt;/span>)
&lt;span style="color:#a6e22e">func&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">moduleName&lt;/span>)
}
}
}
}
})
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">`[*] Android dynamic loader hooked.`&lt;/span>)
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now all functions for extracting the streams or the key material should have been identified so that friTap can use the hooks for extracting the plaintext payload or the TLS keys.&lt;/p>
&lt;p>Lets dive into the hooking implementations itself. The way of instrumentation varies partly between the different supported libraries and plattform, but all follow the same principle.&lt;/p>
&lt;h3 id="hooking-the-read-function">Hooking the read function&lt;/h3>
&lt;p>The read functions of the libraries generally have function signature of the following structure:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">read&lt;/span> (&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The first parameter is a pointer to an SSL object that holds all information about the SSL session in use in the background. This object is used to identify the SSL/TLS stream over which data is received. The second parameter is a pointer to a temporary buffer that holds unencrypted data received from the SSL/TLS stream. The third parameter is the maximum number of bytes that can be stored in the buffer for data received from the SSL/TLS stream.&lt;/p>
&lt;p>For friTap, the second parameter, the buffer containing the unencrypted data, is the important one. To read the contents of this buffer, friTap needs the pointer to it and the number of bytes that were received.
FRIDA&amp;rsquo;s interceptor allows to define hooks for function start and end. These callbacks are executed before the execution and after the execution of the function.
The callback function for the hook of the function start is passed all parameters of the hooked function. Thus the callback function is able to extract and manipulate all passed parameters.
friTap takes advantage of this and extracts from the parameters the second pointer of the read function, which points to the buffer that holds the received, unencrypted data. The implementation is here as an example (using OpenSSL) for the other implementations and it looks like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#a6e22e">Interceptor&lt;/span>.&lt;span style="color:#a6e22e">attach&lt;/span>(&lt;span style="color:#a6e22e">addresses&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;SSL_read&amp;#34;&lt;/span>],
{
&lt;span style="color:#a6e22e">onEnter&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">args&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>) {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">message&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">getPortsAndAddresses&lt;/span>(&lt;span style="color:#a6e22e">SSL_get_fd&lt;/span>(&lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>]) &lt;span style="color:#a6e22e">as&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#a6e22e">addresses&lt;/span>)
&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;ssl_session_id&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">getSslSessionId&lt;/span>(&lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>])
&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;function&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;SSL_read&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">message&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">message&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">buf&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>]
}
...
})
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The pointer to the buffer is in the paramter array named &lt;code>args&lt;/code>, strictly speaking in the second position (it is the second function parameter). This is now saved in the execution context using &lt;code>this.buf = args[1]&lt;/code>, since the buffer will only be filled with the received data after the read function has been executed.&lt;/p>
&lt;p>The hook of the function end has exactly one parameter, the return value of the function. In the case of the read function, this is the number of bytes received, which is important for reading the buffer. The hook for the end of the function looks like the following, again demonstrated with OpenSSL as an example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#a6e22e">Interceptor&lt;/span>.&lt;span style="color:#a6e22e">attach&lt;/span>(&lt;span style="color:#a6e22e">addresses&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;SSL_read&amp;#34;&lt;/span>],
{
...
&lt;span style="color:#a6e22e">onLeave&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">retval&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>) {
&lt;span style="color:#a6e22e">retval&lt;/span> &lt;span style="color:#f92672">|=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e">// Cast retval to 32-bit integer.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">retval&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;span style="color:#66d9ef">return&lt;/span>
}
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">buffer_content&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">buf&lt;/span>.&lt;span style="color:#a6e22e">readByteArray&lt;/span>(&lt;span style="color:#a6e22e">retval&lt;/span>)
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;contentType&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;datalog&amp;#34;&lt;/span>
&lt;span style="color:#a6e22e">send&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">message&lt;/span>, &lt;span style="color:#a6e22e">buffer_content&lt;/span>)
}
})
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>retval&lt;/code> is the return value of the read function, i.e. the number of bytes received. The previously saved pointer to the buffer can now be read with &lt;code>readByteArray()&lt;/code>. By the return value of the read function friTap knows exactly how many bytes have to be read from the buffer. The extracted bytes are then stored in a dictionary object, which in addition to the data also contains information such as port numbers, sender and receiver addresses, etc. . This is then sent via &lt;code>send()&lt;/code> from the target process to the main script (&lt;a href="https://github.com/fkie-cad/friTap/blob/9ba62ad1aecffb3baed812690b74efe99d970d22/friTap.py">python script&lt;/a>), which then processes this information.&lt;/p>
&lt;h3 id="hooking-the-write-function">Hooking the write function&lt;/h3>
&lt;p>As with the read functions, the write functions have the same function signature for all libraries supported by friTap:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">write&lt;/span> (&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The first parameter is a pointer to an SSL object that holds all information about the SSL session being used in the background. This object is used to identify the SSL/TLS stream over which data is sent.
The second parameter is a pointer to a buffer that holds the data to be transmitted, in unencrypted form.
The third parameter specifies how many bytes from the referenced buffer should be sent over the associated SSL/TLS stream.&lt;/p>
&lt;p>Unlike the read function, all information necessary for friTap is already available before function execution. The implementation is again exemplified with the implementation of OpenSSL:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#a6e22e">Interceptor&lt;/span>.&lt;span style="color:#a6e22e">attach&lt;/span>(&lt;span style="color:#a6e22e">addresses&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;SSL_write&amp;#34;&lt;/span>],
{
&lt;span style="color:#a6e22e">onEnter&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">args&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>) {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">message&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">getPortsAndAddresses&lt;/span>(&lt;span style="color:#a6e22e">SSL_get_fd&lt;/span>(&lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>]) &lt;span style="color:#a6e22e">as&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#a6e22e">addresses&lt;/span>)
&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;ssl_session_id&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">getSslSessionId&lt;/span>(&lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>])
&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;function&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;SSL_write&amp;#34;&lt;/span>
&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;contentType&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;datalog&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">bytesToBeSent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>].&lt;span style="color:#a6e22e">readByteArray&lt;/span>(parseInt(&lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">2&lt;/span>]))
&lt;span style="color:#a6e22e">send&lt;/span>(&lt;span style="color:#a6e22e">message&lt;/span>, &lt;span style="color:#a6e22e">bytesToBeSent&lt;/span>)
}
})
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>args[1]&lt;/code> is the pointer to the buffer, &lt;code>args[2]&lt;/code> the number of bytes to send. With &lt;code>readByteArray()&lt;/code> the bytes to send can be copied from the buffer. The extracted bytes are then stored in a dictionary object, which contains besides the data also information like port numbers, sender and receiver address etc.. This is then sent via &lt;code>send()&lt;/code> from the target process to the main script (Python script), which then processes this information.&lt;/p>
&lt;h3 id="key-extraction">Key extraction&lt;/h3>
&lt;p>In addition to hooking the read and write functions, friTap also provides the ability to export all keys created/received during the handshake. These keys can then be used to decrypt encrypted TLS traffic. Wirehsark provides the ability to specify a keylog file that friTap created when the client connected to the server.
The implementation of this functionality varies widely. This is due to the default behavior of the individual libraries, especially depending on the operating system.&lt;/p>
&lt;p>Again, we would like to show an example, based on the implementation of OpenSSL on linux:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">SSL_CTX_set_keylog_callback&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">ObjC&lt;/span>.&lt;span style="color:#a6e22e">available&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">NativeFunction&lt;/span>(&lt;span style="color:#a6e22e">addresses&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;SSL_CTX_set_info_callback&amp;#34;&lt;/span>], &lt;span style="color:#e6db74">&amp;#34;void&amp;#34;&lt;/span>, [&lt;span style="color:#e6db74">&amp;#34;pointer&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;pointer&amp;#34;&lt;/span>]) &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">NativeFunction&lt;/span>(&lt;span style="color:#a6e22e">addresses&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;SSL_CTX_set_keylog_callback&amp;#34;&lt;/span>], &lt;span style="color:#e6db74">&amp;#34;void&amp;#34;&lt;/span>, [&lt;span style="color:#e6db74">&amp;#34;pointer&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;pointer&amp;#34;&lt;/span>])
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">keylog_callback&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">NativeCallback&lt;/span>(&lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">ctxPtr&lt;/span>, &lt;span style="color:#a6e22e">linePtr&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">NativePointer&lt;/span>) {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">message&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> } &lt;span style="color:#f92672">=&lt;/span> {}
&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;contentType&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;keylog&amp;#34;&lt;/span>
&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;keylog&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">linePtr&lt;/span>.&lt;span style="color:#a6e22e">readCString&lt;/span>()
&lt;span style="color:#a6e22e">send&lt;/span>(&lt;span style="color:#a6e22e">message&lt;/span>)
}, &lt;span style="color:#e6db74">&amp;#34;void&amp;#34;&lt;/span>, [&lt;span style="color:#e6db74">&amp;#34;pointer&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;pointer&amp;#34;&lt;/span>])
&lt;/code>&lt;/pre>&lt;/div>&lt;p>If OpenSSL is selected as a dynamically loaded library, many functions are exported by default. Fortunately, the function &lt;code>SSL_CTX_set_keylog_callback&lt;/code> (linux desktop) is also exported. This function gives the user the ability to define a callback function that will be called whenever new key material is generated or received. This function is passed two parameters when it is called: An SSL object associated with the connection and the newly generated or received key material in the form of a string. FRIDA allows you to define your own callback functions, which we did for this use case. friTap creates a new callback function that reads the passed string and stores it in a dictionary object, which is sent to the main script (python script) and processed by it (log or write out).&lt;/p>
&lt;p>In order to register the own callback, the function &lt;code>SSL_CTX_set_keylog_callback&lt;/code> must be called once, before the handshake, with the callback function as parameter. friTap hooks the &lt;code>SSL_new&lt;/code> method for this. This function is called before the handshake, but also after the SSL context has been created, i.e. the binding options have already been set so that the callback function can receive the key material of the subsequent handshake.&lt;/p>
&lt;p>For each operating system, friTap knows the usual library/module and the function that is ultimately responsible for loading the new library. When a new library is loaded into program memory, the name of the new module is checked to see if it matches any of the SSL/TLS library names. If this is the case, the usual read, write and key export functions are hooked.&lt;/p>
&lt;h2 id="special-thanks">Special Thanks&lt;/h2>
&lt;p>We like to thank our colleague Max J. Ufer for his initial work in creating friTap. Further we like to thank Martin Lambertz and Jan-Niclas Hilgert for their feedback while working on friTap. Finally we have to thank Ole André Vadla Ravnås for his tireless efforts in the development of FRIDA.&lt;/p>
&lt;h2 id="getting-started">Getting started&lt;/h2>
&lt;p>friTap can be downloaded here: &lt;a href="https://github.com/fkie-cad/friTap">https://github.com/fkie-cad/friTap&lt;/a>&lt;/p></content></item><item><title>libdesock</title><link>https://lolcads.github.io/posts/2022/02/libdesock/</link><pubDate>Tue, 22 Feb 2022 14:24:40 +0100</pubDate><guid>https://lolcads.github.io/posts/2022/02/libdesock/</guid><description>Fuzzing Network Applications with AFL and libdesock Fuzzing network servers with AFL is challenging since AFL provides its input via stdin or command line arguments while servers get their input over network connections. As the popularity of AFL grew, many attempts have been made of fuzzing popular servers like apache and nginx using different techniques and hacky workarounds. However an off-the-shelf network fuzzing solution for AFL didn&amp;rsquo;t exist for a long time until so-called &amp;ldquo;desocketing&amp;rdquo; tools emerged.</description><content>&lt;h1 id="fuzzing-network-applications-with-afl-and-libdesock">Fuzzing Network Applications with AFL and libdesock&lt;/h1>
&lt;p>Fuzzing network servers with AFL is challenging since AFL provides its
input via stdin or command line arguments while servers get their input
over network connections.
As the popularity of AFL grew, many attempts have been made of fuzzing
popular servers like apache and nginx using different
techniques and hacky workarounds. However an off-the-shelf network fuzzing
solution for AFL didn&amp;rsquo;t exist for a long time until so-called &amp;ldquo;desocketing&amp;rdquo;
tools emerged.
These desocketing tools enabled network fuzzing without
making a lot of additional modifications to the program under test
and quickly became widely used in combination with AFL.&lt;/p>
&lt;h2 id="what-is-desocketing">What is &amp;ldquo;desocketing&amp;rdquo;?&lt;/h2>
&lt;p>Before desocketing tools were published two common techniques for
network fuzzing were&lt;/p>
&lt;ol>
&lt;li>Sending fuzz input over real network connections&lt;/li>
&lt;li>Modifying the target source to use stdin instead of sockets&lt;/li>
&lt;/ol>
&lt;p>The first approach is the most prevalent used by popular fuzzers
like &lt;a href="https://github.com/jtpereyda/boofuzz">boofuzz&lt;/a> or in academia by &lt;a href="https://github.com/aflnet/aflnet">AFLnet&lt;/a> or &lt;a href="https://github.com/stateafl/stateafl">StateAFL&lt;/a>.
This however suffers performance- and stability-drawbacks.
Stability is affected because the servers run with all threads and child processes
enabled. Background threads can be scheduled independently from the input being sent
resulting in invalid coverage information.
Performance is affected because of the amount of kernel activity and network overhead involved.&lt;/p>
&lt;p>The second approach solves the network overhead problem but does not reduce the
kernel activity. It also takes a considerable amount of effort that may lead
to changing &lt;a href="https://securitylab.github.com/research/fuzzing-sockets-FTP/">thousands of lines of code&lt;/a>.&lt;/p>
&lt;p>Desocketing aims to reduce kernel activity and the amount of modifications necessary to a program.
It works by building a shared library that implements functions
like &lt;code>socket()&lt;/code> and &lt;code>accept()&lt;/code> and preloading it via &lt;code>LD_PRELOAD&lt;/code>
into the address space of a network application where it replaces
the network stack of the libc.
The desocketing library simulates incoming connections to the server
but every read on a socket is replaced by a read on stdin
and every write on a socket is redirected to stdout.
Strictly speaking the latter isn&amp;rsquo;t necessary for fuzzing but it&amp;rsquo;s useful
for debugging.&lt;/p>
&lt;p>The following figure demonstrates how to desock nginx such that the network
traffic becomes visible on a terminal.&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/02/demo.svg" alt="">&lt;/p>
&lt;h2 id="how-desocketing-works">How desocketing works&lt;/h2>
&lt;p>Making desocketing libraries has its complexities.
AFLplusplus' &lt;a href="https://github.com/AFLplusplus/AFLplusplus/tree/stable/utils/socket_fuzzing">socketfuzz&lt;/a>
ships a desocketing library that just returns &lt;code>0&lt;/code> (stdin) in &lt;code>accept()&lt;/code>.
Unfortunately this doesn&amp;rsquo;t quite work because &lt;code>send()&lt;/code> and &lt;code>recv()&lt;/code> need an
fd that actually refers to a network connection. If you pass them an fd that
refers to a file the kernel will complain.
Thus we need more complicated methods.&lt;/p>
&lt;p>At the time of writing this, there exists only one popular desocketing solution: &lt;a href="https://github.com/zardus/preeny">preeny&lt;/a>.
preeny creates a socketpair &lt;code>(a,b)&lt;/code> and spawns two threads &lt;code>t1&lt;/code> and
&lt;code>t2&lt;/code> in every call to &lt;code>socket()&lt;/code>.&lt;/p>
&lt;ul>
&lt;li>Thread &lt;code>t1&lt;/code> forwards all data from stdin to &lt;code>a&lt;/code>&lt;/li>
&lt;li>Thread &lt;code>t2&lt;/code> forwards all data from &lt;code>a&lt;/code> to stdout&lt;/li>
&lt;li>In &lt;code>socket()&lt;/code> preeny returns &lt;code>b&lt;/code>&lt;/li>
&lt;li>When AFL writes input to stdin, thread &lt;code>t1&lt;/code> forwards that data to &lt;code>a&lt;/code>&lt;/li>
&lt;li>Writing to &lt;code>a&lt;/code> means that the data will become available in &lt;code>b&lt;/code> and the
application can read the request from &lt;code>b&lt;/code>&lt;/li>
&lt;li>The application writes a response back to &lt;code>b&lt;/code>, making the data available
in socket &lt;code>a&lt;/code> where &lt;code>t2&lt;/code> forwards it to stdout.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://lolcads.github.io/2022/02/preeny.png" alt="">&lt;/p>
&lt;p>Unfortunately this design makes preeny unsuitable for fuzzing:&lt;/p>
&lt;ol>
&lt;li>Spawning threads and joining them introduces additional overhead.&lt;/li>
&lt;li>Each thread realizes busy waiting by calling &lt;code>poll()&lt;/code> every 15ms&lt;/li>
&lt;li>Preeny still relies on a lot of kernel interaction. I/O multiplexing (select, poll, epoll)
is left completely to the kernel.&lt;/li>
&lt;li>The threads may introduce additional instability.&lt;br>
Normally you want to disable threads when fuzzing with AFL.&lt;/li>
&lt;li>It can handle only single-threaded applications but most of the servers
are multi-threaded&lt;/li>
&lt;/ol>
&lt;p>A better desocketing library is needed that is more resource-efficient and handles the complexities of
modern network applications correctly.
So we created a new desocketing library: &amp;ldquo;libdesock&amp;rdquo;.&lt;/p>
&lt;h2 id="using-libdesock">Using libdesock&lt;/h2>
&lt;p>libdesock fully emulates the network stack of the kernel. The kernel is only queried to obtain file
descriptors and to do I/O on stdin and stdout.
Everything else - handling of connections, I/O multiplexing (select, poll, epoll), handling socket metadata (getsockname, getpeername) - entierly happens in userland.&lt;br>
In contrast to preeny, libdesock supports multi-threaded applications and its overall design
makes it more resource efficient and 5x faster than preeny.
This has no effect on AFL&amp;rsquo;s exec/s though, since that primarily depends on the program
and the input.&lt;/p>
&lt;p>We have tested libdesock on common network daemons like&lt;/p>
&lt;ul>
&lt;li>nginx&lt;/li>
&lt;li>Apache httpd&lt;/li>
&lt;li>OpenSSH&lt;/li>
&lt;li>Exim&lt;/li>
&lt;li>bind9&lt;/li>
&lt;li>OpenVPN&lt;/li>
&lt;li>Redis&lt;/li>
&lt;li>dnsmasq&lt;/li>
&lt;li>cupsd&lt;/li>
&lt;li>curl (clients are supported too)&lt;/li>
&lt;/ul>
&lt;p>and several smaller applications.&lt;br>
libdesock also supports event libraries like&lt;/p>
&lt;ul>
&lt;li>libevent&lt;/li>
&lt;li>libuv&lt;/li>
&lt;li>libapr-2&lt;/li>
&lt;/ul>
&lt;p>Network applications generally are very complex and require modifications to be fuzzable with AFL.&lt;br>
They use multiple processes and threads, encryption, compression, checksums, hashes
and sometimes custom allocators that don&amp;rsquo;t work with ASAN.
They also run in an endless loop and have a lot of disk I/O (pidfiles, logfiles, temporary files).
Setting these targets up for fuzzing means to reduce the complexity of the applications.
The following example demonstrates the modifications necessary to fuzz &lt;a href="https://security.appspot.com/vsftpd.html">vsftpd&lt;/a>, a popular FTP server on Linux.&lt;/p>
&lt;h2 id="fuzzing-vsftpd">Fuzzing vsftpd&lt;/h2>
&lt;h3 id="getting-the-source">Getting the source&lt;/h3>
&lt;p>Download version 3.0.5 of vsftpd:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">wget https://security.appspot.com/downloads/vsftpd-3.0.5.tar.gz
tar -xf vsftpd-3.0.5.tar.gz
cd vsftpd-3.0.5
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="patching-the-source">Patching the source&lt;/h3>
&lt;p>vsftpd creates a new child process for each connection. We prohibit that
by commenting out the code that does the fork in &lt;code>standalone.c&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -153,6 +153,7 @@ vsf_standalone_main(void)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> child_info.num_this_ip = 0;
p_raw_addr = vsf_sysutil_sockaddr_get_raw_addr(p_accept_addr);
child_info.num_this_ip = handle_ip_count(p_raw_addr);
&lt;span style="color:#a6e22e">+ /*
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> if (tunable_isolate)
{
if (tunable_http_enable &amp;amp;&amp;amp; tunable_isolate_network)
&lt;span style="color:#75715e">@@ -168,6 +169,8 @@ vsf_standalone_main(void)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
new_child = vsf_sysutil_fork_failok();
}
&lt;span style="color:#a6e22e">+ */
&lt;/span>&lt;span style="color:#a6e22e">+ new_child = 0;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> if (new_child != 0)
{
/* Parent context */
&lt;/code>&lt;/pre>&lt;/div>&lt;p>vsftpd duplicates the FTP command socket to stdin, stdout and stderr.
This obviously interfers with AFL so we disable that in &lt;code>defs.h&lt;/code> &amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -3,7 +3,7 @@
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
#define VSFTP_DEFAULT_CONFIG &amp;#34;/etc/vsftpd.conf&amp;#34;
&lt;span style="color:#f92672">-#define VSFTP_COMMAND_FD 0
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+#define VSFTP_COMMAND_FD 29
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span>
#define VSFTP_PASSWORD_MAX 128
#define VSFTP_USERNAME_MAX 128
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip; and in &lt;code>standalone.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -205,9 +205,7 @@ static void
&lt;/span>&lt;span style="color:#75715e">&lt;/span> prepare_child(int new_client_sock)
{
/* We must satisfy the contract: command socket on fd 0, 1, 2 */
&lt;span style="color:#f92672">- vsf_sysutil_dupfd2(new_client_sock, 0);
&lt;/span>&lt;span style="color:#f92672">- vsf_sysutil_dupfd2(new_client_sock, 1);
&lt;/span>&lt;span style="color:#f92672">- vsf_sysutil_dupfd2(new_client_sock, 2);
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+ vsf_sysutil_dupfd2(new_client_sock, VSFTP_COMMAND_FD);
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> if (new_client_sock &amp;gt; 2)
{
vsf_sysutil_close(new_client_sock);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Next, vsftpd enforces a custom memory limit that interfers with ASAN.
We disable the memory limit in &lt;code>sysutil.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -2793,6 +2793,7 @@ void
&lt;/span>&lt;span style="color:#75715e">&lt;/span> vsf_sysutil_set_address_space_limit(unsigned long bytes)
{
/* Unfortunately, OpenBSD is missing RLIMIT_AS. */
&lt;span style="color:#a6e22e">+ return;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> #ifdef RLIMIT_AS
int ret;
struct rlimit rlim;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then we add a forkserver to vsftpd in &lt;code>prelogin.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -59,6 +59,7 @@ init_connection(struct vsf_session* p_sess)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
emit_greeting(p_sess);
}
&lt;span style="color:#a6e22e">+ __AFL_INIT();
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> parse_username_password(p_sess);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>vsftpd registers a &lt;code>SIGCHLD&lt;/code> handler that interfers with the forkserver
so we have to disable that too in &lt;code>standalone.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -74,7 +74,7 @@ vsf_standalone_main(void)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
vsf_sysutil_setproctitle(&amp;#34;LISTENER&amp;#34;);
}
&lt;span style="color:#f92672">- vsf_sysutil_install_sighandler(kVSFSysUtilSigCHLD, handle_sigchld, 0, 1);
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+ //vsf_sysutil_install_sighandler(kVSFSysUtilSigCHLD, handle_sigchld, 0, 1);
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> vsf_sysutil_install_sighandler(kVSFSysUtilSigHUP, handle_sighup, 0, 1);
if (tunable_listen)
{
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Last but not least we disable the &lt;code>bug()&lt;/code> function in &lt;code>utility.c&lt;/code>. This function does a failing &lt;code>fcntl()&lt;/code>
on an fd returned by the desocketing library since the fd is not a real socket. vsftpd handles the &lt;code>fcntl()&lt;/code> failure by calling &lt;code>bug()&lt;/code> again
leading to an infinite loop.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -40,6 +40,7 @@ die2(const char* p_text1, const char* p_text2)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> void
bug(const char* p_text)
{
&lt;span style="color:#a6e22e">+ return;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> /* Rats. Try and write the reason to the network for diagnostics */
vsf_sysutil_activate_noblock(VSFTP_COMMAND_FD);
(void) vsf_sysutil_write_loop(VSFTP_COMMAND_FD, &amp;#34;500 OOPS: &amp;#34;, 10);
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="build-configuration">Build configuration&lt;/h3>
&lt;p>In the &lt;code>Makefile&lt;/code> replace:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -1,16 +1,16 @@
&lt;/span>&lt;span style="color:#75715e">&lt;/span> # Makefile for systems with GNU tools
&lt;span style="color:#f92672">-CC = gcc
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+CC = afl-clang-fast
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> INSTALL = install
IFLAGS = -idirafter dummyinc
#CFLAGS = -g
&lt;span style="color:#f92672">-CFLAGS = -O2 -fPIE -fstack-protector --param=ssp-buffer-size=4 \
&lt;/span>&lt;span style="color:#f92672">- -Wall -W -Wshadow -Werror -Wformat-security \
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+CFLAGS = -fsanitize=address -g -Og -fPIE -fstack-protector \
&lt;/span>&lt;span style="color:#a6e22e">+ -Wall -W -Wshadow -Wformat-security \
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> -D_FORTIFY_SOURCE=2 \
#-pedantic -Wconversion
LIBS = `./vsf_findlibs.sh`
&lt;span style="color:#f92672">-LINK = -Wl,-s
&lt;/span>&lt;span style="color:#f92672">-LDFLAGS = -fPIE -pie -Wl,-z,relro -Wl,-z,now
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+LINK =
&lt;/span>&lt;span style="color:#a6e22e">+LDFLAGS = -fPIE -pie -Wl,-z,relro -Wl,-z,now -fsanitize=address
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span>
OBJS = main.o utility.o prelogin.o ftpcmdio.o postlogin.o privsock.o \
tunables.o ftpdataio.o secbuf.o ls.o \
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="runtime-configuration">Runtime configuration&lt;/h3>
&lt;p>Like most other servers, vsftpd needs a config file. Create
&lt;code>fuzz.conf&lt;/code> with the following contents:&lt;/p>
&lt;pre tabindex="0">&lt;code>listen=YES
seccomp_sandbox=NO
one_process_model=YES
# User management
anonymous_enable=YES
no_anon_password=YES
nopriv_user=nobody
# Permissions
connect_from_port_20=NO
run_as_launching_user=YES
listen_port=2121
listen_address=127.0.0.1
pasv_address=127.0.0.1
# Filesystem interactions
write_enable=NO
download_enable=NO
&lt;/code>&lt;/pre>&lt;h3 id="start-fuzzing">Start fuzzing&lt;/h3>
&lt;p>To use the desocketing library with AFL we need to set the &lt;code>AFL_PRELOAD&lt;/code>
variable.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">export AFL_PRELOAD&lt;span style="color:#f92672">=&lt;/span>libdesock.so
afl-fuzz -i corpus -o findings -m none -- ./vsftpd fuzz.conf
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://lolcads.github.io/2022/02/afl.svg" alt="">&lt;/p>
&lt;p>Now it&amp;rsquo;s only a matter of high-quality custom mutators and time to find some bugs.&lt;/p>
&lt;p>libdesock can be downloaded here: &lt;a href="https://github.com/fkie-cad/libdesock">https://github.com/fkie-cad/libdesock&lt;/a>&lt;/p></content></item></channel></rss>