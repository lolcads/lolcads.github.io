<!doctype html><html lang=en dir=ltr><head><title>How to build a high-performance network fuzzer with LibAFL and libdesock :: lolcads tech blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Introduction Existing network fuzzing solutions struggle on all fronts. Speed is a big problem because they use either real network connections or emulation/virtualization for snapshot-based fuzzing, both of which have a huge overhead. And, they struggle with deeply exploring the target since most of the tools out there are built on top of AFL.
For our vulnerability research, we built a high-performance network fuzzer that tackles these problems and would like to present its setup in this post.
The first issue we addressed was the problem of input generation. We developed our own input representation and mutators that work with text-based protocols. For that we used LibAFL , a library for building custom fuzzers, which made this very easy.
The second problem we approached was how to feed inputs to network applications. For this, we chose to &ldquo;desocket&rdquo; the applications with libdesock and serve the individual packets over a shared memory channel.
We compared our tool to AFLNet , arguably the most popular network fuzzer at the time of writing this, and found that our setup gave us a 42x performance boost, orders of magnitude more coverage and new vulnerabilities in already heavily fuzzed software.
"><meta name=keywords content="lolcads,exploitation,reverse engineering,tech,low-level,analysis,experiments,Linux,Android,Windows"><meta name=robots content="noodp"><link rel=manifest href=/manifest.json><meta property="og:url" content="https://lolcads.github.io/posts/2025/05/high_performance_network_fuzzing/"><meta property="og:site_name" content="lolcads tech blog"><meta property="og:title" content="How to build a high-performance network fuzzer with LibAFL and libdesock"><meta property="og:description" content="We explain how we built a fuzzer for network applications that we tried to make as efficient and as effective as possible. We utilized custom mutators and input passing over shared memory and found that it gave us a huge speed and coverage boost compared to other network fuzzers."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-21T18:32:12+02:00"><meta property="article:modified_time" content="2025-05-21T18:32:12+02:00"><meta property="article:tag" content="Network"><meta property="article:tag" content="Fuzzing"><meta name=twitter:card content="summary"><meta name=twitter:title content="How to build a high-performance network fuzzer with LibAFL and libdesock"><meta name=twitter:description content="We explain how we built a fuzzer for network applications that we tried to make as efficient and as effective as possible. We utilized custom mutators and input passing over shared memory and found that it gave us a huge speed and coverage boost compared to other network fuzzers."><link rel=canonical href=https://lolcads.github.io/posts/2025/05/high_performance_network_fuzzing/><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/index.min.14211377552be17d56465ae537fca1a7e426b22c2c4ba496c85e278aaa470d24.css></head><body class="flex flex-col min-h-screen w-full bg-slate-50 dark:bg-gray-800"><header class="flex flex-none justify-center z-10"><div class="flex flex-row gap justify-between w-full max-w-4xl lg:max-w-5xl h-12 mt-3"><div class="flex-none ml-2 md:ml-0"><a href=/><img class="h-12 w-12 rounded-full object-cover bg-gray-100" src=/logo.png alt=logo></a></div><div class=flex-1></div><div class=flex-none><nav class="h-full static"><button id=navbar-menu-toggle type=button class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg md:hidden" aria-controls=navbar-menu aria-expanded=false>
<span class=sr-only>Open main menu</span>
<i class="w-8 h-8"><svg class="icon icon-tabler icon-tabler-menu-2" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 6h16"/><path d="M4 12h16"/><path d="M4 18h16"/></svg></i></button><div class="absolute md:static top-16 left-0 right-0 z-50 hidden w-full md:block md:w-auto" id=navbar-menu><ul class="flex flex-col mx-2 md:mx-0 md:flex-row md:border-0 rounded-sm md:rounded-full px-3 text-base font-medium text-slate-800 dark:text-slate-200 shadow-lg bg-white dark:bg-gray-600 shadow-slate-800/5 dark:shadow-slate-200/5 ring-1 ring-slate-900/5 dark:ring-slate-100/5"><li id=post><a class="block px-3 py-3 hover:text-emerald-600 text-emerald-600" href=/posts/ title=Blog>Blog</a></li><li id=about><a class="block px-3 py-3 hover:text-emerald-600" href=/about/ title=About>About</a></li><li id=contact><a class="block px-3 py-3 hover:text-emerald-600" href=/contact/ title=Contact>Contact</a></li></ul></div></nav></div><div class="flex-none mx-1"></div><div class="flex-none md:hidden"><a href=/search/ class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg" aria-controls=navbar-menu aria-expanded=false><span class=sr-only>Search</span>
<i class="w-8 h-8"><svg class="icon icon-tabler icon-tabler-search" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 10m-7 0a7 7 0 1014 0A7 7 0 103 10"/><path d="M21 21l-6-6"/></svg></i></a></div><div class="darkmode-toggle flex flex-none mr-2 md:mr-0"><label for=darkmode-toggle class="flex items-center px-3 cursor-pointer rounded-full bg-gray-100 dark:bg-gray-600" title="Toggle dark mode"><input name=darkmode-toggle id=darkmode-toggle type=checkbox class="sr-only peer" aria-label="Toggle dark mode"><div class="group flex flex-row gap-1 justify-center h-8 px-1 rounded-full bg-white dark:bg-gray-700"><i class="h-6 w-6 flex-none rounded-full bg-yellow-400 place-self-center peer-checked:group-[]:invisible"><svg class="icon icon-tabler icon-tabler-brightness-down" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-3 0a3 3 0 106 0 3 3 0 10-6 0"/><path d="M12 5v.01"/><path d="M17 7v.01"/><path d="M19 12v.01"/><path d="M17 17v.01"/><path d="M12 19v.01"/><path d="M7 17v.01"/><path d="M5 12v.01"/><path d="M7 7v.01"/></svg>
</i><i class="h-6 w-6 flex-none rounded-full place-self-center invisible peer-checked:group-[]:visible"><svg class="icon icon-tabler icon-tabler-moon-stars" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 3c.132.0.263.0.393.0a7.5 7.5.0 007.92 12.446A9 9 0 1112 2.992z"/><path d="M17 4a2 2 0 002 2 2 2 0 00-2 2 2 2 0 00-2-2 2 2 0 002-2"/><path d="M19 11h2m-1-1v2"/></svg></i></div></label></div></div></header><main class="flex flex-auto justify-center"><div class="w-full max-w-4xl lg:max-w-5xl"><div class="flex flex-col mt-6 mx-2 md:mx-0 rounded-lg overflow-hidden shadow-md bg-white dark:bg-gray-700"><div><a href=/posts/2025/05/high_performance_network_fuzzing/></a></div><div class="flex flex-col gap-y-3 p-6"><h1 class="text-4xl font-semibold text-slate-800 dark:text-slate-100"><a href=/posts/2025/05/high_performance_network_fuzzing/>How to build a high-performance network fuzzer with LibAFL and libdesock</a></h1><h2 class="my-4 text-large text-slate-600 dark:text-slate-300">We explain how we built a fuzzer for network applications that we tried to make as efficient and as effective as possible. We utilized custom mutators and input passing over shared memory and found that it gave us a huge speed and coverage boost compared to other network fuzzers.</h2><ul class="flex flex-row flex-wrap text-slate-500 dark:text-slate-300"><li><a href=/tags/network/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Network</span></a></li><li><a href=/tags/fuzzing/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Fuzzing</span></a></li></ul><div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300"><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-calendar" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 7a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V7z"/><path d="M16 3v4"/><path d="M8 3v4"/><path d="M4 11h16"/><path d="M11 15h1"/><path d="M12 15v3"/></svg>
</i><time datetime=2025-05-21T18:32:12+02:00>2025-05-21</time></div><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-hourglass-high" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6.5 7h11"/><path d="M6 20v-2a6 6 0 1112 0v2a1 1 0 01-1 1H7a1 1 0 01-1-1z"/><path d="M6 4v2a6 6 0 1012 0V4a1 1 0 00-1-1H7A1 1 0 006 4z"/></svg>
</i><span>5 minutes to read</span></div></div><div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300"><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-user"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M8 7a4 4 0 108 0A4 4 0 008 7"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
</i><span>Patrick Detering</span></div></div><section class="prose prose-slate dark:prose-invert w-full max-w-4xl lg:max-w-5xl mt-6"><h2>Table of Contents</h2><aside><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#writing-a-custom-fuzzer>Writing a Custom Fuzzer</a></li><li><a href=#implementing-fast-message-passing>Implementing Fast Message Passing</a></li><li><a href=#reaping-the-results>Reaping the Results</a></li></ul></nav></aside></section><article class="mt-6 w-full max-w-4xl lg:max-w-5xl prose prose-slate dark:prose-invert prose-quoteless post-content"><h2 id=introduction>Introduction</h2><p>Existing network fuzzing solutions struggle on all fronts.
Speed is a big problem because they use either real network connections or
emulation/virtualization for snapshot-based fuzzing, both of which have a
huge overhead.
And, they struggle with deeply exploring the target since most of
the tools out there are built on top of AFL.<br>For our vulnerability research, we built a high-performance network fuzzer
that tackles these problems and would like to present its setup in this post.<br>The first issue we addressed was the problem of input generation. We developed
our own input representation and mutators that work with text-based protocols.
For that we used <a href=https://github.com/AFLplusplus/LibAFL target=_blank rel=noopener>LibAFL</a>
, a library for building custom fuzzers, which made
this very easy.<br>The second problem we approached was how to feed inputs to network applications.
For this, we chose to &ldquo;desocket&rdquo; the applications with <a href=https://github.com/fkie-cad/libdesock target=_blank rel=noopener>libdesock</a>
and serve
the individual packets over a shared memory channel.<br>We compared our tool to <a href=https://github.com/aflnet/aflnet target=_blank rel=noopener>AFLNet</a>
, arguably the most popular network fuzzer at
the time of writing this, and found that our setup gave us a 42x performance boost,
orders of magnitude more coverage and new vulnerabilities in already heavily
fuzzed software.</p><h2 id=writing-a-custom-fuzzer>Writing a Custom Fuzzer</h2><p>If we want to find bugs we need to emancipate ourselves from off-the-shelf tools like AFL.<br>Let&rsquo;s have a look at this message exchange in the FTP protocol that is used to establish
a connection for data transmission:</p><pre tabindex=0><code>&gt; PORT 192,168,1,178,12,34
&lt; 200 Okay
</code></pre><p>What could be sensible ways to mutate this message? Do we just want to fuzz the message parser
or could some mutations exercise the application logic on a higher level?<br>Perhaps we could replace the numbers in the command with other numbers like <code>-1</code>, <code>127</code> or <code>4294967295</code>.
Or, we could replace the <code>PORT</code> command with another command.
Or, we could try if <code>PORT</code> takes other arguments by inserting more text separated by spaces.
Either way, our fuzzer needs meaningful text-based mutations and an input representation that enables them.</p><p>Our approach was to represent individual messages of a protocol as a stream of tokens, i.e. a <code>TokenStream</code>,
where a <code>Token</code> is either a <code>Number</code>, <code>Whitespace</code>, or <code>Text</code>.
The <code>PORT</code> command above would be parsed as:</p><pre tabindex=0><code>TokenStream([
  Text(&#34;PORT&#34;),
  Whitespace(&#34; &#34;),
  Number(&#34;192&#34;),
  Text(&#34;,&#34;),
  Number(&#34;168&#34;),
  ...
  Whitespace(&#34;\r\n&#34;),
])
</code></pre><p>This enables our mutators to have some sense of &ldquo;awareness&rdquo;, i.e. the
ability to operate on entire meaningful, semantic units of text. Now
we can individually mutate the numbers, the command, entire arguments,
and much more while still being low-level enough to just flip some bits
in the text.<br>Then we can get to the next level of our input representation.
Since network protocols are a back and forth of multiple messages, our
input needs to be a sequence of <code>TokenStream</code>s, not just a single one.
In Rust, this is very easy to implement. We simply define our data types&mldr;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rs data-lang=rs><span class=line><span class=cl><span class=k>enum</span> <span class=nc>TextToken</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Number</span><span class=p>(</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Whitespace</span><span class=p>(</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Text</span><span class=p>(</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>TokenStream</span><span class=p>(</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>TextToken</span><span class=o>&gt;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>PacketBasedInput</span><span class=p>(</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>TokenStream</span><span class=o>&gt;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>&mldr;and plug the <code>PacketBasedInput</code> into our fuzzer without hassle, thanks to LibAFL.<br>The rest of the fuzzer is kept very simple: No powerschedules, mutation scheduling,
compare coverage or extra feedback about the protocol state.</p><h2 id=implementing-fast-message-passing>Implementing Fast Message Passing</h2><p>Now we have a good method for input generation but we don&rsquo;t want to sacrifice efficiency for effectiveness.
In other words: We need a high-performance method of transmitting fuzz input to the application.
And this is where our desocketing library <a href=https://github.com/fkie-cad/libdesock target=_blank rel=noopener>libdesock</a>
comes into play.<br>With the <a href=https://lolcads.github.io/posts/2022/02/libdesock/ target=_blank rel=noopener>desocketing approach</a>
, we can hook the network functions of the target and handle
network I/O that would otherwise be delegated to the kernel in userspace.
Normally desocketing libraries redirect <code>recv()</code>&rsquo;s on network sockets to some other input channel like stdin
but libdesock allows us to customize this behavior and implement our own input channel.
We chose to use shared memory because it has by far the lowest overhead of all IPC methods.</p><p>We made use of the <a href=https://github.com/fkie-cad/libdesock/blob/main/src/hooks.c target=_blank rel=noopener><em>hooks</em></a>
feature of libdesock and quickly wrote
our own <em>input hook</em> in less than 50 lines of C code that attaches to the shared memory channel and copies its data to the
application whenever requested:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Set by the fuzzer in each iteration:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>cursor</span><span class=p>;</span> <span class=c1>// set to 0 for each new input
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>size_t</span> <span class=n>size</span><span class=p>;</span> <span class=c1>// length of fuzz input
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span> <span class=n>data</span><span class=p>[];</span> <span class=c1>// fuzz input
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>PacketBuffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>PacketBuffer</span><span class=o>*</span> <span class=n>packet_buffer</span> <span class=o>=</span> <span class=cm>/* points to shm */</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Called whenever a read on a network connection occurs.
</span></span></span><span class=line><span class=cl><span class=c1>// We place `size` bytes from the shm channel into `buf`.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>size_t</span> <span class=nf>hook_input</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span> <span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>cursor</span> <span class=o>=</span> <span class=n>packet_buffer</span><span class=o>-&gt;</span><span class=n>cursor</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>rem_bytes</span> <span class=o>=</span> <span class=n>packet_buffer</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>-</span> <span class=n>cursor</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>size</span> <span class=o>=</span> <span class=p>(</span><span class=n>size</span> <span class=o>&lt;</span> <span class=n>rem_bytes</span><span class=p>)</span> <span class=o>?</span> <span class=nl>size</span> <span class=p>:</span> <span class=n>rem_bytes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nf>memcpy</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>packet_buffer</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>[</span><span class=n>cursor</span><span class=p>],</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>packet_buffer</span><span class=o>-&gt;</span><span class=n>cursor</span> <span class=o>+=</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>You might ask yourself how multiple messages are handled since we are just dealing with one flat shared memory buffer.<br>The <code>Token</code>s of a <code>TokenStream</code> in a <code>PacketBasedInput</code> get concatenated to create a single message.
Then, the individual messages get separated by the string <code>--------</code>, which is understood by libdesock.
libdesock automatically detects this separator and feeds input to the application one message at a time.
For example, a valid SMTP transaction to send an E-Mail looks like this:</p><pre tabindex=0><code>EHLO fuzz
--------
AUTH PLAIN
--------
AHRlc3QAdGVzdA==
--------
MAIL FROM:&lt;fuzzer@localhost&gt;
--------
RCPT TO:&lt;user@localhost&gt;
--------
DATA
--------
&lt;email content here&gt;
.
--------
QUIT
</code></pre><h2 id=reaping-the-results>Reaping the Results</h2><p>We did some network fuzzing with AFLNet and our tool.<br>With AFLNet we got around ~30 exec/s on one core and were not able to utilize multiple cores for fuzzing.
With our fuzzer, we got around ~1200 exec/s pro core and were able to utilize multicore-fuzzing with linear
scaling (!), which came as a surprise to us since our targets were very syscall-heavy.
Overall we got hundreds of lines more coverage and found multiple bugs in already heavily fuzzed code.</p><p>The lesson we learned is that if we want to find bugs, we can&rsquo;t just rely on off-the-shelf
fuzzers. A fuzzing solution that gave us an edge was not as far away as we thought.
Even with a little bit of effort we got substantial performance increases.</p><p>If you&rsquo;re interested in the implementation details, you can find our fuzzer <a href=https://github.com/pd-fkie/exim-fuzzer target=_blank rel=noopener>here</a>
on Github.</p><p>Thanks for reading!</p></article></div></div></div></main><footer class="flex flex-none justify-center"><section class="flex flex-col md:flex-row mx-2 md:mx-0 gap-2 md:gap-0 justify-between w-full max-w-4xl lg:max-w-5xl py-6 text-slate-500 dark:text-slate-300"><div class="flex flex-row"></div><div class=grow></div><div class="flex flex-row"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-copyright" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-9 0a9 9 0 1018 0A9 9 0 103 12"/><path d="M14 9.75a3.016 3.016.0 00-4.163.173 2.993 2.993.0 000 4.154A3.016 3.016.0 0014 14.25"/></svg>
</i>2022 - 2025 lolcads</div><div class="flex flex-row"><span class="ml-0 pl-0 md:ml-2 md:pl-2 border-l-0 md:border-l border-slate-300 dark:border-slate-400">Powered by <a href=https://gohugo.io target=_blank rel=noopener class=underline>Hugo</a> <span class=text-red-600>&#9829;</span> <a href=https://github.com/tomowang/hugo-theme-tailwind target=_blank rel=noopener class=underline>Tailwind</a></span></div></section></footer><script src=/main.min.c6372b6836971865bd94bfde974748aca8415824a2facab6ccd66a87384bfacb.js></script><div class="hidden top-1 right-1" id=code-copy><i class="h-6 w-6 block"><svg class="icon icon-tabler icon-tabler-copy" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667A2.667 2.667.0 019.667 7h8.666A2.667 2.667.0 0121 9.667v8.666A2.667 2.667.0 0118.333 21H9.667A2.667 2.667.0 017 18.333z"/><path d="M4.012 16.737A2.005 2.005.0 013 15V5c0-1.1.9-2 2-2h10c.75.0 1.158.385 1.5 1"/></svg></i></div><div class="hidden top-1 right-1" id=code-copy-done><i class="h-6 w-6 block"><svg class="icon icon-tabler icon-tabler-check" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 12l5 5L20 7"/></svg></i></div><script src=/code-copy.min.e7b2a74adef1ed474c335c8bd5e7832b2316b8842b0f9184d65286c5bd64f51a.js></script></body></html>