<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on lolcads tech blog</title><link>https://lolcads.github.io/posts/</link><description>Recent content in Posts on lolcads tech blog</description><generator>Hugo</generator><language>en</language><managingEditor>lolcads@posteo.net (lolcads)</managingEditor><webMaster>lolcads@posteo.net (lolcads)</webMaster><copyright>lolcads</copyright><lastBuildDate>Wed, 21 May 2025 18:32:12 +0200</lastBuildDate><atom:link href="https://lolcads.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>How to build a high-performance network fuzzer with LibAFL and libdesock</title><link>https://lolcads.github.io/posts/2025/05/high_performance_network_fuzzing/</link><pubDate>Wed, 21 May 2025 18:32:12 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2025/05/high_performance_network_fuzzing/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>Existing network fuzzing solutions struggle on all fronts.
Speed is a big problem because they use either real network connections or
emulation/virtualization for snapshot-based fuzzing, both of which have a
huge overhead.
And, they struggle with deeply exploring the target since most of
the tools out there are built on top of AFL.&lt;br>
For our vulnerability research, we built a high-performance network fuzzer
that tackles these problems and would like to present its setup in this post.&lt;br>
The first issue we addressed was the problem of input generation. We developed
our own input representation and mutators that work with text-based protocols.
For that we used &lt;a href="https://github.com/AFLplusplus/LibAFL" target="_blank" rel="noopener">LibAFL&lt;/a>
, a library for building custom fuzzers, which made
this very easy.&lt;br>
The second problem we approached was how to feed inputs to network applications.
For this, we chose to &amp;ldquo;desocket&amp;rdquo; the applications with &lt;a href="https://github.com/fkie-cad/libdesock" target="_blank" rel="noopener">libdesock&lt;/a>
 and serve
the individual packets over a shared memory channel.&lt;br>
We compared our tool to &lt;a href="https://github.com/aflnet/aflnet" target="_blank" rel="noopener">AFLNet&lt;/a>
, arguably the most popular network fuzzer at
the time of writing this, and found that our setup gave us a 42x performance boost,
orders of magnitude more coverage and new vulnerabilities in already heavily
fuzzed software.&lt;/p></description></item><item><title>Outsmarting the Watchdog: How can Adversaries evade Sigma Rule Detection during a Kerberos Golden Ticket Attack?</title><link>https://lolcads.github.io/posts/2025/01/evadingsigma/</link><pubDate>Tue, 14 Jan 2025 10:00:00 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2025/01/evadingsigma/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>In the face of increasing amounts of cyber threats, organizations employ security information and event management (SIEM) systems as a way to collect and analyze information at a central place to detect and counteract against potential cyberattacks.
One common way to detect malicious behavior using this information are &lt;a href="https://sigmahq.io/docs/basics/rules.html" target="_blank" rel="noopener">Sigma rules&lt;/a>
 and the corresponding Sigma detection format.
Given that these rules are open source, attackers can check if their behavior is detected by them and might try to obfuscate their attacks to evade detection, e.g., by adapting used commands.
Thus, it is important that these rules are robust to changes of the detected behavior - both malicious but also accidental.&lt;/p></description></item><item><title>coderec: Detecting Machine Code in Binary Files</title><link>https://lolcads.github.io/posts/2024/11/coderec/</link><pubDate>Mon, 25 Nov 2024 10:37:07 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/11/coderec/</guid><description>&lt;p>Firmware reverse engineering comes with some unique challenges compared to the
reversing of programs that run in the user space of some mainstream operating
system. You will encounter one of them before Ghidra&amp;rsquo;s Code Browser even opens.
Let&amp;rsquo;s illustrate it at a concrete example: I recently got myself some old Cisco
devices off eBay as I was curious to have a look at their proprietary IOS
operating system. However, when loading the IOS image into Ghidra&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> you are
greeted with the following screen:&lt;/p></description></item><item><title>Towards utilizing BTF Information in Linux Memory Forensics</title><link>https://lolcads.github.io/posts/2024/11/btf2json/</link><pubDate>Wed, 13 Nov 2024 12:38:49 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/11/btf2json/</guid><description>&lt;p>This post is about some work that I did on automatic profile generation for memory forensics of Linux systems. To be upfront about it: This work is somewhat half-finished &amp;ndash; it already does something quite useful, but it could do a lot more, and it has not been evaluated thoroughly enough to be considered &amp;ldquo;production ready&amp;rdquo;. The reason I decided to publish it anyway is that I believe that there is an interesting opportunity to change the way in which we generate profiles for the analysis of Linux memory images &lt;em>in practice&lt;/em>. However, in order for it to become a production tool, at least one outstanding problem has to be addressed (I have some ideas on that one) and lots of coding work needs to be done &amp;ndash; and I simply do not have the resources to work on that right now.&lt;/p></description></item><item><title>Adversary Emulation is a Complicated Profession - Intelligent Cyber Adversary Emulation with the Bounty Hunter</title><link>https://lolcads.github.io/posts/2024/09/bountyhunter/</link><pubDate>Thu, 12 Sep 2024 10:00:00 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/09/bountyhunter/</guid><description>&lt;h2 id="cyber-adversary-emulation">Cyber Adversary Emulation&lt;/h2>
&lt;p>Cyber adversary emulation is an assessment method where tactis, techniques, and procedures (TTPs) of real-world attackers are used to test the security controls of a system.
It helps to understand how an attacker might penetrate defenses, to evaluate installed security mechanisms and to improve the security posture by addressing identified weaknesses.
Furthermore, it allows running training scenarios for security professionals, e.g., in cyber ranges where practical exercises can be performed.
Unfortunately, adversary emulation requires significant time, effort, and specialized professionals to conduct.&lt;/p></description></item><item><title>Bytecode Reuse Attack (Part 4)</title><link>https://lolcads.github.io/posts/2024/09/bytecode_exploitation_3/</link><pubDate>Tue, 10 Sep 2024 09:25:28 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/09/bytecode_exploitation_3/</guid><description>&lt;h1 id="bytecode-reuse-attack-part-4">Bytecode Reuse Attack (Part 4)&lt;/h1>
&lt;p>As last blog post on bytecode - based exploitation on Android, the next step following bytecode injection is discussed, namely: &lt;em>bytecode reuse&lt;/em>.&lt;/p>
&lt;p>To answer the question about &lt;em>why&lt;/em> an attacker needs bytecode reuse, although there already is bytecode injection, remember the &lt;em>arms race&lt;/em> in (binary) exploitation. In a nutshell, a new exploitation technique triggers a reaction in form of at least one security mechanism that (partially) mitigates the new technique. If only bytecode injection was researched, then the best response would be the development of a new security mechanism that prevents &lt;code>nterp&lt;/code> from executing arbitrary data. In other words, &lt;code>nterp&lt;/code> would be restricted to &lt;em>executable code&lt;/em>, i.e. bytecode. To be honest, every developer would respond with such a fix, myself included! However, bytecode injection is not the full potential of bytecode - based exploitation.&lt;/p></description></item><item><title>Bytecode Injection (Part 3)</title><link>https://lolcads.github.io/posts/2024/09/bytecode_exploitation_2/</link><pubDate>Tue, 10 Sep 2024 09:20:53 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/09/bytecode_exploitation_2/</guid><description>&lt;h1 id="bytecode-injection-part-3">Bytecode Injection (Part 3)&lt;/h1>
&lt;p>With all the basics out of the way, this blog post shows the first bytecode - based exploitation technique on Android: &lt;em>bytecode injection&lt;/em>! This opens the door to many interesting exploits, where injected bytecode can function as a one - in - all solution or an intermediate stage.&lt;/p>
&lt;p>In order to fully understand this technique, it is recommended to read the introductory blog posts first! As of writing, there is no public information on this topic except for the Android source code.&lt;/p></description></item><item><title>Fundamentals for Bytecode Exploitation (Part 2)</title><link>https://lolcads.github.io/posts/2024/09/bytecode_exploitation_1/</link><pubDate>Tue, 10 Sep 2024 09:17:43 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/09/bytecode_exploitation_1/</guid><description>&lt;h1 id="fundamentals-for-bytecode-exploitation-part-2">Fundamentals for Bytecode Exploitation (Part 2)&lt;/h1>
&lt;p>Exploiting a vulnerability always requires a certain knowledge about the operating system, including how processes are launched, what libraries are used and how control - flow &amp;ldquo;works&amp;rdquo;. While the latter could be considered coming from the architecture, this is not always the case on Android, because the &lt;em>Android RunTime&lt;/em> (ART) provides ways to call bytecode methods and redirect bytecode control - flow. Hence, ART dictates how bytecode control - flow works, not directly the underlying CPU. Understanding the above mechanisms is the minimal requirement for understanding bytecode - based exploitation. Based on that, more sophisticated analysis techniques can be built specifically for Android bytecode, to make bytecode - based exploitation feasible.&lt;/p></description></item><item><title>Introduction to Android Bytecode Exploitation (Part 1)</title><link>https://lolcads.github.io/posts/2024/09/bytecode_exploitation_0/</link><pubDate>Tue, 10 Sep 2024 09:11:56 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/09/bytecode_exploitation_0/</guid><description>&lt;h1 id="introduction-to-android-bytecode-exploitation-part-1">Introduction to Android Bytecode Exploitation (Part 1)&lt;/h1>
&lt;p>Android resides among the most popular operating systems for mobile devices, which causes Android to also be among the most popular targets for exploitation. While Android is frequently updated to fix the latest CVEs, malicious actors already search for new vulnerabilities, as gaining control over millions of computationally powerful devices is very appealing. The market shares underpin that Android is by far the most lucrative platform for malicious actors targeting mobile platforms.&lt;/p></description></item><item><title>Timing Attack Experiments against Scudo (Part 2)</title><link>https://lolcads.github.io/posts/2024/07/scudo_1/</link><pubDate>Fri, 26 Jul 2024 16:46:21 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/07/scudo_1/</guid><description>&lt;h1 id="attempting-timing-attacks-against-scudo">Attempting Timing Attacks against &lt;em>Scudo&lt;/em>&lt;/h1>
&lt;p>In this second blog post we will take a different approach for attacking &lt;a href="https://cs.android.com/android/platform/superproject/&amp;#43;/android-12.0.0_r31:external/scudo/;bpv=0;bpt=0" target="_blank" rel="noopener">&lt;em>Scudo&lt;/em>&lt;/a>
, i.e. we will try to the measure execution times for calls to &lt;code>malloc&lt;/code> and hope to be able to derive a portion of the internal state of the allocator (i.e. perform side channel attacks). The version of Scudo considered in this blog post is &lt;a href="https://cs.android.com/android/platform/superproject/&amp;#43;/android-12.0.0_r31:external/scudo/METADATA;l=19;drc=45e1036faa0dcfa30a01982880be1137d441333d" target="_blank" rel="noopener">&lt;code>161cca266a9d0b6deb5f1fd2de8ad543649a7fa1&lt;/code>&lt;/a>
.&lt;/p>
&lt;p>There will be almost only negative results (which means I unfortunately could not make it work), except for one. The main conclusion we can draw from this post is that &lt;em>Scudo&lt;/em> is &lt;strong>not&lt;/strong> designed to mitigate timing attacks! This follows from trying to leak a piece of information and then accidentally leaking a different and unclassified piece.&lt;/p></description></item><item><title>Scudo, the Allocator (Part 1)</title><link>https://lolcads.github.io/posts/2024/07/scudo_0/</link><pubDate>Thu, 25 Jul 2024 16:46:21 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/07/scudo_0/</guid><description>&lt;h1 id="binary-exploitation-for-scudo-heap-allocator-on-android">Binary Exploitation for &lt;em>Scudo Heap Allocator&lt;/em> on Android&lt;/h1>
&lt;p>In this series of blog posts, we will investigate how an attacker may leverage the internals of the &lt;a href="https://cs.android.com/android/platform/superproject/&amp;#43;/android-12.0.0_r31:external/scudo/standalone/" target="_blank" rel="noopener">&lt;em>Scudo Allocator&lt;/em>&lt;/a>
 in order to obtain an advantage on an Android OS. To that end, necessary prerequisites will be discussed and analysed for their likelihood. The focus will primarily be on &lt;a href="https://cs.android.com/android/platform/superproject/&amp;#43;/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=57" target="_blank" rel="noopener">&lt;code>malloc&lt;/code>&lt;/a>
 and &lt;a href="https://cs.android.com/android/platform/superproject/&amp;#43;/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=35" target="_blank" rel="noopener">&lt;code>free&lt;/code>&lt;/a>
, although &lt;a href="https://cs.android.com/android/platform/superproject/&amp;#43;/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=122" target="_blank" rel="noopener">&lt;code>realloc&lt;/code>&lt;/a>
 and other functions may also be of interest. According to &lt;a href="https://cs.android.com/android/platform/superproject/&amp;#43;/android-12.0.0_r31:external/scudo/METADATA;l=19;drc=45e1036faa0dcfa30a01982880be1137d441333d" target="_blank" rel="noopener">source code&lt;/a>
, the Scudo version considered in this blog is &lt;code>161cca266a9d0b6deb5f1fd2de8ad543649a7fa1&lt;/code>.&lt;/p></description></item><item><title>E²VA: Use After Free Write/Execute Module (Part 4)</title><link>https://lolcads.github.io/posts/2024/07/eva_3/</link><pubDate>Wed, 24 Jul 2024 16:46:21 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/07/eva_3/</guid><description>&lt;h1 id="exploitation-of-use---after---free-modules">Exploitation of &lt;em>Use - After - Free&lt;/em> Modules&lt;/h1>
&lt;p>In this post we will be discussing how to exploit a &lt;em>Use - After - Free&lt;/em> bug in both &lt;em>UseAfterFreeExecModule&lt;/em> and &lt;em>UseAfterFreeWriteModule&lt;/em>. As the names of the modules suggest, they differ in terms of the impact the bug has. To that end, in &lt;em>UseAfterFreeExecModule&lt;/em> we will be able to control a function pointer, whereas in &lt;em>UseAfterFreeWriteModule&lt;/em> we are given a &lt;em>Write - What - Where&lt;/em> condition.&lt;/p></description></item><item><title>E²VA: Stack Buffer Overflow Module (Part 3)</title><link>https://lolcads.github.io/posts/2024/07/eva_2/</link><pubDate>Tue, 23 Jul 2024 16:46:21 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/07/eva_2/</guid><description>&lt;h1 id="exploitation-of-easystackbufferoverflowmodule">Exploitation of &lt;em>EasyStackBufferOverflowModule&lt;/em>&lt;/h1>
&lt;p>This article describes exploitation of the &lt;em>EasyStackBufferOverflowModule&lt;/em>. During exploitation, various Android - specific caveats are discussed.&lt;/p>
&lt;h2 id="assumptions">Assumptions&lt;/h2>
&lt;p>We will assume that we have successfully grabbed a copy of the &lt;code>.apk&lt;/code> file of &lt;em>damnvulnerableapp&lt;/em>. Also, we will &lt;strong>not&lt;/strong> discuss how to unpack an &lt;code>.apk&lt;/code> file, but rather assume that we have access to &lt;code>libEasyStackBufferOverflowModule.so&lt;/code> and the &lt;code>EasyStackBufferOverflowModule&lt;/code> class. If it is unclear how to get access to these components when only given an &lt;code>.apk&lt;/code> file, read the previous blog posts first!&lt;/p></description></item><item><title>E²VA: Android Basics (Part 2)</title><link>https://lolcads.github.io/posts/2024/07/eva_1/</link><pubDate>Mon, 22 Jul 2024 16:46:21 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/07/eva_1/</guid><description>&lt;h1 id="android-binary-exploitation">Android Binary Exploitation&lt;/h1>
&lt;p>In this post, we will examine security mechanisms that Android 12 employs in order to make binary exploitation a bit harder. Also, we will discuss how to get to certain information like shared - object files that are necessary for successful exploitation. The latter will be generalized to getting limited source code access to an app given a corresponding &lt;code>.apk&lt;/code> file.&lt;/p>
&lt;h2 id="environment">Environment&lt;/h2>
&lt;p>Before diving into details, the technical setup has to be clarified. All of the following observations on security mechanisms were encountered on a x86_64 Pixel 3 emulator running Android 12 (build number is &lt;a href="https://source.android.com/docs/setup/about/build-numbers#build-ids-defined" target="_blank" rel="noopener">&lt;code>SE1A.220203.002.A1&lt;/code>&lt;/a>
). When referencing source code from &lt;em>Android Open Source Project&lt;/em> (AOSP), it will be w.r.t. &lt;a href="https://cs.android.com/android/platform/superproject/&amp;#43;/android-12.0.0_r31:" target="_blank" rel="noopener">Android 12.0.0_r31&lt;/a>
. The build variant for &lt;em>damnvulnerableapp&lt;/em> is currently only &lt;code>debug&lt;/code>. Also there is no GooglePlay enabled as we require root on the device for debugging purposes only.&lt;/p></description></item><item><title>*PowerView* is evil, but *PowerVi* and *ew* are legit, right? - Missing signature-based detections due to PowerShell Script Block Logging Fragmentation</title><link>https://lolcads.github.io/posts/2024/04/psscriptblockfragmentation/</link><pubDate>Mon, 15 Apr 2024 11:01:40 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2024/04/psscriptblockfragmentation/</guid><description>&lt;h1 id="powerview-is-evil-but-powervi-and-ew-are-legit-right---missing-signature-based-detections-due-to-powershell-script-block-logging-fragmentation">&lt;em>PowerView&lt;/em> is evil, but &lt;em>PowerVi&lt;/em> and &lt;em>ew&lt;/em> are legit, right? - Missing signature-based detections due to PowerShell Script Block Logging Fragmentation&lt;/h1>
&lt;h2 id="update-15082024">Update [15/08/2024]:&lt;/h2>
&lt;p>In a &lt;a href="https://x.com/nas_bench/status/1806253324456403316" target="_blank" rel="noopener">short discussion on X&lt;/a>
 the source code of the PowerShell Script Block Fragmentation was &lt;a href="https://github.com/PowerShell/PowerShell/blob/7ec8e4ed8f47e81e70de5353500f8a01d5fe396c/src/System.Management.Automation/engine/runtime/CompiledScriptBlock.cs#L1451-L1454" target="_blank" rel="noopener">linked&lt;/a>
.
Looking at the comment in the code, it becomes clear that the size of a script block fragment is intentionally set to a random value in order to deny attackers the easy possibility to split their scripts as they wish.
If a script block is larger than 20000 (Unicode) characters, it is split into fragments with sizes 10000 plus a random value between 0 and 10000 - resulting in script block sizes from 10000 to 20000 characters.
Further research is needed to answer the question if and how the fragmentation of PowerShell script blocks can still be exploited.&lt;/p></description></item><item><title>BPF Memory Forensics with Volatility 3</title><link>https://lolcads.github.io/posts/2023/12/bpf_memory_forensics_with_volatility3/</link><pubDate>Thu, 21 Dec 2023 13:47:46 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2023/12/bpf_memory_forensics_with_volatility3/</guid><description>&lt;h1 id="bpf-memory-forensics-with-volatility-3">BPF Memory Forensics with Volatility 3&lt;/h1>
&lt;h2 id="introduction-and-motivation">Introduction and Motivation&lt;/h2>
&lt;p>Have you ever wondered how an eBPF rootkit looks like? Well, here&amp;rsquo;s one, have a good look:&lt;/p>
&lt;p>&lt;div class="not-prose">
&lt;figure>
 &lt;img src="https://lolcads.github.io/2023/12/ubuntu-20.04-LTS-focal-ebpfkit.png"
 alt="ubuntu-20.04-LTS-focal-ebpfkit.png" 
 loading="lazy"
 >
 &lt;/figure>&lt;/div>
&lt;/p>
&lt;p>Upon receiving a command and control (C2) request, this specimen can execute arbitrary commands on the infected machine, exfiltrate sensitive files, perform passive and active network discovery scans (like &lt;code>nmap&lt;/code>), or provide a privilege escalation backdoor to a local shell. Of course, it&amp;rsquo;s also trying its best to hide itself from system administrators hunting it with different command line tools such as &lt;code>ps&lt;/code>, &lt;code>lsof&lt;/code>, &lt;code>tcpdump&lt;/code> an others or even try tools like &lt;code>rkhunter&lt;/code> or &lt;code>chkrootkit&lt;/code>.&lt;/p></description></item><item><title>Diving into the art of userspace exploitation under Android - Introducing E²VA (Part 1)</title><link>https://lolcads.github.io/posts/2022/11/diving_into_the_art_of_userspace_exploitation_under_android/</link><pubDate>Mon, 21 Nov 2022 18:54:42 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2022/11/diving_into_the_art_of_userspace_exploitation_under_android/</guid><description>&lt;h1 id="investigating-binary-exploitation-for-jni-on-android">Investigating Binary Exploitation for JNI on Android&lt;/h1>
&lt;p>This post aims to be an introduction into a blog series about binary exploitation on Android. It tries to describe how the environment that runs vulnerable modules is set up and how the &lt;em>damnvulnerableapp&lt;/em> supports the process of binary exploitation on Android.&lt;/p>
&lt;h2 id="warning">Warning&lt;/h2>
&lt;p>The following app is intended to be vulnerable to specific attacks and can result in arbitrary code execution in the context of the app. Therefore, beware of this and do not use this app on a device/emulator that contains personal information whatsoever. Always launch the app in a controlled environment. &lt;strong>No authentication&lt;/strong> is necessary to connect to the app and talk to vulnerable modules. Assuming the app is free of bugs, there is a guarantee that only one client can connect at a time.&lt;/p></description></item><item><title>friTap - Decrypting TLS on the fly</title><link>https://lolcads.github.io/posts/2022/08/fritap/</link><pubDate>Fri, 12 Aug 2022 13:09:24 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2022/08/fritap/</guid><description>&lt;h2 id="encryption---a-curse-and-a-blessing-at-the-same-time">Encryption - a curse and a blessing at the same time&lt;/h2>
&lt;p>Digital communication in today&amp;rsquo;s world has a particularly high status in our society. Financial transactions are conducted via online banking, private communication is increasingly limited to digital messenger services, and even health data is experiencing a shift to digital form. Due to the growth of such sensitive digital data, the need for secure transmission of such data has become increasingly important over the past decades. With the introduction of high-performance and digitally secure cryptographic methods, such as SSL/TLS, today&amp;rsquo;s digital communications are predominantly encrypted. Whereas back then, for example, an attacker could hang himself between the client and the server and read the data traffic without encryption, today all he sees is a jumble of letters.
Encryption is truly a boon for protecting sensitive personal data, but it also has its drawbacks, as with almost everything. Encrypted communications negate the ability to analyze communications, which is very relevant when reverse engineering malware or researching vulnerabilities.&lt;/p></description></item><item><title>Make Frida Great Again</title><link>https://lolcads.github.io/posts/2022/07/make_frida_great_again/</link><pubDate>Thu, 28 Jul 2022 13:29:30 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2022/07/make_frida_great_again/</guid><description>&lt;h1 id="make-frida-great-again">Make Frida Great Again&lt;/h1>
&lt;p>In order to analyse binaries on e.g. Android systems, one is offered a plethora of tools to use to figure out what a binary is doing, whether it is malicious or just buggy. One way to figure out the behaviour of a binary is to utilise the strength of dynamic analysis. Under linux, i.e. Android in particular, &lt;a href="https://frida.re" target="_blank" rel="noopener">Frida&lt;/a>
 is a tool that is used for automated instrumentation of binaries, to inspect memory, function calls etc.&lt;/p></description></item><item><title>Exploration of the Dirty Pipe Vulnerability (CVE-2022-0847)</title><link>https://lolcads.github.io/posts/2022/06/dirty_pipe_cve_2022_0847/</link><pubDate>Mon, 06 Jun 2022 19:57:03 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2022/06/dirty_pipe_cve_2022_0847/</guid><description>&lt;h2 id="intro">Intro&lt;/h2>
&lt;p>This blog post reflects our exploration of the Dirty Pipe Vulnerability in the Linux kernel. The bug was discovered by Max Kellermann and described &lt;a href="https://dirtypipe.cm4all.com/" target="_blank" rel="noopener">here&lt;/a>
. If you haven&amp;rsquo;t read the original publication yet, we&amp;rsquo;d suggest that you read it first (maybe also twice ;)). While Kellermann&amp;rsquo;s post is a great resource that contains all the relevant information to understand the bug, it assumes some familiarity with the Linux kernel. To fully understand what&amp;rsquo;s going on we&amp;rsquo;d like to shed some light on specific kernel internals. The aim of this post is to share our knowledge and to provide a resource for other interested individuals. The idea of this post is as follows: We take a small proof-of-concept (PoC) program and divide it into several stages. Each stage issues a system call (or syscall for short), and we will look inside the kernel to understand which actions and state changes occur in response to those calls. For this we use both, the kernel source code (&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source" target="_blank" rel="noopener">elixir.bootlin.com&lt;/a>
, version 5.17.9) and a kernel debugging setup (derived from &lt;a href="https://github.com/martinclauss/linux-kernel-debugging" target="_blank" rel="noopener">linux-kernel-debugging&lt;/a>
). The Dirty Pipe-specific debugging setup and the PoC code is provided in a &lt;a href="https://github.com/vobst/lkd-cve" target="_blank" rel="noopener">GitHub&lt;/a>
 repository.&lt;/p></description></item><item><title>Exploiting CVE-2021-43247</title><link>https://lolcads.github.io/posts/2022/06/exploiting_cve_2021_43247/</link><pubDate>Thu, 02 Jun 2022 10:59:55 +0200</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2022/06/exploiting_cve_2021_43247/</guid><description>&lt;p>In this blog post I will go in depth into the inner workings of &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2021-43247" target="_blank" rel="noopener">CVE-2021-43247&lt;/a>
, which was fixed on the 14th of December 2021.
This bug was classified as &amp;ldquo;Windows TCP/IP Driver Elevation of Privilege Vulnerability&amp;rdquo;.
The vulnerability itself was probably dormant for a long time, but became exploitable when the &lt;code>AF_UNIX&lt;/code> address family
was first introduced in 2019.&lt;/p>
&lt;p>I will also take this as an excuse to explain in detail, what drivers are, how user space communicates with drivers,
what a Local Privilege Escalation (LPE) is and what how we can achieve it in this case.&lt;/p></description></item><item><title>Installing new .NET versions on a Windows 7 VM</title><link>https://lolcads.github.io/posts/2022/03/win7_dotnet_install/</link><pubDate>Wed, 16 Mar 2022 12:01:43 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2022/03/win7_dotnet_install/</guid><description>&lt;h1 id="installing-new-net-versions-on-a-windows-7-vm">Installing new .NET versions on a Windows 7 VM&lt;/h1>
&lt;p>In this post, I will explain how to install .NET Framework 4.8 on a Windows 7 VM.&lt;/p>
&lt;h2 id="motivation">Motivation&lt;/h2>
&lt;p>Virtual Machines running Microsoft Windows are frequently used for dynamic analysis of Windows executables.
Windows 7 is still used for analysis VM, although it is no longer supported by Microsoft and ships with an outdated .NET version.
If a sample requires a .NET version which is not present on the analysis VM, the execution fails and the file cannot be analysed.
For this reason it might be required to install a recent .NET version on a Windows 7 VM.&lt;/p></description></item><item><title>libdesock</title><link>https://lolcads.github.io/posts/2022/02/libdesock/</link><pubDate>Tue, 22 Feb 2022 14:24:40 +0100</pubDate><author>lolcads@posteo.net (lolcads)</author><guid>https://lolcads.github.io/posts/2022/02/libdesock/</guid><description>&lt;h1 id="fuzzing-network-applications-with-afl-and-libdesock">Fuzzing Network Applications with AFL and libdesock&lt;/h1>
&lt;p>Fuzzing network servers with AFL is challenging since AFL provides its
input via stdin or command line arguments while servers get their input
over network connections.
As the popularity of AFL grew, many attempts have been made of fuzzing
popular servers like apache and nginx using different
techniques and hacky workarounds. However an off-the-shelf network fuzzing
solution for AFL didn&amp;rsquo;t exist for a long time until so-called &amp;ldquo;desocketing&amp;rdquo;
tools emerged.
These desocketing tools enabled network fuzzing without
making a lot of additional modifications to the program under test
and quickly became widely used in combination with AFL.&lt;/p></description></item></channel></rss>