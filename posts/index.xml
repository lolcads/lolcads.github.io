<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on lolcads tech blog</title><link>https://lolcads.github.io/posts/</link><description>Recent content in Posts on lolcads tech blog</description><generator>Hugo</generator><language>en</language><copyright>lolcads</copyright><lastBuildDate>Fri, 26 Jul 2024 16:46:21 +0100</lastBuildDate><atom:link href="https://lolcads.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Timing Attack Experiments against Scudo (Part 2)</title><link>https://lolcads.github.io/posts/2024/07/scudo_1/</link><pubDate>Fri, 26 Jul 2024 16:46:21 +0100</pubDate><guid>https://lolcads.github.io/posts/2024/07/scudo_1/</guid><description>Attempting Timing Attacks against Scudo In this second blog post we will take a different approach for attacking Scudo, i.e. we will try to the measure execution times for calls to malloc and hope to be able to derive a portion of the internal state of the allocator (i.e. perform side channel attacks). The version of Scudo considered in this blog post is 161cca266a9d0b6deb5f1fd2de8ad543649a7fa1.
There will be almost only negative results (which means I unfortunately could not make it work), except for one.</description></item><item><title>Scudo, the Allocator (Part 1)</title><link>https://lolcads.github.io/posts/2024/07/scudo_0/</link><pubDate>Thu, 25 Jul 2024 16:46:21 +0100</pubDate><guid>https://lolcads.github.io/posts/2024/07/scudo_0/</guid><description>Binary Exploitation for Scudo Heap Allocator on Android In this series of blog posts, we will investigate how an attacker may leverage the internals of the Scudo Allocator in order to obtain an advantage on an Android OS. To that end, necessary prerequisites will be discussed and analysed for their likelihood. The focus will primarily be on malloc and free, although realloc and other functions may also be of interest. According to source code, the Scudo version considered in this blog is 161cca266a9d0b6deb5f1fd2de8ad543649a7fa1.</description></item><item><title>E²VA: Use After Free Write/Execute Module (Part 4)</title><link>https://lolcads.github.io/posts/2024/07/eva_3/</link><pubDate>Wed, 24 Jul 2024 16:46:21 +0100</pubDate><guid>https://lolcads.github.io/posts/2024/07/eva_3/</guid><description>Exploitation of Use - After - Free Modules In this post we will be discussing how to exploit a Use - After - Free bug in both UseAfterFreeExecModule and UseAfterFreeWriteModule. As the names of the modules suggest, they differ in terms of the impact the bug has. To that end, in UseAfterFreeExecModule we will be able to control a function pointer, whereas in UseAfterFreeWriteModule we are given a Write - What - Where condition.</description></item><item><title>E²VA: Stack Buffer Overflow Module (Part 3)</title><link>https://lolcads.github.io/posts/2024/07/eva_2/</link><pubDate>Tue, 23 Jul 2024 16:46:21 +0100</pubDate><guid>https://lolcads.github.io/posts/2024/07/eva_2/</guid><description>Exploitation of EasyStackBufferOverflowModule This article describes exploitation of the EasyStackBufferOverflowModule. During exploitation, various Android - specific caveats are discussed.
Assumptions We will assume that we have successfully grabbed a copy of the .apk file of damnvulnerableapp. Also, we will not discuss how to unpack an .apk file, but rather assume that we have access to libEasyStackBufferOverflowModule.so and the EasyStackBufferOverflowModule class. If it is unclear how to get access to these components when only given an .</description></item><item><title>E²VA: Android Basics (Part 2)</title><link>https://lolcads.github.io/posts/2024/07/eva_1/</link><pubDate>Mon, 22 Jul 2024 16:46:21 +0100</pubDate><guid>https://lolcads.github.io/posts/2024/07/eva_1/</guid><description>Android Binary Exploitation In this post, we will examine security mechanisms that Android 12 employs in order to make binary exploitation a bit harder. Also, we will discuss how to get to certain information like shared - object files that are necessary for successful exploitation. The latter will be generalized to getting limited source code access to an app given a corresponding .apk file.
Environment Before diving into details, the technical setup has to be clarified.</description></item><item><title>*PowerView* is evil, but *PowerVi* and *ew* are legit, right? - Missing signature-based detections due to PowerShell Script Block Logging Fragmentation</title><link>https://lolcads.github.io/posts/2024/04/psscriptblockfragmentation/</link><pubDate>Mon, 15 Apr 2024 11:01:40 +0200</pubDate><guid>https://lolcads.github.io/posts/2024/04/psscriptblockfragmentation/</guid><description>PowerView is evil, but PowerVi and ew are legit, right? - Missing signature-based detections due to PowerShell Script Block Logging Fragmentation TL;DR: Sigma rules and similar signature-based threat detection measures may miss malicious PowerShell scripts due to unpredictable fragmentation of script block logs.
Introduction Sigma offers more than 3000 rules for signature-based threat detection. 140 of these rules aim to detect suspicious/malicious PowerShell scripts by looking into PowerShell script block logs.</description></item><item><title>BPF Memory Forensics with Volatility 3</title><link>https://lolcads.github.io/posts/2023/12/bpf_memory_forensics_with_volatility3/</link><pubDate>Thu, 21 Dec 2023 13:47:46 +0100</pubDate><guid>https://lolcads.github.io/posts/2023/12/bpf_memory_forensics_with_volatility3/</guid><description>BPF Memory Forensics with Volatility 3 Introduction and Motivation Have you ever wondered how an eBPF rootkit looks like? Well, here&amp;rsquo;s one, have a good look:
Upon receiving a command and control (C2) request, this specimen can execute arbitrary commands on the infected machine, exfiltrate sensitive files, perform passive and active network discovery scans (like nmap), or provide a privilege escalation backdoor to a local shell. Of course, it&amp;rsquo;s also trying its best to hide itself from system administrators hunting it with different command line tools such as ps, lsof, tcpdump an others or even try tools like rkhunter or chkrootkit.</description></item><item><title>Diving into the art of userspace exploitation under Android - Introducing E²VA (Part 1)</title><link>https://lolcads.github.io/posts/2022/11/diving_into_the_art_of_userspace_exploitation_under_android/</link><pubDate>Mon, 21 Nov 2022 18:54:42 +0100</pubDate><guid>https://lolcads.github.io/posts/2022/11/diving_into_the_art_of_userspace_exploitation_under_android/</guid><description>Investigating Binary Exploitation for JNI on Android This post aims to be an introduction into a blog series about binary exploitation on Android. It tries to describe how the environment that runs vulnerable modules is set up and how the damnvulnerableapp supports the process of binary exploitation on Android.
Warning The following app is intended to be vulnerable to specific attacks and can result in arbitrary code execution in the context of the app.</description></item><item><title>friTap - Decrypting TLS on the fly</title><link>https://lolcads.github.io/posts/2022/08/fritap/</link><pubDate>Fri, 12 Aug 2022 13:09:24 +0200</pubDate><guid>https://lolcads.github.io/posts/2022/08/fritap/</guid><description>Encryption - a curse and a blessing at the same time Digital communication in today&amp;rsquo;s world has a particularly high status in our society. Financial transactions are conducted via online banking, private communication is increasingly limited to digital messenger services, and even health data is experiencing a shift to digital form. Due to the growth of such sensitive digital data, the need for secure transmission of such data has become increasingly important over the past decades.</description></item><item><title>Make Frida Great Again</title><link>https://lolcads.github.io/posts/2022/07/make_frida_great_again/</link><pubDate>Thu, 28 Jul 2022 13:29:30 +0200</pubDate><guid>https://lolcads.github.io/posts/2022/07/make_frida_great_again/</guid><description>Make Frida Great Again In order to analyse binaries on e.g. Android systems, one is offered a plethora of tools to use to figure out what a binary is doing, whether it is malicious or just buggy. One way to figure out the behaviour of a binary is to utilise the strength of dynamic analysis. Under linux, i.e. Android in particular, Frida is a tool that is used for automated instrumentation of binaries, to inspect memory, function calls etc.</description></item><item><title>Exploration of the Dirty Pipe Vulnerability (CVE-2022-0847)</title><link>https://lolcads.github.io/posts/2022/06/dirty_pipe_cve_2022_0847/</link><pubDate>Mon, 06 Jun 2022 19:57:03 +0200</pubDate><guid>https://lolcads.github.io/posts/2022/06/dirty_pipe_cve_2022_0847/</guid><description>Intro This blog post reflects our exploration of the Dirty Pipe Vulnerability in the Linux kernel. The bug was discovered by Max Kellermann and described here. If you haven&amp;rsquo;t read the original publication yet, we&amp;rsquo;d suggest that you read it first (maybe also twice ;)). While Kellermann&amp;rsquo;s post is a great resource that contains all the relevant information to understand the bug, it assumes some familiarity with the Linux kernel. To fully understand what&amp;rsquo;s going on we&amp;rsquo;d like to shed some light on specific kernel internals.</description></item><item><title>Exploiting CVE-2021-43247</title><link>https://lolcads.github.io/posts/2022/06/exploiting_cve_2021_43247/</link><pubDate>Thu, 02 Jun 2022 10:59:55 +0200</pubDate><guid>https://lolcads.github.io/posts/2022/06/exploiting_cve_2021_43247/</guid><description>In this blog post I will go in depth into the inner workings of CVE-2021-43247, which was fixed on the 14th of December 2021. This bug was classified as &amp;ldquo;Windows TCP/IP Driver Elevation of Privilege Vulnerability&amp;rdquo;. The vulnerability itself was probably dormant for a long time, but became exploitable when the AF_UNIX address family was first introduced in 2019.
I will also take this as an excuse to explain in detail, what drivers are, how user space communicates with drivers, what a Local Privilege Escalation (LPE) is and what how we can achieve it in this case.</description></item><item><title>Installing new .NET versions on a Windows 7 VM</title><link>https://lolcads.github.io/posts/2022/03/win7_dotnet_install/</link><pubDate>Wed, 16 Mar 2022 12:01:43 +0100</pubDate><guid>https://lolcads.github.io/posts/2022/03/win7_dotnet_install/</guid><description>Installing new .NET versions on a Windows 7 VM In this post, I will explain how to install .NET Framework 4.8 on a Windows 7 VM.
Motivation Virtual Machines running Microsoft Windows are frequently used for dynamic analysis of Windows executables. Windows 7 is still used for analysis VM, although it is no longer supported by Microsoft and ships with an outdated .NET version. If a sample requires a .NET version which is not present on the analysis VM, the execution fails and the file cannot be analysed.</description></item><item><title>libdesock</title><link>https://lolcads.github.io/posts/2022/02/libdesock/</link><pubDate>Tue, 22 Feb 2022 14:24:40 +0100</pubDate><guid>https://lolcads.github.io/posts/2022/02/libdesock/</guid><description>Fuzzing Network Applications with AFL and libdesock Fuzzing network servers with AFL is challenging since AFL provides its input via stdin or command line arguments while servers get their input over network connections. As the popularity of AFL grew, many attempts have been made of fuzzing popular servers like apache and nginx using different techniques and hacky workarounds. However an off-the-shelf network fuzzing solution for AFL didn&amp;rsquo;t exist for a long time until so-called &amp;ldquo;desocketing&amp;rdquo; tools emerged.</description></item></channel></rss>