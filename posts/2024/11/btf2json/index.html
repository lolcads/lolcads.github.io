<!doctype html><html lang=en dir=ltr><head><title>Towards utilizing BTF Information in Linux Memory Forensics :: lolcads tech blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="This post is about some work that I did on automatic profile generation for memory forensics of Linux systems. To be upfront about it: This work is somewhat half-finished &ndash; it already does something quite useful, but it could do a lot more, and it has not been evaluated thoroughly enough to be considered &ldquo;production ready&rdquo;. The reason I decided to publish it anyway is that I believe that there is an interesting opportunity to change the way in which we generate profiles for the analysis of Linux memory images in practice. However, in order for it to become a production tool, at least one outstanding problem has to be addressed (I have some ideas on that one) and lots of coding work needs to be done &ndash; and I simply do not have the resources to work on that right now.
"><meta name=keywords content="Linux,Kernel,BTF,Forensics"><meta name=robots content="noodp"><link rel=manifest href=/manifest.json><meta property="og:url" content="https://lolcads.github.io/posts/2024/11/btf2json/"><meta property="og:site_name" content="lolcads tech blog"><meta property="og:title" content="Towards utilizing BTF Information in Linux Memory Forensics"><meta property="og:description" content="This post is about some work that I did on automatic profile generation for memory forensics of Linux systems. To be upfront about it: This work is somewhat half-finished – it already does something quite useful, but it could do a lot more, and it has not been evaluated thoroughly enough to be considered “production ready”. The reason I decided to publish it anyway is that I believe that there is an interesting opportunity to change the way in which we generate profiles for the analysis of Linux memory images in practice. However, in order for it to become a production tool, at least one outstanding problem has to be addressed (I have some ideas on that one) and lots of coding work needs to be done – and I simply do not have the resources to work on that right now."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-13T12:38:49+01:00"><meta property="article:modified_time" content="2024-11-13T12:38:49+01:00"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Kernel"><meta property="article:tag" content="BTF"><meta property="article:tag" content="Forensics"><meta name=twitter:card content="summary"><meta name=twitter:title content="Towards utilizing BTF Information in Linux Memory Forensics"><meta name=twitter:description content="This post is about some work that I did on automatic profile generation for memory forensics of Linux systems. To be upfront about it: This work is somewhat half-finished – it already does something quite useful, but it could do a lot more, and it has not been evaluated thoroughly enough to be considered “production ready”. The reason I decided to publish it anyway is that I believe that there is an interesting opportunity to change the way in which we generate profiles for the analysis of Linux memory images in practice. However, in order for it to become a production tool, at least one outstanding problem has to be addressed (I have some ideas on that one) and lots of coding work needs to be done – and I simply do not have the resources to work on that right now."><link rel=canonical href=https://lolcads.github.io/posts/2024/11/btf2json/><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/index.min.c860e17f20d9f258820c02bf7ab3f57c9595d0bc21dede7eda08ccd63ba3f4cc.css></head><body class="flex flex-col min-h-screen w-full bg-slate-50 dark:bg-gray-800"><header class="flex flex-none justify-center z-10"><div class="flex flex-row gap justify-between w-full max-w-4xl lg:max-w-5xl h-12 mt-3"><div class="flex-none ml-2 md:ml-0"><a href=/><img class="h-12 w-12 rounded-full object-cover bg-gray-100" src=/logo.png alt=logo></a></div><div class=flex-1></div><div class=flex-none><nav class="h-full static"><button id=navbar-menu-toggle type=button class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg md:hidden" aria-controls=navbar-menu aria-expanded=false>
<span class=sr-only>Open main menu</span>
<i class="w-8 h-8"><svg class="icon icon-tabler icon-tabler-menu-2" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 6h16"/><path d="M4 12h16"/><path d="M4 18h16"/></svg></i></button><div class="absolute md:static top-16 left-0 right-0 z-50 hidden w-full md:block md:w-auto" id=navbar-menu><ul class="flex flex-col mx-2 md:mx-0 md:flex-row md:border-0 rounded-sm md:rounded-full px-3 text-base font-medium text-slate-800 dark:text-slate-200 shadow-lg bg-white dark:bg-gray-600 shadow-slate-800/5 dark:shadow-slate-200/5 ring-1 ring-slate-900/5 dark:ring-slate-100/5"><li id=post><a class="block px-3 py-3 hover:text-emerald-600 text-emerald-600" href=/posts/ title=Blog>Blog</a></li><li id=about><a class="block px-3 py-3 hover:text-emerald-600" href=/about/ title=About>About</a></li><li id=contact><a class="block px-3 py-3 hover:text-emerald-600" href=/contact/ title=Contact>Contact</a></li></ul></div></nav></div><div class="flex-none mx-1"></div><div class="flex-none md:hidden"><a href=/search/ class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg" aria-controls=navbar-menu aria-expanded=false><span class=sr-only>Search</span>
<i class="w-8 h-8"><svg class="icon icon-tabler icon-tabler-search" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 10m-7 0a7 7 0 1014 0A7 7 0 103 10"/><path d="M21 21l-6-6"/></svg></i></a></div><div class="darkmode-toggle flex flex-none mr-2 md:mr-0"><label for=darkmode-toggle class="flex items-center px-3 cursor-pointer rounded-full bg-gray-100 dark:bg-gray-600" title="Toggle dark mode"><input name=darkmode-toggle id=darkmode-toggle type=checkbox class="sr-only peer" aria-label="Toggle dark mode"><div class="group flex flex-row gap-1 justify-center h-8 px-1 rounded-full bg-white dark:bg-gray-700"><i class="h-6 w-6 flex-none rounded-full bg-yellow-400 place-self-center peer-checked:group-[]:invisible"><svg class="icon icon-tabler icon-tabler-brightness-down" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-3 0a3 3 0 106 0 3 3 0 10-6 0"/><path d="M12 5v.01"/><path d="M17 7v.01"/><path d="M19 12v.01"/><path d="M17 17v.01"/><path d="M12 19v.01"/><path d="M7 17v.01"/><path d="M5 12v.01"/><path d="M7 7v.01"/></svg>
</i><i class="h-6 w-6 flex-none rounded-full place-self-center invisible peer-checked:group-[]:visible"><svg class="icon icon-tabler icon-tabler-moon-stars" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 3c.132.0.263.0.393.0a7.5 7.5.0 007.92 12.446A9 9 0 1112 2.992z"/><path d="M17 4a2 2 0 002 2 2 2 0 00-2 2 2 2 0 00-2-2 2 2 0 002-2"/><path d="M19 11h2m-1-1v2"/></svg></i></div></label></div></div></header><main class="flex flex-auto justify-center"><div class="w-full max-w-4xl lg:max-w-5xl"><div class="flex flex-col mt-6 mx-2 md:mx-0 rounded-lg overflow-hidden shadow-md bg-white dark:bg-gray-700"><div><a href=/posts/2024/11/btf2json/></a></div><div class="flex flex-col gap-y-3 p-6"><h1 class="text-4xl font-semibold text-slate-800 dark:text-slate-100"><a href=/posts/2024/11/btf2json/>Towards utilizing BTF Information in Linux Memory Forensics</a></h1><ul class="flex flex-row flex-wrap text-slate-500 dark:text-slate-300"><li><a href=/tags/linux/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Linux</span></a></li><li><a href=/tags/kernel/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Kernel</span></a></li><li><a href=/tags/btf/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>BTF</span></a></li><li><a href=/tags/forensics/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Forensics</span></a></li></ul><div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300"><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-calendar" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 7a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V7z"/><path d="M16 3v4"/><path d="M8 3v4"/><path d="M4 11h16"/><path d="M11 15h1"/><path d="M12 15v3"/></svg>
</i><time datetime=2024-11-13T12:38:49+01:00>2024-11-13</time></div><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-hourglass-high" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6.5 7h11"/><path d="M6 20v-2a6 6 0 1112 0v2a1 1 0 01-1 1H7a1 1 0 01-1-1z"/><path d="M6 4v2a6 6 0 1012 0V4a1 1 0 00-1-1H7A1 1 0 006 4z"/></svg>
</i><span>18 minutes to read</span></div></div><div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300"><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-user"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M8 7a4 4 0 108 0A4 4 0 008 7"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
</i><span>Valentin Obst</span></div></div><section class="prose prose-slate dark:prose-invert w-full max-w-4xl lg:max-w-5xl mt-6"><h2>Table of Contents</h2><aside><nav id=TableOfContents><ul><li><a href=#whats-a-profile>What&rsquo;s a Profile?</a></li><li><a href=#whats-the-problem>What&rsquo;s the problem?</a></li><li><a href=#whats-our-solution-meet-the-bpf-type-format-btf>What&rsquo;s our solution? Meet The BPF Type Format (BTF)!</a></li><li><a href=#what-we-have>What we have!</a><ul><li><a href=#evaluation>Evaluation</a></li></ul></li><li><a href=#symbols-are-only-partially-solved>Symbols Are Only Partially Solved</a></li><li><a href=#call-to-action>Call to Action</a><ul><li><a href=#working-on-a-raw-memory-image>Working on a Raw Memory Image</a></li><li><a href=#evaluating-the-symdb-approach>Evaluating the <code>symdb</code> Approach</a></li></ul></li><li><a href=#appendix-a-accessed-symbols>Appendix A: Accessed Symbols</a></li></ul></nav></aside></section><article class="mt-6 w-full max-w-4xl lg:max-w-5xl prose prose-slate dark:prose-invert prose-quoteless post-content"><p>This post is about some work that I did on automatic profile generation for memory forensics of Linux systems. To be upfront about it: This work is somewhat half-finished &ndash; it already does something quite useful, but it could do a lot more, and it has not been evaluated thoroughly enough to be considered &ldquo;production ready&rdquo;. The reason I decided to publish it anyway is that I believe that there is an interesting opportunity to change the way in which we generate profiles for the analysis of Linux memory images <em>in practice</em>. However, in order for it to become a production tool, at least one outstanding problem has to be addressed (I have some ideas on that one) and lots of coding work needs to be done &ndash; and I simply do not have the resources to work on that right now.</p><p><em>Note</em>: It has been a while since I actively worked on this project, so if someone else ran with this idea in the meantime, please let me know!</p><p><em>Note</em>: You can find the code of the prototype <a href=https://github.com/vobst/btf2json target=_blank rel=noopener>here</a>
.</p><p>So, what is this work about? To analyze memory images, we need <em>profiles</em>, usually those are generated from DWARF debug information, e.g., using tools like <a href=https://github.com/volatilityfoundation/dwarf2json target=_blank rel=noopener><code>dwarf2json</code></a>
. However, here is the problem: DWARF is HUGE, so production kernels never ship with it; thus, it is highly unlikely that the kernel on the target whose memory we are analyzing includes them. Luckily, most (but not all!) Linux distributions provide debug-packages for their kernels. Consequently, a precondition for the generation of a profile is usually to figure out the distribution and exact version of the kernel in the image, and then to download the corresponding debug package.</p><p>But now comes the surprise: What if I tell you that virtually every production kernel that ships today comes with most of the information that we need to generate a profile for it? And that this information can be readily extracted from a raw memory image? Exploring this opportunity is what this work was all about.</p><p>To explain how and why this works, I&rsquo;ll start by <a href=#whats-a-profile>introducing the notion of a <em>profile</em> in memory forensics</a>
, <a href=#whats-the-problem>state the problem that we strive to address</a>
, then <a href=#whats-our-solution-meet-the-bpf-type-format-btf>talk about the BPF Type Format (BTF)</a>
, <a href=#what-we-have>describe how BTF can be used to generate a part of a profile</a>
(+ an <a href=#evaluation>evaluation of our implementation</a>
), <a href=#symbols-are-only-partially-solved>discuss some open questions around symbols</a>
, and finally <a href=#call-to-action>outline what needs to be done for this project to reach its full potential</a>
.</p><p>Let&rsquo;s get started!</p><h2 id=whats-a-profile>What&rsquo;s a Profile?</h2><p>In short: A <em>profile</em> is a bunch of information that is used by <em>analyses</em> to make sense of the raw bytes in a memory image. In other words, it allows you to &ldquo;bridge the semantic gap&rdquo; between 1s and 0s in a dump and the answer to interesting questions like &ldquo;Which network connections did the process that was stated at 13:37 made?&rdquo;.</p><p>Usually, a profile consists of two parts: Information about <em>symbols</em> and <em>types</em> of the kernel that was running on the machine. Symbols are what get you a foot in the door, i.e. where an analysis starts. For example, the head of the list of all tasks can be found via the <code>init_task</code> symbol. From there onward, the types are what allows an analysis to make sense of the raw bytes it finds, to transition between objects by following pointers, and eventually to extract useful information.</p><p>Symbols are pretty simple, they are just <em>names</em> for memory <em>locations</em> together with the <em>type</em> of the data that is stored there. We will say that the triple of <code>(name, location, type)</code> forms a symbol.</p><p>Types are essentially recipes that tell you how to turn raw bytes back into a value of a C-type, i.e., they are a description of the memory layout of a C-type. We will say that the tuple <code>(c_type_kind, c_type_name, memory_layout)</code> forms a type.</p><h2 id=whats-the-problem>What&rsquo;s the problem?</h2><p>The information in a profile is specific to a <em>particular compilation</em> of the operating system kernel, e.g., think of the linker’s freedom in arranging global variables or compile-time options that influence the layout of types. For Windows and macOS it is possible to build a profile database of all released kernels, i.e., you only have to find out which release you have in your dump and then you are ready to go. For Linux, there is a whole zoo of distros and even more kernel packages, a new one of which gets released every few days <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. Building a comprehensive Linux profile database is an endeavor that is doomed to fail.</p><p>There are reliable heuristics for inferring the release of the OS in your dump. Those work well for Windows, macOS and most Linux distros. However, the infeasibility of building a Linux profile database means that you must still use that information about the release to build the profile yourself. Usually this involves downloading the debug package of that exact release and running some tool against it. If this package does not exist, you are lost at that point. In particular this implies that you are completely lost if you are not analyzing a dump of a system running a mainstream Linux distro.</p><p>So, let&rsquo;s get to the definition of the &ldquo;profile generation problem&rdquo;: Given only the bytes in a memory dump, tell me the symbols and types of the kernel that was running in there (maybe not all of them, but enough to do useful analyses).</p><p>Are there existing solutions to this problem? Yes, plenty. There is like 1m of papers, some dating back many years, that identify and address this problem using all sorts of creative approaches, e.g., <a href=https://www.ndss-symposium.org/ndss-paper/an-os-agnostic-approach-to-memory-forensics/ target=_blank rel=noopener>Oliveri et al.</a>
, <a href=https://dl.acm.org/doi/full/10.1145/3485471 target=_blank rel=noopener>Pagani et al.</a>
, <a href=https://dl.acm.org/doi/abs/10.1145/3545948.3545980 target=_blank rel=noopener>Franzen et al.</a>
, <a href=https://www.ndss-symposium.org/ndss-paper/auto-draft-193/ target=_blank rel=noopener>Qi et al.</a>
, <a href=https://dfrws.org/presentation/automatic-profile-generation-for-live-linux-memory-analysis/ target=_blank rel=noopener>Cohen et al.</a>
, or <a href=https://dl.acm.org/doi/abs/10.1145/2897845.2897850 target=_blank rel=noopener>Feng et al.</a>
.</p><p>Seemingly, the &ldquo;rule of the game&rdquo; seems to be that you are allowed to do all sorts of up-front or on-demand analyses that involve the upstream Linux <em>source code</em>, and sometimes even on the live system, to support your analysis of the raw image. We&rsquo;ll also need to make use of the former crutch to make our solution work.</p><p>Why yet another solution you may ask? Well, to the best of my knowledge, none of the proposed solutions has seen widespread adoption as of now. My hope is that the simplicity of our approach might mean that it can make generating profiles for images that meet <em>certain requirements</em> as easy as running a cli tool against it and waiting for a few seconds or so. No need to do some complicated setup, download tons of dependencies, compile a thousand Linux kernels with an aging clang fork, and to wait dozens of minutes or even hours for the profile to be finished - just download the binary and you are good to go <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. In short, our approach is less general, but hopefully more practical than previous work.</p><h2 id=whats-our-solution-meet-the-bpf-type-format-btf>What&rsquo;s our solution? Meet The BPF Type Format (BTF)!</h2><p>You might have heard about <a href=https://datatracker.ietf.org/wg/bpf/about/ target=_blank rel=noopener>BPF</a>
, if not, think of it as an abstract machine with its own bytecode format (a bit like the JVM or WASM). The Linux kernel has its own implementation of this abstract machine, the Linux BPF runtime, i.e., it can execute BPF bytecode programs. The whole point of this subsystem is to have a flexible, fast, safe, and portable way to extend the kernel at runtime. For example, I recently started using the <a href=https://github.com/evilsocket/opensnitch target=_blank rel=noopener>opensnitch</a>
application-level firewall, and it is in fact enforcing its network policies via multiple BPF programs.</p><p>Wait, did you just say <em>portable</em> kernel extensions?!? But how can a program that is compiled to some assembly-like bytecode language and operates on kernel data structures in memory be portable across kernel versions? After all code like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>my_struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef BAR
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=kt>long</span> <span class=n>bar</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=kt>long</span> <span class=n>foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>long</span> <span class=nf>read_foo</span><span class=p>(</span><span class=k>struct</span> <span class=n>my_struct</span><span class=o>*</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>my_struct</span><span class=o>-&gt;</span><span class=n>foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>should be compiled down to instructions that have things like &ldquo;Is a <code>long</code> 4 or 8 bytes?&rdquo; or &ldquo;Was <code>BAR</code> defined?&rdquo; hard coded inside them. The solution to this apparent paradox lies in the interplay of four components: the <a href=https://clang.llvm.org/docs/AttributeReference.html#preserve-access-index target=_blank rel=noopener><code>preserve-access-index</code> C-language attribute</a>
, the compiler toolchain, the user-space dynamic loader, and the kernel that the program should be loaded into.</p><p>In the program&rsquo;s C source code, structures/unions whose member accesses should be portable must be marked with the <code>preserve-access-index</code> attribute <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>. The compiler will then generate the accessing code without hard-coded offsets and record which field of which type was accessed at a particular location in <a href=https://www.kernel.org/doc/html/latest/bpf/llvm_reloc.html#co-re-relocations target=_blank rel=noopener>relocation information</a>
. This information is processed by the user-space dynamic loader running on the target system, which adjusts the program to the layout of types in the running kernel before loading it. The information about memory layout of types is supplied by the running kernel itself via the files in the <code>/sys/kernel/btf/</code> pseudo file system.</p><p>Whaaat? Each and every kernel out there that wants to support portable BPF programs (pretty much every single one) must ship with a description of the memory layout of all its types? That&rsquo;s like having Christmas and your birthday together! Indeed, the relevant information is stored in the <code>.BTF</code> sections of the kernel and module ELF files in the <a href=https://www.kernel.org/doc/html/latest/bpf/btf.html target=_blank rel=noopener>well documented BPF Type Format</a>
.</p><p>This solves the whole <em>types</em> part of the &ldquo;profile-generation-problem&rdquo; for most modern kernels without the need for a debug build. Furthermore, since the kernel image is contiguous in physical memory, it is straight forward to carve the section from a memory image.</p><p><em>Note:</em> The reason why it is feasible to include the BTF information in production kernels is since it is much smaller than DWARF debug information. In part, this is achieved by the format being much less wasteful with disk space, however, it is also fundamentally less expressive. Thus, it is a priori not clear that BTF contains all the type information needed by memory forensics analyses. It was part of this work to establish that this is indeed the case (not too surprising given BTF&rsquo;s original use case described above). I recommend <a href=https://nakryiko.com/posts/btf-dedup/ target=_blank rel=noopener>this post</a>
for an introduction to the BTF format and its relationship to DWARF.</p><p><em>Note:</em> BTF has been around for quite a while, since <a href=https://github.com/torvalds/linux/commit/69b693f0aefa0ed521e8bd02260523b5ae446ad7 target=_blank rel=noopener>Linux 4.18</a>
to be precise, so it is not like you will only find it in bleeding edge kernels.</p><h2 id=what-we-have>What we have!</h2><p>Let&rsquo;s start with the good news: the <a href=https://github.com/vobst/btf2json target=_blank rel=noopener>released prototype <code>btf2json</code></a>
can generate working Volatility3 profiles! At the time of our evaluation, those profiles were even &ldquo;better&rdquo; than the ones generated by <code>dwarf2json</code>, in the sense that they supported more analyses on more memory images. It is also worth noting that the profile generation is about 10x faster.</p><p>Currently, <code>btf2json</code> accepts either an ELF <code>vmlinux</code> image or a raw <code>.BTF</code>-section for the type information, as well as a <code>System.map</code> file for symbol information, to generate a Volatility3 profile.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ btf2json --help
</span></span><span class=line><span class=cl>Generate Volatility <span class=m>3</span> ISF files from BTF <span class=nb>type</span> information
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Usage: btf2json <span class=o>[</span>OPTIONS<span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Options:
</span></span><span class=line><span class=cl>      --btf &lt;BTF&gt;
</span></span><span class=line><span class=cl>          BTF file <span class=k>for</span> obtaining <span class=nb>type</span> information <span class=o>(</span>can also be a kernel image<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      --map &lt;MAP&gt;
</span></span><span class=line><span class=cl>          System.map file <span class=k>for</span> obtaining symbol names and addresses
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      --banner &lt;BANNER&gt;
</span></span><span class=line><span class=cl>          Linux banner.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          Mandatory <span class=k>if</span> using a BTF file <span class=k>for</span> <span class=nb>type</span> information. Takes precedence over all other possible sources of banner information.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      --version
</span></span><span class=line><span class=cl>          Print btf2json version
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      --verbose
</span></span><span class=line><span class=cl>          Display debug output
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      --debug
</span></span><span class=line><span class=cl>          Display more debug output
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      --image &lt;IMAGE&gt;
</span></span><span class=line><span class=cl>          Memory image to extract <span class=nb>type</span> and/or symbol information from <span class=o>(</span>not implemented<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  -h, --help
</span></span><span class=line><span class=cl>          Print <span class=nb>help</span> <span class=o>(</span>see a summary with <span class=s1>&#39;-h&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>$ btf2json --btf path/to/vmlinux/or/btf/section --map path/to/system/map
</span></span><span class=line><span class=cl><span class=c1># prints ISF to stdout</span>
</span></span></code></pre></div><p><em>Note</em>: If you use just the <code>.BTF</code>-section for type information, you also need to provide a Linux banner so that Volatility can match the profile to a memory image.</p><p>The resulting profile can then be used to drive Volatility analyses, just like any other profile that you would have previously generated with <code>dwarf2json</code>.</p><p>In its current form, <code>btf2json</code> already has one key advantage over <code>dwarf2json</code> (besides being much faster :P): no need for debug kernels! This means you can generate profiles for custom, self-compiled kernels (useful when investigating nerds like me) or distributions that do not provide kernel debug symbols (e.g., Arch Linux). Furthermore, you do not have to bother with figuring out the exact kernel release and searching the corresponding debug package in a gigantic repository. Just grab the <code>vmlinux</code> and <code>System.map</code> from the file system and you are good to go!</p><h3 id=evaluation>Evaluation</h3><p>We evaluated <code>btf2json</code> on the following kernels:</p><ul><li>Almalinux 9<ul><li>kernel: 5.14.0-362.8.1.el9_3.x86_64 (<code>f844e</code>)</li></ul></li><li>Archlinux<ul><li>kernel: 6.6.7-arch1-1 (<code>59a42</code>)</li><li>kernel: 6.11.6-arch1-1 (<code>a54bd</code>)</li></ul></li><li>Fedora 38<ul><li>kernel: 6.6.6-100.fc38.x86_64 (<code>85565</code>)</li></ul></li><li>Fedora 39<ul><li>kernel: 6.6.6-200.fc39.x86_64 (<code>7bd7a</code>)</li><li>kernel: 6.11.6-100.fc39.x86_64 (<code>d2be6</code>)</li></ul></li><li>Fedora 40<ul><li>kernel: 6.11.6-200.fc40.x86_64 (<code>bbbb3</code>)</li></ul></li><li>Centos 9s<ul><li>kernel: 5.14.0-391.el9.x86_64 (<code>20d08</code>)</li></ul></li><li>Debian 11<ul><li>kernel: 5.10.0-26-amd64 (<code>2c41e</code>)</li></ul></li><li>Rocky 8<ul><li>kernel: 4.18.0-513.9.1.el8_9.x86_64 (<code>9a6e2</code>)</li></ul></li><li>Ubuntu 22.04<ul><li>kernel: 5.15.0-88-generic (<code>6f76f</code>)</li></ul></li><li>Ubuntu 23.10<ul><li>kernel: 6.5.0-10-generic (<code>ccbb5</code>)</li></ul></li><li>Kali Rolling<ul><li>kernel: 6.11.2-amd64 (<code>c0965</code>)</li></ul></li></ul><p>For each kernel, we</p><ul><li>used <code>dwarf2json</code> (with normal kernel + system map) and <code>btf2json</code> (with debug kernel + system map) to generate a profile (we also measured the time this took the tools),</li><li>booted the kernel in a VM,</li><li>took a memory snapshot of the VM,</li><li>ran all upstream Volatility3 Linux analysis plugins on the memory image, with the debug output cranked up to the highest level.</li></ul><p>For each analysis the</p><ul><li>exit code,</li><li>stdout stream,</li><li>stderr stream,</li></ul><p>were saved.</p><p>We then compared the exit codes, and diffed the stdout and stderr streams, of the analysis plugins with the <code>dwarf2json</code> and <code>btf2json</code> profiles, respectively. Cases where the exit code and/or the stdout/stderr streams differed were manually investigated.</p><p>In total, we evaluated 32 analysis plugins on memory images of 13 different kernels, resulting in a total of <strong>416 unique pairs of memory image and analysis plugin</strong>.</p><ul><li>In 394 cases the exit codes of the plugins running with the <code>btf2json</code>- and <code>dwarf2json</code>-generated profiles were identical.</li><li>In 9 cases the <code>btf2json</code> profile lead to a successful analysis while the analysis with the <code>dwarf2json</code> profile failed. This was the case for the <code>linux.capabilities.Capabilities</code> plugin on all images but Fedora, Ubuntu 23.10, Kali and Archlinux (5 images), and for the <code>linux.check_syscall.Check_syscall</code> plugin on Fedora (4 images).</li><li>In 13 cases the analysis failed with both plugins. This was the case for the <code>linux.vmayarascan.VmaYaraScan</code> plugin on all images.</li></ul><p>We tracked the reason for the failure of the <code>linux.capabilities.Capabilities</code> analysis with the <code>dwarf2json</code> profiles down to the fact that they assigned the <code>kernel_cap_t</code> type for the capabilities in <code>struct cred</code> while <code>btf2json</code> assigned the <code>struct kernel_cap_struct</code> type. While those are in fact related via a typedef, the Volatility3 framework differentiates between them in their implementation to obtain the capability bits. In particular, Volatility uses this distinction to differentiate between pre and post 6.3 kernels (which is why it works on Fedora, Ubuntu, Kali, and Arch), so we believe that there is a bug in the interplay of <code>dwarf2json</code>-profiles and Volatility on older kernels.</p><p>Concerning the failure of the <code>linux.check_syscall.Check_syscall</code> plugin on Fedora, we did not perform an in-depth investigation, however, it seems to be due to issues in the type information of the <code>dwarf2json</code> profile. With the <code>btf2json</code> profile the system call table is correctly extracted.</p><p>Finally, the <code>linux.vmayarascan.VmaYaraScan</code> counts as a failure since it throws an exception if no rules are given.</p><p>Apart from the 9 cases where only the <code>btf2json</code> analysis was successful, the stdout streams of the analyses were identical. On the stderr streams, we observed slight differences in the <code>DEBUG</code>-level log messages that hint at differing inconsistencies in the type information of the profiles (<code>volatility3.framework.symbols: Unresolved reference: </code>messages). On average, running all analyses over an image with the <code>btf2json</code> profile reports 65 unique inconsistencies, whereas a run with the <code>dwarf2json</code> profile detects 90 such inconsistencies.</p><p>With regards to the average runtime, our evaluation showed that the profile generation of <code>btf2json</code> (1.54s) is significantly faster than that of <code>dwarf2json</code> (18.5s), i.e., we see a 12x speedup.</p><p><em>Note:</em> For the evaluation, we used Volatility3 at commit <code>a00a59cd235cb18b7dc28ccf2669e2a82368fab5</code>, <code>btf2json</code> at commit <code>18bd9d1015a7433a85ac2634a7a4f34f6d04c851</code>, and <code>dwarf2json</code> at commit <code>9f14607e0d339d463ea725fbd5c08aa7b7d40f75</code>.</p><h2 id=symbols-are-only-partially-solved>Symbols Are Only Partially Solved</h2><p>Sounds great, right? Well, unfortunately I must admit that <code>btf2json</code> has a dirty secret: the <code>symdb</code>.</p><p>Recall that we defined a symbol as the triple of <code>(name, location, type)</code>. We can get the names and locations from the <code>System.map</code>. However, while BTF is technically able to encode the types of global variables via the <a href=https://www.kernel.org/doc/html/latest/bpf/btf.html#btf-kind-var target=_blank rel=noopener><code>BTF_KIND_VAR</code></a>
and <a href=https://www.kernel.org/doc/html/latest/bpf/btf.html#btf-kind-datasec target=_blank rel=noopener><code>BTF_KIND_DATASEC</code></a>
entries, this is only done for the 400ish per-CPU variables. This leads us to our problem: How do we assign types to symbols?</p><p>Let&rsquo;s take a step back and ask ourselves why we even <em>need</em> the type as part of our definition of a symbol. Symbols are usually the &ldquo;entry point&rdquo; for an analysis. Think of an analysis that lists all tasks, it will usually start at the <code>init_task</code> symbol, and then traverse the dynamically allocated doubly linked list that hangs off it. This stage of &ldquo;getting a foot into the door&rdquo; is where the type of a symbol is needed, and in my experience each analysis is only using a handful of symbols for that purpose.</p><p>Therefore, we decided to measure for which symbols their types are accessed by the existing Volatility analyses. To do so we instrumented the <a href=https://github.com/volatilityfoundation/volatility3/blob/1e871af0644fbd03ba22085241ed795104ccc580/volatility3/framework/interfaces/symbols.py#L60 target=_blank rel=noopener>method responsible for retrieving the type of a symbol</a>
and re-ran all analyses. We found that <strong>32</strong>, of the 150k+, unique symbols have their type accessed. See the Appendix for a <a href=#Appendix-A:-Accessed-Symbols>list of those symbols</a>
.</p><p>As we can see, it is only a tiny fraction of the 150k+ symbols that exist in a Linux kernel.</p><p>This leads me to a bold claim: It is feasible to build and maintain a map <code>([kernel m.m.p version], symbol name) -> (type name)</code> that works in practice.</p><p>I believe that this works for three reasons:</p><ol><li>The subset of symbols that are actually used by analyses is fairly small.</li><li>The type names of these symbols are very stable between kernel versions.</li><li>The type names of these symbols do not depend on build-time configuration options.</li></ol><p>We call this mapping <code>symdb</code> and embed it into the final, stand-alone <code>btf2json</code> executable. Thus, under the above assumptions, <code>btf2json</code> can generate working profiles just from a kernel&rsquo;s BTF information and <code>System.map</code>.</p><p><em>Note</em>: This solution is, in general, inferior to what <code>dwarf2json</code> does. The <code>symdb</code> will contain missing or wrong entries. I just believe that the entries <em>that matter</em> will be correct due to the above considerations.</p><p><em>Note</em>: Currently the <code>symdb</code> is a mapping <code>(symbol name) -> (type name)</code> generated of some kernel I had laying around (and it still works fine for Linux 4.18-6.11!!!). Generating a proper <code>symdb</code> and rigorously evaluating the approach is part of the future work outlined below.</p><h2 id=call-to-action>Call to Action</h2><p>Now, as I said above, I consider this work to be in a half-finished-but-usable state. It can already bring a real benefit to the community, but it is far from reaching its full potential. Thus, here is my vision of what <code>btf2json</code> could become through the investment of considerable time and energy (which I currently do not have). If the community decides that it is a goal worth pursuing, I am confident that we can get there.</p><h3 id=working-on-a-raw-memory-image>Working on a Raw Memory Image</h3><p>Recall that the ultimate goal of automatic profile generation is to generate the profile off a raw memory image. For that to work we would roughly need to add the following things:</p><ul><li><strong>Carve the banner from the image</strong> (conceptually trivial, little work).</li><li><strong>Carve the <code>.BTF</code> section from the image</strong> (conceptually simple, little to medium work). Scanning for the magic bytes <code>0xeb9f</code> and performing some heuristic checks on matches is sufficient, we already prototyped and evaluated this.</li><li><strong>Extract kallsyms from the image</strong>, either<ul><li>using a carving approach like <a href=https://github.com/marin-m/vmlinux-to-elf target=_blank rel=noopener><code>vmlinux-to-elf</code></a>
(conceptually simple, loooots of work),</li><li>using an emulation approach like academic papers (conceptually advanced, medium work). This introduces some big dependencies that make shipping a stand-alone cross-platform executable hard.</li></ul></li></ul><p><em>Note</em>: <code>kallsyms</code> in memory may contain the addresses with ASLR offsets while the <code>System.map</code> has an ASLR-slide of zero. One would either need to find a way to adjust them or teach Volatility to work with &ldquo;real&rdquo; addresses, which would tie the profile to a particular image. I have a rough idea how to do the former: scan for swapper as usual, transition to its root page tables via symbol information, reconstruct page tables and read off slide of kernel region.</p><p><em>Note:</em> This obviously only works for kernels compiled with <code>KALLSYMS=y</code>.</p><h3 id=evaluating-the-symdb-approach>Evaluating the <code>symdb</code> Approach</h3><p>Currently, everything around the <code>symdb</code> is more or less just me eyeballing based on my (limited) experience that &ldquo;this stuff should probably work&rdquo; and our small-scale evaluation. Anyway, we need to actually implement and evaluate this for real!</p><ul><li><strong>Building and automatically maintaining the <code>symdb</code> as it was described above</strong> (conceptually difficult, lots of work). For this we need at the very least the preprocessed C code but working with LLVM IR would be a lot nicer. Then, the extraction of type names for all global symbols is possible for the C code and easy for the LLVM IR. One issue I already see is that to get the preprocessed C code one needs to make choices for all configuration options, and the set of symbols depends on those options - some sort of compromise will be needed here.</li><li><strong>Evaluating the <code>symdb</code> and its underlying assumptions</strong> (conceptually simple, medium work). By using DWARF as ground truth, it should be rather straightforward to evaluate the correctness of the <code>symdb</code> mapping.</li></ul><p>That&rsquo;s it, thanks for reading!</p><h2 id=appendix-a-accessed-symbols>Appendix A: Accessed Symbols</h2><p>List of all symbols whose type is queried when running all Volatility3 analysis plugins. This data was generated by instrumenting the <code>get_type</code> method of the <code>SymbolInterface</code>.</p><p><em>Note</em>: We excluded <code>linux.check_syscall.CheckSyscall</code> as this plugin iterates over (all) symbols and calls <code>get_symbol</code> which, accesses the type for caching purposes. However, it does not use the type information.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>__sched_class_highest
</span></span><span class=line><span class=cl>__sched_class_lowest
</span></span><span class=line><span class=cl>_etext
</span></span><span class=line><span class=cl>_text
</span></span><span class=line><span class=cl>cap_last_cap
</span></span><span class=line><span class=cl>dl_sched_class
</span></span><span class=line><span class=cl>fair_sched_class
</span></span><span class=line><span class=cl>idle_sched_class
</span></span><span class=line><span class=cl>idt_table
</span></span><span class=line><span class=cl>init_files
</span></span><span class=line><span class=cl>init_mm
</span></span><span class=line><span class=cl>init_pid_ns
</span></span><span class=line><span class=cl>init_task
</span></span><span class=line><span class=cl>iomem_resource
</span></span><span class=line><span class=cl>keyboard_notifier_list
</span></span><span class=line><span class=cl>mod_tree
</span></span><span class=line><span class=cl>module_kset
</span></span><span class=line><span class=cl>modules
</span></span><span class=line><span class=cl>net_namespace_list
</span></span><span class=line><span class=cl>prb
</span></span><span class=line><span class=cl>prog_idr
</span></span><span class=line><span class=cl>rt_sched_class
</span></span><span class=line><span class=cl>socket_file_ops
</span></span><span class=line><span class=cl>sockfs_dentry_operations
</span></span><span class=line><span class=cl>stop_sched_class
</span></span><span class=line><span class=cl>tcp4_seq_afinfo
</span></span><span class=line><span class=cl>tcp6_seq_afinfo
</span></span><span class=line><span class=cl>tty_drivers
</span></span><span class=line><span class=cl>udp4_seq_afinfo
</span></span><span class=line><span class=cl>udp6_seq_afinfo
</span></span><span class=line><span class=cl>udplite4_seq_afinfo
</span></span><span class=line><span class=cl>udplite6_seq_afinfo
</span></span></code></pre></div><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Not to mention all the self-compiled kernels that do not have publicly available binary packages at all.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Sorry Windows users, no pre-compiled binaries for you – WSL for the win!&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Alternatively, a portable program can make use of <a href=https://gcc.gnu.org/onlinedocs/gcc/BPF-Built-in-Functions.html target=_blank rel=noopener>compiler built-ins</a>
that can be combined to achieve the same effect, but allow it to do even crazier things, like testing whether a field of an enum exists. I recommend reading <a href=https://nakryiko.com/posts/bpf-core-reference-guide/ target=_blank rel=noopener>this post</a>
if you are interested in learning more about the mechanics of portable programs.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article></div></div></div></main><footer class="flex flex-none justify-center"><section class="flex flex-col md:flex-row mx-2 md:mx-0 gap-2 md:gap-0 justify-between w-full max-w-4xl lg:max-w-5xl py-6 text-slate-500 dark:text-slate-300"><div class="flex flex-row"></div><div class=grow></div><div class="flex flex-row"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-copyright" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-9 0a9 9 0 1018 0A9 9 0 103 12"/><path d="M14 9.75a3.016 3.016.0 00-4.163.173 2.993 2.993.0 000 4.154A3.016 3.016.0 0014 14.25"/></svg>
</i>2022 - 2024 lolcads</div><div class="flex flex-row"><span class="ml-0 pl-0 md:ml-2 md:pl-2 border-l-0 md:border-l border-slate-300 dark:border-slate-400">Powered by <a href=https://gohugo.io target=_blank rel=noopener class=underline>Hugo</a> <span class=text-red-600>&#9829;</span> <a href=https://github.com/tomowang/hugo-theme-tailwind target=_blank rel=noopener class=underline>Tailwind</a></span></div></section></footer><script src=/main.min.c6372b6836971865bd94bfde974748aca8415824a2facab6ccd66a87384bfacb.js></script><div class="hidden top-1 right-1" id=code-copy><i class="h-6 w-6 block"><svg class="icon icon-tabler icon-tabler-copy" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667A2.667 2.667.0 019.667 7h8.666A2.667 2.667.0 0121 9.667v8.666A2.667 2.667.0 0118.333 21H9.667A2.667 2.667.0 017 18.333z"/><path d="M4.012 16.737A2.005 2.005.0 013 15V5c0-1.1.9-2 2-2h10c.75.0 1.158.385 1.5 1"/></svg></i></div><div class="hidden top-1 right-1" id=code-copy-done><i class="h-6 w-6 block"><svg class="icon icon-tabler icon-tabler-check" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 12l5 5L20 7"/></svg></i></div><script src=/code-copy.min.e7b2a74adef1ed474c335c8bd5e7832b2316b8842b0f9184d65286c5bd64f51a.js></script></body></html>