<!doctype html><html lang=en dir=ltr><head><title>Introduction to Android Bytecode Exploitation (Part 1) :: lolcads tech blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Introduction to Android Bytecode Exploitation (Part 1) Android resides among the most popular operating systems for mobile devices, which causes Android to also be among the most popular targets for exploitation. While Android is frequently updated to fix the latest CVEs, malicious actors already search for new vulnerabilities, as gaining control over millions of computationally powerful devices is very appealing. The market shares underpin that Android is by far the most lucrative platform for malicious actors targeting mobile platforms.
"><meta name=keywords content="Android,Bytecode,Exploitation"><meta name=robots content="noodp"><link rel=manifest href=/manifest.json><meta property="og:url" content="https://lolcads.github.io/posts/2024/09/bytecode_exploitation_0/"><meta property="og:site_name" content="lolcads tech blog"><meta property="og:title" content="Introduction to Android Bytecode Exploitation (Part 1)"><meta property="og:description" content="Introduction to Android Bytecode Exploitation (Part 1) Android resides among the most popular operating systems for mobile devices, which causes Android to also be among the most popular targets for exploitation. While Android is frequently updated to fix the latest CVEs, malicious actors already search for new vulnerabilities, as gaining control over millions of computationally powerful devices is very appealing. The market shares underpin that Android is by far the most lucrative platform for malicious actors targeting mobile platforms."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-10T09:11:56+02:00"><meta property="article:modified_time" content="2024-09-10T09:11:56+02:00"><meta property="article:tag" content="Android"><meta property="article:tag" content="Bytecode"><meta property="article:tag" content="Exploitation"><meta name=twitter:card content="summary"><meta name=twitter:title content="Introduction to Android Bytecode Exploitation (Part 1)"><meta name=twitter:description content="Introduction to Android Bytecode Exploitation (Part 1) Android resides among the most popular operating systems for mobile devices, which causes Android to also be among the most popular targets for exploitation. While Android is frequently updated to fix the latest CVEs, malicious actors already search for new vulnerabilities, as gaining control over millions of computationally powerful devices is very appealing. The market shares underpin that Android is by far the most lucrative platform for malicious actors targeting mobile platforms."><link rel=canonical href=https://lolcads.github.io/posts/2024/09/bytecode_exploitation_0/><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/index.min.14211377552be17d56465ae537fca1a7e426b22c2c4ba496c85e278aaa470d24.css></head><body class="flex flex-col min-h-screen w-full bg-slate-50 dark:bg-gray-800"><header class="flex flex-none justify-center z-10"><div class="flex flex-row gap justify-between w-full max-w-4xl lg:max-w-5xl h-12 mt-3"><div class="flex-none ml-2 md:ml-0"><a href=/><img class="h-12 w-12 rounded-full object-cover bg-gray-100" src=/logo.png alt=logo></a></div><div class=flex-1></div><div class=flex-none><nav class="h-full static"><button id=navbar-menu-toggle type=button class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg md:hidden" aria-controls=navbar-menu aria-expanded=false>
<span class=sr-only>Open main menu</span>
<i class="w-8 h-8"><svg class="icon icon-tabler icon-tabler-menu-2" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 6h16"/><path d="M4 12h16"/><path d="M4 18h16"/></svg></i></button><div class="absolute md:static top-16 left-0 right-0 z-50 hidden w-full md:block md:w-auto" id=navbar-menu><ul class="flex flex-col mx-2 md:mx-0 md:flex-row md:border-0 rounded-sm md:rounded-full px-3 text-base font-medium text-slate-800 dark:text-slate-200 shadow-lg bg-white dark:bg-gray-600 shadow-slate-800/5 dark:shadow-slate-200/5 ring-1 ring-slate-900/5 dark:ring-slate-100/5"><li id=post><a class="block px-3 py-3 hover:text-emerald-600 text-emerald-600" href=/posts/ title=Blog>Blog</a></li><li id=about><a class="block px-3 py-3 hover:text-emerald-600" href=/about/ title=About>About</a></li><li id=contact><a class="block px-3 py-3 hover:text-emerald-600" href=/contact/ title=Contact>Contact</a></li></ul></div></nav></div><div class="flex-none mx-1"></div><div class="flex-none md:hidden"><a href=/search/ class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg" aria-controls=navbar-menu aria-expanded=false><span class=sr-only>Search</span>
<i class="w-8 h-8"><svg class="icon icon-tabler icon-tabler-search" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 10m-7 0a7 7 0 1014 0A7 7 0 103 10"/><path d="M21 21l-6-6"/></svg></i></a></div><div class="darkmode-toggle flex flex-none mr-2 md:mr-0"><label for=darkmode-toggle class="flex items-center px-3 cursor-pointer rounded-full bg-gray-100 dark:bg-gray-600" title="Toggle dark mode"><input name=darkmode-toggle id=darkmode-toggle type=checkbox class="sr-only peer" aria-label="Toggle dark mode"><div class="group flex flex-row gap-1 justify-center h-8 px-1 rounded-full bg-white dark:bg-gray-700"><i class="h-6 w-6 flex-none rounded-full bg-yellow-400 place-self-center peer-checked:group-[]:invisible"><svg class="icon icon-tabler icon-tabler-brightness-down" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-3 0a3 3 0 106 0 3 3 0 10-6 0"/><path d="M12 5v.01"/><path d="M17 7v.01"/><path d="M19 12v.01"/><path d="M17 17v.01"/><path d="M12 19v.01"/><path d="M7 17v.01"/><path d="M5 12v.01"/><path d="M7 7v.01"/></svg>
</i><i class="h-6 w-6 flex-none rounded-full place-self-center invisible peer-checked:group-[]:visible"><svg class="icon icon-tabler icon-tabler-moon-stars" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 3c.132.0.263.0.393.0a7.5 7.5.0 007.92 12.446A9 9 0 1112 2.992z"/><path d="M17 4a2 2 0 002 2 2 2 0 00-2 2 2 2 0 00-2-2 2 2 0 002-2"/><path d="M19 11h2m-1-1v2"/></svg></i></div></label></div></div></header><main class="flex flex-auto justify-center"><div class="w-full max-w-4xl lg:max-w-5xl"><div class="flex flex-col mt-6 mx-2 md:mx-0 rounded-lg overflow-hidden shadow-md bg-white dark:bg-gray-700"><div><a href=/posts/2024/09/bytecode_exploitation_0/></a></div><div class="flex flex-col gap-y-3 p-6"><h1 class="text-4xl font-semibold text-slate-800 dark:text-slate-100"><a href=/posts/2024/09/bytecode_exploitation_0/>Introduction to Android Bytecode Exploitation (Part 1)</a></h1><ul class="flex flex-row flex-wrap text-slate-500 dark:text-slate-300"><li><a href=/tags/android/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Android</span></a></li><li><a href=/tags/bytecode/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Bytecode</span></a></li><li><a href=/tags/exploitation/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Exploitation</span></a></li></ul><div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300"><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-calendar" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 7a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V7z"/><path d="M16 3v4"/><path d="M8 3v4"/><path d="M4 11h16"/><path d="M11 15h1"/><path d="M12 15v3"/></svg>
</i><time datetime=2024-09-10T09:11:56+02:00>2024-09-10</time></div><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-hourglass-high" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6.5 7h11"/><path d="M6 20v-2a6 6 0 1112 0v2a1 1 0 01-1 1H7a1 1 0 01-1-1z"/><path d="M6 4v2a6 6 0 1012 0V4a1 1 0 00-1-1H7A1 1 0 006 4z"/></svg>
</i><span>11 minutes to read</span></div></div><div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300"><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-user"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M8 7a4 4 0 108 0A4 4 0 008 7"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
</i><span>Pascal Kühnemann</span></div></div><section class="prose prose-slate dark:prose-invert w-full max-w-4xl lg:max-w-5xl mt-6"><h2>Table of Contents</h2><aside><nav id=TableOfContents><ul><li><a href=#responsible-disclosure>Responsible Disclosure</a></li><li><a href=#test-environment>Test Environment</a></li><li><a href=#analysis-setup>Analysis Setup</a><ul><li><a href=#debugging-android-apps>Debugging Android Apps</a></li><li><a href=#instrumentation-via-frida>Instrumentation via Frida</a></li></ul></li><li><a href=#resources>Resources</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></aside></section><article class="mt-6 w-full max-w-4xl lg:max-w-5xl prose prose-slate dark:prose-invert prose-quoteless post-content"><h1 id=introduction-to-android-bytecode-exploitation-part-1>Introduction to Android Bytecode Exploitation (Part 1)</h1><p>Android resides among the most popular operating systems for mobile devices, which causes Android to also be among the most popular targets for exploitation. While Android is frequently updated to fix the latest CVEs, malicious actors already search for new vulnerabilities, as gaining control over millions of computationally powerful devices is very appealing. The market shares underpin that Android is by far the most lucrative platform for malicious actors targeting mobile platforms.</p><p><div class=not-prose><figure><img src=/2024/09/bytecode_exploitation_0_mobile_market_shares.png alt="Mobile OS Market Shares" loading=lazy></figure></div></p><p>Luckily, Android comes with various enforced security mechanisms. Depending on what <em>layer</em> is considered, there are for example the higher - level Android permission system encouraging to adhere to the <em>principle of least privileges</em>, and the lower - level <em>Address Space Layout Randomization</em> (ASLR) randomizing the layouts of process images so adversaries cannot easily predict the locations of critical code or data. Furthermore, apps are isolated from each other, which prevents malicious apps from e.g. manipulating a banking app&rsquo;s internal storage. Overall, for an adversary to be &ldquo;successful&rdquo;, depending on the adversaries&rsquo; goals, there are plenty of security mechanisms to bypass.</p><p>The attack surface of Android is large and consists of, among other things, the intent system and the associated <code>binder</code>, socket communication and app configurations. Adding to the pile, Android apps can utilize the <em>Java Native Interface</em> (JNI) to delegate parts of an application to the native layer, potentially increasing app performance. However, using native code, i.e. code written in <em>memory unsafe</em> languages like <em>C/C++</em> that runs directly on the CPU, brings in the problems of that specific language. Memory unsafe languages are famous for memory corruption vulnerabilities, which would be impossible to get when writing apps only in e.g. Java. For a concrete example of a <em>Write - What - Where</em> (WWW) condition, consider the following sample code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span>
</span></span><span class=line><span class=cl><span class=n>JNIEXPORT</span> <span class=kt>void</span> <span class=n>JNICALL</span>
</span></span><span class=line><span class=cl><span class=n>Java_</span><span class=o>&lt;</span><span class=n>package_path</span><span class=o>&gt;</span><span class=n>_</span><span class=o>&lt;</span><span class=n>class_name</span><span class=o>&gt;</span><span class=n>_</span><span class=o>&lt;</span><span class=n>native_method_name</span><span class=o>&gt;</span><span class=p>(</span><span class=n>JNIEnv</span> <span class=o>*</span><span class=n>env</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>jclass</span> <span class=n>clazz</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>jlong</span> <span class=n>address</span><span class=p>,</span> <span class=n>jlong</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=kt>uint64_t</span><span class=o>*</span><span class=p>)</span><span class=n>address</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This could still occur (in a more subtle way) inside a legitimate app that uses JNI. Luckily, by default Android uses security mechanisms like <em>stack canary</em>, <em>NX</em>, <em>ASLR</em>, <em>Fortify</em>, <em>RELRO</em> and the hardened heap allocator <a href=https://lolcads.github.io/posts/2024/07/scudo_0/ target=_blank rel=noopener><em>Scudo</em></a>
to name a few examples. Further, Android provides vendors with the ability to build entire components with <a href=https://source.android.com/docs/security/test/shadow-call-stack target=_blank rel=noopener><em>ShadowCallStack</em></a>
and <a href=https://source.android.com/docs/security/test/cfi target=_blank rel=noopener><em>Control - Flow Integrity</em> (CFI)</a>
. For a concrete example, consider the output of <a href=https://github.com/slimm609/checksec.sh target=_blank rel=noopener><code>checksec</code></a>
on <code>libart.so</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ./checksec --version                                                                           
</span></span><span class=line><span class=cl>checksec v2.7.1, Brian Davis, github.com/slimm609/checksec.sh, Dec <span class=m>2015</span>
</span></span><span class=line><span class=cl>Based off checksec v1.5, Tobias Klein, www.trapkit.de, November <span class=m>2011</span>
</span></span><span class=line><span class=cl>$ ./checksec --file<span class=o>=</span>libart.so
</span></span><span class=line><span class=cl>RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE
</span></span><span class=line><span class=cl>Full RELRO      Canary found      NX enabled    DSO             No RPATH   No RUNPATH   <span class=m>36417</span> Symbols	N/A	0		0		libart.so
</span></span></code></pre></div><p>With all these mechanisms in place, the question we want to answer in this series of blog posts is the following:</p><blockquote><p>Assuming exploitation on native code level using techniques that directly work with native code (.*ROP, JOP, COOP, LOOP, &mldr;) does <strong>not</strong> work. What exploitation techniques specific to Android are still available to an attacker trying to exploit a native - level vulnerability?</p></blockquote><p>There is plenty of research targeting the Java - and apk - layers and IPC mechanisms. However, to the best of our knowledge, there does not seem to be any research related to bytecode - based exploitation <em>at runtime</em>. Of course, patching an apk - file requires (static) bytecode injection, but this is not useful if an attacker wants to exploit a vulnerability that is only exposed at runtime. Furthermore, by understanding the <em>offensive perspective</em>, we may be able to derive security mechanisms that prevent a particular technique (memory safe languages do not count for now!). Surprisingly, it turns out that Android app security in presence of a memory error is the <em>minimum</em> of the security of native code and bytecode! Below figure illustrates the idea.<div class=not-prose><figure><img src=/2024/09/bytecode_exploitation_0_bytecode_security_gap.png alt="Android Security Gap" loading=lazy></figure></div></p><p>In other words, there are two execution models on Android, namely <em>native</em> and <em>bytecode</em>. Although each model utilizes its own mountain of security mechanisms, the total security level of an app in presence of a memory error is just as high as the smallest mountain. Thus, there is a difference between the <em>expected</em> and <em>actual security</em> in presence of a memory error, which I call <em>security gap</em>. For example, an attacker facing <em>CFI</em> and <em>ShadowStack</em> is likely to fail defeating the native mountain, but may succeed by conquering the bytecode mountain. Some security mechanisms have impact on both models, like <em>ASLR</em> and the <em>permission system</em> to name a few. In addition to practical security mechanisms, the defensive research community has developed a lot of strong, yet impractical solutions to prevent exploitation of memory errors.</p><p>Now, one may raise the question about <a href=https://github.com/fkie-cad/eeva target=_blank rel=noopener>practicality</a>
. Are there even apps that use JNI <em>and</em> vulnerable native - level functions? According to <a href=https://arxiv.org/pdf/1911.09716 target=_blank rel=noopener>Almanee et al.</a>
, Android apps use a plethora of native - level libraries. Furthermore, it is shown that updating vulnerable libraries takes a considerable amount of time, meaning that adversaries have a good chance to successfully exploit a bug in an app using a library with a known CVE. Also, <a href=https://www.researchgate.net/publication/363739852_Reach_Me_if_You_Can_On_Native_Vulnerability_Reachability_in_Android_Apps target=_blank rel=noopener>Borzacchiello et al.</a>
show that vulnerable native functions can often be reached from the Java side. With both studies combined, we gain the privilege to focus solely on exploitation of an <em>assumed</em> vulnerability, because vulnerabilities are known to be patched slowly and to be reachable. However, apps rarely state that they are affected by a vulnerability in one of their native libraries, which is why we skip over the hunt for a real - world vulnerability for now. If we show that exploitation of a native - level vulnerability (like stack - buffer overflow) using only bytecode is possible, then this means that exploitability of all apps using vulnerable libraries must be reconsidered. This stems from the fact that bytecode - based exploitation is not expected to be mitigated by native - level exploit mitigations. For a concrete example, even though ROP may be (almost) impossible to use to exploit a stack - buffer overflow <em>without</em> executable pointer leak, orthogonally, bytecode injection may very well be applicable.</p><p>Overall, the following topics are covered by individual blog posts:</p><ol><li>Introduction (this post): Gives an overview over the test environment, test device, resources used during research and some tips for (dynamic) Android app analysis.</li><li><a href=https://lolcads.github.io/posts/2024/09/bytecode_exploitation_1/ target=_blank rel=noopener>Android Process Fundamentals</a>
: Shows how bytecode execution is kicked off in Android 13, what common libraries reside in <em>every</em> App and how Java (JNI) methods are invoked. Also, some more advanced app analysis techniques are discussed.</li><li><a href=https://lolcads.github.io/posts/2024/09/bytecode_exploitation_2/ target=_blank rel=noopener>Bytecode Injection</a>
: First exploitation technique shows a major flaw in the design of (probably any) interpreter: data = code. A first PoC using bytecode injection, where e.g. ROP seems impossible, is discussed in detail.</li><li><a href=https://lolcads.github.io/posts/2024/09/bytecode_exploitation_3/ target=_blank rel=noopener>Bytecode Reuse</a>
: Second exploitation technique shows that solving the first flaw will not help, because (byte-)code reuse attacks are possible again. This is a very advanced and specific technique based on the ideas of <a href="https://ieeexplore.ieee.org/ielx7/7160813/7163005/07163058.pdf?tag=1" target=_blank rel=noopener>COOP</a>
and <a href=https://portswigger.net/web-security/deserialization/exploiting target=_blank rel=noopener>insecure deserialization</a>
.</li></ol><p>Of course, there is an associated <a href=https://github.com/fkie-cad/Android-Bytecode-Exploitation/tree/main target=_blank rel=noopener>github repository</a>
that contains all PoCs, deliberately vulnerable apps and more.</p><p>Notice that bytecode exploitation on Android as of writing is <em>very tricky</em>, requiring knowledge that seems out - of - place when talking about native - level exploitation. The goal of every PoC will be <em>arbitrary command execution</em> in the context of the vulnerable app. However, I claim that an attacker can fully take over the target app, including its privileges. Also, it may be that some observations about Android are sprinkled into the posts.</p><p>Before delving into the details, the setup must be discussed. Also, some information on the disclosure process is given.</p><h2 id=responsible-disclosure>Responsible Disclosure</h2><p>All research results, including working PoCs, have been submitted to Google&rsquo;s bug bounty program to ensure that publishing these blog posts does not cause any severe security problems and to give Google time to investigate the findings and respond, if necessary. Of course, there are no concrete vulnerabilities, but rather a new exploitation concept on Android. Also, I find it hard to estimate the practical impact of these blog posts, because many stars must align for bytecode injection and reuse to work, which is why I welcomed the feedback. Fortunately, Google decided the results are <strong>not</strong> a security concern and gave permission to publish blog posts on that matter!</p><h2 id=test-environment>Test Environment</h2><p>Everything discussed in this series of blog posts has been thoroughly tested on a <em>rooted Google Pixel 7</em>, with build number <code>TQ3A.230901.001.C2</code>. This <a href=https://source.android.com/docs/setup/reference/build-numbers#source-code-tags-and-builds target=_blank rel=noopener>boils down</a>
to tag <code>android-13.0.0_r78</code>. The only reason the device is rooted is that it simplifies using <code>gdb</code> and <code>frida-server</code>.</p><p>Furthermore, we build deliberately vulnerable apps that expose their vulnerabilities via a simple network interface based on <code>ServerSocket</code> and <code>Socket</code>. These apps are built in <em>release</em> mode using <em>default</em> configurations of Android Studio (version: 2023.2.1 Patch 1 (Build #AI-232.10300.40.2321.11567975)), working with the assumption that the principle of <em>security by default</em> is followed thoroughly in Android Studio.</p><h2 id=analysis-setup>Analysis Setup</h2><p>With a <em>rooted</em> Pixel 7, USB debugging is used to get a shell on the device via <a href=https://developer.android.com/tools/adb target=_blank rel=noopener><code>adb</code></a>
. Assuming the device is connected to a host, <code>adb</code> is set up and USB - debugging is enabled, run:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>host<span class=o>)</span>$ adb shell
</span></span><span class=line><span class=cl><span class=o>(</span>device<span class=o>)</span>$ su
</span></span><span class=line><span class=cl><span class=o>(</span>device<span class=o>)</span><span class=c1># </span>
</span></span></code></pre></div><p>to obtain a <em>root</em> shell.</p><p>Furthermore, <code>gdbserver</code> or <code>frida-server</code> are used to attach to a target app for detailed dynamic analysis. Luckily, there exists the <code>/data/local/tmp</code> directory, which is world - readable and - writeable. Using <code>adb push &lt;host file name> /data/local/tmp/&lt;file name></code> allows moving e.g. <code>gdbserver</code> to the device. In turn, this enables debugging apps.</p><blockquote><p><em>Note</em>: Another interesting, world - readable file is <a href=https://chromium.googlesource.com/chromium/src/+/HEAD/android_webview/docs/how-does-loading-work.md#Loading-native-code-with-RELRO-sharing target=_blank rel=noopener><code>/data/misc/shared_relro/libwebviewchromium64.relro</code></a>
. This contains actual virtual addresses used by apps that utilize <code>WebView</code>. At first glance, an unprivileged app does not gain anything from reading this file, because Android&rsquo;s fork server architecture shares such information anyways.</p></blockquote><h3 id=debugging-android-apps>Debugging Android Apps</h3><p>To gain a deep understanding of control flow at runtime, especially during execution of an exploit, <a href=https://sourceware.org/gdb/ target=_blank rel=noopener><code>gdb</code></a>
is used. To be precise, <a href=https://github.com/hugsy/gef target=_blank rel=noopener><code>gef</code></a>
is used, but this is personal preference. Associated with <code>gdb</code> is <a href=https://github.com/android/ndk/wiki/Unsupported-Downloads#r23c target=_blank rel=noopener><code>gdbserver</code></a>
, which allows attaching to a running process, like an app, based on the app&rsquo;s pid. To figure out the pid of e.g. <code>"youtube"</code>, run the following commands:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>devive<span class=o>)</span>$ pm list packages youtube
</span></span><span class=line><span class=cl>package:com.google.android.youtube      <span class=c1># &lt;--- probably this one</span>
</span></span><span class=line><span class=cl>package:com.google.android.apps.youtube.music
</span></span><span class=line><span class=cl><span class=o>(</span>device<span class=o>)</span>$ pidof com.google.android.youtube  <span class=c1># not running</span>
</span></span><span class=line><span class=cl><span class=o>(</span>device<span class=o>)</span>$ pidof com.google.android.youtube
</span></span><span class=line><span class=cl><span class=m>11287</span>
</span></span></code></pre></div><p>Combining this with <code>gdb</code> yields the following command for attaching to the target app:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>device<span class=o>)</span><span class=c1># /data/local/tmp/gdbserver :1337 --attach $(pidof &lt;name of app&gt;)</span>
</span></span></code></pre></div><p>To connect <code>gdb</code> to <code>gdbserver</code> running on the device, the debug port must be forwarded:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>host<span class=o>)</span>$ adb forward tcp:1337 tcp:1337
</span></span></code></pre></div><p>Before we can start debugging, it may be useful to get some symbol information. To that end, identify what libraries are relevant for the current task, use <code>adb pull</code> to pull them into a directory, say <code>dbgtmp</code>, and run:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>device<span class=o>)</span>$ gdb-multiarch -q
</span></span><span class=line><span class=cl>gef➤  <span class=nb>set</span> solib-search-path ./dbgtmp/
</span></span><span class=line><span class=cl>gef➤  <span class=nb>set</span> solib-absolute-prefix ./dbgtmp/
</span></span></code></pre></div><p>Now, <code>gdb</code> knows where to look for symbols while debugging.</p><p>At last, <code>gdb</code> can connect to the server</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>gef➤  target extended-remote :1337
</span></span><span class=line><span class=cl>gef➤  sharedlibrary
</span></span></code></pre></div><p>These may seem like a lot of steps, but it is worth it!</p><h4 id=about-lldb>About <code>lldb</code></h4><p>Of course, it is also possible to use <a href=https://lldb.llvm.org/ target=_blank rel=noopener><code>lldb</code></a>
to debug an app. For example, one can utilize Android Studio&rsquo;s integrated native debugging based on <code>lldb</code> to debug apps. <code>lldb</code> does a great job at resolving symbols, but there seems to be a lack of <em>plugins</em>. For example, I use <code>gef</code> for debugging Android apps, which comes with features like memory search and hexdumping. That being said, <code>lldb</code> is (hopefully) sematically equivalent to <code>gdb</code> and its plugins. It does not matter what debugger is used, but I prefer <code>gdb</code>.</p><h3 id=instrumentation-via-frida>Instrumentation via Frida</h3><p>While debugging can also be automated, it is somewhat inefficient and does not always provide the features needed for dynamic analysis. For example, finding the representation of the <code>java.lang.Class</code> <em>object</em> seems like a daunting task when only equipped with a debugger. This is where <a href=https://frida.re/docs/home/ target=_blank rel=noopener><code>frida</code></a>
comes to the rescue. Unfortunately, <code>frida</code> is too complex to fit a <a href=https://frida.re/docs/examples/android/ target=_blank rel=noopener>tutorial</a>
into this series of blog posts.</p><p>To get <code>frida</code> up and running, utilize <a href=https://github.com/frida/frida/releases target=_blank rel=noopener><code>frida-server</code></a>
:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>host<span class=o>)</span>$ adb push frida-server /data/local/tmp/frida-server
</span></span><span class=line><span class=cl><span class=o>(</span>host<span class=o>)</span>$ adb shell
</span></span><span class=line><span class=cl><span class=o>(</span>device<span class=o>)</span>$ su
</span></span><span class=line><span class=cl><span class=o>(</span>device<span class=o>)</span><span class=c1># /data/local/tmp/frida-server</span>
</span></span></code></pre></div><p>Now, to attach to some process based on the pid, use the following python code</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>import</span> <span class=nn>frida</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>device</span> <span class=o>=</span> <span class=n>frida</span><span class=o>.</span><span class=n>get_usb_device</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>session</span> <span class=o>=</span> <span class=n>device</span><span class=o>.</span><span class=n>attach</span><span class=p>(</span><span class=o>&lt;</span><span class=n>pid</span><span class=o>&gt;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>script</span> <span class=o>=</span> <span class=n>session</span><span class=o>.</span><span class=n>create_script</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>    for (let i = 0; i &lt; 10; i++) </span><span class=se>{{</span><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>        console.log(&#34;Hijacked </span><span class=si>{</span><span class=n>pid</span><span class=si>}</span><span class=s1>&#34;);
</span></span></span><span class=line><span class=cl><span class=s1>    </span><span class=se>}}</span><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>on_message</span><span class=p>(</span><span class=n>message</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>message</span><span class=p>[</span><span class=s1>&#39;type&#39;</span><span class=p>]</span> <span class=o>==</span> <span class=s1>&#39;send&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;</span><span class=si>{</span><span class=n>message</span><span class=p>[</span><span class=s1>&#39;payload&#39;</span><span class=p>]</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;Something went wrong: </span><span class=si>{</span><span class=n>message</span><span class=p>[</span><span class=s2>&#34;description&#34;</span><span class=p>]</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=n>message</span><span class=p>[</span><span class=s1>&#39;stack&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>script</span><span class=o>.</span><span class=n>on</span><span class=p>(</span><span class=s1>&#39;message&#39;</span><span class=p>,</span> <span class=n>on_message</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>script</span><span class=o>.</span><span class=n>load</span><span class=p>()</span>
</span></span></code></pre></div><p>It may be beneficial to use format strings for setting up the js script to run inside the target app, e.g. to set a default block size for memory dumping.</p><h2 id=resources>Resources</h2><p>The main resource, the foundation of all this research, is the <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78 target=_blank rel=noopener>source code of the Android Runtime (ART)</a>
. However, a lot of knowledge has been generated from simply testing hypotheses, days of debugging and trying to make as many cross - references to already well - known topics as possible. For example, having some knowledge on COOP attacks allowed me to come up with the technique for bytecode reuse. This is why some statements made throughout this series are without a concrete reference.</p><h2 id=conclusion>Conclusion</h2><p>In this blog post, we laid some groundwork for understanding bytecode - based exploitation on Android. Most importantly, we discussed the execution environment and how to set up <code>gdb</code> and <code>frida</code>. The next post will be a deep dive into various Android components, especially the fork server architecture and its implications for Android apps!</p></article></div></div></div></main><footer class="flex flex-none justify-center"><section class="flex flex-col md:flex-row mx-2 md:mx-0 gap-2 md:gap-0 justify-between w-full max-w-4xl lg:max-w-5xl py-6 text-slate-500 dark:text-slate-300"><div class="flex flex-row"></div><div class=grow></div><div class="flex flex-row"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-copyright" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-9 0a9 9 0 1018 0A9 9 0 103 12"/><path d="M14 9.75a3.016 3.016.0 00-4.163.173 2.993 2.993.0 000 4.154A3.016 3.016.0 0014 14.25"/></svg>
</i>2022 - 2025 lolcads</div><div class="flex flex-row"><span class="ml-0 pl-0 md:ml-2 md:pl-2 border-l-0 md:border-l border-slate-300 dark:border-slate-400">Powered by <a href=https://gohugo.io target=_blank rel=noopener class=underline>Hugo</a> <span class=text-red-600>&#9829;</span> <a href=https://github.com/tomowang/hugo-theme-tailwind target=_blank rel=noopener class=underline>Tailwind</a></span></div></section></footer><script src=/main.min.c6372b6836971865bd94bfde974748aca8415824a2facab6ccd66a87384bfacb.js></script><div class="hidden top-1 right-1" id=code-copy><i class="h-6 w-6 block"><svg class="icon icon-tabler icon-tabler-copy" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667A2.667 2.667.0 019.667 7h8.666A2.667 2.667.0 0121 9.667v8.666A2.667 2.667.0 0118.333 21H9.667A2.667 2.667.0 017 18.333z"/><path d="M4.012 16.737A2.005 2.005.0 013 15V5c0-1.1.9-2 2-2h10c.75.0 1.158.385 1.5 1"/></svg></i></div><div class="hidden top-1 right-1" id=code-copy-done><i class="h-6 w-6 block"><svg class="icon icon-tabler icon-tabler-check" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 12l5 5L20 7"/></svg></i></div><script src=/code-copy.min.e7b2a74adef1ed474c335c8bd5e7832b2316b8842b0f9184d65286c5bd64f51a.js></script></body></html>