<!doctype html><html lang=en dir=ltr><head><title>Bytecode Reuse Attack (Part 4) :: lolcads tech blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Bytecode Reuse Attack (Part 4) As last blog post on bytecode - based exploitation on Android, the next step following bytecode injection is discussed, namely: bytecode reuse.
To answer the question about why an attacker needs bytecode reuse, although there already is bytecode injection, remember the arms race in (binary) exploitation. In a nutshell, a new exploitation technique triggers a reaction in form of at least one security mechanism that (partially) mitigates the new technique. If only bytecode injection was researched, then the best response would be the development of a new security mechanism that prevents nterp from executing arbitrary data. In other words, nterp would be restricted to executable code, i.e. bytecode. To be honest, every developer would respond with such a fix, myself included! However, bytecode injection is not the full potential of bytecode - based exploitation.
"><meta name=keywords content="Android,Bytecode,Exploitation"><meta name=robots content="noodp"><link rel=manifest href=/manifest.json><meta property="og:url" content="https://lolcads.github.io/posts/2024/09/bytecode_exploitation_3/"><meta property="og:site_name" content="lolcads tech blog"><meta property="og:title" content="Bytecode Reuse Attack (Part 4)"><meta property="og:description" content="Bytecode Reuse Attack (Part 4) As last blog post on bytecode - based exploitation on Android, the next step following bytecode injection is discussed, namely: bytecode reuse.
To answer the question about why an attacker needs bytecode reuse, although there already is bytecode injection, remember the arms race in (binary) exploitation. In a nutshell, a new exploitation technique triggers a reaction in form of at least one security mechanism that (partially) mitigates the new technique. If only bytecode injection was researched, then the best response would be the development of a new security mechanism that prevents nterp from executing arbitrary data. In other words, nterp would be restricted to executable code, i.e. bytecode. To be honest, every developer would respond with such a fix, myself included! However, bytecode injection is not the full potential of bytecode - based exploitation."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-10T09:25:28+02:00"><meta property="article:modified_time" content="2024-09-10T09:25:28+02:00"><meta property="article:tag" content="Android"><meta property="article:tag" content="Bytecode"><meta property="article:tag" content="Exploitation"><meta name=twitter:card content="summary"><meta name=twitter:title content="Bytecode Reuse Attack (Part 4)"><meta name=twitter:description content="Bytecode Reuse Attack (Part 4) As last blog post on bytecode - based exploitation on Android, the next step following bytecode injection is discussed, namely: bytecode reuse.
To answer the question about why an attacker needs bytecode reuse, although there already is bytecode injection, remember the arms race in (binary) exploitation. In a nutshell, a new exploitation technique triggers a reaction in form of at least one security mechanism that (partially) mitigates the new technique. If only bytecode injection was researched, then the best response would be the development of a new security mechanism that prevents nterp from executing arbitrary data. In other words, nterp would be restricted to executable code, i.e. bytecode. To be honest, every developer would respond with such a fix, myself included! However, bytecode injection is not the full potential of bytecode - based exploitation."><link rel=canonical href=https://lolcads.github.io/posts/2024/09/bytecode_exploitation_3/><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/index.min.c860e17f20d9f258820c02bf7ab3f57c9595d0bc21dede7eda08ccd63ba3f4cc.css></head><body class="flex flex-col min-h-screen w-full bg-slate-50 dark:bg-gray-800"><header class="flex flex-none justify-center z-10"><div class="flex flex-row gap justify-between w-full max-w-4xl lg:max-w-5xl h-12 mt-3"><div class="flex-none ml-2 md:ml-0"><a href=/><img class="h-12 w-12 rounded-full object-cover bg-gray-100" src=/logo.png alt=logo></a></div><div class=flex-1></div><div class=flex-none><nav class="h-full static"><button id=navbar-menu-toggle type=button class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg md:hidden" aria-controls=navbar-menu aria-expanded=false>
<span class=sr-only>Open main menu</span>
<i class="w-8 h-8"><svg class="icon icon-tabler icon-tabler-menu-2" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 6h16"/><path d="M4 12h16"/><path d="M4 18h16"/></svg></i></button><div class="absolute md:static top-16 left-0 right-0 z-50 hidden w-full md:block md:w-auto" id=navbar-menu><ul class="flex flex-col mx-2 md:mx-0 md:flex-row md:border-0 rounded-sm md:rounded-full px-3 text-base font-medium text-slate-800 dark:text-slate-200 shadow-lg bg-white dark:bg-gray-600 shadow-slate-800/5 dark:shadow-slate-200/5 ring-1 ring-slate-900/5 dark:ring-slate-100/5"><li id=post><a class="block px-3 py-3 hover:text-emerald-600 text-emerald-600" href=/posts/ title=Blog>Blog</a></li><li id=about><a class="block px-3 py-3 hover:text-emerald-600" href=/about/ title=About>About</a></li><li id=contact><a class="block px-3 py-3 hover:text-emerald-600" href=/contact/ title=Contact>Contact</a></li></ul></div></nav></div><div class="flex-none mx-1"></div><div class="flex-none md:hidden"><a href=/search/ class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg" aria-controls=navbar-menu aria-expanded=false><span class=sr-only>Search</span>
<i class="w-8 h-8"><svg class="icon icon-tabler icon-tabler-search" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 10m-7 0a7 7 0 1014 0A7 7 0 103 10"/><path d="M21 21l-6-6"/></svg></i></a></div><div class="darkmode-toggle flex flex-none mr-2 md:mr-0"><label for=darkmode-toggle class="flex items-center px-3 cursor-pointer rounded-full bg-gray-100 dark:bg-gray-600" title="Toggle dark mode"><input name=darkmode-toggle id=darkmode-toggle type=checkbox class="sr-only peer" aria-label="Toggle dark mode"><div class="group flex flex-row gap-1 justify-center h-8 px-1 rounded-full bg-white dark:bg-gray-700"><i class="h-6 w-6 flex-none rounded-full bg-yellow-400 place-self-center peer-checked:group-[]:invisible"><svg class="icon icon-tabler icon-tabler-brightness-down" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-3 0a3 3 0 106 0 3 3 0 10-6 0"/><path d="M12 5v.01"/><path d="M17 7v.01"/><path d="M19 12v.01"/><path d="M17 17v.01"/><path d="M12 19v.01"/><path d="M7 17v.01"/><path d="M5 12v.01"/><path d="M7 7v.01"/></svg>
</i><i class="h-6 w-6 flex-none rounded-full place-self-center invisible peer-checked:group-[]:visible"><svg class="icon icon-tabler icon-tabler-moon-stars" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 3c.132.0.263.0.393.0a7.5 7.5.0 007.92 12.446A9 9 0 1112 2.992z"/><path d="M17 4a2 2 0 002 2 2 2 0 00-2 2 2 2 0 00-2-2 2 2 0 002-2"/><path d="M19 11h2m-1-1v2"/></svg></i></div></label></div></div></header><main class="flex flex-auto justify-center"><div class="w-full max-w-4xl lg:max-w-5xl"><div class="flex flex-col mt-6 mx-2 md:mx-0 rounded-lg overflow-hidden shadow-md bg-white dark:bg-gray-700"><div><a href=/posts/2024/09/bytecode_exploitation_3/></a></div><div class="flex flex-col gap-y-3 p-6"><h1 class="text-4xl font-semibold text-slate-800 dark:text-slate-100"><a href=/posts/2024/09/bytecode_exploitation_3/>Bytecode Reuse Attack (Part 4)</a></h1><ul class="flex flex-row flex-wrap text-slate-500 dark:text-slate-300"><li><a href=/tags/android/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Android</span></a></li><li><a href=/tags/bytecode/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Bytecode</span></a></li><li><a href=/tags/exploitation/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Exploitation</span></a></li></ul><div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300"><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-calendar" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 7a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V7z"/><path d="M16 3v4"/><path d="M8 3v4"/><path d="M4 11h16"/><path d="M11 15h1"/><path d="M12 15v3"/></svg>
</i><time datetime=2024-09-10T09:25:28+02:00>2024-09-10</time></div><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-hourglass-high" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6.5 7h11"/><path d="M6 20v-2a6 6 0 1112 0v2a1 1 0 01-1 1H7a1 1 0 01-1-1z"/><path d="M6 4v2a6 6 0 1012 0V4a1 1 0 00-1-1H7A1 1 0 006 4z"/></svg>
</i><span>30 minutes to read</span></div></div><div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300"><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-user"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M8 7a4 4 0 108 0A4 4 0 008 7"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
</i><span>Pascal KÃ¼hnemann</span></div></div><section class="prose prose-slate dark:prose-invert w-full max-w-4xl lg:max-w-5xl mt-6"><h2>Table of Contents</h2><aside><nav id=TableOfContents><ul><li><a href=#assumptions>Assumptions</a></li><li><a href=#necessary-groundwork>Necessary Groundwork</a><ul><li><a href=#invoking-interface-methods>Invoking Interface Methods</a></li></ul></li><li><a href=#goal>Goal</a><ul><li><a href=#core-idea>Core Idea</a></li><li><a href=#high---level-solution>High - Level Solution</a></li><li><a href=#kicking-off-execution>Kicking Off Execution</a></li><li><a href=#proof-of-concept>Proof of Concept</a></li></ul></li><li><a href=#potential-solutions>Potential Solutions</a></li></ul></nav></aside></section><article class="mt-6 w-full max-w-4xl lg:max-w-5xl prose prose-slate dark:prose-invert prose-quoteless post-content"><h1 id=bytecode-reuse-attack-part-4>Bytecode Reuse Attack (Part 4)</h1><p>As last blog post on bytecode - based exploitation on Android, the next step following bytecode injection is discussed, namely: <em>bytecode reuse</em>.</p><p>To answer the question about <em>why</em> an attacker needs bytecode reuse, although there already is bytecode injection, remember the <em>arms race</em> in (binary) exploitation. In a nutshell, a new exploitation technique triggers a reaction in form of at least one security mechanism that (partially) mitigates the new technique. If only bytecode injection was researched, then the best response would be the development of a new security mechanism that prevents <code>nterp</code> from executing arbitrary data. In other words, <code>nterp</code> would be restricted to <em>executable code</em>, i.e. bytecode. To be honest, every developer would respond with such a fix, myself included! However, bytecode injection is not the full potential of bytecode - based exploitation.</p><p>Therefore, the core idea is to provide enough information on bytecode - based exploitation to be able to understand its implications on security and maybe design fitting mitigations. In terms of the below visualization, instead of filling in the left mountain one by one, providing more research results on bytecode - based exploitation may enable the creation of a batch of security mechanisms. Notice that the below illustration shows a kind of security deception: the security level of an app in the presence of a memory error is the <em>minimum</em> of the security levels of all interpreters. As <code>nterp</code> is not protected at all except by side effects of e.g. ASLR, the presence of strong native - level security mechanisms may give a false sense of security.<div class=not-prose><figure><img src=/2024/09/bytecode_exploitation_3_bytecode_security_gap.png alt="Android Security Gap" loading=lazy></figure></div></p><p>Later on, after the bytecode reuse attack is somewhat understood, a few mitigation attempts are discussed. However, <em>practical</em> mitigations are yet to be found!</p><p>Before we delve into bytecode reuse attacks on Android, just a heads up:</p><blockquote><p><strong>Disclaimer</strong>: Bytecode reuse is the most complicated exploitation technique in this series of blog posts. To derive it, we draw from various fields in offensive security. Hence, this post is <strong>very</strong> technical and one of the harder posts to digest.</p></blockquote><h2 id=assumptions>Assumptions</h2><p>For simplicity, we assume an attacker is able to trick a victim into installing and runnning an <em>unprivileged</em> app. I.e. in this blog post, next to bytecode reuse, the potential security impact of Android&rsquo;s <em>fork server architecture</em> is investigated via a <em>local</em> attacker. While a successful <em>remote</em> attacker shows a much greater impact than a successful <em>local</em> attacker, according to other <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8947838" target=_blank rel=noopener>research</a>
the installation of some arbitrary, potentially malicious app is no unrealistic assumption!</p><p>Again, for simplicity, the <em>local</em> attacker is represented by a &ldquo;simple&rdquo; python script that emulates app interactions via socket communication. Therefore, when working with fork server - related information leaks, instead of writing an app that parses its own process image, the python script is simply given addresses taken from <code>gdb</code>. This requires caution to not use any app - specific addresses. In order to ensure that only fork server - related leaks are used by the script, the attack must be successful over multiple app restarts!</p><p>For the same reasons discussed for bytecode injection, a vulnerable app is created. However, the app itself does not provide any information leaks, but <em>only</em> the ability to <em>repeatedly</em> invoke a <em>write - what - where</em> (WWW) condition. I.e. an attacker is able to directly specify a value and an address to write the value to. The goal then is to derive a generic exploitation technique that reuses <em>existing</em> bytecode in the target app. Again, a WWW, while a very strong primitive, is only an example vulnerability to ease testing and demonstrating different attacks. It does not yield any benefit to artificially construct a complicated vulnerability! In fact, it would make the ~1000 LoC PoC for the WWW even longer and harder to read (although a python guru would most likely be able to squeeze my 1000 LoC into 10).</p><p>Below is the vulnerable native function accessible to an attacker.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span>
</span></span><span class=line><span class=cl><span class=n>JNIEXPORT</span> <span class=kt>void</span> <span class=n>JNICALL</span>
</span></span><span class=line><span class=cl><span class=n>Java_com_poc_poc_1local_MainActivity_www</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>JNIEnv</span> <span class=o>*</span><span class=n>env</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>jclass</span> <span class=n>clazz</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>        <span class=n>jlong</span> <span class=n>address</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>jlong</span> <span class=n>value</span><span class=p>)</span> <span class=n>__attribute__</span> <span class=p>((</span><span class=n>optnone</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=kt>uint64_t</span><span class=o>*</span><span class=p>)</span><span class=n>address</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Next, as usual, a few basics must be discussed.</p><h2 id=necessary-groundwork>Necessary Groundwork</h2><p>Luckily, the majority of basics is covered in a previous blog post. Therefore, the only mechanism left to understand is <code>invoke-interface</code>. Although we all love reading through tons of source code, I use a numbering scheme of the form <code>[1]</code>, <code>[2]</code> etc. to mark points of interest in code. After the source code listings, these markings are summarized and discussed, so there is no need to fully read all source code snippets!</p><h3 id=invoking-interface-methods>Invoking Interface Methods</h3><p>The bytecode instruction <code>invoke-interface</code> is used in scenarios where <em>polymorphism</em> makes resolving the concrete method to call complicated. As the name suggests, this bytecode instruction can be utilized to invoke implementations of interface methods.</p><p>Because different types can implement the same interface, <code>invoke-interface</code> must be using a type - agnostic mechanism to resolve the method to invoke. This motivates to look further into the implementation of the bytecode instruction iteself, to identify how <code>invoke-interface</code> accesses objects and associated classes during method resolution and invocation. Remember that an attacker is able to inject data into the target process, including fake objects and classes.</p><h4 id=generic-analysis>Generic Analysis</h4><p><a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/interpreter/mterp/arm64ng/invoke.S#72 target=_blank rel=noopener><code>invoke-interface</code></a>
is fully defined by the assembly function <code>invoke_interface</code>. The code of <code>invoke_interface</code> reveals interesting properties about interface method resolution! Before delving into the details, lets build an example</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>interface</span> <span class=nc>Logger</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kt>void</span><span class=w> </span><span class=nf>log</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>message</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>FileLogger</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Logger</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>log</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>message</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=cm>/*...*/</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>ConsoleLogger</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Logger</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>log</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>message</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=cm>/*...*/</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>Test</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>Logger</span><span class=o>[]</span><span class=w> </span><span class=n>loggers</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Logger</span><span class=o>[]</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>new</span><span class=w> </span><span class=n>FileLogger</span><span class=p>(),</span><span class=w> </span><span class=c1>// =: fl</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>new</span><span class=w> </span><span class=n>ConsoleLogger</span><span class=p>()</span><span class=w> </span><span class=c1>// =: cl</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>Logger</span><span class=w> </span><span class=n>logger</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>loggers</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=n>logger</span><span class=p>.</span><span class=na>log</span><span class=p>(</span><span class=s>&#34;Test123&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>In the following, <code>fl</code> and <code>cl</code> denote their respective instance of <code>FileLogger</code> and <code>ConsoleLogger</code> in the context of the above Java code example.</p><h5 id=caching-interface-method>Caching Interface Method</h5><p>First of all, <code>invoke-interface</code> starts off with a fast - path for interface method resolution. I.e. for finding the <code>ArtMethod*</code> representing the abstract method declared inside an <code>interface</code>. The caching mechanism can be seen below.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=err>%</span><span class=nf>def</span> <span class=no>fetch_from_thread_cache</span><span class=p>(</span><span class=no>dest_reg</span><span class=p>,</span> <span class=no>miss_label</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nf>add</span>      <span class=no>ip</span><span class=p>,</span> <span class=no>xSELF</span><span class=p>,</span> <span class=c1>#THREAD_INTERPRETER_CACHE_OFFSET       // cache address
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>ubfx</span>     <span class=no>ip2</span><span class=p>,</span> <span class=no>xPC</span><span class=p>,</span> <span class=c1>#2, #THREAD_INTERPRETER_CACHE_SIZE_LOG2  // entry index
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>add</span>      <span class=no>ip</span><span class=p>,</span> <span class=no>ip</span><span class=p>,</span> <span class=no>ip2</span><span class=p>,</span> <span class=no>lsl</span> <span class=c1>#4            // entry address within the cache
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>ldp</span>      <span class=no>ip</span><span class=p>,</span> <span class=no>$</span><span class=err>{</span><span class=no>dest_reg</span><span class=err>}</span><span class=p>,</span> <span class=p>[</span><span class=no>ip</span><span class=p>]</span>          <span class=c1>// entry key (pc) and value (offset)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>cmp</span>      <span class=no>ip</span><span class=p>,</span> <span class=no>xPC</span>
</span></span><span class=line><span class=cl>    <span class=nf>b.ne</span>     <span class=no>$</span><span class=err>{</span><span class=no>miss_label</span><span class=err>}</span>
</span></span></code></pre></div><p>Notice that the cache uses the current dex program counter <code>xPC</code> to derive the cache set (of size 1). If the entry in that cache set matches the <code>xPC</code>, then the corresponding value is loaded, i.e. the <code>ArtMethod*</code>.</p><p>Therefore, it cannot be that the cached method represents a concrete implementation of the interface method. Consider the above example code. Invoking <code>fl.log</code> initially causes a cache miss, which triggers method resolution via <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/interpreter/mterp/arm64ng/main.S#1891 target=_blank rel=noopener><code>nterp_get_method</code></a>
, i.e. <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/interpreter/mterp/nterp.cc#248 target=_blank rel=noopener><code>NterpGetMethod</code></a>
. Thus, if the concrete implementation <code>FileLogger::log</code> was cached instead of a generic representation of <code>Logger::log</code>, then the second iteration trying to run <code>cl.log</code> would wind up calling <code>fl.log</code> again, because the current dex program counter causes a cache hit and thus triggers the fast - path, fully avoiding another method resolution. All of this implies that whatever is returned by <code>NterpGetMethod</code> must represent the abstract method declared in the interface, e.g. in <code>Logger</code>.</p><h5 id=method-resolution-via-nterpgetmethod>Method Resolution Via <code>NterpGetMethod</code></h5><p>The first time a specific <code>invoke-interface</code> is executed during execution of an app will always cause a cache miss, unless the cache is initialized with some methods. <code>NterpGetMethod</code> is then used to find the corresponding <code>ArtMethod*</code> or an encoded version of the method index referencing the abstract method relative to a declaring <code>.dex</code> file.</p><p>Consider the stripped version of <code>NterpGetMethod</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>size_t</span> <span class=nf>NterpGetMethod</span><span class=p>(</span><span class=n>Thread</span> <span class=o>*</span><span class=n>self</span><span class=p>,</span> <span class=n>ArtMethod</span> <span class=o>*</span><span class=n>caller</span><span class=p>,</span> <span class=kt>uint16_t</span> <span class=o>*</span><span class=n>dex_pc_ptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>REQUIRES_SHARED</span><span class=p>(</span><span class=n>Locks</span><span class=o>::</span><span class=n>mutator_lock_</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// [1]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>UpdateHotness</span><span class=p>(</span><span class=n>caller</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Instruction</span> <span class=o>*</span><span class=n>inst</span> <span class=o>=</span> <span class=n>Instruction</span><span class=o>::</span><span class=n>At</span><span class=p>(</span><span class=n>dex_pc_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>InvokeType</span> <span class=n>invoke_type</span> <span class=o>=</span> <span class=n>kStatic</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint16_t</span> <span class=n>method_index</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>Opcode</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>case</span> <span class=n>Instruction</span><span class=o>::</span><span class=nl>INVOKE_INTERFACE</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>method_index</span> <span class=o>=</span> <span class=n>inst</span><span class=o>-&gt;</span><span class=n>VRegB_35c</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>invoke_type</span> <span class=o>=</span> <span class=n>kInterface</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>LOG</span><span class=p>(</span><span class=n>FATAL</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Unknown instruction &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>inst</span><span class=o>-&gt;</span><span class=n>Opcode</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>ClassLinker</span> <span class=o>*</span><span class=k>const</span> <span class=n>class_linker</span> <span class=o>=</span> <span class=n>Runtime</span><span class=o>::</span><span class=n>Current</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>GetClassLinker</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * SkipAccessChecks() is a flag in the caller&#39;s `access_flags_` field.
</span></span></span><span class=line><span class=cl><span class=cm>     * Apparently access checks are usually done for native, i.e. not 
</span></span></span><span class=line><span class=cl><span class=cm>     * interpreted, code.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * Either class_linker-&gt;ResolveMethod find the ArtMethod* in the DexCache, or
</span></span></span><span class=line><span class=cl><span class=cm>	 * performs a manual resolution using the underlying .dex file. ASSUMING THE 
</span></span></span><span class=line><span class=cl><span class=cm>	 * LATTER, BECAUSE THIS CLEARLY SHOWS WHAT METHOD IS RETURNED.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>     <span class=c1>// [2]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ArtMethod</span> <span class=o>*</span><span class=n>resolved_method</span> <span class=o>=</span> <span class=n>caller</span><span class=o>-&gt;</span><span class=n>SkipAccessChecks</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=o>?</span> <span class=n>class_linker</span><span class=o>-&gt;</span><span class=n>ResolveMethod</span><span class=o>&lt;</span><span class=n>ClassLinker</span><span class=o>::</span><span class=n>ResolveMode</span><span class=o>::</span><span class=n>kNoChecks</span><span class=o>&gt;</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                                    <span class=n>self</span><span class=p>,</span> <span class=n>method_index</span><span class=p>,</span> <span class=n>caller</span><span class=p>,</span> <span class=n>invoke_type</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=o>:</span><span class=n>class_linker</span><span class=o>-&gt;</span><span class=n>ResolveMethod</span><span class=o>&lt;</span><span class=n>ClassLinker</span><span class=o>::</span><span class=n>ResolveMode</span><span class=o>::</span><span class=n>kCheckICCEAndIAE</span><span class=o>&gt;</span><span class=p>(</span>
</span></span><span class=line><span class=cl>									<span class=n>self</span><span class=p>,</span> <span class=n>method_index</span><span class=p>,</span> <span class=n>caller</span><span class=p>,</span> <span class=n>invoke_type</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>resolved_method</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>DCHECK</span><span class=p>(</span><span class=n>self</span><span class=o>-&gt;</span><span class=n>IsExceptionPending</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>invoke_type</span> <span class=o>==</span> <span class=n>kSuper</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=cm>/*...*/</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>invoke_type</span> <span class=o>==</span> <span class=n>kInterface</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>result</span> <span class=o>=</span> <span class=mi>0u</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>resolved_method</span><span class=o>-&gt;</span><span class=n>GetDeclaringClass</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>IsObjectClass</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>             * If declaring class is java.lang.Object:
</span></span></span><span class=line><span class=cl><span class=cm>             */</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Set the low bit to notify the interpreter it should do a vtable 
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// call.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>DCHECK_LT</span><span class=p>(</span><span class=n>resolved_method</span><span class=o>-&gt;</span><span class=n>GetMethodIndex</span><span class=p>(),</span> <span class=mh>0x10000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span> <span class=o>=</span> <span class=p>(</span><span class=n>resolved_method</span><span class=o>-&gt;</span><span class=n>GetMethodIndex</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=mi>16</span><span class=p>)</span> <span class=o>|</span> <span class=mi>1U</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>DCHECK</span><span class=p>(</span><span class=n>resolved_method</span><span class=o>-&gt;</span><span class=n>GetDeclaringClass</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>IsInterface</span><span class=p>());</span>
</span></span><span class=line><span class=cl>            <span class=n>DCHECK</span><span class=p>(</span><span class=o>!</span><span class=n>resolved_method</span><span class=o>-&gt;</span><span class=n>IsCopied</span><span class=p>());</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>resolved_method</span><span class=o>-&gt;</span><span class=n>IsAbstract</span><span class=p>())</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>                 * If declaring class is any non - abstract class:
</span></span></span><span class=line><span class=cl><span class=cm>                 */</span>
</span></span><span class=line><span class=cl>                <span class=c1>// Set the second bit to notify the interpreter this is a default
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// method.
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>result</span> <span class=o>=</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>size_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>resolved_method</span><span class=p>)</span> <span class=o>|</span> <span class=mi>2U</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>                 * If declaring class is abstract class (may still provide 
</span></span></span><span class=line><span class=cl><span class=cm>                 * definition):
</span></span></span><span class=line><span class=cl><span class=cm>                 */</span>
</span></span><span class=line><span class=cl>                 <span class=c1>//[3]
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>result</span> <span class=o>=</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>size_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>resolved_method</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>UpdateCache</span><span class=p>(</span><span class=n>self</span><span class=p>,</span> <span class=n>dex_pc_ptr</span><span class=p>,</span> <span class=n>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>resolved_method</span><span class=o>-&gt;</span><span class=n>GetDeclaringClass</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>IsStringClass</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>resolved_method</span><span class=o>-&gt;</span><span class=n>IsStatic</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>resolved_method</span><span class=o>-&gt;</span><span class=n>IsConstructor</span><span class=p>()){</span> <span class=cm>/*...*/</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>invoke_type</span> <span class=o>==</span> <span class=n>kVirtual</span><span class=p>){</span> <span class=cm>/*...*/</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>{</span> <span class=cm>/*...*/</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Above code is still complex, so consider the following explanation:</p><ol><li>General information is extracted from bytecode. Most importantly, this is where a method invocation is classified as e.g. <code>kInterface</code>, i.e. an <code>invoke-interface</code>. The <code>method_index</code> refers to the <code>method_id_item</code> inside the declaring <code>.dex</code> file.</li><li>Based on the <code>method_index</code>, the <code>ClassLinker</code> is utilized to resolve the corresponding <code>ArtMethod*</code>, i.e. the ART representation of a Java method. Interestingly, the calling method <code>caller</code> dictates whether validation checks are performed or not via its <code>caller->access_flags_</code> field. Invoking bytecode in a &ldquo;benign way&rdquo; should not trigger such checks.</li><li>After a matching <code>ArtMethod*</code> has been found, its <code>declaring_class</code> is checked. This dictates whether the returned value is either a valid <code>ArtMethod*</code>, or encoded variant of either an <code>ArtMethod*</code> or a <code>method_index</code>. Under the assumption that the <code>resolved_method</code> represents an abstract interface method, its <code>declaring_class</code> field should be the declaring interface, e.g. <code>Logger</code>, which is neither <code>java.lang.Object</code> nor a concrete class. Hence, an <code>ArtMethod*</code> is returned as is, without any encoding.</li></ol><p>Following <code>class_linker->ResolveMethod</code> gives insights into where ART searches for the <code>ArtMethod*</code>.</p><h5 id=classlinker---based-method-resolution><code>ClassLinker</code> - based Method Resolution</h5><p>Consider the following reduced implementation of <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/class_linker-inl.h#357 target=_blank rel=noopener><code>class_linker->ResolveMethod</code></a>
:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kr>inline</span> <span class=n>ArtMethod</span> <span class=o>*</span><span class=n>ClassLinker</span><span class=o>::</span><span class=n>ResolveMethod</span><span class=p>(</span><span class=n>Thread</span> <span class=o>*</span><span class=n>self</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                             <span class=kt>uint32_t</span> <span class=n>method_idx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                             <span class=n>ArtMethod</span> <span class=o>*</span><span class=n>referrer</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                             <span class=n>InvokeType</span> <span class=n>type</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Below comment implies that there exists an array of ArtMethods pointing
</span></span></span><span class=line><span class=cl><span class=cm>     * to native methods that are resolved at app startup.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=c1>// We do not need the read barrier for getting the DexCache for the initial 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// resolved method
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// lookup as both from-space and to-space copies point to the same native 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// resolved methods array.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// [1]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ArtMethod</span> <span class=o>*</span><span class=n>resolved_method</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>	    <span class=n>referrer</span><span class=o>-&gt;</span><span class=n>GetDexCache</span><span class=o>&lt;</span><span class=n>kWithoutReadBarrier</span><span class=o>&gt;</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>GetResolvedMethod</span><span class=p>(</span>
</span></span><span class=line><span class=cl>	        <span class=n>method_idx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Method resolution using fast path failed, so resolve method manually.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>     <span class=c1>// [2]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>UNLIKELY</span><span class=p>(</span><span class=n>resolved_method</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>referrer</span> <span class=o>=</span> <span class=n>referrer</span><span class=o>-&gt;</span><span class=n>GetInterfaceMethodIfProxy</span><span class=p>(</span><span class=n>image_pointer_size_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>ObjPtr</span><span class=o>&lt;</span><span class=n>mirror</span><span class=o>::</span><span class=n>Class</span><span class=o>&gt;</span> <span class=n>declaring_class</span> <span class=o>=</span> <span class=n>referrer</span><span class=o>-&gt;</span><span class=n>GetDeclaringClass</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>StackHandleScope</span><span class=o>&lt;</span><span class=mi>2</span><span class=o>&gt;</span> <span class=n>hs</span><span class=p>(</span><span class=n>self</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Handle</span><span class=o>&lt;</span><span class=n>mirror</span><span class=o>::</span><span class=n>DexCache</span><span class=o>&gt;</span> <span class=n>h_dex_cache</span><span class=p>(</span>
</span></span><span class=line><span class=cl>	        <span class=n>hs</span><span class=p>.</span><span class=n>NewHandle</span><span class=p>(</span><span class=n>referrer</span><span class=o>-&gt;</span><span class=n>GetDexCache</span><span class=p>()));</span>
</span></span><span class=line><span class=cl>        <span class=n>Handle</span><span class=o>&lt;</span><span class=n>mirror</span><span class=o>::</span><span class=n>ClassLoader</span><span class=o>&gt;</span> <span class=n>h_class_loader</span><span class=p>(</span>
</span></span><span class=line><span class=cl>	        <span class=n>hs</span><span class=p>.</span><span class=n>NewHandle</span><span class=p>(</span><span class=n>declaring_class</span><span class=o>-&gt;</span><span class=n>GetClassLoader</span><span class=p>()));</span>
</span></span><span class=line><span class=cl>        <span class=n>resolved_method</span> <span class=o>=</span> <span class=n>ResolveMethod</span><span class=o>&lt;</span><span class=n>kResolveMode</span><span class=o>&gt;</span><span class=p>(</span><span class=n>method_idx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                      <span class=n>h_dex_cache</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                      <span class=n>h_class_loader</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                      <span class=n>referrer</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                      <span class=n>type</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Note: We cannot check here to see whether we added the method to the 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// cache. It might be an erroneous class, which results in it being hidden 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// from us.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// [3]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>resolved_method</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above code does the following:</p><ol><li>Tries to find the <code>ArtMethod*</code> in an associated <code>DexCache</code>. Notice that upon app creation, <code>Zygote</code> already sets up a <code>DexCache</code>, which means that all apps on the device know the address of at least one <code>DexCache</code> instance. In this case, it is assumed that we get a cache miss to further investigate how method resolution works. In reality, this may already mark the end of method resolution in case of a cache hit.</li><li>In case of a cache miss the method is resolved by <code>method_idx</code>, which was taken from the fixed parameter of <code>invoke-interface</code> opcode.</li><li>Finally, the <code>ArtMethod*</code> is returned. However, the comment states that resolving a method manually may bypass validation checks. This will not be a problem, if the checks are skipped anyways.</li></ol><p>Now comes the most interesting part of the method resolution, namely another <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/class_linker-inl.h#433 target=_blank rel=noopener><code>ResolveMethod</code></a>
implementation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kr>inline</span> <span class=n>ArtMethod</span> <span class=o>*</span><span class=n>ClassLinker</span><span class=o>::</span><span class=n>ResolveMethod</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>method_idx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>									 <span class=n>Handle</span><span class=o>&lt;</span><span class=n>mirror</span><span class=o>::</span><span class=n>DexCache</span><span class=o>&gt;</span> <span class=n>dex_cache</span><span class=p>,</span>
</span></span><span class=line><span class=cl>									 <span class=n>Handle</span><span class=o>&lt;</span><span class=n>mirror</span><span class=o>::</span><span class=n>ClassLoader</span><span class=o>&gt;</span> <span class=n>class_loader</span><span class=p>,</span>
</span></span><span class=line><span class=cl>									 <span class=n>ArtMethod</span> <span class=o>*</span><span class=n>referrer</span><span class=p>,</span>
</span></span><span class=line><span class=cl>									 <span class=n>InvokeType</span> <span class=n>type</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Check for hit in the dex cache.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ArtMethod</span> <span class=o>*</span><span class=n>resolved</span> <span class=o>=</span> <span class=n>dex_cache</span><span class=o>-&gt;</span><span class=n>GetResolvedMethod</span><span class=p>(</span><span class=n>method_idx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>valid_dex_cache_method</span> <span class=o>=</span> <span class=n>resolved</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>;</span> <span class=c1>// = false
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>kResolveMode</span> <span class=o>==</span> <span class=n>ResolveMode</span><span class=o>::</span><span class=n>kNoChecks</span> <span class=o>&amp;&amp;</span> <span class=n>valid_dex_cache_method</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=cm>/*...*/</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Uses .dex file to resolve the method_id of the method to be invoked. A 
</span></span></span><span class=line><span class=cl><span class=cm>     * method_id consists of a `class_idx`, `proto_idx` and `name_idx`. For an 
</span></span></span><span class=line><span class=cl><span class=cm>     * interface method, `class_idx` is expected to refer (within .dex file) to 
</span></span></span><span class=line><span class=cl><span class=cm>     * an interface.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * Interestingly, to fake an interface method invocation, the only thing that
</span></span></span><span class=line><span class=cl><span class=cm>     * needs to be &#34;not - faked&#34; is the method_idx used to identify the 
</span></span></span><span class=line><span class=cl><span class=cm>     * method_id.
</span></span></span><span class=line><span class=cl><span class=cm>	 * For example, to fake a call to UiAutomation::executeShellCommand, it 
</span></span></span><span class=line><span class=cl><span class=cm>	 * suffices to know its method_idx (and DexCache). From there, the type is 
</span></span></span><span class=line><span class=cl><span class=cm>	 * inferred by the method_id data to be UiAutomation. In other words, when 
</span></span></span><span class=line><span class=cl><span class=cm>	 * creating a fake ArtMethod object, its declaring class must reference a 
</span></span></span><span class=line><span class=cl><span class=cm>	 * correct DexCache (shared by Zygote) and its method_idx must describe the 
</span></span></span><span class=line><span class=cl><span class=cm>	 * correct method.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>DexFile</span> <span class=o>&amp;</span><span class=n>dex_file</span> <span class=o>=</span> <span class=o>*</span><span class=n>dex_cache</span><span class=o>-&gt;</span><span class=n>GetDexFile</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>dex</span><span class=o>::</span><span class=n>MethodId</span> <span class=o>&amp;</span><span class=n>method_id</span> <span class=o>=</span> <span class=n>dex_file</span><span class=p>.</span><span class=n>GetMethodId</span><span class=p>(</span><span class=n>method_idx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ObjPtr</span><span class=o>&lt;</span><span class=n>mirror</span><span class=o>::</span><span class=n>Class</span><span class=o>&gt;</span> <span class=n>klass</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>valid_dex_cache_method</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/*...*/</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>	    <span class=c1>// [1]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// The method was not in the DexCache, resolve the declaring class.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>klass</span> <span class=o>=</span> <span class=n>ResolveType</span><span class=p>(</span><span class=n>method_id</span><span class=p>.</span><span class=n>class_idx_</span><span class=p>,</span> <span class=n>dex_cache</span><span class=p>,</span> <span class=n>class_loader</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>klass</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/*...*/</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*...*/</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>valid_dex_cache_method</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>	    <span class=c1>// [2]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>resolved</span> <span class=o>=</span> <span class=n>FindResolvedMethod</span><span class=p>(</span>
</span></span><span class=line><span class=cl>				        <span class=n>klass</span><span class=p>,</span> <span class=n>dex_cache</span><span class=p>.</span><span class=n>Get</span><span class=p>(),</span> <span class=n>class_loader</span><span class=p>.</span><span class=n>Get</span><span class=p>(),</span> <span class=n>method_idx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*...*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// If we found a method, check for incompatible class changes.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// [3]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>LIKELY</span><span class=p>(</span><span class=n>resolved</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>        <span class=n>LIKELY</span><span class=p>(</span><span class=n>kResolveMode</span> <span class=o>==</span> <span class=n>ResolveMode</span><span class=o>::</span><span class=n>kNoChecks</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>               <span class=o>!</span><span class=n>resolved</span><span class=o>-&gt;</span><span class=n>CheckIncompatibleClassChange</span><span class=p>(</span><span class=n>type</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>resolved</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// If we had a method, or if we can find one with another lookup type,
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// it&#39;s an incompatible-class-change error.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=cm>/*...*/</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Again, consider the following explanations:</p><ol><li>If the method is not part of the <code>DexCache</code>, the class associated with the method referenced by <code>method_idx</code> will be resolved. This is where <code>.dex</code> is explicitly used to extract the <code>method_id_item</code>.</li><li>Then, the <code>ArtMethod*</code> is resolved based on that class and <code>method_idx</code>.</li><li>With a resolved method at hand, some mandatory validation checks are performed before the method is returned.</li></ol><p>Skipping some intermediate methods, eventually <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/mirror/class.cc#517 target=_blank rel=noopener><code>FindInterfaceMethodWithSignature</code></a>
is invoked:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=n>ArtMethod</span> <span class=o>*</span><span class=nf>FindInterfaceMethodWithSignature</span><span class=p>(</span><span class=n>ObjPtr</span><span class=o>&lt;</span><span class=n>Class</span><span class=o>&gt;</span> <span class=n>klass</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                          <span class=n>std</span><span class=o>::</span><span class=n>string_view</span> <span class=n>name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                          <span class=k>const</span> <span class=n>SignatureType</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                          <span class=n>PointerSize</span> <span class=n>pointer_size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>REQUIRES_SHARED</span><span class=p>(</span><span class=n>Locks</span><span class=o>::</span><span class=n>mutator_lock_</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// If the current class is not an interface, skip the search of its declared 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// methods; such lookup is used only to distinguish between 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// IncompatibleClassChangeError and NoSuchMethodError and the caller has 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// already tried to search methods in the class.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// [1]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>LIKELY</span><span class=p>(</span><span class=n>klass</span><span class=o>-&gt;</span><span class=n>IsInterface</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Search declared methods, both direct and virtual.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// (This lookup is used also for invoke-static on interface classes.)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=n>ArtMethod</span> <span class=o>&amp;</span><span class=nl>method</span> <span class=p>:</span> <span class=n>klass</span><span class=o>-&gt;</span><span class=n>GetDeclaredMethodsSlice</span><span class=p>(</span><span class=n>pointer_size</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>method</span><span class=p>.</span><span class=n>GetNameView</span><span class=p>()</span> <span class=o>==</span> <span class=n>name</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                <span class=n>method</span><span class=p>.</span><span class=n>GetSignature</span><span class=p>()</span> <span class=o>==</span> <span class=n>signature</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=o>&amp;</span><span class=n>method</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// TODO: If there is a unique maximally-specific non-abstract superinterface 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// method, we should return it, otherwise an arbitrary one can be returned.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Check all interfaces specified in iftable of the class. This gives the 
</span></span></span><span class=line><span class=cl><span class=cm>     * ArtMethod of the interface method, not its concrete implementation! For 
</span></span></span><span class=line><span class=cl><span class=cm>     * an invoke-interface opcode, `klass` is currently a class that provides a 
</span></span></span><span class=line><span class=cl><span class=cm>     * concrete implementation.
</span></span></span><span class=line><span class=cl><span class=cm>     * Thus `klass` skips the above `klass-&gt;IsInterface()` check and its iftable 
</span></span></span><span class=line><span class=cl><span class=cm>     * is read.
</span></span></span><span class=line><span class=cl><span class=cm>     * THEREFORE, IFTABLE OF A CLASS SPECIFIES IMPLEMENTED INTERFACES.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=c1>// [2]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ObjPtr</span><span class=o>&lt;</span><span class=n>IfTable</span><span class=o>&gt;</span> <span class=n>iftable</span> <span class=o>=</span> <span class=n>klass</span><span class=o>-&gt;</span><span class=n>GetIfTable</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int32_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>iftable_count</span> <span class=o>=</span> <span class=n>iftable</span><span class=o>-&gt;</span><span class=n>Count</span><span class=p>();</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>iftable_count</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ObjPtr</span><span class=o>&lt;</span><span class=n>Class</span><span class=o>&gt;</span> <span class=n>iface</span> <span class=o>=</span> <span class=n>iftable</span><span class=o>-&gt;</span><span class=n>GetInterface</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>ArtMethod</span> <span class=o>&amp;</span><span class=nl>method</span> <span class=p>:</span> <span class=n>iface</span><span class=o>-&gt;</span><span class=n>GetVirtualMethodsSlice</span><span class=p>(</span><span class=n>pointer_size</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>method</span><span class=p>.</span><span class=n>GetNameView</span><span class=p>()</span> <span class=o>==</span> <span class=n>name</span> <span class=o>&amp;&amp;</span> 
</span></span><span class=line><span class=cl>                <span class=n>method</span><span class=p>.</span><span class=n>GetSignature</span><span class=p>()</span> <span class=o>==</span> <span class=n>signature</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=o>&amp;</span><span class=n>method</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*...Check super classes and java.lang.Object, or fail and return nullptr*/</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In a nutshell, method resolution boils down to iterating over the <code>klass->iftable_</code> field and checking all methods of all implemented interfaces for a matching method signature. To that end:</p><ol><li>Initially, the <code>klass</code> is still a class with the concrete implementation of the interface method. For example, this could still be <code>FileLogger</code> or <code>ConsoleLogger</code>, but not <code>Logger</code>.</li><li>Classes that implement an interface use an interface table that describes where to find the concrete implementations of an implemented interface. This table is enumerated and each interface is checked for whether it declares a method that matches the signature of the method to be invoked by <code>invoke-interface</code>. Whatever method matches (first; although signatures should be unique) is returned.</li></ol><p>This concludes the quick dive into method resolution. Overall, executing <code>invoke-interface</code> tries to find the abstract method declared in the interface based on the method index that is a fixed operand of the <code>invoke-interface</code> opcode. Eventually, whatever is returned from <code>NterpGetMethod</code> is cached, so that future executions that pass the dex program counter of the <code>invoke-interface</code> can take the fast path.</p><h5 id=interface-method-tables>Interface Method Tables</h5><p>Going back to the implementation of <code>invoke-interface</code>, the following code remains to be understood:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>    * At this point, x26 is either
</span></span></span><span class=line><span class=cl><span class=cm>    * - ArtMethod* describing the declared method to be invoked, or
</span></span></span><span class=line><span class=cl><span class=cm>    * - Encoded method index
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=c1>// First argument is the &#39;this&#39; pointer.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>    * w1=index of this-register
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=nf>FETCH</span> <span class=no>w1</span><span class=p>,</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=na>.if</span> <span class=p>!</span><span class=no>$range</span>
</span></span><span class=line><span class=cl>    <span class=nf>and</span> <span class=no>w1</span><span class=p>,</span> <span class=no>w1</span><span class=p>,</span> <span class=c1>#0xf
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=na>.endif</span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>    * w1=this
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=nf>GET_VREG</span> <span class=no>w1</span><span class=p>,</span> <span class=no>w1</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Note: if w1 is null, this will be handled by our SIGSEGV handler.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>    * w1=Class object of this
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ============[1]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>ldr</span> <span class=no>w2</span><span class=p>,</span> <span class=p>[</span><span class=no>x1</span><span class=p>,</span> <span class=c1>#MIRROR_OBJECT_CLASS_OFFSET]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Test the first two bits of the fetched ArtMethod:
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// - If the first bit is set, this is a method on j.l.Object
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// - If the second bit is set, this is a default method.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>    * Implicit assumption that ArtMethod* are 4-byte aligned.
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=nf>tst</span> <span class=no>w26</span><span class=p>,</span> <span class=c1>#0x3
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>b.ne</span> <span class=mi>3</span><span class=no>f</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>    * Case: Non - abstract class, but not java.lang.Object.
</span></span></span><span class=line><span class=cl><span class=cm>    * Query w3=imt_index_ from ArtMethod* of the interface method (abstract 
</span></span></span><span class=line><span class=cl><span class=cm>    * method).
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ============[2]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>ldrh</span> <span class=no>w3</span><span class=p>,</span> <span class=p>[</span><span class=no>x26</span><span class=p>,</span> <span class=c1>#ART_METHOD_IMT_INDEX_OFFSET]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>2:</span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>    * Use first entry of embedded vtable, i.e. Interface Method Table pointer
</span></span></span><span class=line><span class=cl><span class=cm>    * with imt_index_ to select the concrete implementation of the interface 
</span></span></span><span class=line><span class=cl><span class=cm>    * method.
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ============[3]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>ldr</span> <span class=no>x2</span><span class=p>,</span> <span class=p>[</span><span class=no>x2</span><span class=p>,</span> <span class=c1>#MIRROR_CLASS_IMT_PTR_OFFSET_64]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>ldr</span> <span class=no>x0</span><span class=p>,</span> <span class=p>[</span><span class=no>x2</span><span class=p>,</span> <span class=no>w3</span><span class=p>,</span> <span class=no>uxtw</span> <span class=c1>#3]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>    * x0 holds concrete implementation, i.e. an ArtMethod*
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=na>.if</span> <span class=no>$range</span>
</span></span><span class=line><span class=cl>    <span class=nf>b</span> <span class=no>NterpCommonInvokeInterfaceRange</span>
</span></span><span class=line><span class=cl>    <span class=na>.else</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ============[4]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>b</span> <span class=no>NterpCommonInvokeInterface</span>
</span></span><span class=line><span class=cl>    <span class=na>.endif</span>
</span></span></code></pre></div><p>Although all parts are relevant, the following main steps are taken:</p><ol><li><code>w1</code> is equal to <code>this</code>, i.e. the pointer to the object used for invocation. E.g. in <code>fl.log("Test")</code> that would be <code>fl</code>, not <code>FileLogger</code>, not <code>Logger</code> and also not <code>log</code>! Basically, <code>w1</code> contains the <em>receiving object</em>. Then <code>w2</code> contains the pointer to the class of <code>w1</code>, i.e. a <code>mirror::Class*</code>. Furthermore, the least - significant 2 bits of the resolved <code>ArtMethod*</code> (or encoded method index) are checked. This stems from <code>NterpGetMethod</code>, which is assumed to have simply returned a not - encoded <code>ArtMethod*</code>. Hence, the branch is not taken.</li><li>Next, the <code>resolved_method->imt_index_</code> is extracted into <code>w3</code>. This selects the concrete implementation of the resolved method.</li><li>Then, the actual <code>ImTable*</code> is read from the first entry of the embedded vtable. Using the <code>imt_index_</code> scaled by the size of a <code>ArtMethod*</code>, <code>x0</code> is set to be the concrete implementation of the resolved abstract method.</li><li>Finally, <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/interpreter/mterp/arm64ng/main.S#1742 target=_blank rel=noopener><code>NterpCommonInvokeInterface</code></a>
is used to invoke the concrete implementation.</li></ol><p>Observe that the concrete method invocation is basically just a lookup in the <code>ImTable*</code>, which is similar to a <em>vtable</em> in C++ and stored inside the embedded vtable of the <code>Class</code>. A <code>Class</code> is referenced by an object. Therefore, if an attacker controls an object, then the attacker can also reference a fake <code>Class</code> and thus a fake <code>ImTable*</code>. Overall, hijacking an object gives an attacker control over what methods are invoked during <code>invoke-interface</code>!</p><p>This of course requires knowledge on some internal values, among which reside:</p><ul><li><code>class_idx</code> of the class providing the concrete implementation. It should not be possible to inject a custom class with invalid <code>class_idx</code>, because either type resolution goes through <code>DexCache</code> or the associated <code>.dex</code> file. If neither contain the type, an error is raised.</li><li>Valid <code>iftable</code> that states that a particular interface is implemented by the fake class. Technically, an <code>iftable</code> will not be needed if the fast - path is taken or the <code>method_index</code> can be resolved by the <code>DexCache</code>.</li><li>Valid <code>embedded_vtable</code>, which references an <code>ImTable</code> in its first entry. It is possible to overlap the following vtable entries and the <code>ImTable</code>.</li></ul><p>As a rule of thumb:</p><blockquote><p>When creating a fake object and class, try to build as valid structures as feasible.</p></blockquote><p>In other words, no need to be fancy with complex overlapping pointers etc, because the probability that some code inside the enormous ART code base validates or tries to work with the fake structures is pretty high (keyword: garbage collector). The exception to this rule of thumb is overlapping the <code>ImTable</code> with the embedded vtable, because it is an <em>easy</em> and almost <em>foolproof</em> way to save some space.</p><h2 id=goal>Goal</h2><p>With the theory out of the way, we again settle for <em>arbitrary command execution</em> in the context of the vulnerable app. For simplicity, the goal is to eventually invoke <code>Runtime.getRuntime().exec("&lt;command>")</code>. However, it is forbidden to inject bytecode into the target process. It is only allowed to either inject <em>data</em>, i.e. <em>objects</em>, <em>classes</em> and more. Also, only existing bytecode may be reused. Trivially, using <em>native techniques</em> as intermediate step to gain bytecode execution is also forbidden.</p><h3 id=core-idea>Core Idea</h3><p>As mentioned before, bytecode reuse draws from various fields of offensive security. To be precise, we use</p><ul><li><a href="https://ieeexplore.ieee.org/ielx7/7160813/7163005/07163058.pdf?tag=1" target=_blank rel=noopener><em>Counterfeit Object Oriented Programming</em> (COOP)</a>
: An exploitation technique for memory errors in C++ programs that is based on <em>fake object injection</em> and <em>vtable pointer</em> manipulation.</li><li><em>Insecure Deserialization</em>: A vulnerability that allows an attacker to determine the data to be <em>deserialized</em> by the target app. For this post, the idea of <a href=https://portswigger.net/web-security/deserialization/exploiting#gadget-chains target=_blank rel=noopener>gadget chains</a>
is critical.</li></ul><p>Without diving into all the rabbit holes I found myself in during research, the overall idea is to identify a <em>good</em> sequence of <code>invoke-interface</code> bytecode instructions. For example, the <em>chain</em> could look like <code>this.objA.funcA(this.objB)</code>. It is important to note that the &ldquo;surrounding&rdquo; object represented by <code>this</code> is controlled by an attacker. Thus, an attacker also controls <code>objA</code> and <code>objB</code>. If an attacker controls <code>objA</code>, it may be possible to control <em>what</em> function is invoked. This is due to the fact that an attacker can choose the composition of an <code>ImTable</code> of a fake object.</p><h4 id=coop-vs-gadget-chains>COOP vs. Gadget Chains</h4><p>For those interested in or familiar with <em>COOP</em>, the original approach using a <em>main loop gadget</em> does not work well with bytecode. The most limiting factor is passing arguments from one gadget to another. Consider the following setup:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>interface</span> <span class=nc>Observer</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>invoke</span><span class=p>(</span><span class=n>Object</span><span class=w> </span><span class=n>data</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Observer</span><span class=o>[]</span><span class=w> </span><span class=n>observers</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>...;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>Observer</span><span class=w> </span><span class=n>o</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>observers</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>o</span><span class=p>.</span><span class=na>invoke</span><span class=p>(...);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Basically, the <code>o.invoke</code> invocation internally uses an <code>invoke-interface</code> bytecode instruction. This means an attacker can inject an array of fake objects that provide their own implementations of <code>Observer::invoke</code> through their fake class definitions. Now, being able to execute an arbitrary list of methods will be useful, if either the methods do not need to <em>cooperate</em> or use a <em>shared</em> object to pass (intermediate) results. Unfortunately, the approach of using spilled hardware registers or the stack to pass data between gadgets is <strong>not</strong> (easily) applicable to bytecode. Also using vregs and vrefs does not work, because these are cleared when <code>nterp</code> sets up the execution environment for a method. Therefore, at best, there is a global object referenced by the methods invoked via fake objects, or the object passed as parameter is usable in some way. Notice that both approaches drastically restrict the set of available gadgets. Being able to invoke a sequence of methods that is semantically equivalent to <code>System.exec("&lt;command>")</code> seems like a daunting and impossible task.</p><p>This is the reason why we abstract away from the <em>structure</em> used in COOP attacks shown above, i.e. the <code>for</code> - loop over a fake object array. Observe that every piece of Java code that uses <code>invoke-interface</code> is a potential <em>structure</em>, including <code>this.objA.funcA(this.objB)</code>, which could translate to <code>this.shell.executeShellCommand(this.commandString)</code>. Again, notice the combination of COOP and gadget chains from insecure deserialization: <code>invoke-interface</code> uses the <em>IMT</em> of a class to determine the <em>interface</em> method implementation to invoke, and the <em>structure</em> gives the framework or layout to be adhered to.</p><h3 id=high---level-solution>High - Level Solution</h3><p>To reach the goal, the structure <code>this.objA.func(this.objB)</code> is used. An attentive reader may realize that the structure does not match <code>Runtime.getRuntime().exec("&lt;command>")</code>. In order to make them match, it would be required that <code>objA = &lt;Runtime instance></code>. Unfortunately, we cannot assume that the location of a Java object in memory remains the same across all apps forked from <code>zygote64</code>, due to <em>garbage collection</em>. Creating a <em>fake runtime</em> is also infeasible due to the complexity and relevance of that object. However, it may be possible to create a <em>fake object</em> that provides a method, which eventually triggers execution of <code>Runtime.getRuntime().exec("&lt;command>")</code>, where the command string is also controllable.</p><p>Without showing the time - consuming search for candidate gadgets, which has been supported by some static analysis of <code>.dex</code> files of <code>framework.jar</code> available in <em>every</em> app using a modified version of <code>Topper</code>, the classes of interest are <a href=https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-13.0.0_r78/core/java/android/hardware/input/VirtualKeyboard.java#38 target=_blank rel=noopener><code>VirtualKeyboard</code></a>
, <a href=https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-13.0.0_r78/core/java/android/app/UiAutomation.java#108 target=_blank rel=noopener><code>UiAutomation</code></a>
and <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/mirror/string.h#285 target=_blank rel=noopener><code>String</code></a>
.</p><p>Lets break down the overall approach. First of all, <a href=https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-13.0.0_r78/core/java/android/hardware/input/VirtualKeyboard.java#51 target=_blank rel=noopener><code>VirtualKeyboard::close</code></a>
provides the <em>structure</em>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@RequiresPermission</span><span class=p>(</span><span class=n>android</span><span class=p>.</span><span class=na>Manifest</span><span class=p>.</span><span class=na>permission</span><span class=p>.</span><span class=na>CREATE_VIRTUAL_DEVICE</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>close</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// this.objA.funcA(this.objB)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>mVirtualDevice</span><span class=p>.</span><span class=na>unregisterInputDevice</span><span class=p>(</span><span class=n>mToken</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>RemoteException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>throw</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>rethrowFromSystemServer</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Mapping the structure to variable names yields:</p><ul><li><code>objA = mVirtualDevice</code></li><li><code>funcA = unregisterInputDevice</code></li><li><code>mToken = objB</code></li></ul><p>Now, one might argue that objects are strictly typed and thus cannot be changed to different types, even at runtime. To that end, consider the bytecode of <code>VirtualKeyboard::close</code> below.</p><pre tabindex=0><code>[Index = 0xe8da, Offset = 0x4e85a8, Num Regs = 0x3]: public void VirtualKeyboard::close()
    0000: IGET_OBJECT v0, v2, FIELD:VirtualKeyboard;-&gt;mVirtualDevice:IVirtualDevice;
    0004: IGET_OBJECT v1, v2, FIELD:VirtualKeyboard;-&gt;mToken:IBinder;
    0008: INVOKE_INTERFACE {v0, v1}, METHOD:IVirtualDevice;-&gt;unregisterInputDevice(IBinder;)V
    000e: NOP 
    0010: RETURN_VOID 
    0012: MOVE_EXCEPTION v0
    0014: INVOKE_VIRTUAL {v0}, METHOD:RemoteException;-&gt;rethrowFromSystemServer()RuntimeException;
    001a: MOVE_RESULT_OBJECT v1
    001c: THROW v1
</code></pre><blockquote><p><em>Note</em>: The annotations <code>Override</code> and <code>RequiresPermission</code> do not seem to be enforced at runtime or impact method invocation in any way, which seems to align with the <a href=https://docs.oracle.com/javase/tutorial/java/annotations/ target=_blank rel=noopener>definition</a>
.</p></blockquote><p>Unless <code>VirtualKeyboard::close</code> throws an exception, the method really consists of only <code>4</code> relevant instructions:</p><pre tabindex=0><code>0000: IGET_OBJECT v0, v2, FIELD:VirtualKeyboard;-&gt;mVirtualDevice:IVirtualDevice;
0004: IGET_OBJECT v1, v2, FIELD:VirtualKeyboard;-&gt;mToken:IBinder;
0008: INVOKE_INTERFACE {v0, v1}, METHOD:IVirtualDevice;-&gt;unregisterInputDevice(IBinder;)V
0010: RETURN_VOID 
</code></pre><p>Notice that <code>iget-object vA, vB, field@CCCC</code> does exactly as the name suggests: move the field with index <code>CCCC</code> of object referenced by <code>vB</code> into vreg <code>vA</code>. The last spark of hope is that <code>iget-object</code> checks the type of the fields it operates on. From <a href=#necessary-groundwork>fundamentals</a>
we get that method resolution using <code>invoke-interface</code> does not really <em>care</em> about the type of the involved objects, but rather only looks at the <code>ImTable</code> of the class of the receiving object. Now, lets rip apart the illusion of type checks at runtime by considering the implementation of <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/interpreter/mterp/arm64ng/object.S#213 target=_blank rel=noopener><code>iget-object</code></a>
:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=err>%</span><span class=nf>def</span> <span class=no>op_iget_object</span><span class=p>():</span>
</span></span><span class=line><span class=cl><span class=err>%</span>  <span class=nf>op_iget</span><span class=p>(</span><span class=no>load</span><span class=err>=&#34;</span><span class=no>ldr</span><span class=err>&#34;</span><span class=p>,</span> <span class=no>volatile_load</span><span class=err>=&#34;</span><span class=no>ldar</span><span class=err>&#34;</span><span class=p>,</span> <span class=no>maybe_extend</span><span class=err>=&#34;&#34;</span><span class=p>,</span> <span class=no>wide</span><span class=err>=&#34;</span><span class=mi>0</span><span class=err>&#34;</span><span class=p>,</span> <span class=no>is_object</span><span class=err>=&#34;</span><span class=mi>1</span><span class=err>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>%</span><span class=nf>def</span> <span class=no>op_iget</span><span class=p>(</span><span class=no>load</span><span class=err>=&#34;</span><span class=no>ldr</span><span class=err>&#34;</span><span class=p>,</span> <span class=no>volatile_load</span><span class=err>=&#34;</span><span class=no>ldar</span><span class=err>&#34;</span><span class=p>,</span> <span class=no>maybe_extend</span><span class=err>=&#34;&#34;</span><span class=p>,</span> <span class=no>wide</span><span class=err>=&#34;</span><span class=mi>0</span><span class=err>&#34;</span><span class=p>,</span> <span class=no>is_object</span><span class=err>=&#34;</span><span class=mi>0</span><span class=err>&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl><span class=err>%</span>  <span class=nf>slow_path</span> <span class=err>=</span> <span class=no>add_slow_path</span><span class=p>(</span><span class=no>op_iget_slow_path</span><span class=p>,</span> <span class=no>volatile_load</span><span class=p>,</span> <span class=no>maybe_extend</span><span class=p>,</span> <span class=no>wide</span><span class=p>,</span> <span class=no>is_object</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=err>%</span>  <span class=nf>fetch_from_thread_cache</span><span class=p>(</span><span class=err>&#34;</span><span class=no>x0</span><span class=err>&#34;</span><span class=p>,</span> <span class=no>miss_label</span><span class=err>=</span><span class=no>slow_path</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=na>.L$</span><span class=err>{</span><span class=no>opcode</span><span class=err>}</span><span class=no>_resume</span><span class=p>:</span>
</span></span><span class=line><span class=cl>   <span class=nf>lsr</span>     <span class=no>w2</span><span class=p>,</span> <span class=no>wINST</span><span class=p>,</span> <span class=c1>#12              // w2&lt;- B
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nf>GET_VREG</span> <span class=no>w3</span><span class=p>,</span> <span class=no>w2</span>                     <span class=c1>// w3&lt;- object we&#39;re operating on
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nf>ubfx</span>    <span class=no>w2</span><span class=p>,</span> <span class=no>wINST</span><span class=p>,</span> <span class=c1>#8, #4           // w2&lt;- A
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nf>cbz</span>     <span class=no>w3</span><span class=p>,</span> <span class=no>common_errNullObject</span>    <span class=c1>// object was null
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=na>.if</span> <span class=no>$wide</span>
</span></span><span class=line><span class=cl>   <span class=nf>$load</span>   <span class=no>x0</span><span class=p>,</span> <span class=p>[</span><span class=no>x3</span><span class=p>,</span> <span class=no>x0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>   <span class=nf>SET_VREG_WIDE</span> <span class=no>x0</span><span class=p>,</span> <span class=no>w2</span>                <span class=c1>// fp[A] &lt;- value
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=na>.elseif</span> <span class=no>$is_object</span>                  <span class=c1>// ===================[1]
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nf>$load</span>   <span class=no>w0</span><span class=p>,</span> <span class=p>[</span><span class=no>x3</span><span class=p>,</span> <span class=no>x0</span><span class=p>]</span>                <span class=c1>// ===================[2]
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nf>TEST_IF_MARKING</span> <span class=no>.L$</span><span class=err>{</span><span class=no>opcode</span><span class=err>}</span><span class=no>_read_barrier</span>
</span></span><span class=line><span class=cl><span class=na>.L$</span><span class=err>{</span><span class=no>opcode</span><span class=err>}</span><span class=no>_resume_after_read_barrier</span><span class=p>:</span>
</span></span><span class=line><span class=cl>   <span class=nf>SET_VREG_OBJECT</span> <span class=no>w0</span><span class=p>,</span> <span class=no>w2</span>              <span class=c1>// fp[A] &lt;- value
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=na>.else</span>
</span></span><span class=line><span class=cl>   <span class=nf>$load</span>   <span class=no>w0</span><span class=p>,</span> <span class=p>[</span><span class=no>x3</span><span class=p>,</span> <span class=no>x0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>   <span class=nf>SET_VREG</span> <span class=no>w0</span><span class=p>,</span> <span class=no>w2</span>                     <span class=c1>// fp[A] &lt;- value
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=na>.endif</span>
</span></span><span class=line><span class=cl>   <span class=nf>FETCH_ADVANCE_INST</span> <span class=mi>2</span>                <span class=c1>// ===================[3]
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nf>GET_INST_OPCODE</span> <span class=no>ip</span>
</span></span><span class=line><span class=cl>   <span class=nf>GOTO_OPCODE</span> <span class=no>ip</span>
</span></span><span class=line><span class=cl>   <span class=na>.if</span> <span class=no>$is_object</span>
</span></span><span class=line><span class=cl><span class=na>.L$</span><span class=err>{</span><span class=no>opcode</span><span class=err>}</span><span class=no>_read_barrier</span><span class=p>:</span>
</span></span><span class=line><span class=cl>   <span class=nf>bl</span>      <span class=no>art_quick_read_barrier_mark_reg00</span>
</span></span><span class=line><span class=cl>   <span class=nf>b</span>       <span class=no>.L$</span><span class=err>{</span><span class=no>opcode</span><span class=err>}</span><span class=no>_resume_after_read_barrier</span>
</span></span><span class=line><span class=cl>   <span class=na>.endif</span>
</span></span></code></pre></div><p>While there is nothing more refreshing than reading arm assembly mixed with custom macros, whose definitions are sprinkled over various files, below is the short version:</p><ol><li>After passing the caching mechanism, which sets <code>x0</code> to the field offset in memory and is also used in <code>invoke-interface</code>, it is checked what kind of field is moved from the object in <code>vB</code> to <code>vA</code>. The code distinguishes between <em>wide</em> types like <code>long</code> and <code>double</code>, <em>objects</em> and <em>the rest</em>. As <code>iget-object</code> sets <code>is_object = 1</code> when calling into <code>op_iget</code>, the object path is taken.</li><li>Access the field at offset <code>x0</code> relative to the base of object referenced by <code>vB</code>. This loads a 32-bit address into <code>w0</code>. Observe that <code>x0 >= 8</code>, because objects have predefined <code>klass_</code> and <code>monitor_</code> fields.</li><li>Continue with the next instruction.</li></ol><p>The above code only tells half of the story, because a <em>cache miss</em> means the <code>ArtField</code> must be resolved using the slow path through <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/interpreter/mterp/arm64ng/object.S#186 target=_blank rel=noopener><code>nterp_get_instance_field_offset</code></a>
. Notice that even if the slow path performed type checks, any repeated execution of the <code>iget-object</code> instructions in <code>VirtualKeyboard::close</code> would use the fast path, unless their cache entries are evicted. Of course, it may be sufficient to only check the type in the slow path and then <em>assume</em> its correctness in the fast path.</p><p>Continuing with the high - level approach, the structure provided by <code>VirtualKeyboard::close</code> is very dynamic at runtime, allowing an attacker to replace not only the objects but also their classes and thus their invoked methods. Now, looking into <code>UiAutomation</code> reveals the reason for why <code>VirtualKeyboard::close</code> is a suitable candidate for <a href=https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-13.0.0_r78/core/java/android/app/UiAutomation.java#1373 target=_blank rel=noopener>shell invocation</a>
:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=n>ParcelFileDescriptor</span><span class=w> </span><span class=nf>executeShellCommand</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>command</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>warnIfBetterCommand</span><span class=p>(</span><span class=n>command</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ParcelFileDescriptor</span><span class=w> </span><span class=n>source</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ParcelFileDescriptor</span><span class=w> </span><span class=n>sink</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ParcelFileDescriptor</span><span class=o>[]</span><span class=w> </span><span class=n>pipe</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ParcelFileDescriptor</span><span class=p>.</span><span class=na>createPipe</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>source</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pipe</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>sink</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pipe</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Calling out without a lock held.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>mUiAutomationConnection</span><span class=p>.</span><span class=na>executeShellCommand</span><span class=p>(</span><span class=n>command</span><span class=p>,</span><span class=w> </span><span class=n>sink</span><span class=p>,</span><span class=w> </span><span class=kc>null</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>IOException</span><span class=w> </span><span class=n>ioe</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Log</span><span class=p>.</span><span class=na>e</span><span class=p>(</span><span class=n>LOG_TAG</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Error executing shell command!&#34;</span><span class=p>,</span><span class=w> </span><span class=n>ioe</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>RemoteException</span><span class=w> </span><span class=n>re</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Log</span><span class=p>.</span><span class=na>e</span><span class=p>(</span><span class=n>LOG_TAG</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Error executing shell command!&#34;</span><span class=p>,</span><span class=w> </span><span class=n>re</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>IoUtils</span><span class=p>.</span><span class=na>closeQuietly</span><span class=p>(</span><span class=n>sink</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>source</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Surprisingly, <code>UiAutomation</code> provides a convenience method for invoking shell commands. However, in comparison to <code>Runtime.getRuntime().exec</code>, it is a lot easier to create a fake <code>UiAutomation</code> object than it is to create a fake <code>Runtime</code> instance.</p><p>The key component in the above Java code is <code>mUiAutomationConnection.executeShellCommand(command, sink, null)</code>. Without showing the entire call stack, eventually, the following <a href=https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-13.0.0_r78/core/java/android/app/UiAutomationConnection.java#461 target=_blank rel=noopener>code</a>
is called:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>executeShellCommandWithStderr</span><span class=p>(</span><span class=kd>final</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>command</span><span class=p>,</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>ParcelFileDescriptor</span><span class=w> </span><span class=n>sink</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>final</span><span class=w> </span><span class=n>ParcelFileDescriptor</span><span class=w> </span><span class=n>source</span><span class=p>,</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>ParcelFileDescriptor</span><span class=w> </span><span class=n>stderrSink</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>throws</span><span class=w> </span><span class=n>RemoteException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>synchronized</span><span class=w> </span><span class=p>(</span><span class=n>mLock</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>throwIfCalledByNotTrustedUidLocked</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>throwIfShutdownLocked</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>throwIfNotConnectedLocked</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>final</span><span class=w> </span><span class=n>java</span><span class=p>.</span><span class=na>lang</span><span class=p>.</span><span class=na>Process</span><span class=w> </span><span class=n>process</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>process</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Runtime</span><span class=p>.</span><span class=na>getRuntime</span><span class=p>().</span><span class=na>exec</span><span class=p>(</span><span class=n>command</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>IOException</span><span class=w> </span><span class=n>exc</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>RuntimeException</span><span class=p>(</span><span class=s>&#34;Error running shell command &#39;&#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>command</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;&#39;&#34;</span><span class=p>,</span><span class=w> </span><span class=n>exc</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Basically, if an attacker is able to pass the methods <code>throwIfCalledByNotTrustedUidLocked</code>, <code>throwIfShutdownLocked</code> and <code>throwIfNotConnectedLocked</code> without crashing the app, then an attacker - chosen command will be executed. For simplicity, we do not care what happens after command execution. I.e. crashing the app <em>after</em> successful command execution is enough to prove that bytecode reuse attacks are possible.</p><p>Without further ado, consider the <a href=https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-13.0.0_r78/core/java/android/app/UiAutomationConnection.java#611 target=_blank rel=noopener>critical methods</a>
:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>throwIfShutdownLocked</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>mIsShutdown</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>IllegalStateException</span><span class=p>(</span><span class=s>&#34;Connection shutdown!&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>throwIfNotConnectedLocked</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>isConnectedLocked</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// Returns: this.mClient != null</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>IllegalStateException</span><span class=p>(</span><span class=s>&#34;Not connected!&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>throwIfCalledByNotTrustedUidLocked</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>callingUid</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Binder</span><span class=p>.</span><span class=na>getCallingUid</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>callingUid</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>mOwningUid</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>mOwningUid</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>Process</span><span class=p>.</span><span class=na>SYSTEM_UID</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>callingUid</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>0</span><span class=w> </span><span class=cm>/*root*/</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>SecurityException</span><span class=p>(</span><span class=s>&#34;Calling from not trusted UID!&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Bypassing these checks is trivial, because the <code>mUiAutomationConnection</code> object of <code>UiAutomation</code> is also attacker - controlled. Therefore, setting the fields <em>appropriately</em> allows passing the checks. For example, <code>throwIfNotConnectedLocked</code> tries to enforce that <code>this.mClient != null</code> before the command is executed. Internally, this simply compares the field value in the <code>mUiAutomationConnection</code> object with <code>0</code>. This means that setting <code>mClient = 1</code> bypasses the check, although this is not a valid reference.</p><p>Lets conclude with a visualization of the entire high - level approach. First of all, we start off with the correct structure. Method invocation works with the correct objects and classes.<div class=not-prose><figure><img src=/2024/09/bytecode_exploitation_3_original_structure.png alt="Original structure and method invocation" loading=lazy></figure></div></p><p>However, after objects have been replaced with their fake counterparts, the invocation looks like can be seen below. Observe that the overall <em>structure</em> remains the same, only objects, classes and associated method implementations change.<div class=not-prose><figure><img src=/2024/09/bytecode_exploitation_3_modified_structure.png alt="Modified objects in original structure" loading=lazy></figure></div></p><p>As the latter image already shows, when looking for the method to invoke via <code>invoke-interface</code>, <code>nterp</code> uses the fake class and eventually the <code>.dex</code> file associated with that class. After the abstract method has been resolved, the abstract method&rsquo;s <code>imt_index_</code> field is used to choose the correct <code>ImTable</code> entry. Therefore, the <code>ImTable</code> may be shrinked to only account for the lookup of the entry at index <code>imt_index_</code>. Because <code>nterp</code> uses whatever method is found in the <code>ImTable</code>, invocation of <code>executeShellCommand</code> is inevitable.</p><p>Long story short, not only is an attacker able to inject fake objects, classes, <code>ArtMethod</code>s, <code>ArtField</code>s and tables, but it is also possible to force <em>existing</em> bytecode to operate on those fake structures. In a nutshell, an attacker can convert the <em>WWW</em> condition into a <strong>type confusion</strong> and <strong>trick the interpreter to work with custom objects</strong>, causing invocation of arbitrary methods at runtime (of course, method signatures should match).</p><h3 id=kicking-off-execution>Kicking Off Execution</h3><p>Building on the blog posts covering Android basics for bytecode exploitation, the <a href=https://android.googlesource.com/platform/libcore/+/refs/tags/android-13.0.0_r78/ojluni/src/main/java/sun/util/locale/LanguageTag.java#65 target=_blank rel=noopener><code>GRANDFATHERED</code></a>
map can be used to kick off execution of the chain that executes a shell command. To that end, reconsider the following code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>LanguageTag</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=o>[]&gt;</span><span class=w> </span><span class=n>GRANDFATHERED</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>LanguageTag</span><span class=w> </span><span class=nf>parse</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>languageTag</span><span class=p>,</span><span class=w> </span><span class=n>ParseStatus</span><span class=w> </span><span class=n>sts</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>gfmap</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GRANDFATHERED</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>LocaleUtils</span><span class=p>.</span><span class=na>toLowerString</span><span class=p>(</span><span class=n>languageTag</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Observe that the invocation <code>GRANDFATHERED.get</code> uses <code>invoke-interface</code> again, because <code>GRANDFATHERED</code> is a <code>HashMap</code>, but <code>::get</code> is declared in <a href=https://android.googlesource.com/platform/libcore/+/refs/tags/android-13.0.0_r78/ojluni/src/main/java/java/util/Map.java#241 target=_blank rel=noopener>Map</a>
interface. Therefore, using a similar approach as discussed above, <code>GRANDFATHERED</code> can be replaced with an instance of <code>VirtualKeyboard</code>, and the invocation of <code>::get</code> can be redirected to <code>VirtualKeyboard::close</code>. Setting up the <code>VirtualKeyboard</code> instance to contain instances of <code>UiAutomation</code> and <code>String</code> for <code>mVirtualDevice</code> and <code>mToken</code>, respectively, allows kicking off command execution. What is more is that <code>LanguageTag::parse</code> is most likely called inside a <a href=https://developer.android.com/guide/components/activities/activity-lifecycle#alc target=_blank rel=noopener><em>lifecycle</em></a>
method like <code>onStop</code>, which guarantees execution of the gadget chains.</p><p>Because <code>GRANDFATHERED</code> seems to be located inside the <code>boot.art</code> memory region, which again seems to be shared by all maps, it is a relatively stable target to abuse in the test environment.</p><h3 id=proof-of-concept>Proof of Concept</h3><p>The concrete PoC code is about 1000 LoC, because we need to respect structures like <code>mirror::Class</code> etc. Encoding these structures in Python bloats up the PoC. However, the quintessence is exactly what is discussed in the above sections. For a visual proof, consider the following <a href=https://github.com/fkie-cad/Android-Bytecode-Exploitation/blob/main/bytecode-reuse/poc_local_bytecode_reuse.py target=_blank rel=noopener>PoC</a>
video.</p><p><video src=/2024/09/bytecode_exploitation_3_poc_local_video.webm width=100% controls></video></p><p>It is important to note that the memory region, in which fake objects are built up using the <em>WWW</em> condition, must be in a 32 - bit address range, because references to objects and classes must be 32 - bit addresses. In case of the above video, that region is <code>[anon:.bss]</code>. The other memory regions are used to reference existing bytecode (<code>framework.jar</code>), reference the interpreter handler <code>ExecuteNterpImpl</code> to construct valid <code>ArtMethod</code> instances (<code>libart.so</code>), kick off gadget chain execution via <code>GRANDFATHERED</code> (<code>boot.art</code>) and reference a valid <code>DexCache</code> instance initialized by <code>zygote64</code> (<code>boot-framework.art</code>). All of these memory regions have been confirmed to be duplicated upon fork in a previous blog post using <em>maps diffing</em>.</p><p>Of course, a <em>better</em> PoC would be to construct a malicious Android app that attacks the victim app. However, creating parsers for e.g. <code>boot.art</code> to spot <code>GRANDFATHERED</code> <em>dynamically</em> is considered a lot of busywork and does not show more than the extern python script mimicking a local app.</p><h2 id=potential-solutions>Potential Solutions</h2><p>From a security perspective, multiple mitigations come to mind:</p><ol><li>Enforce type checks at runtime.</li><li>Use a kind of random token (like csrf token) sampled <em>after</em> the app is forked from <code>zygote64</code>. Then, each object holds that token as a field next to <code>monitor_</code> and <code>klass_</code>. Upon usage of an object, the object&rsquo;s token is compared to the original random token. If both tokens match, execution will continue. Otherwise, the app is aborted.</li></ol><p>Of course, these mitigations do not take into account the performance overhead introduced by all the checks. If every bytecode instruction validated a random token, performance would propably be a lot worse. On the other hand, one may argue that the interpreter started off too greedily as regards performance, and such security checks are legitimate. This is a common tradeoff: security vs. performance. Luckily, the techniques discussed in this series of blog posts are fairly hard to pull off, which severely reduces practicality.</p><h1 id=responsible-disclosure>Responsible Disclosure</h1><p>All research results, including working PoCs, have been submitted to Google&rsquo;s bug bounty program to ensure that publishing these blog posts does not cause any severe security problems and to give Google time to investigate the findings and respond, if necessary. Of course, there are no concrete vulnerabilities, but rather a new exploitation concept on Android. Also, I find it hard to estimate the practical impact of these blog posts, because many stars must align for bytecode injection and reuse to work, which is why I welcomed the feedback. Fortunately, Google decided the results are <strong>not</strong> a security concern and gave permission to publish blog posts on that matter!</p><h1 id=summary>Summary</h1><p>This concludes our journey through the land of bytecode - based exploitation on Android! Here, the more advanced bytecode reuse technique is discussed, along with fundamentals necessary to grasp all concepts described. Also, some security mechanisms that immediately come to mind are mentioned without taking into account performance impact.</p><p>Naturally, there is a lot more to be discovered about bytecode execution and exploitation on Android. The series of blog posts on Android bytecode is the result of about 1.5 years of part-time research, with some distractions along the way. Hence, the blog posts do not contain <em>everything</em> discovered or tested, but only the most interesting cherries! I stopped counting the rabbit holes I followed that did not provide any results or at best &ldquo;funny&rdquo; facts, like e.g. <em>throw - oriented programming</em>.</p><p>Overall, I learned that security research on a well - known operating system like Android is similar to walking the corridor in Hilbert&rsquo;s hotel: infinite options, so you really need to choose the doors you open wisely. Regardless, persistence is key to find something that is interesting, so keep learning, researching and hacking! ;)</p></article></div></div></div></main><footer class="flex flex-none justify-center"><section class="flex flex-col md:flex-row mx-2 md:mx-0 gap-2 md:gap-0 justify-between w-full max-w-4xl lg:max-w-5xl py-6 text-slate-500 dark:text-slate-300"><div class="flex flex-row"></div><div class=grow></div><div class="flex flex-row"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-copyright" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-9 0a9 9 0 1018 0A9 9 0 103 12"/><path d="M14 9.75a3.016 3.016.0 00-4.163.173 2.993 2.993.0 000 4.154A3.016 3.016.0 0014 14.25"/></svg>
</i>2022 - 2024 lolcads</div><div class="flex flex-row"><span class="ml-0 pl-0 md:ml-2 md:pl-2 border-l-0 md:border-l border-slate-300 dark:border-slate-400">Powered by <a href=https://gohugo.io target=_blank rel=noopener class=underline>Hugo</a> <span class=text-red-600>&#9829;</span> <a href=https://github.com/tomowang/hugo-theme-tailwind target=_blank rel=noopener class=underline>Tailwind</a></span></div></section></footer><script src=/main.min.c6372b6836971865bd94bfde974748aca8415824a2facab6ccd66a87384bfacb.js></script><div class="hidden top-1 right-1" id=code-copy><i class="h-6 w-6 block"><svg class="icon icon-tabler icon-tabler-copy" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667A2.667 2.667.0 019.667 7h8.666A2.667 2.667.0 0121 9.667v8.666A2.667 2.667.0 0118.333 21H9.667A2.667 2.667.0 017 18.333z"/><path d="M4.012 16.737A2.005 2.005.0 013 15V5c0-1.1.9-2 2-2h10c.75.0 1.158.385 1.5 1"/></svg></i></div><div class="hidden top-1 right-1" id=code-copy-done><i class="h-6 w-6 block"><svg class="icon icon-tabler icon-tabler-check" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 12l5 5L20 7"/></svg></i></div><script src=/code-copy.min.e7b2a74adef1ed474c335c8bd5e7832b2316b8842b0f9184d65286c5bd64f51a.js></script></body></html>