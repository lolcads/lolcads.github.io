<!doctype html><html lang=en dir=ltr><head><title>Fundamentals for Bytecode Exploitation (Part 2) :: lolcads tech blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Fundamentals for Bytecode Exploitation (Part 2) Exploiting a vulnerability always requires a certain knowledge about the operating system, including how processes are launched, what libraries are used and how control - flow &ldquo;works&rdquo;. While the latter could be considered coming from the architecture, this is not always the case on Android, because the Android RunTime (ART) provides ways to call bytecode methods and redirect bytecode control - flow. Hence, ART dictates how bytecode control - flow works, not directly the underlying CPU. Understanding the above mechanisms is the minimal requirement for understanding bytecode - based exploitation. Based on that, more sophisticated analysis techniques can be built specifically for Android bytecode, to make bytecode - based exploitation feasible.
"><meta name=keywords content="Android,Bytecode,Exploitation"><meta name=robots content="noodp"><link rel=manifest href=/manifest.json><meta property="og:url" content="https://lolcads.github.io/posts/2024/09/bytecode_exploitation_1/"><meta property="og:site_name" content="lolcads tech blog"><meta property="og:title" content="Fundamentals for Bytecode Exploitation (Part 2)"><meta property="og:description" content="Fundamentals for Bytecode Exploitation (Part 2) Exploiting a vulnerability always requires a certain knowledge about the operating system, including how processes are launched, what libraries are used and how control - flow “works”. While the latter could be considered coming from the architecture, this is not always the case on Android, because the Android RunTime (ART) provides ways to call bytecode methods and redirect bytecode control - flow. Hence, ART dictates how bytecode control - flow works, not directly the underlying CPU. Understanding the above mechanisms is the minimal requirement for understanding bytecode - based exploitation. Based on that, more sophisticated analysis techniques can be built specifically for Android bytecode, to make bytecode - based exploitation feasible."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-10T09:17:43+02:00"><meta property="article:modified_time" content="2024-09-10T09:17:43+02:00"><meta property="article:tag" content="Android"><meta property="article:tag" content="Bytecode"><meta property="article:tag" content="Exploitation"><meta name=twitter:card content="summary"><meta name=twitter:title content="Fundamentals for Bytecode Exploitation (Part 2)"><meta name=twitter:description content="Fundamentals for Bytecode Exploitation (Part 2) Exploiting a vulnerability always requires a certain knowledge about the operating system, including how processes are launched, what libraries are used and how control - flow “works”. While the latter could be considered coming from the architecture, this is not always the case on Android, because the Android RunTime (ART) provides ways to call bytecode methods and redirect bytecode control - flow. Hence, ART dictates how bytecode control - flow works, not directly the underlying CPU. Understanding the above mechanisms is the minimal requirement for understanding bytecode - based exploitation. Based on that, more sophisticated analysis techniques can be built specifically for Android bytecode, to make bytecode - based exploitation feasible."><link rel=canonical href=https://lolcads.github.io/posts/2024/09/bytecode_exploitation_1/><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/index.min.c860e17f20d9f258820c02bf7ab3f57c9595d0bc21dede7eda08ccd63ba3f4cc.css></head><body class="flex flex-col min-h-screen w-full bg-slate-50 dark:bg-gray-800"><header class="flex flex-none justify-center z-10"><div class="flex flex-row gap justify-between w-full max-w-4xl lg:max-w-5xl h-12 mt-3"><div class="flex-none ml-2 md:ml-0"><a href=/><img class="h-12 w-12 rounded-full object-cover bg-gray-100" src=/logo.png alt=logo></a></div><div class=flex-1></div><div class=flex-none><nav class="h-full static"><button id=navbar-menu-toggle type=button class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg md:hidden" aria-controls=navbar-menu aria-expanded=false>
<span class=sr-only>Open main menu</span>
<i class="w-8 h-8"><svg class="icon icon-tabler icon-tabler-menu-2" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 6h16"/><path d="M4 12h16"/><path d="M4 18h16"/></svg></i></button><div class="absolute md:static top-16 left-0 right-0 z-50 hidden w-full md:block md:w-auto" id=navbar-menu><ul class="flex flex-col mx-2 md:mx-0 md:flex-row md:border-0 rounded-sm md:rounded-full px-3 text-base font-medium text-slate-800 dark:text-slate-200 shadow-lg bg-white dark:bg-gray-600 shadow-slate-800/5 dark:shadow-slate-200/5 ring-1 ring-slate-900/5 dark:ring-slate-100/5"><li id=post><a class="block px-3 py-3 hover:text-emerald-600 text-emerald-600" href=/posts/ title=Blog>Blog</a></li><li id=about><a class="block px-3 py-3 hover:text-emerald-600" href=/about/ title=About>About</a></li><li id=contact><a class="block px-3 py-3 hover:text-emerald-600" href=/contact/ title=Contact>Contact</a></li></ul></div></nav></div><div class="flex-none mx-1"></div><div class="flex-none md:hidden"><a href=/search/ class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg" aria-controls=navbar-menu aria-expanded=false><span class=sr-only>Search</span>
<i class="w-8 h-8"><svg class="icon icon-tabler icon-tabler-search" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 10m-7 0a7 7 0 1014 0A7 7 0 103 10"/><path d="M21 21l-6-6"/></svg></i></a></div><div class="darkmode-toggle flex flex-none mr-2 md:mr-0"><label for=darkmode-toggle class="flex items-center px-3 cursor-pointer rounded-full bg-gray-100 dark:bg-gray-600" title="Toggle dark mode"><input name=darkmode-toggle id=darkmode-toggle type=checkbox class="sr-only peer" aria-label="Toggle dark mode"><div class="group flex flex-row gap-1 justify-center h-8 px-1 rounded-full bg-white dark:bg-gray-700"><i class="h-6 w-6 flex-none rounded-full bg-yellow-400 place-self-center peer-checked:group-[]:invisible"><svg class="icon icon-tabler icon-tabler-brightness-down" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-3 0a3 3 0 106 0 3 3 0 10-6 0"/><path d="M12 5v.01"/><path d="M17 7v.01"/><path d="M19 12v.01"/><path d="M17 17v.01"/><path d="M12 19v.01"/><path d="M7 17v.01"/><path d="M5 12v.01"/><path d="M7 7v.01"/></svg>
</i><i class="h-6 w-6 flex-none rounded-full place-self-center invisible peer-checked:group-[]:visible"><svg class="icon icon-tabler icon-tabler-moon-stars" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 3c.132.0.263.0.393.0a7.5 7.5.0 007.92 12.446A9 9 0 1112 2.992z"/><path d="M17 4a2 2 0 002 2 2 2 0 00-2 2 2 2 0 00-2-2 2 2 0 002-2"/><path d="M19 11h2m-1-1v2"/></svg></i></div></label></div></div></header><main class="flex flex-auto justify-center"><div class="w-full max-w-4xl lg:max-w-5xl"><div class="flex flex-col mt-6 mx-2 md:mx-0 rounded-lg overflow-hidden shadow-md bg-white dark:bg-gray-700"><div><a href=/posts/2024/09/bytecode_exploitation_1/></a></div><div class="flex flex-col gap-y-3 p-6"><h1 class="text-4xl font-semibold text-slate-800 dark:text-slate-100"><a href=/posts/2024/09/bytecode_exploitation_1/>Fundamentals for Bytecode Exploitation (Part 2)</a></h1><ul class="flex flex-row flex-wrap text-slate-500 dark:text-slate-300"><li><a href=/tags/android/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Android</span></a></li><li><a href=/tags/bytecode/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Bytecode</span></a></li><li><a href=/tags/exploitation/ class="flex flex-row text-sm mr-2 py-1"><i class="h-5 w-5 flex-none"><svg class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 9h14"/><path d="M5 15h14"/><path d="M11 4 7 20"/><path d="M17 4l-4 16"/></svg>
</i><span class=ml-0>Exploitation</span></a></li></ul><div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300"><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-calendar" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 7a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V7z"/><path d="M16 3v4"/><path d="M8 3v4"/><path d="M4 11h16"/><path d="M11 15h1"/><path d="M12 15v3"/></svg>
</i><time datetime=2024-09-10T09:17:43+02:00>2024-09-10</time></div><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-hourglass-high" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6.5 7h11"/><path d="M6 20v-2a6 6 0 1112 0v2a1 1 0 01-1 1H7a1 1 0 01-1-1z"/><path d="M6 4v2a6 6 0 1012 0V4a1 1 0 00-1-1H7A1 1 0 006 4z"/></svg>
</i><span>28 minutes to read</span></div></div><div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300"><div class="flex flex-row text-base gap-x-1"><i class="h-6 w-6 flex-none"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-user"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M8 7a4 4 0 108 0A4 4 0 008 7"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
</i><span>Pascal Kühnemann</span></div></div><section class="prose prose-slate dark:prose-invert w-full max-w-4xl lg:max-w-5xl mt-6"><h2>Table of Contents</h2><aside><nav id=TableOfContents><ul><li><a href=#android-runtime>Android Runtime</a><ul><li><a href=#art-structures>ART Structures</a></li><li><a href=#android-bytecode>Android Bytecode</a></li><li><a href=#android-bytecode-execution>Android Bytecode Execution</a></li><li><a href=#bytecode-oddities>Bytecode Oddities</a></li></ul></li><li><a href=#fork-server-architecture-on-android>Fork Server Architecture on Android</a><ul><li><a href=#maps-diffing>Maps Diffing</a></li><li><a href=#region-diffing>Region Diffing</a></li><li><a href=#monitoring-memory-accesses-to-bootart>Monitoring Memory Accesses to <code>boot.art</code></a></li></ul></li><li><a href=#summary>Summary</a></li></ul></nav></aside></section><article class="mt-6 w-full max-w-4xl lg:max-w-5xl prose prose-slate dark:prose-invert prose-quoteless post-content"><h1 id=fundamentals-for-bytecode-exploitation-part-2>Fundamentals for Bytecode Exploitation (Part 2)</h1><p>Exploiting a vulnerability always requires a certain knowledge about the operating system, including how processes are launched, what libraries are used and how control - flow &ldquo;works&rdquo;. While the latter could be considered coming from the architecture, this is not always the case on Android, because the <em>Android RunTime</em> (ART) provides ways to call bytecode methods and redirect bytecode control - flow. Hence, ART dictates how bytecode control - flow works, not directly the underlying CPU. Understanding the above mechanisms is the minimal requirement for understanding bytecode - based exploitation. Based on that, more sophisticated analysis techniques can be built specifically for Android bytecode, to make bytecode - based exploitation feasible.</p><p>In this blog post, we first dive into how Android bytecode methods are invoked, which entails a discussion about how Java classes, objects, methods and fields are handled in memory by ART. Then, we take a look at Android&rsquo;s <em>fork server architecture</em>. Building on this, interesting memory regions common to all Android apps are discussed, which include <code>.dex</code>, <code>.so</code>, <code>.art</code> and <code>.oat</code> files. During all of this, I showcase analysis methods used to practically verify the discussed topics.</p><h2 id=android-runtime>Android Runtime</h2><p>Every Android app contains the <code>libart.so</code> library, which is the ART implementation. This is probably the most <strong>vital</strong> library for Android apps! Not only that, but from the perspective of an attacker trying to abuse a memory error in a JNI function, <code>libart.so</code> is <em>gadget heaven</em>. Among other things, <code>libart.so</code> is responsible for executing bytecode. Further, it dictates the memory layout of methods, fields, classes and thus objects. We start off with some basics on ART structures and Android bytecode, then discuss how Android bytecode is executed.</p><h3 id=art-structures>ART Structures</h3><p>Bytecode operates on data representing methods, fields, classes, objects and more. Therefore, before looking into concrete bytecode implementations, these structures must be discussed. From now on, we assume we are looking at an app written in Java. Also, we do not consider inheritance for simplicity.</p><p>The most famous structure is probably the (Java) <em>object</em>, which is defined in <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/mirror/object.h#774 target=_blank rel=noopener><code>mirror::Object</code></a>
. Surprisingly, an object consists of only two fields:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Object</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>HeapReference</span><span class=o>&lt;</span><span class=n>Class</span><span class=o>&gt;</span> <span class=n>klass_</span><span class=p>;</span>    <span class=c1>// 32-bit value
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>monitor_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Overall, this means an object is just a 64 - bit value, which seems odd given the fact that in Java we can access all kinds of fields. Conceptually comparable to how Chromium&rsquo;s JavaScript engine V8 handles dynamic objects using the &ldquo;static&rdquo; language C++, Android uses a <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/mirror/class.h#1419 target=_blank rel=noopener><code>mirror::Class</code></a>
to define where to find the fields of an object. So, although the C++ representation of an object does not explicitly account for all accessible fields, in memory an object is followed by the concrete values of its fields. The associated <code>Class</code> stored in <code>object->klass_</code> contains an array of <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/art_field.h#241 target=_blank rel=noopener><code>ArtField</code></a>
objects called <code>Class::ifields_</code>. Each <code>ArtField</code> represents a single field by specifying e.g. the field&rsquo;s type, access flags (like <code>private</code>) and offset relative to the end of the C++ object in memory. Fields stored relative to an object/instance are called <em>instance</em> fields. <em>Static</em> fields are stored relative to the <code>Class</code>.</p><p>In other words, an object looks like this in memory:</p><pre tabindex=0><code>0x00: object-&gt;klass_
0x04: object-&gt;monitor_
0x08: object-&gt;field0
0x0c: object-&gt;field1
...
</code></pre><p>Usually, fields are 32 - bit values, but some primitive types like <code>long</code> and <code>double</code> require 64 bits. Because <code>ArtField</code>s only tell the runtime <em>where</em> to find a field inside an object&rsquo;s memory and <em>what</em> type that field is, objects are very dynamic in terms of shape. By the way, speaking V8, the <code>Class</code> is somewhat similar to the <em>shape</em> of an object. Consider the following visualization:<div class=not-prose><figure><img src=/2024/09/bytecode_exploitation_1_bytecode_object_layout_memory.png alt="Bytecode Object Memory Layout" loading=lazy></figure></div></p><p>Although there can be many fields for a particular class instance, Android enforces a particular <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/class_linker.cc#8793 target=_blank rel=noopener>field order</a>
. Hence, unless e.g. field types change, the field order inside an object is constant and thus predictable.</p><p>Regarding method invocations, Android utilizes a structure called <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/art_method.h#810 target=_blank rel=noopener><code>ArtMethod</code></a>
. The comments indicate what a field means for a bytecode method:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>class</span> <span class=nc>ArtMethod</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>access_flags_</span><span class=p>;</span> <span class=c1>// A lot of potential flags like &#34;public&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>dex_method_index_</span><span class=p>;</span> <span class=c1>// Index into .dex file (context)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint16_t</span> <span class=n>method_index_</span><span class=p>;</span> <span class=c1>// Index into vtable (?)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint16_t</span> <span class=n>hotness_count_</span><span class=p>;</span>    <span class=c1>// How often this method is called. Triggers JIT compilation on 0, else &gt; 0.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>uint16_t</span> <span class=n>imt_index_</span><span class=p>;</span>    <span class=c1>// Index into Interface Method Table (IMT)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>PtrSizedFields</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=o>*</span><span class=n>data_</span><span class=p>;</span>    <span class=c1>// Reference to code_item in .dex file
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>void</span> <span class=o>*</span><span class=n>entry_point_from_quick_compiled_code_</span><span class=p>;</span>    <span class=c1>// Reference to ExecuteNterpImpl
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=n>ptr_sized_fields_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Of course, an <code>ArtMethod</code> does not necessarily need to represent a bytecode method. The ART provides many kinds of methods, of which a bytecode method is just a single instance.</p><p>There are various ways an <code>ArtMethod</code> can be linked into a <code>Class</code>, because e.g. Java provides many different types of methods and thus method invocations. For example, if a method is &ldquo;normal&rdquo;, like</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Me</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;What am I reading??&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>new</span><span class=w> </span><span class=n>Me</span><span class=p>().</span><span class=na>run</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p>then the method <code>run</code> is invoked via the <code>invoke-virtual</code> bytecode. This means that (a pointer to) the <code>ArtMethod</code> is stored inside the <em>embedded vtable</em> of the class <code>Me</code>, which is located right behind the <code>Class</code> object in memory.</p><p>Obviously, things are never simple. To avoid method resolution everytime a method is invoked, Android uses multiple caching layers, one of which is implemented by the <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/mirror/dex_cache.h#464 target=_blank rel=noopener><code>DexCache</code></a>
class. In a nutshell, a <code>DexCache</code> is linked to a single <a href=https://source.android.com/docs/core/runtime/dex-format target=_blank rel=noopener><code>.dex</code></a>
file and tries to prevent the runtime from repeatedly parsing the <code>.dex</code> file to e.g. get a type definition. Every <code>Class</code> instance is linked to a single <code>DexCache</code> instance. When invoking a method on an object, the <code>DexCache</code> associated with the class that declares the calling method is used to look up the <code>ArtMethod</code> before parsing the <code>.dex</code> file (if no lower cache layer contains the method). This means any method is bound to a single <code>DexCache</code> and thus to a single <code>.dex</code> file, which I define as the <strong>context of a bytecode method</strong>. Each method is restricted to the types, methods etc. defined in the <em>context</em>, i.e. the <code>.dex</code> file of the <code>DexCache</code> associated with the declaring class of the method.</p><p>Notice we are only scratching the surface! In a later post, we will investigate how <em>interface method invocation</em> works in detail. Also, observe that there are a lot of cross - references among the above structures. Objects reference their classes, which again reference methods each pointing back to their declaring class. Fields have relative pointers into objects and are referenced by a class. This is what makes understanding and manipulating such structures highly complicated!</p><h3 id=android-bytecode>Android Bytecode</h3><p>Android <a href=https://source.android.com/docs/core/runtime/dalvik-bytecode target=_blank rel=noopener>bytecode</a>
(actually called <em>Dalvik bytecode</em>, but whatever), is what is executed by Android&rsquo;s interpreters. As we focus on Android 13, the main interpreter is called <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/interpreter/mterp/ target=_blank rel=noopener><code>nterp</code></a>
and is mostly written in assembly. There is another interpreter called the <code>switch</code> interpreter, written in C++, but it seems to be rarely used. A single bytecode instruction consists of at least <em>two</em> bytes. Moreover, the number of bytes required for each bytecode instruction is divisible by <em>two</em>. This stems from the fact that bytecode works with so called <em>code units</em>, where <code>1 code unit = 2 bytes</code>.</p><p>Lets consider an example:</p><pre tabindex=0><code>01 12x move vA, vB
</code></pre><p>Actually, the instruction is <code>move vA, vB</code>, because the value <code>0x01</code> is the opcode indicating that this instruction is a <code>move</code> and <code>12x</code> is the <a href=https://source.android.com/docs/core/runtime/instruction-formats target=_blank rel=noopener>format</a>
of the instruction. E.g. <code>12x</code> means <code>op vA, vB</code>. A concrete instance of the above instruction would be</p><pre tabindex=0><code>move v0, v1
</code></pre><p>where the value in <em>virtual register</em> <code>v1</code> is moved/copied into <em>vreg</em> <code>v0</code>. On Intel x64, this is somewhat similar to <code>mov eax, ebx</code>.</p><p>A single vreg can hold a 32 - bit value. Further, each vreg is associated with a <em>virtual reference</em> (vref), which also holds 32 bits. However, vrefs are never accessed directly, i.e. there will never be an instruction like <code>move rA, rB</code>. Instead, vrefs are used to handle object references in the <em>background</em>. For example, let <code>r0</code> be the vref associated with vreg <code>v0</code>. If <code>v0</code> holds an integer, i.e. a non - object value, then <code>r0 = 0</code>. However, if <code>v0</code> holds an object, then <code>r0</code> also holds the same object. Of course, holding an object means holding an object <em>reference</em>, which must be a <em>valid 32-bit pointer</em>. Depending on what the method containing the bytecode requested, more vregs may be accessible, like <code>v1</code> or <code>v65535</code>. Vreg indices are always <em>unsigned</em> and not only depend on what the method requested, but also on the bytecode operating on the vreg.</p><p>In memory, the above example <code>move v0, v1</code> looks like so:</p><pre tabindex=0><code>01 10
</code></pre><p>As stated earlier, <code>01</code> is the opcode indicating a <code>move</code>. Furthermore, the format <code>op vA, vB</code> indicates that vreg indices are 4 bits each. Basically, each letter in a vreg description, like <code>A</code> in <code>vA</code>, represents another 4 bits available to encode a vreg index. In this case, <code>vA</code> and <code>vB</code> may range from <code>v0</code> to <code>v(2**4-1)=v15</code>. When writing Java code, there is no way to manually specify the vreg indices. However, when writing bytecode shellcode, care must be taken to not exceed bytecode instruction - enforced ranges. Otherwise, indices may be different from what is needed in the exploit, or throw off following bytecode instructions.</p><p>One pecularity remains to be discussed: why is <code>v0, v1</code> translated to <code>10</code> in the above example? This stems from the little - endian architecture of the test device. Basically, the format enforces a memory layout like so <code>01 BA</code>.</p><p>Lets consider another example: a &ldquo;normal&rdquo; method invocation</p><pre tabindex=0><code>6e 35c invoke-virtual {vC, vD, vE, vF, vG}, meth@BBBB
</code></pre><p>Similar to before, <code>vC</code> to <code>vG</code> are given 4 bits each to index the vregs that hold method arguments. Two things are odd though:</p><ol><li>Where is <code>A</code> in the above definition?</li><li>What is <code>meth@BBBB</code>?</li></ol><p>Regarding the first point, <code>A</code> is a 4 bit value that determines the <em>actual</em> number of arguments passed. Otherwise, any method invocation via <code>invoke-virtual</code> would be forced to handle exactly 5 arguments. Secondly, <code>meth@BBBB</code> is a 16 - bit unsigned index into the method table of the <code>.dex</code> file of the <em>calling</em>/<em>current</em> method, i.e. the context. To make sure this is clear, consider the following example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>invoke</span><span class=o>-</span><span class=n>virtual</span><span class=w> </span><span class=p>{</span><span class=n>v0</span><span class=p>,</span><span class=w> </span><span class=n>v1</span><span class=p>},</span><span class=w> </span><span class=n>meth</span><span class=nd>@1234</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Here, the context is the <code>.dex</code> file associated with the <code>ArtMethod</code> representing <code>run</code>! Therefore, if we try to call a method that does not appear inside the context, like <code>Runtime::exec(String command)</code>, then an error will be thrown or worse a method with the same method index will be called and cause a crash!</p><p>The format of <code>invoke-virtual</code> dictates a memory layout like <code>6e AG BB BB DC FE</code>. If <code>A &lt; 5</code>, then any superfluous vreg indices are set to <code>0</code>, although they are ignored anyways. Of course, <code>BBBB</code> is stored in little endian.</p><p>Finally, lets consider one last example: creating arrays directly from bytecode</p><pre tabindex=0><code>26 31t fill-array-data vAA, +BBBBBBBB 
</code></pre><p>This time, <code>vAA</code> may be any of <code>v0</code> to <code>v255</code>. Furthermore, <code>+BBBBBBBB</code> is a 32-bit <em>signed</em> branch offset relative to the address of this instruction <em>in code units</em>. Assuming <code>dex_pc</code> is the virtual address of a <code>fill-array-data</code> instruction, to compute the address this instruction is referencing do the following: <code>dex_pc + 2 * (+BBBBBBBB)</code>. Because the 32-bit value is signed, whatever is referenced may be located <em>above</em> or <em>below</em> the instruction. Interestingly, the data structure referenced is a <code>fill-array-data-payload</code>:</p><table><thead><tr><th>Name</th><th>Format</th></tr></thead><tbody><tr><td>ident</td><td>0x0300 (u16)</td></tr><tr><td>element_width</td><td>u16</td></tr><tr><td>size</td><td>u32</td></tr><tr><td>data</td><td>[u8]</td></tr></tbody></table><blockquote><p><em>Note</em>: Java uses <em>two</em> bytes for a single char. So, to create a <code>char[]</code> directly from bytecode, we must ensure that <code>element_width = 2</code>. Bytecode is full of such caveats!</p></blockquote><h3 id=android-bytecode-execution>Android Bytecode Execution</h3><p>Execution of bytecode requires an <em>interpreter</em>, in this case <code>nterp</code>. Given an <code>ArtMethod</code>, the interpreter starts with <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/interpreter/mterp/arm64ng/main.S#1593 target=_blank rel=noopener><code>ExecuteNterpImpl</code></a>
. It sets up the <em>execution environment</em>, which includes</p><ol><li>Spilling registers on stack. Bytecode uses <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/interpreter/mterp/arm64ng/main.S#59 target=_blank rel=noopener>fixed hardware registers</a>
, just like native code.</li><li>Allocating memory for vregs and vrefs. These are initialized to <code>0</code>.</li><li>Setting up arguments to be passed to the invoked method.</li></ol><p>Below are the most important hardware registers and their descriptions:</p><table><thead><tr><th>Register</th><th>Description</th></tr></thead><tbody><tr><td>x19</td><td>Thread pointer</td></tr><tr><td>x29</td><td>Interpreted frame pointer</td></tr><tr><td>x25</td><td>Base of vrefs</td></tr><tr><td>x22</td><td>Interpreted program counter (dex_pc)</td></tr></tbody></table><p>Usually, native code execution involves managing stack frames, which seems daunting considering the complexity of ART. Luckily, the documentation of <code>nterp</code>, despite spread over various files, is pretty good. Hence, the <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/nterp_helpers.cc#39 target=_blank rel=noopener><code>nterp</code> stack layout</a>
is fully documented:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cm>/*    ----------------
</span></span></span><span class=line><span class=cl><span class=cm> *    |              |      All callee save registers of the platform
</span></span></span><span class=line><span class=cl><span class=cm> *    | callee-save  |      (core and floating point).
</span></span></span><span class=line><span class=cl><span class=cm> *    | registers    |      On x86 and x64 this includes the return address,
</span></span></span><span class=line><span class=cl><span class=cm> *    |              |      already spilled on entry.
</span></span></span><span class=line><span class=cl><span class=cm> *    ----------------
</span></span></span><span class=line><span class=cl><span class=cm> *    |   x86 args   |      x86 only: registers used for argument passing.
</span></span></span><span class=line><span class=cl><span class=cm> *    ----------------
</span></span></span><span class=line><span class=cl><span class=cm> *    |  alignment   |      Stack aligment of kStackAlignment.
</span></span></span><span class=line><span class=cl><span class=cm> *    ----------------
</span></span></span><span class=line><span class=cl><span class=cm> *    |              |      Contains `registers_size` entries (of size 4) from
</span></span></span><span class=line><span class=cl><span class=cm> *    |    dex       |      the code item information of the method.
</span></span></span><span class=line><span class=cl><span class=cm> *    |  registers   |
</span></span></span><span class=line><span class=cl><span class=cm> *    |              |
</span></span></span><span class=line><span class=cl><span class=cm> *    ----------------
</span></span></span><span class=line><span class=cl><span class=cm> *    |              |      A copy of the dex registers above, but only
</span></span></span><span class=line><span class=cl><span class=cm> *    |  reference   |      containing references, used for GC.
</span></span></span><span class=line><span class=cl><span class=cm> *    |  registers   |
</span></span></span><span class=line><span class=cl><span class=cm> *    |              |
</span></span></span><span class=line><span class=cl><span class=cm> *    ----------------
</span></span></span><span class=line><span class=cl><span class=cm> *    |  caller fp   |      Frame pointer of caller. Stored below the reference
</span></span></span><span class=line><span class=cl><span class=cm> *    ----------------      registers array for easy access from nterp when returning.
</span></span></span><span class=line><span class=cl><span class=cm> *    |  dex_pc_ptr  |      Pointer to the dex instruction being executed.
</span></span></span><span class=line><span class=cl><span class=cm> *    ----------------      Stored whenever nterp goes into the runtime.
</span></span></span><span class=line><span class=cl><span class=cm> *    |  alignment   |      Pointer aligment for dex_pc_ptr and caller_fp.
</span></span></span><span class=line><span class=cl><span class=cm> *    ----------------
</span></span></span><span class=line><span class=cl><span class=cm> *    |              |      In case nterp calls compiled code, we reserve space
</span></span></span><span class=line><span class=cl><span class=cm> *    |     out      |      for out registers. This space will be used for
</span></span></span><span class=line><span class=cl><span class=cm> *    |   registers  |      arguments passed on stack.
</span></span></span><span class=line><span class=cl><span class=cm> *    |              |
</span></span></span><span class=line><span class=cl><span class=cm> *    ----------------
</span></span></span><span class=line><span class=cl><span class=cm> *    |  ArtMethod*  |      The method being currently executed.
</span></span></span><span class=line><span class=cl><span class=cm> *    ----------------  &lt;----- STACK POINTER: qword [SP] = ArtMethod*
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span></code></pre></div><p>Hence, vrefs and vregs are adjacent arrays of 32-bit values. Furthermore, way up the stack are callee - save registers, which will include the <code>dex_pc</code> of the calling function, if the calling function is also a bytecode method, i.e. there is a new <em>return address</em> - do you see where this is going? >:)</p><h3 id=bytecode-oddities>Bytecode Oddities</h3><p>With the basics out of the way, lets quickly gloss over some <em>weird</em> things in bytecode. It seems like Android&rsquo;s interpreter <code>nterp</code> is making the following assumption:</p><blockquote><p>Bytecode is correct.</p></blockquote><p>This is well - founded under another assumption that bytecode can only originate from e.g. Java or Kotlin. However, in a setting where an attacker is able to control e.g. a stack - buffer overflow, so that the stored bytecode return address is overwritten to point to attacker - controlled memory, this assumption does not hold anymore. Overall, the assumption chain may look like <code>(Bytecode can only originate from Java/Kotlin => Bytecode is correct) => No need for checks</code>.</p><p>Consider the implemention of a previous sample bytecode instruction: <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/interpreter/mterp/arm64ng/other.S#160 target=_blank rel=noopener><code>move vA, vB</code></a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=err>%</span><span class=nf>def</span> <span class=no>op_move</span><span class=p>(</span><span class=no>is_object</span><span class=err>=&#34;</span><span class=mi>0</span><span class=err>&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* for move, move-object, long-to-int */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* op vA, vB */</span>
</span></span><span class=line><span class=cl>    <span class=nf>lsr</span>     <span class=no>w1</span><span class=p>,</span> <span class=no>wINST</span><span class=p>,</span> <span class=c1>#12              // x1&lt;- B from 15:12
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>ubfx</span>    <span class=no>w0</span><span class=p>,</span> <span class=no>wINST</span><span class=p>,</span> <span class=c1>#8, #4           // x0&lt;- A from 11:8
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>FETCH_ADVANCE_INST</span> <span class=mi>1</span>                <span class=c1>// advance rPC, load wINST
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>GET_VREG</span> <span class=no>w2</span><span class=p>,</span> <span class=no>w1</span>                     <span class=c1>// x2&lt;- fp[B]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>GET_INST_OPCODE</span> <span class=no>ip</span>                  <span class=c1>// ip&lt;- opcode from wINST
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=na>.if</span> <span class=no>$is_object</span>
</span></span><span class=line><span class=cl>    <span class=nf>SET_VREG_OBJECT</span> <span class=no>w2</span><span class=p>,</span> <span class=no>w0</span>              <span class=c1>// fp[A]&lt;- x2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=na>.else</span>
</span></span><span class=line><span class=cl>    <span class=nf>SET_VREG</span> <span class=no>w2</span><span class=p>,</span> <span class=no>w0</span>                     <span class=c1>// fp[A]&lt;- x2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=na>.endif</span>
</span></span><span class=line><span class=cl>    <span class=nf>GOTO_OPCODE</span> <span class=no>ip</span>                      <span class=c1>// execute next instruction
</span></span></span></code></pre></div><p>With a basic understanding of assembly, we cannot seem to spot any bounds checks on vreg indices&mldr; Surely they are located in macros like <code>GET_VREG</code> and <code>SET_VREG(_OBJECT)</code>!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=na>.macro</span> <span class=no>GET_VREG</span> <span class=no>reg</span><span class=p>,</span> <span class=no>vreg</span>
</span></span><span class=line><span class=cl>    <span class=nf>ldr</span>     <span class=err>\</span><span class=no>reg</span><span class=p>,</span> <span class=p>[</span><span class=no>xFP</span><span class=p>,</span> <span class=err>\</span><span class=no>vreg</span><span class=p>,</span> <span class=no>uxtw</span> <span class=c1>#2]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=na>.endm</span>
</span></span><span class=line><span class=cl><span class=na>.macro</span> <span class=no>GET_VREG_OBJECT</span> <span class=no>reg</span><span class=p>,</span> <span class=no>vreg</span>
</span></span><span class=line><span class=cl>    <span class=nf>ldr</span>     <span class=err>\</span><span class=no>reg</span><span class=p>,</span> <span class=p>[</span><span class=no>xREFS</span><span class=p>,</span> <span class=err>\</span><span class=no>vreg</span><span class=p>,</span> <span class=no>uxtw</span> <span class=c1>#2]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=na>.endm</span>
</span></span><span class=line><span class=cl><span class=na>.macro</span> <span class=no>SET_VREG</span> <span class=no>reg</span><span class=p>,</span> <span class=no>vreg</span>
</span></span><span class=line><span class=cl>    <span class=nf>str</span>     <span class=err>\</span><span class=no>reg</span><span class=p>,</span> <span class=p>[</span><span class=no>xFP</span><span class=p>,</span> <span class=err>\</span><span class=no>vreg</span><span class=p>,</span> <span class=no>uxtw</span> <span class=c1>#2]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>str</span>     <span class=no>wzr</span><span class=p>,</span> <span class=p>[</span><span class=no>xREFS</span><span class=p>,</span> <span class=err>\</span><span class=no>vreg</span><span class=p>,</span> <span class=no>uxtw</span> <span class=c1>#2]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=na>.endm</span>
</span></span><span class=line><span class=cl><span class=na>.macro</span> <span class=no>SET_VREG_OBJECT</span> <span class=no>reg</span><span class=p>,</span> <span class=no>vreg</span>
</span></span><span class=line><span class=cl>    <span class=nf>str</span>     <span class=err>\</span><span class=no>reg</span><span class=p>,</span> <span class=p>[</span><span class=no>xFP</span><span class=p>,</span> <span class=err>\</span><span class=no>vreg</span><span class=p>,</span> <span class=no>uxtw</span> <span class=c1>#2]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>str</span>     <span class=err>\</span><span class=no>reg</span><span class=p>,</span> <span class=p>[</span><span class=no>xREFS</span><span class=p>,</span> <span class=err>\</span><span class=no>vreg</span><span class=p>,</span> <span class=no>uxtw</span> <span class=c1>#2]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=na>.endm</span>
</span></span></code></pre></div><p>There are no checks! Looking back at the <code>nterp</code> stack frame allows estimating the impact: (almost) arbitrary stack index out - of - bounds <em>access</em> (i.e. read and write). Interestingly, all bytecode implementations I reviewed missed out on index bounds checks.</p><p>What is more is that, if we claimed that e.g. <code>v0</code> contains an object and called <code>move-object v42, v0</code>, then <code>nterp</code> would happily copy it over. Notice that <code>move_object</code> calls <code>op_move(is_object="1")</code>. For a concrete example of how to interpret an arbitrary value as an object reference, consider the case where the method is allocated enough space to hold four vregs, i.e. <code>v0</code> to <code>v3</code> are <em>valid</em>. Knowing that <code>r0</code> to <code>r3</code> <em>precede</em> <code>v0</code> in memory, this also implies that <code>r4 = v0</code>, i.e. <code>r4</code> and <code>v0</code> overlap. Hence, setting <code>v0</code> makes <code>v4</code> interpret the contents of <code>v0</code> as an object. Another, similar approach can be seen below:</p><pre tabindex=0><code>const-wide/32 v0, &lt;fake object address&gt;
move-object v0, v0
</code></pre><p>This works, because <code>op_move v0, v0</code> moves the value in <strong>vreg</strong> <code>v0</code> into both, <code>v0</code> and <code>r0</code>. I.e. when calling <code>move-object vA, vB</code>, it does not matter whether <code>vB</code> actually contains an object. After the move, whatever was in <code>vB</code> (<strong>not</strong> <code>rB</code>) will be interpreted as an object in <code>vA</code>. This is kind of like a <em>fakeobj</em> primitive in browser exploitation, i.e. a <em>type confusion</em>.</p><p>In a nutshell, Android&rsquo;s interpreter <code>nterp</code> blindly trusts that the bytecode to execute is correct and does not try to &ldquo;harm&rdquo; the execution environment. This is what makes bytecode injection a nice intermediate stage to eventually run a <em>JITROP</em>.</p><h2 id=fork-server-architecture-on-android>Fork Server Architecture on Android</h2><p>A <em>fork server architecture</em> refers to a multi - process mechanism that creates new processes from a base process using the <a href=https://manpages.ubuntu.com/manpages/bionic/man2/fork.2.html target=_blank rel=noopener><code>fork</code></a>
syscall, often as a reaction to a certain event. Most importantly, whatever process invokes <code>fork</code> is <em>duplicated</em>, and control - flow for both, parent (old) and child (new) processes, continues right behind the <code>fork</code> syscall instruction. Usually, a C program calling <code>fork</code> looks like so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>pid_t</span> <span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// child process
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// parent process
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>Assuming the child process does <em>not</em> run <code>execve</code> or similar, child and parent share the same memory layout. This means e.g. that the base addresses of common libraries like <code>libc.so.6</code> are identical in child and parent processes! Given a vulnerability in the parent process and that an attacker already controls the child process, information leaks are often not required anymore for successful exploitation. To take this even further, not just the <em>layout</em> is identical, but also majority of the contents.</p><p>While duplicating processes seems like a bad idea from a security perspective, especially when memory unsafe languages are involved, the fork server architecture can function as a form of optimization. Specifically, on mobile devices with significantly less computational power and memory than your average PC, operating systems can pre - initialize common parts of all apps in a particular base process. Then, when a user starts an app, the base process is <code>fork</code>ed and app - specific behaviour is loaded - no need to repeat the same initialization phase for each app.</p><p>Of course, Android does exactly that: uses a base process called <code>zygote64</code> to set up, among other things, the JVM. Also, common shared libraries are loaded, garbage collection is set up, some common objects are created and much more. Although this increases app performance, especially during startup, it also implies that <em>every app knows the majority of the memory layout of all other apps</em>. Notice that the process used for forking, i.e. <code>zygote64</code>, is run by <code>root</code>. Therefore, all &ldquo;normal&rdquo; apps know a lot about the memory layout and contents of a root process!</p><p>Now, lets figure out what and how many memory regions are actually shared!</p><h3 id=maps-diffing>Maps Diffing</h3><p>A very simple heuristic to figure out common memory regions over a set of running processes is to use the <code>/proc/&lt;pid>/maps</code> file. Usually, on any operating system not using a fork server architecture, we would expect to have no matching memory regions in terms of name, virtual address, size and permissions. However, knowing that apps are forked from <code>zygote64</code>, we can simply take the intersection of the sets of memory regions of all processes in question to get an approximation for all duplicated memory regions.</p><p>To get this job done, we can reuse an <a href=https://gist.github.com/fxthomas/3c915909bbf84bc14782cb6adef0f915 target=_blank rel=noopener>existing maps parser</a>
. The most crucial code can be seen below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>MAPS_LINE_RE</span> <span class=o>=</span> <span class=n>re</span><span class=o>.</span><span class=n>compile</span><span class=p>(</span><span class=sa>r</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    (?P&lt;addr_start&gt;[0-9a-f]+)-(?P&lt;addr_end&gt;[0-9a-f]+)\s+  # Address
</span></span></span><span class=line><span class=cl><span class=s2>    (?P&lt;perms&gt;\S+)\s+                                     # Permissions
</span></span></span><span class=line><span class=cl><span class=s2>    (?P&lt;offset&gt;[0-9a-f]+)\s+                              # Map offset
</span></span></span><span class=line><span class=cl><span class=s2>    (?P&lt;dev&gt;\S+)\s+                                       # Device node
</span></span></span><span class=line><span class=cl><span class=s2>    (?P&lt;inode&gt;\d+)\s+                                     # Inode
</span></span></span><span class=line><span class=cl><span class=s2>    (?P&lt;pathname&gt;.*)\s+                                   # Pathname
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span><span class=p>,</span> <span class=n>re</span><span class=o>.</span><span class=n>VERBOSE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@dataclass</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Record</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>addr_start</span><span class=p>:</span> <span class=nb>int</span>
</span></span><span class=line><span class=cl>    <span class=n>addr_end</span><span class=p>:</span> <span class=nb>int</span>
</span></span><span class=line><span class=cl>    <span class=n>perms</span><span class=p>:</span> <span class=nb>str</span>
</span></span><span class=line><span class=cl>    <span class=n>offset</span><span class=p>:</span> <span class=nb>int</span>
</span></span><span class=line><span class=cl>    <span class=n>dev</span><span class=p>:</span> <span class=nb>str</span>
</span></span><span class=line><span class=cl>    <span class=n>inode</span><span class=p>:</span> <span class=nb>int</span>
</span></span><span class=line><span class=cl>    <span class=n>pathname</span><span class=p>:</span> <span class=nb>str</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse</span><span class=p>(</span><span class=n>lines</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>str</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=n>List</span><span class=p>[</span><span class=n>Record</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Parses maps records from the list of all lines in a maps file.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=n>Record</span><span class=p>(</span><span class=o>*</span><span class=n>m</span><span class=o>.</span><span class=n>groups</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>lines</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>m</span> <span class=o>:=</span> <span class=n>MAPS_LINE_RE</span><span class=o>.</span><span class=k>match</span><span class=p>(</span><span class=n>line</span><span class=p>))</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>diff_regions</span><span class=p>(</span><span class=n>lhs</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=n>Record</span><span class=p>],</span> <span class=n>rhs</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=n>Record</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=n>List</span><span class=p>[</span><span class=n>Record</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Performs lhs = lhs &lt;intersect&gt; rhs in terms of set intersection.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=n>lhs</span><span class=p>[</span><span class=n>lhs</span><span class=o>.</span><span class=n>index</span><span class=p>(</span><span class=n>r</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>r</span> <span class=ow>in</span> <span class=n>rhs</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>r</span> <span class=ow>in</span> <span class=n>lhs</span>
</span></span><span class=line><span class=cl>    <span class=p>]</span>
</span></span></code></pre></div><p>Then, with a list of memory regions for each target app, taking the intersection gives the approximate set of duplicated memory regions. Of course, we could simply use <code>zygote64</code> and any app to get the set of memory regions coming directly from the base process. For a sample comparison on the test device, consider the following output:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>host<span class=o>)</span>$ python3 ./maps_differ.py &lt;pid of zygote64&gt; &lt;pid of com.google.android.youtube&gt;
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl><span class=o>[</span>1754<span class=o>]</span>: 0x78f19d7000 - 0x78f19d9000 <span class=o>(</span>offset: 0x0<span class=o>)</span>: <span class=o>[</span>anon:.bss<span class=o>]</span> <span class=o>(</span>rw-p<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=o>[</span>1755<span class=o>]</span>: 0x7fdab74000 - 0x7fdab75000 <span class=o>(</span>offset: 0x0<span class=o>)</span>:  <span class=o>(</span>---p<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=o>[</span>1756<span class=o>]</span>: 0x7fdab75000 - 0x7fdb374000 <span class=o>(</span>offset: 0x0<span class=o>)</span>: <span class=o>[</span>stack<span class=o>]</span> <span class=o>(</span>rw-p<span class=o>)</span>
</span></span><span class=line><span class=cl>Total: <span class=m>1757</span>
</span></span></code></pre></div><p>Despite looking like a big number, without a reference we cannot make any observations on that number alone. So, consider the number of entries in the <code>/proc/$(pidof zygote64)/maps</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>device<span class=o>)</span><span class=c1># wc -l /proc/$(pidof zygote64)/maps</span>
</span></span><span class=line><span class=cl><span class=m>1784</span> /proc/752/maps
</span></span></code></pre></div><p>This means that <code>1757</code> out of <code>1784</code> maps entries may have been duplicated during the <code>fork</code>, which is roughly <code>98.5%</code>. Notice that the child process may have unmapped or remapped some regions of its parent. The above intersection is done on all attributes of the maps entries, meaning that remapping a memory region already causes our analysis to discard that region. However, in this case only memory regions that have not changed are relevant for exploitation! To stabilize this approach, one can repeatedly restart an app and compute the set of common memory regions over multiple app restarts.</p><blockquote><p><em>Note</em>: Doing this <em>maps diffing</em> over device reboots reveals two duplicated memory regions, namely <code>[anon:dalvik-main space (region space)] (rw-p)</code> and <code>[anon:dalvik-Sentinel fault page] (---p)</code>. However, rebooting the device should also re - randomize the layout of <code>zygote64</code>! Therefore, these two memory regions must be <em>deterministic</em>! While the sentinel fault page does not have any permissions set (maybe look into segfault handlers for special logic for that region), the <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/runtime/gc/heap.cc#200 target=_blank rel=noopener>first region</a>
is readable and writable. Hence, even a remote attacker can predict the location of a readable and writable memory region without a concrete information leak other than the target OS version! However, notice that this region is garbage collected and where (Java) objects are stored, so writing without understanding the GC will probably cause various crashes and be very instable.</p></blockquote><p>Observe that getting an idea of what memory regions are duplicated across all apps allows to make reasonable assumptions on memory region positions in a local attacker scenario. If an attacker controls an unprivileged app, then knowing that e.g. <code>libart.so</code> is duplicated will enable the attacker to make the assumption that his/her location of <code>libart.so</code> is identical to the location in a victim app. Also, the only reason I spotted the deterministic memory regions was because of maps diffing. I never expected to find deterministic memory regions on modern devices and thus did not bother searching.</p><h4 id=memory-regions>Memory Regions</h4><p>With a set of duplicated memory regions at hand, we can now proceed with analysing what is actually shared. To save some time, the following entries are of interest:</p><pre tabindex=0><code>[0001]: 0x6f3be000 - 0x6f64c000 (offset: 0x0): [anon:dalvik-/system/framework/boot.art] (rw-p)                               
[0008]: 0x6fa71000 - 0x6fa72000 (offset: 0x0): [anon:.bss] (rw-p)                                                            
[0425]: 0x763343d000 - 0x7633dbd000 (offset: 0x1a18000): /system/framework/framework.jar (r--p)
[0431]: 0x7635e00000 - 0x7635f54000 (offset: 0x0): /apex/com.android.art/lib64/libart.so (r--p)
</code></pre><p>There are plenty of resources discussing common file types like <code>.so</code> and <code>.jar</code>. However, <a href=https://lief.re/doc/latest/tutorials/10_android_formats.html#art target=_blank rel=noopener><code>.art</code></a>
is a bit trickier. Most importantly, <code>.art</code> files contain <em>heap dumps of C++ objects</em>. Because (Java) objects are based on C++ objects on Android, this means <code>.art</code> may also contain (Java) objects (which they do btw).</p><p>So, what about the <code>[anon:.bss]</code>? To this day, I have no clue what this is used for, but they proved to have the following important properties:</p><ol><li>Some <code>[anon:.bss]</code> regions are in 32-bit memory.</li><li>Readable and writable permissions.</li><li>At least <code>0x1000</code> bytes in size.</li></ol><p>The first property is very important for object references in e.g. Java, because these are restricted to 32-bit pointers.</p><p>Further, the <code>framework.jar</code> file seems to contain the entire ART Java code and probably the standard library part like <code>Runtime</code>. This is important, because if an attacker is able to redirect bytecode control - flow to a chosen location, <code>framework.jar</code> will be gadget heaven. Hence, we will take a quick look at the internals of <code>framework.jar</code>.</p><h5 id=framework-jar-file-components>Framework JAR File Components</h5><p>It turns out that the <code>framework.jar</code> is just a <code>zip</code> archive. Unzipping using <code>unzip</code> reveals the following, filtered contents:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>host<span class=o>)</span>$ unzip framework.jar
</span></span><span class=line><span class=cl><span class=o>(</span>host<span class=o>)</span>$ ls
</span></span><span class=line><span class=cl>android  classes.dex  classes2.dex  classes3.dex  classes4.dex  com  META-INF  res
</span></span></code></pre></div><p>Everything except for the <code>.dex</code> files is a directory, probably describing the structure of <code>.jar</code> file and what data is provided, i.e. metadata. The most interesting components are <a href=https://source.android.com/docs/core/runtime/dex-format target=_blank rel=noopener><code>.dex</code> files</a>
, which contain the actual code provided by the <code>.jar</code> file, along with types, strings and more. <code>.dex</code> files are also part of <code>.apk</code> files, i.e. apps, and contain the application - specific and some framework code. Again, whatever <code>.dex</code> is the current context, we will be restricted to the resources provided by that <code>.dex</code> file, if the goal is to stay on bytecode - level.</p><p>To analyse <code>.dex</code> files a plethora of tools is available online. Mainly, we are interested in indices into certain tables like type and method tables. To that end, one can simply use <code>dexlib2</code> or <a href=https://github.com/fkie-cad/Topper target=_blank rel=noopener><code>Topper</code></a>
.</p><p>Although I developed Topper for a different, now obsolete reason, its core engine still allows extracting the information needed. Basically, what can be done is the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&gt; file --file &lt;path to .dex file&gt; --type DEX
</span></span><span class=line><span class=cl>classes.dex&gt; list methods --regex <span class=s2>&#34;UiAutomation::executeShellCommand&#34;</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=nv>Offset</span> <span class=o>=</span> 0x0<span class=o>]</span>: classes.dex
</span></span><span class=line><span class=cl>  <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0x39fc, <span class=nv>Offset</span> <span class=o>=</span> 0x25e0f0, Num <span class=nv>Regs</span> <span class=o>=</span> 0x10<span class=o>]</span>: private android/os/ParcelFileDescriptor<span class=o>[]</span> android/app/UiAutomation::executeShellCommandInternal<span class=o>(</span>java/lang/String command, boolean includeStderr<span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0x39fb, <span class=nv>Offset</span> <span class=o>=</span> 0x25e05c, Num <span class=nv>Regs</span> <span class=o>=</span> 0x8<span class=o>]</span>: public android/os/ParcelFileDescriptor android/app/UiAutomation::executeShellCommand<span class=o>(</span>java/lang/String <span class=nb>command</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0x39fd, <span class=nv>Offset</span> <span class=o>=</span> 0x25e1f0, Num <span class=nv>Regs</span> <span class=o>=</span> 0x3<span class=o>]</span>: public android/os/ParcelFileDescriptor<span class=o>[]</span> android/app/UiAutomation::executeShellCommandRw<span class=o>(</span>java/lang/String <span class=nb>command</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0x39fe, <span class=nv>Offset</span> <span class=o>=</span> 0x25e20c, Num <span class=nv>Regs</span> <span class=o>=</span> 0x3<span class=o>]</span>: public android/os/ParcelFileDescriptor<span class=o>[]</span> android/app/UiAutomation::executeShellCommandRwe<span class=o>(</span>java/lang/String <span class=nb>command</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0x39fb<span class=o>]</span>: android/os/ParcelFileDescriptor android/app/UiAutomation::executeShellCommand<span class=o>(</span>Ljava/lang/String<span class=p>;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0x39fc<span class=o>]</span>: android/os/ParcelFileDescriptor<span class=o>[]</span> android/app/UiAutomation::executeShellCommandInternal<span class=o>(</span>Ljava/lang/String<span class=p>;</span>, Z<span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0x39fd<span class=o>]</span>: android/os/ParcelFileDescriptor<span class=o>[]</span> android/app/UiAutomation::executeShellCommandRw<span class=o>(</span>Ljava/lang/String<span class=p>;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0x39fe<span class=o>]</span>: android/os/ParcelFileDescriptor<span class=o>[]</span> android/app/UiAutomation::executeShellCommandRwe<span class=o>(</span>Ljava/lang/String<span class=p>;</span><span class=o>)</span>
</span></span></code></pre></div><p>Notice that loading <code>classes.dex</code> from <code>framework.jar</code> may take some time, because <code>Topper</code> tries to &ldquo;decompile&rdquo; all methods into their smali representations, all on a single thread (it was a research project btw.)! However, observe that methods are prefixed with information about their index, offset and number of used virtual registers. Some information is taken from the so - called <a href=https://source.android.com/docs/core/runtime/dex-format#code-item target=_blank rel=noopener><code>code_item</code></a>
. Apparently, the <code>.dex</code> file contains duplicate definitions of methods, or, more likely, an abstract description and a concrete definition. When looking at methods, only consider the entries that have an offset and the number of registers set. With the above, it is apparent that <code>framework.jar</code> contains code that enables execution of shell commands.</p><p>Similar to method indices, type indices can be extracted like so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>classes.dex&gt; list types --regex <span class=s2>&#34;android/app/UiAutomation&#34;</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=nv>Offset</span> <span class=o>=</span> 0x0<span class=o>]</span>: classes.dex
</span></span><span class=line><span class=cl>  <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0x599<span class=o>]</span>: android/app/UiAutomation<span class=nv>$AccessibilityEventFilter</span>
</span></span><span class=line><span class=cl>  <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0x59a<span class=o>]</span>: android/app/UiAutomation<span class=nv>$ConnectionState</span>
</span></span><span class=line><span class=cl>  <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0x59b<span class=o>]</span>: android/app/UiAutomation<span class=nv>$IAccessibilityServiceClientImpl$1$$</span>ExternalSyntheticLambda0
</span></span><span class=line><span class=cl>  <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0x59c<span class=o>]</span>: android/app/UiAutomation<span class=nv>$IAccessibilityServiceClientImpl$1</span>
</span></span><span class=line><span class=cl>  <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0x59d<span class=o>]</span>: android/app/UiAutomation<span class=nv>$IAccessibilityServiceClientImpl</span>
</span></span><span class=line><span class=cl>  <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0x59e<span class=o>]</span>: android/app/UiAutomation<span class=nv>$OnAccessibilityEventListener</span>
</span></span><span class=line><span class=cl>  <span class=o>[</span><span class=nv>Index</span> <span class=o>=</span> 0x59f<span class=o>]</span>: android/app/UiAutomation
</span></span><span class=line><span class=cl>  ...
</span></span></code></pre></div><p>So, one might ask why we use a tool to extract indices. In a practical setting, an attacker controlling an unprivileged app most likely does not have access to external tools like <code>Topper</code>. There are two perspectives to consider. First, these indices can be considered to be part of the <em>manual</em> component of an exploit, similar to what gadget offsets are in a simple, classical ROP chain. The other perspective is more similar to the idea of <em>JITROP</em>, where the app dynamically calculates the needed indices. Luckily, the latter is possible, because e.g. <code>framework.jar</code> is duplicated into every app process. If, however, an application - specific <code>.dex</code> file is required to make an exploit work, then only the first perpespective seems feasible, unless an attacker can get a hold of the target <code>.apk</code> file.</p><h4 id=alternative-dexdump>Alternative: <code>dexdump</code></h4><p>Another tool that may reveal the required information is <a href=https://android.googlesource.com/platform/art/+/refs/tags/android-13.0.0_r78/dexdump/ target=_blank rel=noopener><code>dexdump</code></a>
. It seems to be available on Android devices by default, i.e. it can be run via</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>device<span class=o>)</span>$ dexdump ./classes.dex <span class=p>|</span> head
</span></span><span class=line><span class=cl>Processing <span class=s1>&#39;./classes.dex&#39;</span>...
</span></span><span class=line><span class=cl>Opened <span class=s1>&#39;./classes.dex&#39;</span>, DEX version <span class=s1>&#39;039&#39;</span>
</span></span><span class=line><span class=cl>Class <span class=c1>#0            -</span>
</span></span><span class=line><span class=cl>  Class descriptor  : <span class=s1>&#39;Landroid/Manifest$permission;&#39;</span>
</span></span><span class=line><span class=cl>  Access flags      : 0x0011 <span class=o>(</span>PUBLIC FINAL<span class=o>)</span>
</span></span><span class=line><span class=cl>  Superclass        : <span class=s1>&#39;Ljava/lang/Object;&#39;</span>
</span></span><span class=line><span class=cl>  Interfaces        -
</span></span><span class=line><span class=cl>  Static fields     -
</span></span><span class=line><span class=cl>    <span class=c1>#0              : (in Landroid/Manifest$permission;)</span>
</span></span><span class=line><span class=cl>      name          : <span class=s1>&#39;ACCEPT_HANDOVER&#39;</span>
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>Although no guarantees are made that <code>dexdump</code> provides the information required for exploitation, it may be easier to utilize than <code>Topper</code>!</p><h3 id=region-diffing>Region Diffing</h3><p>Instead of comparing the memory layout of two apps over multiple app restarts or even device reboots, we can also inspect how the actual data changes, in fancy terms: <em>region diffing</em>. Again, we use a naive heuristic that simply compares two instances of the same memory region, each coming from a different app process (potentially the same app, just restarted), byte by byte. Because many memory regions are large, comparing two or more memory regions is time consuming. Hence, this post only considers a <em>special</em> region: <code>[anon:dalvik-/system/framework/boot.art] (rw-p)</code>.</p><p>There are several ways to hijack bytecode control - flow on Android. One way revolves around replacing an existing, valid object with a fake object. <code>boot.art</code> contains <em>heap - dumps</em> consisting of e.g. objects and turned out to be quite reliable as regards hijacking control - flow. It is important to note that these dumped objects come from somewhere that exists before the app does, so their layouts and locations are most likely predictable. With the deterministic <code>dalvik-main space</code>, an attacker could try to replace an object with a fake one, but the GC often moves objects within that region, so that does not seem like a consistent, stable approach. Thus, <code>boot.art</code> seems like the best bet for this task.</p><p>To perform region diffing, we can use <a href=https://frida.re/ target=_blank rel=noopener><em>Frida</em></a>
. Similar to maps diffing, we start an app, pull its <code>boot.art</code> from memory and repeat. Before that, we can also ensure that <code>boot.art</code> is used at all. One way to do that is by simply changing the region&rsquo;s permissions from <code>rw-</code> to <code>---</code>, which should trigger a crash:</p><pre tabindex=0><code>gef➤  vmmap boot.art
0x0000006fe57000 0x000000700e5000 0x00000000000000 rw- [anon:dalvik-/system/framework/boot.art]
gef➤  mprotect 0x0000006fe57000 0
gef➤  continue
Thread 15 &#34;Profile Saver&#34; received signal SIGSEGV, Segmentation fault.
</code></pre><p>Using a simple tool I wrote, we can obtain the following, interesting matching regions regarding <code>boot.art</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python3 maps_differ.py
</span></span><span class=line><span class=cl><span class=o>(</span>Cmd<span class=o>)</span> ...
</span></span><span class=line><span class=cl><span class=o>(</span>Cmd<span class=o>)</span> search maps --regex <span class=s2>&#34;.*boot.art&#34;</span>
</span></span><span class=line><span class=cl>0x6fe57000 - 0x700e5000 <span class=o>(</span>offset: 0x0<span class=o>)</span>: <span class=o>[</span>anon:dalvik-/system/framework/boot.art<span class=o>]</span> <span class=o>(</span>rw-p<span class=o>)</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl><span class=o>(</span>Cmd<span class=o>)</span> diff region --count <span class=m>4</span> --region-base 0x6fe57000 --names com.poc.poc_local
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>Found <span class=m>4010</span> matching blob<span class=o>(</span>s<span class=o>)</span>.
</span></span><span class=line><span class=cl><span class=o>(</span>Cmd<span class=o>)</span> search blobs
</span></span><span class=line><span class=cl>0x6fe57000 - 0x6fe57e08 <span class=o>(</span>size: 0xe08<span class=o>)</span>
</span></span><span class=line><span class=cl>0x6fe57e09 - 0x6fe59bbc <span class=o>(</span>size: 0x1db3<span class=o>)</span>
</span></span><span class=line><span class=cl>0x6fe5700d - 0x6fe57012 <span class=o>(</span>size: 0x5<span class=o>)</span>
</span></span><span class=line><span class=cl>0x6fe57024 - 0x6fe57028 <span class=o>(</span>size: 0x4<span class=o>)</span>
</span></span><span class=line><span class=cl>0x6fe57034 - 0x6fe5703a <span class=o>(</span>size: 0x6<span class=o>)</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>0x6fff9250 - 0x7003c656 <span class=o>(</span>size: 0x43406<span class=o>)</span>
</span></span></code></pre></div><p>From the above results, we can see that the first <code>0xe08</code> bytes of the region remain constant over multiple runs. Furthermore, a single byte at address <code>&lt;boot.art> + 0xe08</code> seems to change over multiple runs. After the single byte, another <code>0x1db3</code> bytes are constant. Also, towards the end of <code>boot.art</code> seems to be a very large constant region. Therefore, and because of the fact that <code>boot.art</code> contains dumped objects, <code>boot.art</code> is a suitable candidate for <em>semantic analysis</em>. Note that up to this point, we only checked whether resources <em>change</em> over app restarts via byte - by - byte comparison. Btw. some changing resources are also interesting. For example, an object located in <code>boot.art</code> may change, because the GC moved a referenced object to another location.</p><h3 id=monitoring-memory-accesses-to-bootart>Monitoring Memory Accesses to <code>boot.art</code></h3><p>The goal is to figure out what resources in <code>boot.art</code> are accessed by an app. Knowing that Android apps adhere to the <a href=https://developer.android.com/guide/components/activities/activity-lifecycle target=_blank rel=noopener><em>application lifecycle</em></a>
, we are especially interested in resources that are accessed during <em>inevitable</em> events like <code>onStop</code> and <code>onDestroy</code>!</p><p>Again, <em>Frida</em> helps monitoring memory accesses in the following way:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>region_to_js</span><span class=p>(</span><span class=n>region</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>json</span><span class=o>.</span><span class=n>dumps</span><span class=p>({</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;addr_start&#39;</span><span class=p>:</span> <span class=n>region</span><span class=o>.</span><span class=n>addr_start</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;addr_end&#39;</span><span class=p>:</span> <span class=n>region</span><span class=o>.</span><span class=n>addr_end</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>regions_to_js_array</span><span class=p>(</span><span class=n>regions</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>ar</span> <span class=o>=</span> <span class=s1>&#39;[&#39;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>region</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>regions</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>ar</span> <span class=o>+=</span> <span class=n>region_to_js</span><span class=p>(</span><span class=n>region</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>regions</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>ar</span> <span class=o>+=</span> <span class=s1>&#39;,&#39;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ar</span> <span class=o>+</span> <span class=s1>&#39;]</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=n>script</span> <span class=o>=</span> <span class=n>session</span><span class=o>.</span><span class=n>create_script</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>    const regions = </span><span class=si>{</span><span class=n>regions_to_js_array</span><span class=p>(</span><span class=n>regions</span><span class=p>)</span><span class=si>}</span><span class=s1>;
</span></span></span><span class=line><span class=cl><span class=s1>    console.log(JSON.stringify(regions, null, 2));
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>    for (let region of regions) </span><span class=se>{{</span><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>        const frida_region = </span><span class=se>{{</span><span class=s1>base: ptr(region.addr_start), size: region.addr_end - region.addr_start</span><span class=se>}}</span><span class=s1>;
</span></span></span><span class=line><span class=cl><span class=s1>        MemoryAccessMonitor.enable(frida_region, </span><span class=se>{{</span><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>            onAccess: function(details) </span><span class=se>{{</span><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>                console.log(&#39;Accessed &#39; + details[&#39;address&#39;] + &#39; from: &#39; + details[&#39;from&#39;].toString(16));
</span></span></span><span class=line><span class=cl><span class=s1>            </span><span class=se>}}</span><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>        </span><span class=se>}}</span><span class=s1>);
</span></span></span><span class=line><span class=cl><span class=s1>    </span><span class=se>}}</span><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p>What the above snippet does is monitor memory accesses to all regions specified in the <code>regions</code> list. From previous analyses, it is known that only one region is of interest, namely <code>boot.art</code>. With the above script and some user interaction to trigger <code>onStop</code> and <code>onDestroy</code> manually, it is possible to identify objects that are only accessed during these late lifecycle events. In my case, I found <code>boot.art + 0x215f0</code>, which turned out to be <a href=https://android.googlesource.com/platform/libcore/+/refs/tags/android-13.0.0_r78/ojluni/src/main/java/sun/util/locale/LanguageTag.java#65 target=_blank rel=noopener><code>GRANDFATHERED</code></a>
. One approach to figure out the identity of an object in memory is to set an object&rsquo;s <code>klass_</code> pointer to <code>null</code> and observe the stack trace in the crash dump via <code>logcat</code>. <code>GRANDFATHERED</code> is defined in <code>LanguageTag</code> like so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>LanguageTag</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=o>[]&gt;</span><span class=w> </span><span class=n>GRANDFATHERED</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>LanguageTag</span><span class=w> </span><span class=nf>parse</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>languageTag</span><span class=p>,</span><span class=w> </span><span class=n>ParseStatus</span><span class=w> </span><span class=n>sts</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>gfmap</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GRANDFATHERED</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>LocaleUtils</span><span class=p>.</span><span class=na>toLowerString</span><span class=p>(</span><span class=n>languageTag</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Apparently, <code>LanguageTag.parse</code> is invoked somewhere inside a lifecycle method, most likely <code>onStop</code>, because the app does not need to be terminated to trigger this method invocation. To generalize this approach, if we are able to trigger an observable event when the object of interest is used, then we can emit behaviour that specifically triggers execution of lifecycle methods. For example, <code>onDestroy</code> is expected to only be called on app termination. Thus, if the object is used when the app is moved to the back, then it may be that the object is used in <code>onStop</code>. Of course, we would have to come up with a sophisticated set of experiments to precisely determine the lifecycle method that uses an object of interest!</p><p>Unfortunately, this story must be put on hold until the post on bytecode reuse attacks, as we only want to cover the basics in this post ;)</p><h2 id=summary>Summary</h2><p>In this blog post, we peeked into various Android fundamentals, always driven by the goal of bytecode - based exploitation. First, bytecode basics are discussed, which lay a foundation for a follow - up discussion on <em>weird</em> behaviour inside bytecode. Then, a more practical view on Android&rsquo;s fork server architecture is given. All major memory analysis steps used throughout this blog series are discussed.</p><p>Next up is the first bytecode - based exploitation technique: bytecode injection!</p></article></div></div></div></main><footer class="flex flex-none justify-center"><section class="flex flex-col md:flex-row mx-2 md:mx-0 gap-2 md:gap-0 justify-between w-full max-w-4xl lg:max-w-5xl py-6 text-slate-500 dark:text-slate-300"><div class="flex flex-row"></div><div class=grow></div><div class="flex flex-row"><i class="h-6 w-6 flex-none"><svg class="icon icon-tabler icon-tabler-copyright" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-9 0a9 9 0 1018 0A9 9 0 103 12"/><path d="M14 9.75a3.016 3.016.0 00-4.163.173 2.993 2.993.0 000 4.154A3.016 3.016.0 0014 14.25"/></svg>
</i>2022 - 2024 lolcads</div><div class="flex flex-row"><span class="ml-0 pl-0 md:ml-2 md:pl-2 border-l-0 md:border-l border-slate-300 dark:border-slate-400">Powered by <a href=https://gohugo.io target=_blank rel=noopener class=underline>Hugo</a> <span class=text-red-600>&#9829;</span> <a href=https://github.com/tomowang/hugo-theme-tailwind target=_blank rel=noopener class=underline>Tailwind</a></span></div></section></footer><script src=/main.min.c6372b6836971865bd94bfde974748aca8415824a2facab6ccd66a87384bfacb.js></script><div class="hidden top-1 right-1" id=code-copy><i class="h-6 w-6 block"><svg class="icon icon-tabler icon-tabler-copy" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667A2.667 2.667.0 019.667 7h8.666A2.667 2.667.0 0121 9.667v8.666A2.667 2.667.0 0118.333 21H9.667A2.667 2.667.0 017 18.333z"/><path d="M4.012 16.737A2.005 2.005.0 013 15V5c0-1.1.9-2 2-2h10c.75.0 1.158.385 1.5 1"/></svg></i></div><div class="hidden top-1 right-1" id=code-copy-done><i class="h-6 w-6 block"><svg class="icon icon-tabler icon-tabler-check" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 12l5 5L20 7"/></svg></i></div><script src=/code-copy.min.e7b2a74adef1ed474c335c8bd5e7832b2316b8842b0f9184d65286c5bd64f51a.js></script></body></html>